@Test(timeout = 4000) [EOL]   public void testgetFieldNameValueSeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.setSizeStartText((String) null); [EOL]       assertEquals("=", standardToStringStyle0.getFieldNameValueSeparator()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testToArray() { [EOL] [EOL] //test a list of size 10 [EOL] List<Integer> list = new ArrayList<Integer>(); [EOL] [EOL] for(int i=0; i<10; i++) { [EOL] list.add(i); [EOL] } [EOL] [EOL] Integer[] arr = GenericsUtil.toArray(list); [EOL] [EOL] for (int i = 0; i < arr.length; i++) { [EOL] assertEquals( [EOL] "Array has identical elements as input list", [EOL] list.get(i), arr[i]); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testDefaultConfUsed() { [EOL] Configuration conf = getConf(); [EOL] conf.unset(YarnConfiguration.NM_REMOTE_APP_LOG_DIR); [EOL] conf.unset(YarnConfiguration.NM_REMOTE_APP_LOG_DIR_SUFFIX); [EOL] conf.set(YarnConfiguration.LOG_AGGREGATION_FILE_FORMATS, "TFile"); [EOL] [EOL] LogAggregationFileControllerFactory factory = [EOL] new LogAggregationFileControllerFactory(getConf()); [EOL] LogAggregationFileController fc = factory.getFileControllerForWrite(); [EOL] [EOL] assertEquals(WRONG_ROOT_LOG_DIR_MSG, "/tmp/logs", [EOL] fc.getRemoteRootLogDir().toString()); [EOL] assertEquals(WRONG_ROOT_LOG_DIR_SUFFIX_MSG, "logs-tfile", [EOL] fc.getRemoteRootLogDirSuffix()); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger( [EOL] TestLogAggregationFileControllerFactory.class); [EOL] private static final String REMOTE_LOG_ROOT = "target/app-logs/"; [EOL] private static final String REMOTE_DEFAULT_DIR = "default/"; [EOL] private static final String APP_OWNER = "test"; [EOL] private static final String WRONG_ROOT_LOG_DIR_MSG = [EOL] "Wrong remote root log directory found."; [EOL] private static final String WRONG_ROOT_LOG_DIR_SUFFIX_MSG = [EOL] "Wrong remote root log directory suffix found."; [EOL] private static final List<Class<? extends LogAggregationFileController>> [EOL] ALL_FILE_CONTROLLERS = Arrays.asList( [EOL] TestLogAggregationFileController.class, [EOL] LogAggregationIndexedFileController.class, [EOL] LogAggregationTFileController.class); [EOL] private static final List<String> ALL_FILE_CONTROLLER_NAMES = [EOL] Arrays.asList("TestLogAggregationFileController", "IFile", "TFile"); [EOL] private ApplicationId appId = ApplicationId.newInstance( [EOL] System.currentTimeMillis(), 1); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetClass()  throws Throwable  { [EOL]       ClassLoader classLoader0 = ClassLoader.getSystemClassLoader(); [EOL]       Class<?> class0 = ClassUtils.getClass(classLoader0, "short"); [EOL]       assertEquals("short", class0.toString()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClusterMetricsXML() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("cluster") [EOL] .path("metrics").accept("application/xml").get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_XML + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] String xml = response.getEntity(String.class); [EOL] verifyClusterMetricsXML(xml); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRMWebServices.class); [EOL] private static MockRM rm; [EOL]
@Test [EOL] public void testGetConnectAddress() throws IOException { [EOL] NetUtils.addStaticResolution("host", "127.0.0.1"); [EOL] InetSocketAddress addr = NetUtils.createSocketAddrForHost("host", 1); [EOL] InetSocketAddress connectAddr = NetUtils.getConnectAddress(addr); [EOL] assertEquals(addr.getHostName(), connectAddr.getHostName()); [EOL] [EOL] addr = new InetSocketAddress(1); [EOL] connectAddr = NetUtils.getConnectAddress(addr); [EOL] assertEquals(InetAddress.getLocalHost().getHostName(), [EOL] connectAddr.getHostName()); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestNetUtils.class); [EOL] private static final int DEST_PORT = 4040; [EOL] private static final String DEST_PORT_NAME = Integer.toString(DEST_PORT); [EOL] private static final int LOCAL_PORT = 8080; [EOL] private static final String LOCAL_PORT_NAME = Integer.toString(LOCAL_PORT); [EOL] static final long TIME_FUDGE_MILLIS = 200; [EOL] static NetUtilsTestResolver resolver; [EOL] static Configuration config; [EOL]
@Test [EOL] public void testLoadFindsLog4J() throws Throwable { [EOL] run(FindClass.SUCCESS, FindClass.A_RESOURCE, LOG4J_PROPERTIES); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFindClass.class); [EOL] public static final String LOG4J_PROPERTIES = "log4j.properties"; [EOL]
@Test [EOL] public void testUpgradeDisabledWhenAllCompsHaveNeverRestartPolicy() [EOL] throws Exception { [EOL] Service service = createService(); [EOL] service.getComponents().forEach(comp -> [EOL] comp.setRestartPolicy(Component.RestartPolicyEnum.NEVER)); [EOL] [EOL] ServiceClient client = MockServiceClient.create(rule, service, true); [EOL] [EOL] //upgrade the service [EOL] service.setVersion("v2"); [EOL] try { [EOL] client.initiateUpgrade(service); [EOL] } catch (YarnException ex) { [EOL] Assert.assertEquals("All the components of the service " + [EOL] service.getName() + " have " + Component.RestartPolicyEnum.NEVER [EOL] + " restart policy, so it cannot be upgraded.", [EOL] ex.getMessage()); [EOL] return; [EOL] } [EOL] Assert.fail(); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger( [EOL] TestServiceClient.class); [EOL] @Rule [EOL] public ServiceTestUtils.ServiceFSWatcher rule = [EOL] new ServiceTestUtils.ServiceFSWatcher(); [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       compareToBuilder0.append(false, true); [EOL]       assertEquals((-1), compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testQueueProcessor() { [EOL] ContextProcessor queueProcessor = new QueueProcessor(); [EOL] ApplicationId app = ApplicationId.newInstance(123456, 111); [EOL] ApplicationSubmissionContext applicationSubmissionContext = [EOL] mock(ApplicationSubmissionContext.class); [EOL] when(applicationSubmissionContext.getApplicationId()).thenReturn(app); [EOL] queueProcessor.process("host.cluster2.com", "queue1", [EOL] app, applicationSubmissionContext); [EOL] verify(applicationSubmissionContext, times(1)).setQueue("queue1"); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisEndedBy()  throws Throwable  { [EOL]       Integer integer0 = new Integer(1); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(0, 0).when(comparator0).compare(any() , any()); [EOL]       Range<Object> range0 = Range.between((Object) integer0, (Object) "", comparator0); [EOL]       boolean boolean0 = range0.isEndedBy("Elements in a range must not be null: element1="); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testuncaughtExceptionHandler()  throws Throwable  { [EOL]       BasicThreadFactory.Builder basicThreadFactory_Builder0 = new BasicThreadFactory.Builder(); [EOL]       MockThread mockThread0 = new MockThread(""); [EOL]       Thread.UncaughtExceptionHandler thread_UncaughtExceptionHandler0 = mockThread0.getUncaughtExceptionHandler(); [EOL]       BasicThreadFactory.Builder basicThreadFactory_Builder1 = basicThreadFactory_Builder0.uncaughtExceptionHandler(thread_UncaughtExceptionHandler0); [EOL]       BasicThreadFactory basicThreadFactory0 = basicThreadFactory_Builder1.build(); [EOL]       Thread thread0 = basicThreadFactory0.newThread(mockThread0); [EOL]       assertEquals(0, thread0.countStackFrames()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testescapeJson()  throws Throwable  { [EOL]       String string0 = StringEscapeUtils.unescapeJson("Kr^K5)xi3M!@H]nX\"'Z"); [EOL]       assertEquals("Kr^K5)xi3M!@H]nX\"'Z", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCommandShellExample() throws Exception { [EOL] Example ex = new Example(); [EOL] ex.setConf(new Configuration()); [EOL] int rc = 0; [EOL] [EOL] outContent.reset(); [EOL] String[] args1 = {"hello"}; [EOL] rc = ex.run(args1); [EOL] assertEquals(outMsg("test exit code - normal hello"), 0, rc); [EOL] assertTrue(outMsg("test normal hello message"), [EOL] outContent.toString().contains(Example.HELLO_MSG)); [EOL] [EOL] outContent.reset(); [EOL] String[] args2 = {"hello", "x"}; [EOL] rc = ex.run(args2); [EOL] assertEquals(outMsg("test exit code - bad hello"), 1, rc); [EOL] assertTrue(outMsg("test bad hello message"), [EOL] outContent.toString().contains(Example.Hello.HELLO_USAGE)); [EOL] [EOL] outContent.reset(); [EOL] String[] args3 = {"goodbye"}; [EOL] rc = ex.run(args3); [EOL] assertEquals(outMsg("test exit code - normal goodbye"), 0, rc); [EOL] assertTrue(outMsg("test normal goodbye message"), [EOL] outContent.toString().contains(Example.GOODBYE_MSG)); [EOL] } [EOL] private final ByteArrayOutputStream outContent = new ByteArrayOutputStream(); [EOL]
@Test(timeout = 4000) [EOL]   public void testhandleCauseUnchecked()  throws Throwable  { [EOL]       ExecutionException executionException0 = mock(ExecutionException.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn((Throwable) null).when(executionException0).getCause(); [EOL]       ConcurrentUtils.extractCauseUnchecked(executionException0); [EOL]       ExecutionException executionException1 = new ExecutionException("#0K`4yx[{#", (Throwable) null); [EOL]       StackTraceElement[] stackTraceElementArray0 = new StackTraceElement[4]; [EOL]       StackTraceElement stackTraceElement0 = new StackTraceElement("org.apache.commons.lang3.concurrent.BasicThreadFactory$Builder", "org.apache.commons.lang3.concurrent.BasicThreadFactory$Builder", "org.apache.commons.lang3.concurrent.ConcurrentUtils", 0); [EOL]       stackTraceElementArray0[0] = stackTraceElement0; [EOL]       StackTraceElement stackTraceElement1 = new StackTraceElement("", "", "", 0); [EOL]       stackTraceElementArray0[1] = stackTraceElement1; [EOL]       StackTraceElement stackTraceElement2 = new StackTraceElement("!yvqM)9R9B+@s*FdB", "!yvqM)9R9B+@s*FdB", "org.apache.commons.lang3.concurrent.BasicThreadFactory$Builder", (-1072)); [EOL]       stackTraceElementArray0[2] = stackTraceElement2; [EOL]       StackTraceElement stackTraceElement3 = new StackTraceElement("XjP`4mI|d1]R6", "org.apache.commons.lang3.concurrent.ConcurrentUtils$ConstantFuture", "!yvqM)9R9B+@s*FdB", 2); [EOL]       stackTraceElementArray0[3] = stackTraceElement3; [EOL]       executionException1.setStackTrace(stackTraceElementArray0); [EOL]       ConcurrentUtils.extractCause(executionException1); [EOL]       ExecutionException executionException2 = new ExecutionException((Throwable) null); [EOL]       executionException2.fillInStackTrace(); [EOL]       executionException2.fillInStackTrace(); [EOL]       ConcurrentUtils.handleCauseUnchecked(executionException2); [EOL]       assertNotSame(executionException2, executionException1); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void teststringMatcher()  throws Throwable  { [EOL]       StrMatcher strMatcher0 = StrMatcher.stringMatcher("U"); [EOL]       char[] charArray0 = new char[7]; [EOL]       charArray0[0] = 'U'; [EOL]       int int0 = strMatcher0.isMatch(charArray0, 0); [EOL]       assertEquals(1, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCloseWhenFlushThrowingIOException() throws Exception { [EOL] MockOutputStream out = new MockOutputStream(); [EOL] SyncableDataOutputStream sdos = new SyncableDataOutputStream(out); [EOL] out.flushThrowIOE = true; [EOL] LambdaTestUtils.intercept(IOException.class, "An IOE from flush", () -> sdos.close()); [EOL] MockOutputStream out2 = new MockOutputStream(); [EOL] out2.flushThrowIOE = true; [EOL] LambdaTestUtils.intercept(IOException.class, "An IOE from flush", () -> { [EOL] try (SyncableDataOutputStream sdos2 = new SyncableDataOutputStream(out2)) { [EOL] } [EOL] }); [EOL] } [EOL]
@Test [EOL] public void testRemoteAddrWithTrustedProxy() { [EOL] assertEquals(clientAddr, getRemoteAddr(clientAddr, proxyAddr, true)); [EOL] assertEquals(clientAddr, getRemoteAddr(chainedClientAddr, proxyAddr, true)); [EOL] } [EOL] private final Configuration conf = new HdfsConfiguration(); [EOL] private static String clientAddr = "1.1.1.1"; [EOL] private static String chainedClientAddr = clientAddr+", 2.2.2.2"; [EOL] private static String proxyAddr = "3.3.3.3"; [EOL]
@Test [EOL] public void testSubmitReservationInvalidPlan() { [EOL] ReservationSubmissionRequest request = [EOL] createSimpleReservationSubmissionRequest(1, 1, 1, 5, 3); [EOL] when(rSystem.getPlan(PLAN_NAME)).thenReturn(null); [EOL] Plan plan = null; [EOL] try { [EOL] plan = [EOL] rrValidator.validateReservationSubmissionRequest(rSystem, request, [EOL] ReservationSystemTestUtil.getNewReservationId()); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertNull(plan); [EOL] String message = e.getMessage(); [EOL] Assert [EOL] .assertTrue(message [EOL] .endsWith(" is not managed by reservation system. Please try again with a valid reservable queue.")); [EOL] LOG.info(message); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestReservationInputValidator.class); [EOL] private static final String PLAN_NAME = "test-reservation"; [EOL] private Clock clock; [EOL] private Map<String, Plan> plans = new HashMap<String, Plan>(1); [EOL] private ReservationSystem rSystem; [EOL] private Plan plan; [EOL] private ReservationInputValidator rrValidator; [EOL]
@Test [EOL] public void testFinish() throws IOException { [EOL] And and = new And(); [EOL] Expression first = mock(Expression.class); [EOL] Expression second = mock(Expression.class); [EOL] [EOL] Deque<Expression> children = new LinkedList<Expression>(); [EOL] children.add(second); [EOL] children.add(first); [EOL] and.addChildren(children); [EOL] [EOL] and.finish(); [EOL] verify(first).finish(); [EOL] verify(second).finish(); [EOL] verifyNoMoreInteractions(first); [EOL] verifyNoMoreInteractions(second); [EOL] } [EOL] @Rule [EOL] public Timeout globalTimeout = new Timeout(10000); [EOL]
@Test [EOL] public void testPreserveStatus() throws IOException { [EOL] TaskAttemptContext taskAttemptContext = getTaskAttemptContext(config); [EOL] JobContext jobContext = new JobContextImpl(taskAttemptContext.getConfiguration(), [EOL] taskAttemptContext.getTaskAttemptID().getJobID()); [EOL] Configuration conf = jobContext.getConfiguration(); [EOL] [EOL] [EOL] String sourceBase; [EOL] String targetBase; [EOL] FileSystem fs = null; [EOL] try { [EOL] OutputCommitter committer = new CopyCommitter(null, taskAttemptContext); [EOL] fs = FileSystem.get(conf); [EOL] FsPermission sourcePerm = new FsPermission((short) 511); [EOL] FsPermission initialPerm = new FsPermission((short) 448); [EOL] sourceBase = TestDistCpUtils.createTestSetup(fs, sourcePerm); [EOL] targetBase = TestDistCpUtils.createTestSetup(fs, initialPerm); [EOL] [EOL] final DistCpOptions options = new DistCpOptions.Builder( [EOL] Collections.singletonList(new Path(sourceBase)), new Path("/out")) [EOL] .preserve(FileAttribute.PERMISSION).build(); [EOL] options.appendToConf(conf); [EOL] final DistCpContext context = new DistCpContext(options); [EOL] context.setTargetPathExists(false); [EOL] [EOL] CopyListing listing = new GlobbedCopyListing(conf, CREDENTIALS); [EOL] Path listingFile = new Path("/tmp1/" + rand.nextLong()); [EOL] listing.buildListing(listingFile, context); [EOL] [EOL] conf.set(CONF_LABEL_TARGET_FINAL_PATH, targetBase); [EOL] [EOL] committer.commitJob(jobContext); [EOL] checkDirectoryPermissions(fs, targetBase, sourcePerm); [EOL] [EOL] //Test for idempotent commit [EOL] committer.commitJob(jobContext); [EOL] checkDirectoryPermissions(fs, targetBase, sourcePerm); [EOL] [EOL] } finally { [EOL] TestDistCpUtils.delete(fs, "/tmp1"); [EOL] conf.unset(DistCpConstants.CONF_LABEL_PRESERVE_STATUS); [EOL] } [EOL] [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestCopyCommitter.class); [EOL] private static final Random rand = new Random(); [EOL] private static final long BLOCK_SIZE = 1024; [EOL] private static final Credentials CREDENTIALS = new Credentials(); [EOL] public static final int PORT = 39737; [EOL] private static Configuration clusterConfig; [EOL] private static MiniDFSCluster cluster; [EOL] private Configuration config; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("SzpQ!4 ;U"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) "SzpQ!4 ;U", 66, '\"'); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.deleteAll("SzpQ!4 ;U"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       int int0 = (-1498); [EOL]       StrBuilder strBuilder0 = new StrBuilder((-1498)); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       char char0 = 'Y'; [EOL]       StrMatcher strMatcher0 = StrMatcher.commaMatcher(); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher('Y'); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceAll("I%EqwV7sG3W", "I%EqwV7sG3W"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       int int1 = strBuilder0.lastIndexOf(strMatcher0, 116); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = 'Y'; [EOL]       int int2 = 7; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.validateRange((-738), (-1498)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -738 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 30000) [EOL] public void testInitDecommMetricNoRegistration() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] MockNM nm1 = rm.registerNode("host1:1234", 5120); [EOL] MockNM nm2 = rm.registerNode("host2:5678", 10240); [EOL] nm1.nodeHeartbeat(true); [EOL] nm2.nodeHeartbeat(true); [EOL] //host3 will not register or heartbeat [EOL] writeToHostsFile(excludeHostFile, "host3", "host2"); [EOL] conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, [EOL] excludeHostFile.getAbsolutePath()); [EOL] writeToHostsFile(hostFile, "host1", "host2"); [EOL] conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, [EOL] hostFile.getAbsolutePath()); [EOL] rm.getNodesListManager().refreshNodes(conf); [EOL] rm.drainEvents(); [EOL] Assert.assertEquals("The decommissioned nodes metric should be 1 ", [EOL] 1, ClusterMetrics.getMetrics().getNumDecommisionedNMs()); [EOL] rm.stop(); [EOL] [EOL] MockRM rm1 = new MockRM(conf); [EOL] rm1.start(); [EOL] rm1.getNodesListManager().refreshNodes(conf); [EOL] rm1.drainEvents(); [EOL] Assert.assertEquals("The decommissioned nodes metric should be 2 ", [EOL] 2, ClusterMetrics.getMetrics().getNumDecommisionedNMs()); [EOL] rm1.stop(); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(1580); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       char[] charArray1 = strBuilder0.getChars(charArray0); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, charArray0.length); [EOL]       assertEquals(0, charArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 60000) [EOL] public void testDFSAdminUnreachableDatanode() throws Exception { [EOL] redirectStream(); [EOL] final DFSAdmin dfsAdmin = new DFSAdmin(conf); [EOL] for (String command : new String[]{"-getDatanodeInfo", [EOL] "-evictWriters", "-getBalancerBandwidth"}) { [EOL] // Connecting to Xfer port instead of IPC port will get [EOL] // Datanode unreachable. java.io.EOFException [EOL] final String dnDataAddr = datanode.getXferAddress().getHostString() + ":" [EOL] + datanode.getXferPort(); [EOL] resetStream(); [EOL] final List<String> outs = Lists.newArrayList(); [EOL] final int ret = ToolRunner.run(dfsAdmin, [EOL] new String[]{command, dnDataAddr}); [EOL] assertEquals(-1, ret); [EOL] [EOL] scanIntoList(out, outs); [EOL] assertTrue("Unexpected " + command + " stdout: " + out, outs.isEmpty()); [EOL] assertTrue("Unexpected " + command + " stderr: " + err, [EOL] err.toString().contains("Exception")); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestDFSAdmin.class); [EOL] private Configuration conf = null; [EOL] private MiniDFSCluster cluster; [EOL] private DFSAdmin admin; [EOL] private DataNode datanode; [EOL] private NameNode namenode; [EOL] private final ByteArrayOutputStream out = new ByteArrayOutputStream(); [EOL] private final ByteArrayOutputStream err = new ByteArrayOutputStream(); [EOL] private static final PrintStream OLD_OUT = System.out; [EOL] private static final PrintStream OLD_ERR = System.err; [EOL] private String tempResource = null; [EOL] private static final int NUM_DATANODES = 2; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetTimeInstance()  throws Throwable  { [EOL]       TimeZone timeZone0 = TimeZone.getTimeZone("CGnq5w2>W6Y47X"); [EOL]       Locale locale0 = Locale.SIMPLIFIED_CHINESE; [EOL]       FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0); [EOL]       String string0 = fastDateFormat0.getPattern(); [EOL]       assertEquals("ahh'\u65F6'mm'\u5206'ss'\u79D2' z", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("1so6^[^z!mYS2"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(true); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       String string0 = strBuilder0.getNullText(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = new StrBuilder("1so6^[^z!mYS2"); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln(strBuilder2); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.appendFixedWidthPadRight((-364), (-364), ';'); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(true); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder5.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendln(strBuilder0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder6.getNullText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.lowerCase("ghZ]CWmR;Q]$V");q]$v", string0); [EOL]        [EOL]       String string1 = StringUtils.substringBetween("", "Search and Replace array lengths don't match: "); [EOL]        [EOL]       String string2 = StringUtils.appendIfMissing("Strings must not be null", (CharSequence) null, (CharSequence[]) null); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       String string0 = strBuilder0.build(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, ""); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       String string1 = ""; [EOL]       StringBuffer stringBuffer0 = new StringBuffer(""); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append(stringBuffer0, 3, 0); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       ArrayDeque<Object> arrayDeque0 = new ArrayDeque<Object>(); [EOL]        [EOL]       Iterator<Object> iterator0 = arrayDeque0.descendingIterator(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators(iterator0, "java.class.version"); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append('Y'); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDecodeWritableArgSanityCheck() throws Exception { [EOL] Token<AbstractDelegationTokenIdentifier> token = new Token<>(); [EOL] intercept(HadoopIllegalArgumentException.class, [EOL] () -> token.decodeFromUrlString(null)); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]       standardToStringStyle0.appendCyclicObject(stringBuffer0, (String) null, stringBuffer0); [EOL]       assertEquals(">", standardToStringStyle0.getSizeEndText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testescapeEcmaScript()  throws Throwable  { [EOL]       String string0 = StringEscapeUtils.unescapeEcmaScript("+g"); [EOL]       assertEquals("+g", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testTrashProcedure() throws Exception { [EOL] Path src = new Path("/" + getMethodName() + "-src"); [EOL] Path dst = new Path("/" + getMethodName() + "-dst"); [EOL] FileSystem fs = cluster.getFileSystem(); [EOL] fs.mkdirs(src); [EOL] fs.mkdirs(new Path(src, "dir")); [EOL] assertTrue(fs.exists(src)); [EOL] [EOL] FedBalanceContext context = [EOL] new FedBalanceContext.Builder(src, dst, TestDistCpProcedure.MOUNT, conf) [EOL] .setMapNum(10).setBandwidthLimit(1).setTrash(TrashOption.TRASH) [EOL] .build(); [EOL] TrashProcedure trashProcedure = [EOL] new TrashProcedure("trash-procedure", null, 1000, context); [EOL] trashProcedure.moveToTrash(); [EOL] assertFalse(fs.exists(src)); [EOL] } [EOL] private static Configuration conf; [EOL] private static MiniDFSCluster cluster; [EOL] private static String nnUri; [EOL]
@Test [EOL] public void testCompareToNumberDataLT() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare testCompareToNumberDataLT"); [EOL] TModelInstanceDetails lhs = new TModelInstanceDetails(); [EOL] lhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] lhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] lhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] lhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("3.10"); [EOL] TModelInstanceDetails rhs = new TModelInstanceDetails(); [EOL] [EOL] rhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] rhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] rhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("3.14"); [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", true, false, false); [EOL] [EOL] int result = instance.compare(lhs, rhs); [EOL] Assert.assertTrue("result " + result, result < 0); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       int int0 = 7; [EOL]       StrBuilder strBuilder0 = new StrBuilder(7); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.trim(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       int int1 = 0; [EOL]       int int2 = 32; [EOL]       StrBuilder strBuilder2 = strBuilder0.insert(0, 32); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append('r'); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       Integer integer0 = new Integer(0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.clear(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.quoteMatcher(); [EOL]        [EOL]       String string0 = ")[C$#_(U9,]+>eub7]}"; [EOL]       StrBuilder strBuilder5 = strBuilder0.appendln(false); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.replaceAll(strMatcher0, ")[C$#_(U9,]+>eub7]}"); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]       assertNull(strBuilder6.getNewLineText()); [EOL]        [EOL]       char char0 = 'c'; [EOL]       int int3 = strBuilder0.lastIndexOf('c', 7); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder2.appendSeparator("Solaris"); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder7.getNewLineText()); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder1.new StrBuilderWriter(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder4.appendFixedWidthPadRight((Object) "java.vm.specification.version", 81, '0'); [EOL]       assertNull(strBuilder8.getNewLineText()); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder_StrBuilderWriter0.write("J~TQzXP^tZ:~", 7, 519); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFileMissing() { [EOL] [EOL] IPList ipl = new FileBasedIPList("missingips.txt"); [EOL] [EOL] assertFalse("110.113.221.222 is in the list", [EOL] ipl.isIn("110.113.221.222")); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testtoStringYesNo()  throws Throwable  { [EOL]       String string0 = BooleanUtils.toStringYesNo(true); [EOL]       assertEquals("yes", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>(); [EOL]       equalsBuilder0.append(true, true); [EOL]       Class<Integer> class0 = Integer.class; [EOL]       String[] stringArray0 = new String[3]; [EOL]       stringArray0[1] = ""; [EOL]       stringArray0[2] = "Q@a+w^PT*i"; [EOL]       EqualsBuilder.reflectionEquals((Object) equalsBuilder0, (Object) null, true, (Class<?>) class0, stringArray0); [EOL]       Boolean boolean0 = Boolean.FALSE; [EOL]       MutablePair<IDKey, IDKey> mutablePair0 = new MutablePair<IDKey, IDKey>(); [EOL]       float[] floatArray0 = new float[4]; [EOL]       floatArray0[1] = (float) (byte)2; [EOL]       EqualsBuilder.reflectionEquals((Object) stringArray0[0], (Object) boolean0, stringArray0); [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append((-3995L), (-3995L)); [EOL]        [EOL]       float[] floatArray1 = new float[1]; [EOL]       floatArray1[0] = (float) (byte)2; [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(floatArray0, floatArray1); [EOL]       assertFalse(equalsBuilder2.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testRenameAcrossFs() throws IOException { [EOL] fc.mkdir(new Path("/newDir/dirFoo"), FileContext.DEFAULT_PERM, true); [EOL] // the root will get interpreted to the root of the chrooted fs. [EOL] fc.rename(new Path("/newDir/dirFoo"), new Path("file:///dirFooBar")); [EOL] FileContextTestHelper.isDir(fc, new Path("/dirFooBar")); [EOL] } [EOL] FileContextTestHelper fileContextTestHelper = new FileContextTestHelper(); [EOL] FileContext fc; [EOL] FileContext fcTarget; [EOL] Path chrootedTo; [EOL]
@Test [EOL] public void testGetRelativePathRoot() { [EOL] Path root = new Path("/"); [EOL] Path child = new Path("/a"); [EOL] assertThat(DistCpUtils.getRelativePath(root, child)).isEqualTo("/a"); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestDistCpUtils.class); [EOL] private static final Configuration config = new Configuration(); [EOL] private static MiniDFSCluster cluster; [EOL] private static final FsPermission fullPerm = new FsPermission((short) 777); [EOL] private static final FsPermission almostFullPerm = new FsPermission((short) 666); [EOL] private static final FsPermission noPerm = new FsPermission((short) 0); [EOL] private static Random rand = new Random(); [EOL]
@Test [EOL] public void testNodeLabelProcessor() { [EOL] ContextProcessor nodeLabelProcessor = new NodeLabelProcessor(); [EOL] ApplicationId app = ApplicationId.newInstance(123456, 111); [EOL] ApplicationSubmissionContext applicationSubmissionContext = [EOL] mock(ApplicationSubmissionContext.class); [EOL] when(applicationSubmissionContext.getApplicationId()).thenReturn(app); [EOL] nodeLabelProcessor.process("host.cluster2.com", "foo", app, [EOL] applicationSubmissionContext); [EOL] verify(applicationSubmissionContext, times(1)) [EOL] .setNodeLabelExpression("foo"); [EOL] } [EOL]
@Test [EOL] public void testCopyBytesWithCountShouldThrowOutTheStreamClosureExceptions() [EOL] throws Exception { [EOL] InputStream inputStream = Mockito.mock(InputStream.class); [EOL] OutputStream outputStream = Mockito.mock(OutputStream.class); [EOL] Mockito.doReturn(-1).when(inputStream).read(new byte[4096], 0, 1); [EOL] Mockito.doThrow(new IOException("Exception in closing the stream")).when( [EOL] outputStream).close(); [EOL] try { [EOL] IOUtils.copyBytes(inputStream, outputStream, (long) 1, true); [EOL] fail("Should throw out the exception"); [EOL] } catch (IOException e) { [EOL] assertEquals("Not throwing the expected exception.", [EOL] "Exception in closing the stream", e.getMessage()); [EOL] } [EOL] Mockito.verify(inputStream, Mockito.atLeastOnce()).close(); [EOL] Mockito.verify(outputStream, Mockito.atLeastOnce()).close(); [EOL] } [EOL] private static final String TEST_FILE_NAME = "test_file"; [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestIOUtils.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       String string0 = "A"; [EOL]       String string1 = "org.apache.commons.lang3.text.StrBuilder$StrBuilderTokenizer"; [EOL]       int int0 = 34; [EOL]       boolean boolean0 = false; [EOL]       StrBuilder strBuilder1 = new StrBuilder("A"); [EOL]       assertEquals(33, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln(strBuilder1); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(33, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append(0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(33, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]        [EOL]       char char0 = strBuilder3.charAt(0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(33, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder3.append((CharSequence) strBuilder2, 34, 0); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetEntitiesByConfigFilters() throws Exception { [EOL] Client client = createClient(); [EOL] try { [EOL] URI uri = URI.create("http://localhost:" + serverPort + "/ws/v2/" + [EOL] "timeline/clusters/cluster1/apps/app1/entities/app?" + [EOL] "conffilters=config_1%20eq%20123%20AND%20config_3%20eq%20abc"); [EOL] ClientResponse resp = getResponse(client, uri); [EOL] Set<TimelineEntity> entities = [EOL] resp.getEntity(new GenericType<Set<TimelineEntity>>(){}); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] resp.getType().toString()); [EOL] assertNotNull(entities); [EOL] assertEquals(1, entities.size()); [EOL] assertTrue("Entity with id_3 should have been present in response.", [EOL] entities.contains(newEntity("app", "id_3"))); [EOL] } finally { [EOL] client.destroy(); [EOL] } [EOL] } [EOL] private static final String ROOT_DIR = new File("target", [EOL] TestTimelineReaderWebServices.class.getSimpleName()).getAbsolutePath(); [EOL] private int serverPort; [EOL] private TimelineReaderServer server; [EOL]
@Test [EOL] public void testRMAuditLoggerWithIP() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] RPC.setProtocolEngine(conf, TestRpcService.class, [EOL] ProtobufRpcEngine2.class); [EOL] [EOL] // Create server side implementation [EOL] MyTestRPCServer serverImpl = new MyTestRPCServer(); [EOL] BlockingService service = TestRpcServiceProtos.TestProtobufRpcProto [EOL] .newReflectiveBlockingService(serverImpl); [EOL] [EOL] // start the IPC server [EOL] Server server = new RPC.Builder(conf) [EOL] .setProtocol(TestRpcService.class) [EOL] .setInstance(service).setBindAddress("0.0.0.0") [EOL] .setPort(0).setNumHandlers(5).setVerbose(true).build(); [EOL] [EOL] server.start(); [EOL] [EOL] InetSocketAddress addr = NetUtils.getConnectAddress(server); [EOL] [EOL] // Make a client connection and test the audit log [EOL] TestRpcService proxy = RPC.getProxy(TestRpcService.class, [EOL] TestProtocol.versionID, addr, conf); [EOL] // Start the testcase [EOL] TestProtos.EmptyRequestProto pingRequest = [EOL] TestProtos.EmptyRequestProto.newBuilder().build(); [EOL] proxy.ping(null, pingRequest); [EOL] [EOL] server.stop(); [EOL] RPC.stopProxy(proxy); [EOL] } [EOL] private static final String USER = "test"; [EOL] private static final String OPERATION = "oper"; [EOL] private static final String TARGET = "tgt"; [EOL] private static final String PERM = "admin group"; [EOL] private static final String DESC = "description of an audit log"; [EOL] private static final String QUEUE = "root"; [EOL] private static final ApplicationId APPID = mock(ApplicationId.class); [EOL] private static final ApplicationAttemptId ATTEMPTID = mock(ApplicationAttemptId.class); [EOL] private static final ContainerId CONTAINERID = mock(ContainerId.class); [EOL] private static final Resource RESOURCE = mock(Resource.class); [EOL] private static final String CALLER_CONTEXT = "context"; [EOL] private static final byte[] CALLER_SIGNATURE = "signature".getBytes(); [EOL] private static final String PARTITION = "label1"; [EOL]
@Test [EOL] public void testAsyncEntityDiscard() throws Exception { [EOL] TimelineWriter writer = mock(TimelineWriter.class); [EOL] [EOL] when(writer.write(any(), any(), any())).thenAnswer( [EOL] new AnswersWithDelay(500, new Returns(new TimelineWriteResponse()))); [EOL] TimelineCollector collector = new TimelineCollectorForTest(writer); [EOL] Configuration config = new Configuration(); [EOL] config [EOL] .setInt(YarnConfiguration.TIMELINE_SERVICE_WRITER_ASYNC_QUEUE_CAPACITY, [EOL] 3); [EOL] collector.init(config); [EOL] collector.start(); [EOL] for (int i = 0; i < 10; ++i) { [EOL] TimelineEntities entities = generateTestEntities(i + 1, 1); [EOL] collector.putEntitiesAsync(entities, [EOL] UserGroupInformation.createRemoteUser("test-user")); [EOL] } [EOL] Thread.sleep(3000); [EOL] verify(writer, times(4)) [EOL] .write(any(TimelineCollectorContext.class), any(TimelineEntities.class), [EOL] any(UserGroupInformation.class)); [EOL] verify(writer, never()).flush(); [EOL] collector.stop(); [EOL] } [EOL]
@Test [EOL] public void testMaxAllocationsPerAMHeartbeatDifferentSchedKey() [EOL] throws Exception { [EOL] ResourceBlacklistRequest blacklistRequest = [EOL] ResourceBlacklistRequest.newInstance( [EOL] new ArrayList<>(), new ArrayList<>()); [EOL] allocator.setMaxAllocationsPerAMHeartbeat(2); [EOL] final ExecutionTypeRequest oppRequest = ExecutionTypeRequest.newInstance( [EOL] ExecutionType.OPPORTUNISTIC, true); [EOL] List<ResourceRequest> reqs = [EOL] Arrays.asList( [EOL] ResourceRequest.newInstance(Priority.newInstance(1), "*", [EOL] CAPABILITY_1GB, 1, true, null, OPPORTUNISTIC_REQ), [EOL] ResourceRequest.newInstance(Priority.newInstance(2), "h6", [EOL] CAPABILITY_1GB, 2, true, null, OPPORTUNISTIC_REQ), [EOL] ResourceRequest.newInstance(Priority.newInstance(3), "/r3", [EOL] CAPABILITY_1GB, 2, true, null, OPPORTUNISTIC_REQ)); [EOL] ApplicationAttemptId appAttId = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(0L, 1), 1); [EOL] [EOL] oppCntxt.updateNodeList( [EOL] Arrays.asList( [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h3", 1234), "h3:1234", "/r2"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h2", 1234), "h2:1234", "/r1"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h5", 1234), "h5:1234", "/r1"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h4", 1234), "h4:1234", "/r2"))); [EOL] [EOL] List<Container> containers = allocator.allocateContainers( [EOL] blacklistRequest, reqs, appAttId, oppCntxt, 1L, "user1"); [EOL] LOG.info("Containers: {}", containers); [EOL] // Although capacity is present, but only 2 containers should be allocated [EOL] // as max allocation per AM heartbeat is set to 2. [EOL] Assert.assertEquals(2, containers.size()); [EOL] containers = allocator.allocateContainers( [EOL] blacklistRequest, new ArrayList<>(), appAttId, oppCntxt, 1L, "user1"); [EOL] LOG.info("Containers: {}", containers); [EOL] // 2 more containers should be allocated from pending allocation requests. [EOL] Assert.assertEquals(2, containers.size()); [EOL] containers = allocator.allocateContainers( [EOL] blacklistRequest, new ArrayList<>(), appAttId, oppCntxt, 1L, "user1"); [EOL] LOG.info("Containers: {}", containers); [EOL] // Remaining 1 container should be allocated. [EOL] Assert.assertEquals(1, containers.size()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger( [EOL] TestDistributedOpportunisticContainerAllocator.class); [EOL] private static final int GB = 1024; [EOL] private DistributedOpportunisticContainerAllocator allocator = null; [EOL] private OpportunisticContainerContext oppCntxt = null; [EOL] private static final Priority PRIORITY_NORMAL = Priority.newInstance(1); [EOL] private static final Resource CAPABILITY_1GB = [EOL] Resources.createResource(1 * GB); [EOL] private static final ExecutionTypeRequest OPPORTUNISTIC_REQ = [EOL] ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC, true); [EOL]
@Test [EOL] public void testRevertAllSuppressed() throws Throwable { [EOL] CounterTask failLast = new CounterTask("task", ITEM_COUNT, Item::commit); [EOL] [EOL] assertFailed(builder() [EOL] .suppressExceptions() [EOL] .stopOnFailure() [EOL] .revertWith(reverter) [EOL] .abortWith(aborter) [EOL] .onFailure(failures), [EOL] failLast); [EOL] failLast.assertInvoked("success", ITEM_COUNT); [EOL] int abCount = aborter.getCount(); [EOL] int revCount = reverter.getCount(); [EOL] assertEquals(ITEM_COUNT, 1 + abCount + revCount); [EOL] // identify which task failed from the set [EOL] int failing = failures.getItem().id; [EOL] // all committed were reverted [EOL] items.stream() [EOL] .filter(i -> i.id != failing) [EOL] .filter(i -> i.committed) [EOL] .forEach(Item::assertReverted); [EOL] items.stream() [EOL] .filter(i -> i.id != failing) [EOL] .filter(i -> !i.committed) [EOL] .forEach(Item::assertAborted); [EOL] // all reverted items are committed [EOL] items.stream().filter(i -> i.reverted) [EOL] .forEach(Item::assertCommitted); [EOL] [EOL] // only one failure was triggered [EOL] failures.assertInvoked("failure event", 1); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestTasks.class); [EOL] public static final int ITEM_COUNT = 16; [EOL] private static final int FAILPOINT = 8; [EOL] private final int numThreads; [EOL] private ExecutorService threadPool; [EOL] Tasks.Submitter submitter; [EOL] private final CounterTask failingTask [EOL] = new CounterTask("failing committer", FAILPOINT, Item::commit); [EOL] private final FailureCounter failures [EOL] = new FailureCounter("failures", 0, null); [EOL] private final CounterTask reverter [EOL] = new CounterTask("reverter", 0, Item::revert); [EOL] private final CounterTask aborter [EOL] = new CounterTask("aborter", 0, Item::abort); [EOL] private List<Item> items; [EOL]
@Test [EOL] public void testUpdateReservation() { [EOL] Plan plan = new InMemoryPlan(queueMetrics, policy, agent, totalCapacity, 1L, [EOL] resCalc, minAlloc, maxAlloc, planName, replanner, true, context); [EOL] ReservationId reservationID = [EOL] ReservationSystemTestUtil.getNewReservationId(); [EOL] // First add a reservation [EOL] int[] alloc = { 10, 10, 10, 10, 10, 10 }; [EOL] int start = 100; [EOL] ReservationAllocation rAllocation = [EOL] createReservationAllocation(reservationID, start, alloc); [EOL] Assert.assertNull(plan.getReservationById(reservationID)); [EOL] try { [EOL] plan.addReservation(rAllocation, false); [EOL] } catch (PlanningException e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] doAssertions(plan, rAllocation); [EOL] [EOL] RLESparseResourceAllocation userCons = [EOL] plan.getConsumptionForUserOverTime(user, start, start + alloc.length); [EOL] for (int i = 0; i < alloc.length; i++) { [EOL] assertEquals(Resource.newInstance(1024 * (alloc[i]), (alloc[i])), [EOL] plan.getTotalCommittedResources(start + i)); [EOL] assertEquals(Resource.newInstance(1024 * (alloc[i]), (alloc[i])), [EOL] userCons.getCapacityAtTime(start + i)); [EOL] } [EOL] [EOL] // Now update it [EOL] start = 110; [EOL] int[] updatedAlloc = { 0, 5, 10, 10, 5, 0 }; [EOL] rAllocation = [EOL] createReservationAllocation(reservationID, start, updatedAlloc, true); [EOL] try { [EOL] plan.updateReservation(rAllocation); [EOL] } catch (PlanningException e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] doAssertions(plan, rAllocation); [EOL] [EOL] userCons = plan.getConsumptionForUserOverTime(user, start, [EOL] start + updatedAlloc.length); [EOL] [EOL] for (int i = 0; i < updatedAlloc.length; i++) { [EOL] assertEquals(Resource.newInstance(1024 * (updatedAlloc[i] + i), [EOL] updatedAlloc[i] + i), plan.getTotalCommittedResources(start + i)); [EOL] assertEquals(Resource.newInstance(1024 * (updatedAlloc[i] + i), [EOL] updatedAlloc[i] + i), userCons.getCapacityAtTime(start + i)); [EOL] } [EOL] } [EOL] private String user = "yarn"; [EOL] private String planName = "test-reservation"; [EOL] private ResourceCalculator resCalc; [EOL] private Resource minAlloc; [EOL] private Resource maxAlloc; [EOL] private Resource totalCapacity; [EOL] private Clock clock; [EOL] private QueueMetrics queueMetrics; [EOL] private SharingPolicy policy; [EOL] private ReservationAgent agent; [EOL] private Planner replanner; [EOL] private RMContext context; [EOL] private long maxPeriodicity; [EOL]
@Test [EOL] public void testUsingWeightedTimeCostProviderNoRequests() { [EOL] scheduler = getSchedulerWithWeightedTimeCostProvider(2, "ipc.18"); [EOL] [EOL] assertEquals(0, scheduler.getPriorityLevel(mockCall("A"))); [EOL] } [EOL] private DecayRpcScheduler scheduler; [EOL]
@Test(timeout = 4000) [EOL]   public void testwrite()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]        [EOL]       char[] charArray0 = new char[5]; [EOL]       StrMatcher.CharSetMatcher strMatcher_CharSetMatcher0 = new StrMatcher.CharSetMatcher(charArray0); [EOL]        [EOL]       int int0 = strBuilder0.indexOf((StrMatcher) strMatcher_CharSetMatcher0, 8); [EOL]        [EOL]       charArray0[0] = '+'; [EOL]       StrBuilder strBuilder1 = strBuilder0.append(charArray0); [EOL]        [EOL]       charArray0[1] = 'd'; [EOL]       charArray0[2] = '8'; [EOL]       charArray0[3] = '='; [EOL]       charArray0[4] = 'H'; [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln(charArray0); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]        [EOL]       Writer writer0 = strBuilder2.asWriter(); [EOL]       assertNotNull(writer0); [EOL]        [EOL]       boolean boolean0 = strBuilder0.endsWith((String) null); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append(strBuilder3, 2438, 2438); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetCheckProcessIsAliveCommand() throws Exception { [EOL] String anyPid = "9999"; [EOL] String[] checkProcessAliveCommand = getCheckProcessIsAliveCommand( [EOL] anyPid); [EOL] [EOL] String[] expectedCommand; [EOL] [EOL] if (Shell.WINDOWS) { [EOL] expectedCommand = [EOL] new String[]{getWinUtilsPath(), "task", "isAlive", anyPid }; [EOL] } else if (Shell.isSetsidAvailable) { [EOL] expectedCommand = new String[] { "bash", "-c", "kill -0 -- -'" + [EOL] anyPid + "'"}; [EOL] } else { [EOL] expectedCommand = new String[] {"bash", "-c", "kill -0 '" + anyPid + [EOL] "'" }; [EOL] } [EOL] Assert.assertArrayEquals(expectedCommand, checkProcessAliveCommand); [EOL] } [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(30000); [EOL] @Rule [EOL] public TestName methodName = new TestName(); [EOL] private File rootTestDir = GenericTestUtils.getTestDir(); [EOL] private File methodDir; [EOL]
@Test(timeout = 300000) [EOL] public void testMoverWithStripedFile() throws Exception { [EOL] final Configuration conf = new HdfsConfiguration(); [EOL] initConfWithStripe(conf); [EOL] [EOL] // start 10 datanodes [EOL] int numOfDatanodes =10; [EOL] int storagesPerDatanode=2; [EOL] long capacity = 10 * defaultBlockSize; [EOL] long[][] capacities = new long[numOfDatanodes][storagesPerDatanode]; [EOL] for (int i = 0; i < numOfDatanodes; i++) { [EOL] for(int j=0;j<storagesPerDatanode;j++){ [EOL] capacities[i][j]=capacity; [EOL] } [EOL] } [EOL] final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf) [EOL] .numDataNodes(numOfDatanodes) [EOL] .storagesPerDatanode(storagesPerDatanode) [EOL] .storageTypes(new StorageType[][]{ [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}}) [EOL] .storageCapacities(capacities) [EOL] .build(); [EOL] [EOL] try { [EOL] cluster.waitActive(); [EOL] cluster.getFileSystem().enableErasureCodingPolicy( [EOL] StripedFileTestUtil.getDefaultECPolicy().getName()); [EOL] [EOL] // set "/bar" directory with HOT storage policy. [EOL] ClientProtocol client = NameNodeProxies.createProxy(conf, [EOL] cluster.getFileSystem(0).getUri(), ClientProtocol.class).getProxy(); [EOL] String barDir = "/bar"; [EOL] client.mkdirs(barDir, new FsPermission((short) 777), true); [EOL] client.setStoragePolicy(barDir, [EOL] HdfsConstants.HOT_STORAGE_POLICY_NAME); [EOL] // set an EC policy on "/bar" directory [EOL] client.setErasureCodingPolicy(barDir, [EOL] StripedFileTestUtil.getDefaultECPolicy().getName()); [EOL] [EOL] // write file to barDir [EOL] final String fooFile = "/bar/foo"; [EOL] long fileLen = 20 * defaultBlockSize; [EOL] DFSTestUtil.createFile(cluster.getFileSystem(), new Path(fooFile), [EOL] fileLen,(short) 3, 0); [EOL] [EOL] // verify storage types and locations [EOL] LocatedBlocks locatedBlocks = [EOL] client.getBlockLocations(fooFile, 0, fileLen); [EOL] for(LocatedBlock lb : locatedBlocks.getLocatedBlocks()){ [EOL] for( StorageType type : lb.getStorageTypes()){ [EOL] Assert.assertEquals(StorageType.DISK, type); [EOL] } [EOL] } [EOL] StripedFileTestUtil.verifyLocatedStripedBlocks(locatedBlocks, [EOL] dataBlocks + parityBlocks); [EOL] [EOL] // start 5 more datanodes [EOL] numOfDatanodes +=5; [EOL] capacities = new long[5][storagesPerDatanode]; [EOL] for (int i = 0; i < 5; i++) { [EOL] for(int j=0;j<storagesPerDatanode;j++){ [EOL] capacities[i][j]=capacity; [EOL] } [EOL] } [EOL] cluster.startDataNodes(conf, 5, [EOL] new StorageType[][]{ [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}}, [EOL] true, null, null, null,capacities, null, false, false, false, null); [EOL] cluster.triggerHeartbeats(); [EOL] [EOL] // move file to ARCHIVE [EOL] client.setStoragePolicy(barDir, "COLD"); [EOL] // run Mover [EOL] int rc = ToolRunner.run(conf, new Mover.Cli(), [EOL] new String[] { "-p", barDir }); [EOL] Assert.assertEquals("Movement to ARCHIVE should be successful", 0, rc); [EOL] [EOL] // verify storage types and locations [EOL] locatedBlocks = client.getBlockLocations(fooFile, 0, fileLen); [EOL] for(LocatedBlock lb : locatedBlocks.getLocatedBlocks()){ [EOL] for( StorageType type : lb.getStorageTypes()){ [EOL] Assert.assertEquals(StorageType.ARCHIVE, type); [EOL] } [EOL] } [EOL] StripedFileTestUtil.verifyLocatedStripedBlocks(locatedBlocks, [EOL] dataBlocks + parityBlocks); [EOL] [EOL] // start 5 more datanodes [EOL] numOfDatanodes += 5; [EOL] capacities = new long[5][storagesPerDatanode]; [EOL] for (int i = 0; i < 5; i++) { [EOL] for (int j = 0; j < storagesPerDatanode; j++) { [EOL] capacities[i][j] = capacity; [EOL] } [EOL] } [EOL] cluster.startDataNodes(conf, 5, [EOL] new StorageType[][] { { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK } }, [EOL] true, null, null, null, capacities, null, false, false, false, null); [EOL] cluster.triggerHeartbeats(); [EOL] [EOL] // move file blocks to ONE_SSD policy [EOL] client.setStoragePolicy(barDir, "ONE_SSD"); [EOL] [EOL] // run Mover [EOL] rc = ToolRunner.run(conf, new Mover.Cli(), new String[] { "-p", barDir }); [EOL] [EOL] // verify storage types and locations [EOL] // Movements should have been ignored for the unsupported policy on [EOL] // striped file [EOL] locatedBlocks = client.getBlockLocations(fooFile, 0, fileLen); [EOL] for (LocatedBlock lb : locatedBlocks.getLocatedBlocks()) { [EOL] for (StorageType type : lb.getStorageTypes()) { [EOL] Assert.assertEquals(StorageType.ARCHIVE, type); [EOL] } [EOL] } [EOL] }finally{ [EOL] cluster.shutdown(); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestMover.class); [EOL] private static final int DEFAULT_BLOCK_SIZE = 100; [EOL] private File keytabFile; [EOL] private String principal; [EOL] private final ErasureCodingPolicy ecPolicy = [EOL] StripedFileTestUtil.getDefaultECPolicy(); [EOL] private final int dataBlocks = ecPolicy.getNumDataUnits(); [EOL] private final int parityBlocks = ecPolicy.getNumParityUnits(); [EOL] private final int cellSize = ecPolicy.getCellSize(); [EOL] private final int stripesPerBlock = 4; [EOL] private final int defaultBlockSize = cellSize * stripesPerBlock; [EOL]
@Test(timeout = 4000) [EOL]   public void testcontains()  throws Throwable  { [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[9]; [EOL]       ArrayList<Integer> arrayList0 = new ArrayList<Integer>(955); [EOL]       assertFalse(arrayList0.contains(955)); [EOL]        [EOL]       String string0 = StringUtils.join((Iterable<?>) arrayList0, '5'); [EOL]       assertFalse(arrayList0.contains(955)); [EOL]        [EOL]       charSequenceArray0[0] = (CharSequence) ""; [EOL]       String string1 = StringUtils.mid("", 955, 3); [EOL]        [EOL]       charSequenceArray0[1] = (CharSequence) ""; [EOL]       String string2 = StringUtils.upperCase(""); [EOL]        [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       String string3 = StringUtils.removeStartIgnoreCase("\r", ""); [EOL]        [EOL]       charSequenceArray0[3] = (CharSequence) "\r"; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charSequenceArray0[2]); [EOL]        [EOL]       charSequenceArray0[4] = (CharSequence) charBuffer0; [EOL]       CharSequence charSequence0 = StringUtils.defaultIfEmpty(charSequenceArray0[0], charSequenceArray0[0]); [EOL]        [EOL]       charSequenceArray0[5] = (CharSequence) ""; [EOL]       long[] longArray0 = new long[7]; [EOL]       longArray0[0] = (long) 3; [EOL]       longArray0[1] = 2587L; [EOL]       longArray0[2] = (long) 3; [EOL]       longArray0[3] = (long) 955; [EOL]       longArray0[4] = (long) 955; [EOL]       longArray0[5] = (long) 3; [EOL]       longArray0[6] = (-1L); [EOL]       String string4 = StringUtils.join(longArray0, '5', 8192, (-1515)); [EOL]        [EOL]       charSequenceArray0[6] = (CharSequence) ""; [EOL]       String string5 = StringUtils.chomp("\"N;ix%MK");ix%MK", string5); [EOL]        [EOL]       charSequenceArray0[7] = (CharSequence) "\"N;ix%MK"; [EOL]       float[] floatArray0 = new float[2]; [EOL]       floatArray0[0] = (float) 8192; [EOL]       floatArray0[1] = (float) 3L; [EOL]       String string6 = StringUtils.join(floatArray0, 'L', 32, 16); [EOL]        [EOL]       charSequenceArray0[8] = (CharSequence) ""; [EOL]       int int0 = StringUtils.indexOfDifference(charSequenceArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetStart()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.is('B'); [EOL]       CharRange charRange1 = CharRange.is('e'); [EOL]       boolean boolean0 = charRange0.contains(charRange1); [EOL]       assertEquals('e', charRange1.getStart()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEquals()  throws Throwable  { [EOL]       EqualsBuilder.isRegistered("Unexpected IllegalAccessException", "Unexpected IllegalAccessException"); [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append((Object) "Unexpected IllegalAccessException", (Object) "Unexpected IllegalAccessException"); [EOL]       assertTrue(equalsBuilder1.isEquals()); [EOL]        [EOL]       boolean[] booleanArray0 = new boolean[3]; [EOL]       booleanArray0[0] = false; [EOL]       booleanArray0[1] = false; [EOL]       booleanArray0[2] = false; [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append((boolean[]) null, booleanArray0); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.appendSuper(false); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append(443.779, 443.779); [EOL]       short[] shortArray0 = new short[2]; [EOL]       shortArray0[0] = (short)1; [EOL]       shortArray0[1] = (short) (-756); [EOL]       short[] shortArray1 = new short[1]; [EOL]       shortArray1[0] = (short) (-756); [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append(shortArray0, shortArray1); [EOL]       EqualsBuilder equalsBuilder6 = equalsBuilder5.append(false, false); [EOL]       assertFalse(equalsBuilder1.isEquals()); [EOL]       assertFalse(equalsBuilder6.isEquals()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testProvidedStorageMap() throws IOException { [EOL] ProvidedStorageMap providedMap = new ProvidedStorageMap( [EOL] nameSystemLock, bm, conf); [EOL] DatanodeStorageInfo providedMapStorage = [EOL] providedMap.getProvidedStorageInfo(); [EOL] // the provided storage cannot be null [EOL] assertNotNull(providedMapStorage); [EOL] [EOL] // create a datanode [EOL] DatanodeDescriptor dn1 = createDatanodeDescriptor(5000); [EOL] [EOL] // associate two storages to the datanode [EOL] DatanodeStorage dn1ProvidedStorage = new DatanodeStorage( [EOL] providedStorageID, [EOL] DatanodeStorage.State.NORMAL, [EOL] StorageType.PROVIDED); [EOL] DatanodeStorage dn1DiskStorage = new DatanodeStorage( [EOL] "sid-1", DatanodeStorage.State.NORMAL, StorageType.DISK); [EOL] [EOL] when(nameSystemLock.hasWriteLock()).thenReturn(true); [EOL] DatanodeStorageInfo dns1Provided = [EOL] providedMap.getStorage(dn1, dn1ProvidedStorage); [EOL] DatanodeStorageInfo dns1Disk = providedMap.getStorage(dn1, dn1DiskStorage); [EOL] [EOL] assertTrue("The provided storages should be equal", [EOL] dns1Provided == providedMapStorage); [EOL] assertTrue("Disk storage has not yet been registered with block manager", [EOL] dns1Disk == null); [EOL] // add the disk storage to the datanode. [EOL] DatanodeStorageInfo dnsDisk = new DatanodeStorageInfo(dn1, dn1DiskStorage); [EOL] dn1.injectStorage(dnsDisk); [EOL] assertTrue("Disk storage must match the injected storage info", [EOL] dnsDisk == providedMap.getStorage(dn1, dn1DiskStorage)); [EOL] [EOL] // create a 2nd datanode [EOL] DatanodeDescriptor dn2 = createDatanodeDescriptor(5010); [EOL] // associate a provided storage with the datanode [EOL] DatanodeStorage dn2ProvidedStorage = new DatanodeStorage( [EOL] providedStorageID, [EOL] DatanodeStorage.State.NORMAL, [EOL] StorageType.PROVIDED); [EOL] [EOL] DatanodeStorageInfo dns2Provided = providedMap.getStorage( [EOL] dn2, dn2ProvidedStorage); [EOL] assertTrue("The provided storages should be equal", [EOL] dns2Provided == providedMapStorage); [EOL] assertTrue("The DatanodeDescriptor should contain the provided storage", [EOL] dn2.getStorageInfo(providedStorageID) == providedMapStorage); [EOL] } [EOL] private Configuration conf; [EOL] private BlockManager bm; [EOL] private RwLock nameSystemLock; [EOL] private String providedStorageID; [EOL] private String blockPoolID; [EOL]
@Test [EOL] public void testChildCapacity() { [EOL] converter = builder.build(); [EOL] [EOL] converter.convertQueueHierarchy(rootQueue); [EOL] [EOL] // root [EOL] assertEquals("root.default capacity", "33.333", [EOL] csConfig.get(PREFIX + "root.default.capacity")); [EOL] assertEquals("root.admins capacity", "33.333", [EOL] csConfig.get(PREFIX + "root.admins.capacity")); [EOL] assertEquals("root.users capacity", "33.334", [EOL] csConfig.get(PREFIX + "root.users.capacity")); [EOL] [EOL] // root.users [EOL] assertEquals("root.users.john capacity", "25.000", [EOL] csConfig.get(PREFIX + "root.users.john.capacity")); [EOL] assertEquals("root.users.joe capacity", "75.000", [EOL] csConfig.get(PREFIX + "root.users.joe.capacity")); [EOL] [EOL] // root.admins [EOL] assertEquals("root.admins.alice capacity", "75.000", [EOL] csConfig.get(PREFIX + "root.admins.alice.capacity")); [EOL] assertEquals("root.admins.bob capacity", "25.000", [EOL] csConfig.get(PREFIX + "root.admins.bob.capacity")); [EOL] } [EOL] private static final float MAX_AM_SHARE_DEFAULT = 0.16f; [EOL] private static final int MAX_APPS_DEFAULT = 15; [EOL] private static final Resource CLUSTER_RESOURCE = [EOL] Resource.newInstance(16384, 16); [EOL] private final static Set<String> ALL_QUEUES = [EOL] Sets.newHashSet("root", [EOL] "root.default", [EOL] "root.admins", [EOL] "root.users", [EOL] "root.admins.alice", [EOL] "root.admins.bob", [EOL] "root.users.joe", [EOL] "root.users.john"); [EOL] private static final String FILE_PREFIX = "file:"; [EOL] private static final String FAIR_SCHEDULER_XML = [EOL] prepareFileName("fair-scheduler-conversion.xml"); [EOL] private FSQueueConverter converter; [EOL] private Configuration yarnConfig; [EOL] private Configuration csConfig; [EOL] private FairScheduler fs; [EOL] private FSQueue rootQueue; [EOL] private ConversionOptions conversionOptions; [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] private FSQueueConverterBuilder builder; [EOL] @Mock [EOL] private FSConfigToCSConfigRuleHandler ruleHandler; [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL]
@Test (timeout = 120000) [EOL] public void testToTaskID() { [EOL] TaskId tid = MRApps.toTaskID("task_1_2_r_3"); [EOL] assertEquals(1, tid.getJobId().getAppId().getClusterTimestamp()); [EOL] assertEquals(2, tid.getJobId().getAppId().getId()); [EOL] assertEquals(2, tid.getJobId().getId()); [EOL] assertEquals(TaskType.REDUCE, tid.getTaskType()); [EOL] assertEquals(3, tid.getId()); [EOL] [EOL] tid = MRApps.toTaskID("task_1_2_m_3"); [EOL] assertEquals(TaskType.MAP, tid.getTaskType()); [EOL] } [EOL] private static File testWorkDir = null; [EOL] private static final String[] SYS_CLASSES = new String[] { [EOL] "/java/fake/Klass", [EOL] "/javax/management/fake/Klass", [EOL] "/org/apache/commons/logging/fake/Klass", [EOL] "/org/apache/log4j/fake/Klass", [EOL] "/org/apache/hadoop/fake/Klass" [EOL] }; [EOL] private static final String[] DEFAULT_XMLS = new String[] { [EOL] "core-default.xml", [EOL] "mapred-default.xml", [EOL] "hdfs-default.xml", [EOL] "yarn-default.xml" [EOL] }; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder(strBuilder0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       Integer integer0 = new Integer(10); [EOL]        [EOL]       StringBuilder stringBuilder1 = stringBuilder0.append((Object) integer0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[9]; [EOL]       charArray0[0] = 'U'; [EOL]       charArray0[1] = 'C'; [EOL]       charArray0[2] = 'r'; [EOL]       charArray0[3] = 'g'; [EOL]       charArray0[4] = 'h'; [EOL]       charArray0[5] = 'p'; [EOL]       charArray0[6] = '('; [EOL]       charArray0[7] = 'P'; [EOL]       charArray0[8] = '@'; [EOL]       StringBuilder stringBuilder2 = stringBuilder1.append(charArray0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StringBuilder stringBuilder3 = stringBuilder2.insert(10, (float) 10); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.append(stringBuilder3, 10, 10); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void isOriginalTGTReturnsCorrectValues() { [EOL] assertTrue(SecurityUtil.isTGSPrincipal [EOL] (new KerberosPrincipal("krbtgt/foo@foo"))); [EOL] assertTrue(SecurityUtil.isTGSPrincipal [EOL] (new KerberosPrincipal("krbtgt/foo.bar.bat@foo.bar.bat"))); [EOL] assertFalse(SecurityUtil.isTGSPrincipal [EOL] (null)); [EOL] assertFalse(SecurityUtil.isTGSPrincipal [EOL] (new KerberosPrincipal("blah"))); [EOL] assertFalse(SecurityUtil.isTGSPrincipal [EOL] (new KerberosPrincipal("krbtgt/hello"))); [EOL] assertFalse(SecurityUtil.isTGSPrincipal [EOL] (new KerberosPrincipal("krbtgt/foo@FOO"))); [EOL] } [EOL] private static final String ZK_AUTH_VALUE = "a_scheme:a_password"; [EOL]
@Test(timeout = 4000) [EOL]   public void testsetVariableResolver()  throws Throwable  { [EOL]       HashMap<String, String> hashMap0 = new HashMap<String, String>(); [EOL]       StrSubstitutor strSubstitutor0 = new StrSubstitutor((Map<String, String>) hashMap0, "", "$!$](1CnP-5;", 'J'); [EOL]       StrLookup<?> strLookup0 = strSubstitutor0.getVariableResolver(); [EOL]       strSubstitutor0.setVariableResolver(strLookup0); [EOL]       assertEquals('J', strSubstitutor0.getEscapeChar()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testhashCode()  throws Throwable  { [EOL]       HashCodeBuilder hashCodeBuilder0 = new HashCodeBuilder((-811), (-811)); [EOL]       hashCodeBuilder0.append((boolean[]) null); [EOL]       assertEquals(657721, (int)hashCodeBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testTrash() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.setClass("fs.file.impl", TestLFS.class, FileSystem.class); [EOL] trashShell(FileSystem.getLocal(conf), TEST_DIR); [EOL] } [EOL] private final static File BASE_PATH = new File(GenericTestUtils.getTempPath( [EOL] "testTrash")); [EOL] private final static Path TEST_DIR = new Path(BASE_PATH.getAbsolutePath()); [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(false); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder2 = strBuilder0.insert(0, (String) null); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       Writer writer0 = strBuilder2.asWriter(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher(':'); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("vSi.a.bur[", 3954); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.trim(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder4.capacity()); [EOL]        [EOL]       int int1 = 6; [EOL]       StrBuilder strBuilder5 = strBuilder3.append(6); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder5.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strMatcher0.isMatch(charArray0, 3954); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAsyncSchedulingEnabledConversion() { [EOL] converter.convertSiteProperties(yarnConfig, yarnConvertedConfig, true, [EOL] true); [EOL] [EOL] assertTrue("Asynchronous scheduling", yarnConvertedConfig.getBoolean( [EOL] CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_ENABLE, [EOL] CapacitySchedulerConfiguration.DEFAULT_SCHEDULE_ASYNCHRONOUSLY_ENABLE)); [EOL] } [EOL] private Configuration yarnConfig; [EOL] private FSYarnSiteConverter converter; [EOL] private Configuration yarnConvertedConfig; [EOL]
@Test(timeout = 4000) [EOL]   public void testisNumber()  throws Throwable  { [EOL]       boolean boolean0 = NumberUtils.isNumber("43Eh>Xb3,/"); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test public void testDelimiterConf() { [EOL] String filename = getTestFilename("test-metrics2-delimiter"); [EOL] new ConfigBuilder().add("p1.foo", "p1foo1,p1foo2,p1foo3").save(filename); [EOL] [EOL] MetricsConfig mc = MetricsConfig.create("p1", filename); [EOL] Configuration expected = new ConfigBuilder() [EOL] .add("foo", "p1foo1") [EOL] .add("foo", "p1foo2") [EOL] .add("foo", "p1foo3") [EOL] .config; [EOL] assertEq(expected, mc); [EOL] } [EOL] static final Logger LOG = LoggerFactory.getLogger(TestMetricsConfig.class); [EOL]
@Test [EOL] @TestDir [EOL] @TestJetty [EOL] @TestHdfs [EOL] public void testCreateFileWithUnmaskedPermissions() throws Exception { [EOL] createHttpFSServer(false, false); [EOL] [EOL] FileSystem fs = FileSystem.get(TestHdfsHelper.getHdfsConf()); [EOL] // Create a folder with a default acl default:user2:rw- [EOL] fs.mkdirs(new Path("/tmp")); [EOL] AclEntry acl = new org.apache.hadoop.fs.permission.AclEntry.Builder() [EOL] .setType(AclEntryType.USER) [EOL] .setScope(AclEntryScope.DEFAULT) [EOL] .setName("user2") [EOL] .setPermission(FsAction.READ_WRITE) [EOL] .build(); [EOL] fs.setAcl(new Path("/tmp"), new ArrayList<AclEntry>(Arrays.asList(acl))); [EOL] [EOL] String notUnmaskedFile = "/tmp/notUnmasked"; [EOL] String unmaskedFile = "/tmp/unmasked"; [EOL] [EOL] // Create a file inside the folder. It should inherit the default acl [EOL] // but the mask should affect the ACL permissions. The mask is controlled [EOL] // by the group permissions, which are 0, and hence the mask will make [EOL] // the effective permission of the inherited ACL be NONE. [EOL] createWithHttp(notUnmaskedFile, "700"); [EOL] [EOL] // Pull the relevant ACL from the FS object and check the mask has affected [EOL] // its permissions. [EOL] AclStatus aclStatus = fs.getAclStatus(new Path(notUnmaskedFile)); [EOL] AclEntry theAcl = findAclWithName(aclStatus, "user2"); [EOL] [EOL] Assert.assertNotNull(theAcl); [EOL] Assert.assertEquals(FsAction.NONE, [EOL] aclStatus.getEffectivePermission(theAcl)); [EOL] [EOL] // Create another file, this time pass a mask of 777. Now the inherited [EOL] // permissions should be as expected [EOL] createWithHttp(unmaskedFile, "700", "777"); [EOL] [EOL] aclStatus = fs.getAclStatus(new Path(unmaskedFile)); [EOL] theAcl = findAclWithName(aclStatus, "user2"); [EOL] [EOL] Assert.assertNotNull(theAcl); [EOL] Assert.assertEquals(FsAction.READ_WRITE, [EOL] aclStatus.getEffectivePermission(theAcl)); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]       assertEquals(18, strBuilder0.size()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(18, strBuilder0.size()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertEquals(18, strBuilder0.size()); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertEquals(18, strBuilder0.size()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertEquals(18, strBuilder0.size()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]       assertEquals(18, strBuilder0.size()); [EOL]       assertEquals(18, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("D:qv{0F`Yb3&H^f*N2", 1); [EOL]       assertEquals(36, strBuilder0.size()); [EOL]       assertEquals(36, strBuilder2.size()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]       assertEquals(54, strBuilder0.size()); [EOL]       assertEquals(54, strBuilder3.size()); [EOL]       assertEquals(54, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) "[go_kPb1Q']x loR)ZZ"); [EOL]       assertEquals(81, strBuilder0.size()); [EOL]       assertEquals(81, strBuilder4.size()); [EOL]        [EOL]       String string0 = strBuilder4.leftString(1); [EOL]       assertEquals(81, strBuilder0.size()); [EOL]       assertEquals(81, strBuilder4.size()); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]       assertEquals(81, strBuilder0.size()); [EOL]       assertEquals(81, strBuilder3.size()); [EOL]       assertEquals(81, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(true); [EOL]       assertEquals(86, strBuilder0.size()); [EOL]       assertEquals(86, strBuilder3.size()); [EOL]       assertEquals(86, strBuilder5.size()); [EOL]       assertEquals(86, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", 1); [EOL]       assertEquals(93, strBuilder0.size()); [EOL]       assertEquals(93, strBuilder3.size()); [EOL]       assertEquals(93, strBuilder6.size()); [EOL]       assertEquals(93, strBuilder2.size()); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       String string1 = locale0.getDisplayVariant(); [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]       assertEquals(0, set0.size()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]       assertEquals(93, strBuilder0.size()); [EOL]       assertEquals(93, strBuilder4.size()); [EOL]       assertEquals(0, set0.size()); [EOL]       assertEquals(93, strBuilder7.size()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder5.insert(1, charArray0, 31, 1); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // Invalid offset: 31 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDeleteReservationDoesnotExist() { [EOL] ReservationDeleteRequest request = new ReservationDeleteRequestPBImpl(); [EOL] ReservationId rId = ReservationSystemTestUtil.getNewReservationId(); [EOL] request.setReservationId(rId); [EOL] when(rSystem.getQueueForReservation(rId)).thenReturn(null); [EOL] Plan plan = null; [EOL] try { [EOL] plan = rrValidator.validateReservationDeleteRequest(rSystem, request); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertNull(plan); [EOL] String message = e.getMessage(); [EOL] Assert [EOL] .assertTrue(message.equals(MessageFormat [EOL] .format( [EOL] "The specified reservation with ID: {0} is unknown. Please try again with a valid reservation.", [EOL] rId))); [EOL] LOG.info(message); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestReservationInputValidator.class); [EOL] private static final String PLAN_NAME = "test-reservation"; [EOL] private Clock clock; [EOL] private Map<String, Plan> plans = new HashMap<String, Plan>(1); [EOL] private ReservationSystem rSystem; [EOL] private Plan plan; [EOL] private ReservationInputValidator rrValidator; [EOL]
@Test(timeout = 10000) [EOL] public void testGlobalUpdate() { [EOL] SchedConfUpdateInfo schedUpdateInfo = new SchedConfUpdateInfo(); [EOL] cli.globalUpdates("schedKey1=schedVal1,schedKey2=schedVal2", [EOL] schedUpdateInfo); [EOL] Map<String, String> paramValues = new HashMap<>(); [EOL] paramValues.put("schedKey1", "schedVal1"); [EOL] paramValues.put("schedKey2", "schedVal2"); [EOL] validateGlobalParams(schedUpdateInfo, paramValues); [EOL] } [EOL] private SchedConfCLI cli; [EOL] private static MockRM rm; [EOL] private static String userName; [EOL] private static final File CONF_FILE = new File(new File("target", [EOL] "test-classes"), YarnConfiguration.CS_CONFIGURATION_FILE); [EOL] private static final File OLD_CONF_FILE = new File(new File("target", [EOL] "test-classes"), YarnConfiguration.CS_CONFIGURATION_FILE + ".tmp"); [EOL]
@Test [EOL] public void testUpdateReservationInvalidDuration() { [EOL] ReservationUpdateRequest request = [EOL] createSimpleReservationUpdateRequest(1, 1, 1, 3, 4); [EOL] Plan plan = null; [EOL] try { [EOL] plan = rrValidator.validateReservationUpdateRequest(rSystem, request); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertNull(plan); [EOL] String message = e.getMessage(); [EOL] Assert [EOL] .assertTrue(message [EOL] .contains("must be greater or equal to the minimum resource duration")); [EOL] LOG.info(message); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestReservationInputValidator.class); [EOL] private static final String PLAN_NAME = "test-reservation"; [EOL] private Clock clock; [EOL] private Map<String, Plan> plans = new HashMap<String, Plan>(1); [EOL] private ReservationSystem rSystem; [EOL] private Plan plan; [EOL] private ReservationInputValidator rrValidator; [EOL]
@Test [EOL] public void testUserUpdateSetting() throws IOException { [EOL] ShellBasedIdMapping iug = new ShellBasedIdMapping(new Configuration()); [EOL] assertThat(iug.getTimeout()).isEqualTo( [EOL] IdMappingConstant.USERGROUPID_UPDATE_MILLIS_DEFAULT); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] conf.setLong(IdMappingConstant.USERGROUPID_UPDATE_MILLIS_KEY, 0); [EOL] iug = new ShellBasedIdMapping(conf); [EOL] assertThat(iug.getTimeout()).isEqualTo( [EOL] IdMappingConstant.USERGROUPID_UPDATE_MILLIS_MIN); [EOL] [EOL] conf.setLong(IdMappingConstant.USERGROUPID_UPDATE_MILLIS_KEY, [EOL] IdMappingConstant.USERGROUPID_UPDATE_MILLIS_DEFAULT * 2); [EOL] iug = new ShellBasedIdMapping(conf); [EOL] assertThat(iug.getTimeout()).isEqualTo( [EOL] IdMappingConstant.USERGROUPID_UPDATE_MILLIS_DEFAULT * 2); [EOL] } [EOL] private static final Map<Integer, Integer> EMPTY_PASS_THROUGH_MAP = [EOL] new PassThroughMap<Integer>(); [EOL]
@Test [EOL] public void testSetName() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] WritableName.setName(SimpleWritable.class, testName); [EOL] [EOL] Class<?> test = WritableName.getClass(testName,conf); [EOL] assertTrue(test.equals(SimpleWritable.class)); [EOL] } [EOL] private static final String testName = "mystring"; [EOL]
@Test(timeout = 4000) [EOL]   public void testisNegated()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.is('w'); [EOL]       char char0 = charRange0.getStart(); [EOL]       assertFalse(charRange0.isNegated()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testremove()  throws Throwable  { [EOL]       double[] doubleArray0 = new double[6]; [EOL]       double[] doubleArray1 = ArrayUtils.removeElements(doubleArray0, doubleArray0); [EOL]       assertEquals(0, doubleArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       CompareToBuilder compareToBuilder1 = compareToBuilder0.append(true, true); [EOL]       assertEquals(0, compareToBuilder1.toComparison()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("F47@g0~|IH&t"); [EOL]       assertEquals(44, strBuilder0.capacity()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       StrMatcher strMatcher1 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       char[] charArray1 = new char[8]; [EOL]        [EOL]       charArray1[0] = 'n'; [EOL]       charArray1[1] = 'n'; [EOL]       charArray1[2] = 'S'; [EOL]       charArray1[3] = 'n'; [EOL]       charArray1[4] = 'S'; [EOL]       charArray1[5] = 'S'; [EOL]       charArray1[6] = 'S'; [EOL]       charArray1[7] = 'S'; [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray1); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-1), 207, 'S'); [EOL]       assertEquals(438, strBuilder0.capacity()); [EOL]       assertEquals(438, strBuilder1.capacity()); [EOL]        [EOL]       charArray0[1] = 'S'; [EOL]       StrMatcher strMatcher3 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       StrMatcher strMatcher4 = StrMatcher.stringMatcher(""); [EOL]        [EOL]       int int0 = strBuilder0.indexOf(strMatcher0, 0); [EOL]       assertEquals(438, strBuilder0.capacity()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.equals((Object) null); [EOL]       assertEquals(438, strBuilder0.capacity()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSetTypeSpaces() throws Exception { [EOL] QuotaCounts qc1 = new QuotaCounts.Builder().build(); [EOL] QuotaCounts qc2 = new QuotaCounts.Builder().nameSpace(1).storageSpace(512) [EOL] .typeSpaces(5).build(); [EOL] qc1.setTypeSpaces(qc2.getTypeSpaces()); [EOL] for (StorageType t : StorageType.values()) { [EOL] assertEquals(qc2.getTypeSpace(t), qc1.getTypeSpace(t)); [EOL] } [EOL] [EOL] // test ConstEnumCounters [EOL] qc1.setTypeSpaces(QuotaCounts.STORAGE_TYPE_RESET); [EOL] assertSame(QuotaCounts.STORAGE_TYPE_RESET, qc1.tsCounts); [EOL] } [EOL]
@Test [EOL] public void testGetStringCollection() { [EOL] Configuration c = new Configuration(); [EOL] c.set("x", " a, b\n,\nc "); [EOL] Collection<String> strs = c.getTrimmedStringCollection("x"); [EOL] assertEquals(3, strs.size()); [EOL] assertArrayEquals(new String[]{ "a", "b", "c" }, [EOL] strs.toArray(new String[0])); [EOL] [EOL] // Check that the result is mutable [EOL] strs.add("z"); [EOL] [EOL] // Make sure same is true for missing config [EOL] strs = c.getStringCollection("does-not-exist"); [EOL] assertEquals(0, strs.size()); [EOL] strs.add("z"); [EOL] } [EOL] @Rule [EOL] public ExpectedException thrown= ExpectedException.none(); [EOL] private static final double DOUBLE_DELTA = 0.000000001f; [EOL] private Configuration conf; [EOL] final static String CONFIG = new File("./test-config-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG2 = new File("./test-config2-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG_CORE = new File("./core-site.xml") [EOL] .getAbsolutePath(); [EOL] final static String CONFIG_FOR_ENUM = new File("./test-config-enum-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG_FOR_URI = new File( [EOL] "./test-config-uri-TestConfiguration.xml").toURI().toString(); [EOL] private static final String CONFIG_MULTI_BYTE = new File( [EOL] "./test-config-multi-byte-TestConfiguration.xml").getAbsolutePath(); [EOL] private static final String CONFIG_MULTI_BYTE_SAVED = new File( [EOL] "./test-config-multi-byte-saved-TestConfiguration.xml").getAbsolutePath(); [EOL] final static Random RAN = new Random(); [EOL] final static String XMLHEADER = [EOL] IBM_JAVA?"<?xml version=\"1.0\" encoding=\"UTF-8\"?><configuration>": [EOL] "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><configuration>"; [EOL] public static final String ESCAPED = "&apos;&#39;&#0039;&#x27;"; [EOL] private static final String SENSITIVE_CONFIG_KEYS = [EOL] CommonConfigurationKeysPublic.HADOOP_SECURITY_SENSITIVE_CONFIG_KEYS; [EOL] private BufferedWriter out; [EOL] ArrayList<Prop> props = new ArrayList<Prop>(); [EOL]
@Test [EOL] public void testTokenRenewerInvalidReturn() throws Exception { [EOL] DelegationTokenToRenew mockDttr = mock(DelegationTokenToRenew.class); [EOL] mockDttr.expirationDate = 0; [EOL] delegationTokenRenewer.setTimerForTokenRenewal(mockDttr); [EOL] assertNull(mockDttr.timerTask); [EOL] [EOL] mockDttr.expirationDate = -1; [EOL] delegationTokenRenewer.setTimerForTokenRenewal(mockDttr); [EOL] assertNull(mockDttr.timerTask); [EOL] [EOL] mockDttr.expirationDate = System.currentTimeMillis() - 1; [EOL] delegationTokenRenewer.setTimerForTokenRenewal(mockDttr); [EOL] assertNull(mockDttr.timerTask); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestDelegationTokenRenewer.class); [EOL] private static final Text KIND = [EOL] DelegationTokenRenewer.HDFS_DELEGATION_KIND; [EOL] private static BlockingQueue<Event> eventQueue; [EOL] private static volatile AtomicInteger counter; [EOL] private static AsyncDispatcher dispatcher; [EOL] private static Configuration conf; [EOL] DelegationTokenRenewer delegationTokenRenewer; [EOL]
@SuppressWarnings("deprecation") [EOL] @Test [EOL] public void testSiteContinuousSchedulingConversion() { [EOL] yarnConfig.setBoolean( [EOL] FairSchedulerConfiguration.CONTINUOUS_SCHEDULING_ENABLED, true); [EOL] yarnConfig.setInt( [EOL] FairSchedulerConfiguration.CONTINUOUS_SCHEDULING_SLEEP_MS, 666); [EOL] [EOL] converter.convertSiteProperties(yarnConfig, yarnConvertedConfig, false, [EOL] false); [EOL] [EOL] assertTrue("Cont. scheduling", yarnConvertedConfig.getBoolean( [EOL] CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_ENABLE, false)); [EOL] assertEquals("Scheduling interval", 666, [EOL] yarnConvertedConfig.getInt( [EOL] "yarn.scheduler.capacity.schedule-asynchronously" + [EOL] ".scheduling-interval-ms", -1)); [EOL] } [EOL] private Configuration yarnConfig; [EOL] private FSYarnSiteConverter converter; [EOL] private Configuration yarnConvertedConfig; [EOL]
@Test [EOL] public void testNoUnsupportedHACommandsInHelp() throws Exception { [EOL] ByteArrayOutputStream dataErr = new ByteArrayOutputStream(); [EOL] System.setErr(new PrintStream(dataErr)); [EOL] String[] args = {}; [EOL] assertEquals(-1, rmAdminCLIWithHAEnabled.run(args)); [EOL] String errOut = dataErr.toString(); [EOL] assertFalse(errOut.contains("-transitionToObserver")); [EOL] dataErr.reset(); [EOL] String[] args1 = {"-transitionToObserver"}; [EOL] assertEquals(-1, rmAdminCLIWithHAEnabled.run(args1)); [EOL] errOut = dataErr.toString(); [EOL] assertTrue(errOut.contains("transitionToObserver: Unknown command")); [EOL] dataErr.reset(); [EOL] args1[0] = "-failover"; [EOL] assertEquals(-1, rmAdminCLIWithHAEnabled.run(args1)); [EOL] errOut = dataErr.toString(); [EOL] assertTrue(errOut.contains("failover: Unknown command")); [EOL] dataErr.reset(); [EOL] String[] args2 = {"-help", "-transitionToObserver"}; [EOL] assertEquals(0, rmAdminCLIWithHAEnabled.run(args2)); [EOL] errOut = dataErr.toString(); [EOL] assertFalse(errOut.contains("-transitionToObserver")); [EOL] dataErr.reset(); [EOL] args2[1] = "-failover"; [EOL] assertEquals(0, rmAdminCLIWithHAEnabled.run(args2)); [EOL] errOut = dataErr.toString(); [EOL] assertFalse(errOut.contains("-failover")); [EOL] dataErr.reset(); [EOL] } [EOL] private ResourceManagerAdministrationProtocol admin; [EOL] private HAServiceProtocol haadmin; [EOL] private RMAdminCLI rmAdminCLI; [EOL] private RMAdminCLI rmAdminCLIWithHAEnabled; [EOL] private CommonNodeLabelsManager dummyNodeLabelsManager; [EOL] private boolean remoteAdminServiceAccessed = false; [EOL] private static final String HOST_A = "1.2.3.1"; [EOL] private static final String HOST_B = "1.2.3.2"; [EOL] private static File dest; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetFieldNameValueSeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       assertEquals("=", standardToStringStyle0.getFieldNameValueSeparator()); [EOL]        [EOL]       standardToStringStyle0.setFieldNameValueSeparator((String) null); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testUpload() [EOL] throws IOException, UploaderException, InterruptedException { [EOL] final String fileName = "/upload.tar.gz"; [EOL] File parent = new File(testDir); [EOL] try { [EOL] parent.deleteOnExit(); [EOL] [EOL] FrameworkUploader uploader = prepareTree(parent); [EOL] [EOL] uploader.target = "file://" + parent.getAbsolutePath() + fileName; [EOL] [EOL] uploader.buildPackage(); [EOL] try (TarArchiveInputStream archiveInputStream = new TarArchiveInputStream( [EOL] new GZIPInputStream( [EOL] new FileInputStream( [EOL] parent.getAbsolutePath() + fileName)))) { [EOL] Set<String> fileNames = new HashSet<>(); [EOL] Set<Long> sizes = new HashSet<>(); [EOL] TarArchiveEntry entry1 = archiveInputStream.getNextTarEntry(); [EOL] fileNames.add(entry1.getName()); [EOL] sizes.add(entry1.getSize()); [EOL] TarArchiveEntry entry2 = archiveInputStream.getNextTarEntry(); [EOL] fileNames.add(entry2.getName()); [EOL] sizes.add(entry2.getSize()); [EOL] Assert.assertTrue( [EOL] "File name error", fileNames.contains("a.jar")); [EOL] Assert.assertTrue( [EOL] "File size error", sizes.contains((long) 13)); [EOL] Assert.assertTrue( [EOL] "File name error", fileNames.contains("b.jar")); [EOL] Assert.assertTrue( [EOL] "File size error", sizes.contains((long) 14)); [EOL] } [EOL] } finally { [EOL] FileUtils.deleteDirectory(parent); [EOL] } [EOL] } [EOL] private static String testDir; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoIntValue()  throws Throwable  { [EOL]       int int0 = CharUtils.toIntValue((Character) null, 97); [EOL]       assertEquals(97, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.stripToEmpty("-2+AJhSn#?.RX,#(^c="); [EOL]        [EOL]       boolean boolean0 = StringUtils.startsWith("-2+AJhSn#?.RX,#(^c=", "-2+AJhSn#?.RX,#(^c="); [EOL]        [EOL]       ArrayList<Object> arrayList0 = new ArrayList<Object>(); [EOL]        [EOL]       Iterator<Object> iterator0 = arrayList0.iterator(); [EOL]        [EOL]       String string1 = StringUtils.join(iterator0, ""); [EOL]       assertFalse(string1.equals((Object)string0)); [EOL]        [EOL]       String[] stringArray0 = new String[0]; [EOL]       String string2 = StringUtils.replaceEach((String) null, stringArray0, stringArray0); [EOL]        [EOL]       boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null); [EOL]        [EOL]       char[] charArray0 = new char[5]; [EOL]       charArray0[0] = '|'; [EOL]       charArray0[1] = 'S'; [EOL]       charArray0[2] = '1'; [EOL]       charArray0[3] = 'l'; [EOL]       charArray0[4] = 'E'; [EOL]       boolean boolean2 = StringUtils.containsOnly((CharSequence) "", charArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEnableSubstitutionInVariables()  throws Throwable  { [EOL]       HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>(); [EOL]       StrSubstitutor strSubstitutor0 = new StrSubstitutor((Map<String, Integer>) hashMap0, "ZFU$pUC", "ZFU$pUC"); [EOL]       strSubstitutor0.setEnableSubstitutionInVariables(true); [EOL]       strSubstitutor0.setVariablePrefix("ZFU$pUC"); [EOL]       assertTrue(strSubstitutor0.isEnableSubstitutionInVariables()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testShortNameSsh() throws BadFencingConfigurationException { [EOL] NodeFencer fencer = setupFencer("sshfence"); [EOL] assertFalse(fencer.fence(MOCK_TARGET)); [EOL] } [EOL] private HAServiceTarget MOCK_TARGET; [EOL] private static String FENCER_TRUE_COMMAND_UNIX = "shell(true)"; [EOL] private static String FENCER_TRUE_COMMAND_WINDOWS = "shell(rem)"; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmptyTokenAsNull()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getCSVInstance(); [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setQuoteChar('5'); [EOL]       assertTrue(strTokenizer1.isEmptyTokenAsNull()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       int int0 = 79; [EOL]       StrBuilder strBuilder0 = new StrBuilder(79); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0.0F); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append((double) 79); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       int int1 = (-2267); [EOL]       StrBuilder strBuilder3 = strBuilder1.appendln((Object) strBuilder1); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.deleteAll('o'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.replaceAll("nCIF=^XRVL:\t%AH&", "end < start"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append((CharSequence) stringBuilder0, 79, (-211)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void processOptionsHeaderNoQuotas() { [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] options.add("-v"); [EOL] options.add("dummy"); [EOL] [EOL] PrintStream out = mock(PrintStream.class); [EOL] [EOL] Count count = new Count(); [EOL] count.out = out; [EOL] [EOL] count.processOptions(options); [EOL] [EOL] String noQuotasHeader = [EOL] // <----12----> <----12----> <-------18-------> [EOL] " DIR_COUNT FILE_COUNT CONTENT_SIZE PATHNAME"; [EOL] verify(out).println(noQuotasHeader); [EOL] verifyNoMoreInteractions(out); [EOL] } [EOL] private static final String WITH_QUOTAS = "Content summary with quotas"; [EOL] private static final String NO_QUOTAS = "Content summary without quotas"; [EOL] private static final String HUMAN = "human: "; [EOL] private static final String BYTES = "bytes: "; [EOL] private static final String QUOTAS_AND_USAGE = "quotas and usage"; [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static FileStatus fileStat; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.remove("null comparator", '.'); [EOL]        [EOL]       int int0 = StringUtils.getLevenshteinDistance((CharSequence) "null comparator", (CharSequence) "null comparator", 64); [EOL]        [EOL]       String string1 = StringUtils.replace("null comparator", "null comparator", "Minimum abbreviation width with offset is 7", (-809)); [EOL]       assertFalse(string1.equals((Object)string0)); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       boolean boolean0 = StringUtils.containsOnly((CharSequence) "Minimum abbreviation width with offset is 7", charArray0); [EOL]        [EOL]       String[] stringArray0 = StringUtils.substringsBetween("Minimum abbreviation width with offset is 7", "null comparator", "9'A"); [EOL]        [EOL]       String string2 = StringUtils.removeStart("Minimum abbreviation width with offset is 7", "null comparator"); [EOL]       assertTrue(string2.equals((Object)string1)); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]        [EOL]       boolean boolean1 = StringUtils.isAsciiPrintable("Minimum abbreviation width with offset is 7"); [EOL]        [EOL]       String string3 = StringUtils.replaceOnce("Minimum abbreviation width with offset is 7", "Minimum abbreviation width with offset is 7", "Minimum abbreviation width with offset is 7"); [EOL]       assertTrue(string3.equals((Object)string1)); [EOL]       assertTrue(string3.equals((Object)string2)); [EOL]       assertFalse(string3.equals((Object)string0)); [EOL]        [EOL]       String string4 = StringUtils.deleteWhitespace("Minimum abbreviation width with offset is 7"); [EOL]       assertFalse(string4.equals((Object)string0)); [EOL]       assertFalse(string4.equals((Object)string3)); [EOL]       assertFalse(string4.equals((Object)string1)); [EOL]       assertFalse(string4.equals((Object)string2)); [EOL]        [EOL]       int int1 = StringUtils.indexOfAny((CharSequence) "Minimum abbreviation width with offset is 7", charArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       String string0 = ""; [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       char char0 = 's'; [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteFirst('s'); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.trimMatcher(); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.stringMatcher(""); [EOL]        [EOL]       int int0 = 0; [EOL]       StrBuilder strBuilder2 = strBuilder0.replace(strMatcher0, "", 0, 0, 116); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder2.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.stringMatcher(""); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.insert(2545, false); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2545 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testIsJavaVersionAtLeast() { [EOL] assertTrue(Shell.isJavaVersionAtLeast(8)); [EOL] } [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(30000); [EOL] @Rule [EOL] public TestName methodName = new TestName(); [EOL] private File rootTestDir = GenericTestUtils.getTestDir(); [EOL] private File methodDir; [EOL]
@Test [EOL] public void testDeleteReservation() { [EOL] // First add a reservation [EOL] Plan plan = new InMemoryPlan(queueMetrics, policy, agent, totalCapacity, 1L, [EOL] resCalc, minAlloc, maxAlloc, planName, replanner, true, context); [EOL] ReservationId reservationID = [EOL] ReservationSystemTestUtil.getNewReservationId(); [EOL] int[] alloc = { 10, 10, 10, 10, 10, 10 }; [EOL] int start = 100; [EOL] ReservationAllocation rAllocation = [EOL] createReservationAllocation(reservationID, start, alloc, true); [EOL] Assert.assertNull(plan.getReservationById(reservationID)); [EOL] try { [EOL] plan.addReservation(rAllocation, false); [EOL] } catch (PlanningException e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] doAssertions(plan, rAllocation); [EOL] [EOL] RLESparseResourceAllocation userCons = [EOL] plan.getConsumptionForUserOverTime(user, start, start + alloc.length); [EOL] [EOL] for (int i = 0; i < alloc.length; i++) { [EOL] assertEquals( [EOL] Resource.newInstance(1024 * (alloc[i] + i), (alloc[i] + i)), [EOL] plan.getTotalCommittedResources(start + i)); [EOL] assertEquals( [EOL] Resource.newInstance(1024 * (alloc[i] + i), (alloc[i] + i)), [EOL] userCons.getCapacityAtTime(start + i)); [EOL] } [EOL] [EOL] // Now delete it [EOL] try { [EOL] plan.deleteReservation(reservationID); [EOL] } catch (PlanningException e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] Assert.assertNull(plan.getReservationById(reservationID)); [EOL] userCons = [EOL] plan.getConsumptionForUserOverTime(user, start, start + alloc.length); [EOL] for (int i = 0; i < alloc.length; i++) { [EOL] assertEquals(Resource.newInstance(0, 0), [EOL] plan.getTotalCommittedResources(start + i)); [EOL] assertEquals(Resource.newInstance(0, 0), [EOL] userCons.getCapacityAtTime(start + i)); [EOL] } [EOL] } [EOL] private String user = "yarn"; [EOL] private String planName = "test-reservation"; [EOL] private ResourceCalculator resCalc; [EOL] private Resource minAlloc; [EOL] private Resource maxAlloc; [EOL] private Resource totalCapacity; [EOL] private Clock clock; [EOL] private QueueMetrics queueMetrics; [EOL] private SharingPolicy policy; [EOL] private ReservationAgent agent; [EOL] private Planner replanner; [EOL] private RMContext context; [EOL] private long maxPeriodicity; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       boolean boolean0 = standardToStringStyle0.isArrayContentDetail(); [EOL]       assertEquals(">", standardToStringStyle0.getSizeEndText()); [EOL]   } [EOL]  [EOL]
@Test(timeout=180000) [EOL] public void testInvalidOperations() throws IOException { [EOL] try { [EOL] DomainSocket.connect( [EOL] new File(sockDir.getDir(), "test_sock_invalid_operation"). [EOL] getAbsolutePath()); [EOL] } catch (IOException e) { [EOL] GenericTestUtils.assertExceptionContains("connect(2) error: ", e); [EOL] } [EOL] } [EOL] private static TemporarySocketDirectory sockDir; [EOL]
@Test [EOL] public void testGenerateNodeTableMapping() throws Exception { [EOL] Set<NodeDetails> nodes = SLSUtils.generateNodes(3, 3); [EOL] File tempFile = File.createTempFile("testslsutils", ".tmp"); [EOL] tempFile.deleteOnExit(); [EOL] String fileName = tempFile.getAbsolutePath(); [EOL] SLSUtils.generateNodeTableMapping(nodes, fileName); [EOL] [EOL] List<String> lines = Files.readAllLines(Paths.get(fileName)); [EOL] Assert.assertEquals(3, lines.size()); [EOL] for (String line : lines) { [EOL] Assert.assertTrue(line.contains("node")); [EOL] Assert.assertTrue(line.contains("/rack")); [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testintToHexDigit()  throws Throwable  { [EOL]       char char0 = Conversion.intToHexDigit(1); [EOL]       assertEquals('1', char0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       HashCodeBuilder hashCodeBuilder0 = new HashCodeBuilder(); [EOL]       HashCodeBuilder hashCodeBuilder1 = hashCodeBuilder0.append(true); [EOL]       HashCodeBuilder hashCodeBuilder2 = hashCodeBuilder0.append((short) (-1)); [EOL]       hashCodeBuilder0.append(0.0F); [EOL]       long[] longArray0 = new long[8]; [EOL]       longArray0[0] = (-152L); [EOL]       longArray0[1] = (long) (short) (-1); [EOL]       longArray0[2] = (long) (short) (-1); [EOL]       longArray0[3] = (long) (short) (-1); [EOL]       longArray0[4] = (-1L); [EOL]       longArray0[5] = (long) (short) (-1); [EOL]       longArray0[6] = (long) Integer.MAX_VALUE; [EOL]       longArray0[7] = (long) Integer.MAX_VALUE; [EOL]       HashCodeBuilder hashCodeBuilder3 = hashCodeBuilder2.append(longArray0); [EOL]       HashCodeBuilder.reflectionHashCode(Integer.MAX_VALUE, Integer.MAX_VALUE, (Object) hashCodeBuilder3); [EOL]       int int0 = HashCodeBuilder.reflectionHashCode((Object) hashCodeBuilder1, true); [EOL]       //  // Unstable assertion: assertEquals(952405261, (int)hashCodeBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testset()  throws Throwable  { [EOL]       MockDate mockDate0 = new MockDate(0, 0, 0); [EOL]       Date date0 = DateUtils.setDays(mockDate0, 0); [EOL]       mockDate0.setTime(0); [EOL]       boolean boolean0 = DateUtils.isSameInstant(date0, (Date) mockDate0); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 10000) [EOL] public void testImageUploadTimeout() throws Exception { [EOL] Configuration conf = new HdfsConfiguration(); [EOL] NNStorage mockStorage = Mockito.mock(NNStorage.class); [EOL] HttpServer2 testServer = HttpServerFunctionalTest.createServer("hdfs"); [EOL] try { [EOL] testServer.addServlet("ImageTransfer", ImageServlet.PATH_SPEC, [EOL] TestImageTransferServlet.class); [EOL] testServer.start(); [EOL] URL serverURL = HttpServerFunctionalTest.getServerURL(testServer); [EOL] // set the timeout here, otherwise it will take default. [EOL] TransferFsImage.timeout = 2000; [EOL] [EOL] File tmpDir = new File(new FileSystemTestHelper().getTestRootDir()); [EOL] tmpDir.mkdirs(); [EOL] [EOL] File mockImageFile = File.createTempFile("image", "", tmpDir); [EOL] FileOutputStream imageFile = new FileOutputStream(mockImageFile); [EOL] imageFile.write("data".getBytes()); [EOL] imageFile.close(); [EOL] Mockito.when( [EOL] mockStorage.findImageFile(Mockito.any(NameNodeFile.class), [EOL] Mockito.anyLong())).thenReturn(mockImageFile); [EOL] Mockito.when(mockStorage.toColonSeparatedString()).thenReturn( [EOL] "storage:info:string"); [EOL] [EOL] try { [EOL] TransferFsImage.uploadImageFromStorage(serverURL, conf, mockStorage, [EOL] NameNodeFile.IMAGE, 1L); [EOL] fail("TransferImage Should fail with timeout"); [EOL] } catch (SocketTimeoutException e) { [EOL] assertEquals("Upload should timeout", "Read timed out", e.getMessage()); [EOL] } [EOL] } finally { [EOL] testServer.stop(); [EOL] } [EOL] } [EOL] private static final File TEST_DIR = PathUtils.getTestDir(TestTransferFsImage.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitMsb0ToInt()  throws Throwable  { [EOL]       int int0 = Conversion.hexDigitMsb0ToInt('7'); [EOL]       assertEquals(14, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testRPCRuntimeExceptionUnwrapping() { [EOL] String message = "RPCRuntimeExceptionUnwrapping"; [EOL] RuntimeException re = new NullPointerException(message); [EOL] ServiceException se = new ServiceException(re); [EOL] [EOL] Throwable t = null; [EOL] try { [EOL] RPCUtil.unwrapAndThrowException(se); [EOL] } catch (Throwable thrown) { [EOL] t = thrown; [EOL] } [EOL] [EOL] Assert.assertTrue(NullPointerException.class.isInstance(t)); [EOL] Assert.assertTrue(t.getMessage().contains(message)); [EOL] } [EOL]
@Test(timeout=15000) [EOL] public void testCallbackThrowsRTE() throws Exception { [EOL] hm.addCallback(new Callback() { [EOL] @Override [EOL] public void enteredState(State newState) { [EOL] throw new RuntimeException("Injected RTE"); [EOL] } [EOL] }); [EOL] LOG.info("Mocking bad health check, waiting for UNHEALTHY"); [EOL] svc.isHealthy = false; [EOL] waitForState(hm, HealthMonitor.State.HEALTH_MONITOR_FAILED); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger( [EOL] TestHealthMonitor.class); [EOL] private AtomicInteger createProxyCount = new AtomicInteger(0); [EOL] private volatile boolean throwOOMEOnCreate = false; [EOL] private HealthMonitor hm; [EOL] private DummyHAService svc; [EOL]
@Test [EOL] public void testPutWithTtlDirListingMeta() throws Exception { [EOL] // arrange [EOL] DirListingMetadata dlm = new DirListingMetadata(new Path("/"), null, [EOL] false); [EOL] MetadataStore ms = spy(MetadataStore.class); [EOL] ITtlTimeProvider timeProvider = [EOL] mock(ITtlTimeProvider.class); [EOL] when(timeProvider.getNow()).thenReturn(100L); [EOL] [EOL] // act [EOL] S3Guard.putWithTtl(ms, dlm, Collections.emptyList(), timeProvider, null); [EOL] [EOL] // assert [EOL] assertEquals("last update in " + dlm, 100L, dlm.getLastUpdated()); [EOL] verify(timeProvider, times(1)).getNow(); [EOL] verify(ms, times(1)).put(dlm, Collections.emptyList(), null); [EOL] } [EOL] public static final String MS_FILE_1 = "s3a://bucket/dir/ms-file1"; [EOL] public static final String MS_FILE_2 = "s3a://bucket/dir/ms-file2"; [EOL] public static final String S3_FILE_3 = "s3a://bucket/dir/s3-file3"; [EOL] public static final String S3_DIR_4 = "s3a://bucket/dir/s3-dir4"; [EOL] public static final Path DIR_PATH = new Path("s3a://bucket/dir"); [EOL] private MetadataStore ms; [EOL] private ITtlTimeProvider timeProvider; [EOL]
@Test [EOL] public void testContainerRetries() throws Exception { [EOL] [EOL] DefaultProviderService providerService = new DefaultProviderService(); [EOL] AbstractLauncher mockLauncher = mock(AbstractLauncher.class); [EOL] ContainerLaunchService.ComponentLaunchContext componentLaunchContext = [EOL] mock(ContainerLaunchService.ComponentLaunchContext.class); [EOL] [EOL] ComponentInstance componentInstance = mock(ComponentInstance.class); [EOL] [EOL] //Never Restart Policy [EOL] Component component = mock(Component.class); [EOL] when(componentInstance.getComponent()).thenReturn(component); [EOL] [EOL] when(component.getRestartPolicyHandler()).thenReturn(NeverRestartPolicy [EOL] .getInstance()); [EOL] [EOL] providerService.buildContainerRetry(mockLauncher, getConfig(), [EOL] componentLaunchContext, componentInstance); [EOL] verifyZeroInteractions(mockLauncher); [EOL] [EOL] [EOL] //OnFailure restart policy [EOL] when(component.getRestartPolicyHandler()).thenReturn(OnFailureRestartPolicy [EOL] .getInstance()); [EOL] when(componentLaunchContext.getConfiguration()).thenReturn(new [EOL] Configuration()); [EOL] providerService.buildContainerRetry(mockLauncher, getConfig(), [EOL] componentLaunchContext, componentInstance); [EOL] verify(mockLauncher).setRetryContext(DEFAULT_CONTAINER_RETRY_MAX, [EOL] DEFAULT_CONTAINER_RETRY_INTERVAL, [EOL] DEFAULT_CONTAINER_FAILURES_VALIDITY_INTERVAL); [EOL] [EOL] reset(mockLauncher); [EOL] [EOL] //Always restart policy [EOL] when(component.getRestartPolicyHandler()).thenReturn(AlwaysRestartPolicy [EOL] .getInstance()); [EOL] providerService.buildContainerRetry(mockLauncher, getConfig(), [EOL] componentLaunchContext, componentInstance); [EOL] [EOL] verify(mockLauncher).setRetryContext(DEFAULT_CONTAINER_RETRY_MAX, [EOL] DEFAULT_CONTAINER_RETRY_INTERVAL, [EOL] DEFAULT_CONTAINER_FAILURES_VALIDITY_INTERVAL); [EOL] } [EOL] private AbstractLauncher launcher; [EOL]
@Test [EOL] public void testStderrLogging() { [EOL] assertTrue(fencer.tryFence(TEST_TARGET, "echo hello>&2")); [EOL] Mockito.verify(ShellCommandFencer.LOG).warn( [EOL] Mockito.endsWith("echo hello>&2: hello")); [EOL] } [EOL] private ShellCommandFencer fencer = createFencer(); [EOL] private static final HAServiceTarget TEST_TARGET = [EOL] new DummyHAService(HAServiceState.ACTIVE, [EOL] new InetSocketAddress("dummyhost", 1234)); [EOL] private static final Logger LOG = ShellCommandFencer.LOG; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetStart()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.isNotIn('9', '9'); [EOL]       char char0 = charRange0.getEnd(); [EOL]       assertEquals('9', charRange0.getStart()); [EOL]   } [EOL]  [EOL]
@Test (timeout=50000) [EOL] public void testBatchedFlushJobEndMultiplier() throws Exception { [EOL] TestParams t = new TestParams(); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(MRJobConfig.MR_AM_STAGING_DIR, t.workDir); [EOL] conf.setLong(MRJobConfig.MR_AM_HISTORY_COMPLETE_EVENT_FLUSH_TIMEOUT_MS, [EOL] 60 * 1000l); //2 seconds. [EOL] conf.setInt(MRJobConfig.MR_AM_HISTORY_JOB_COMPLETE_UNFLUSHED_MULTIPLIER, 3); [EOL] conf.setInt(MRJobConfig.MR_AM_HISTORY_MAX_UNFLUSHED_COMPLETE_EVENTS, 10); [EOL] conf.setInt( [EOL] MRJobConfig.MR_AM_HISTORY_USE_BATCHED_FLUSH_QUEUE_SIZE_THRESHOLD, 0); [EOL] [EOL] JHEvenHandlerForTest realJheh = [EOL] new JHEvenHandlerForTest(t.mockAppContext, 0); [EOL] JHEvenHandlerForTest jheh = spy(realJheh); [EOL] jheh.init(conf); [EOL] [EOL] EventWriter mockWriter = null; [EOL] try { [EOL] jheh.start(); [EOL] handleEvent(jheh, new JobHistoryEvent(t.jobId, new AMStartedEvent( [EOL] t.appAttemptId, 200, t.containerId, "nmhost", 3000, 4000, -1))); [EOL] mockWriter = jheh.getEventWriter(); [EOL] verify(mockWriter).write(any(HistoryEvent.class)); [EOL] [EOL] for (int i = 0 ; i < 100 ; i++) { [EOL] queueEvent(jheh, new JobHistoryEvent(t.jobId, new TaskFinishedEvent( [EOL] t.taskID, t.taskAttemptID, 0, TaskType.MAP, "", null, 0))); [EOL] } [EOL] queueEvent(jheh, new JobHistoryEvent(t.jobId, new JobFinishedEvent( [EOL] TypeConverter.fromYarn(t.jobId), 0, 10, 10, 0, 0, 0, 0, null, null, [EOL] new Counters()))); [EOL] [EOL] handleNextNEvents(jheh, 29); [EOL] verify(mockWriter, times(0)).flush(); [EOL] [EOL] handleNextNEvents(jheh, 72); [EOL] verify(mockWriter, times(4)).flush(); //3 * 30 + 1 for JobFinished [EOL] } finally { [EOL] jheh.stop(); [EOL] verify(mockWriter).close(); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestJobHistoryEventHandler.class); [EOL] private static MiniDFSCluster dfsCluster = null; [EOL] private static String coreSitePath; [EOL]
@Test [EOL] public void testFairSchedulerXmlIsNotDefinedNeitherDirectlyNorInYarnSiteXml() [EOL] throws Exception { [EOL] FSConfigToCSConfigConverterParams params = [EOL] createParamsBuilder(YARN_SITE_XML_NO_REF_TO_FS_XML) [EOL] .withClusterResource(CLUSTER_RESOURCE_STRING) [EOL] .build(); [EOL] [EOL] expectedException.expect(PreconditionException.class); [EOL] expectedException.expectMessage("fair-scheduler.xml is not defined"); [EOL] converter.convert(params); [EOL] } [EOL] private static final String CLUSTER_RESOURCE_STRING = [EOL] "vcores=20, memory-mb=240"; [EOL] private static final Resource CLUSTER_RESOURCE = [EOL] Resource.newInstance(16384, 16); [EOL] private static final String FILE_PREFIX = "file:"; [EOL] private static final String FAIR_SCHEDULER_XML = [EOL] prepareFileName("fair-scheduler-conversion.xml"); [EOL] private static final String FS_INVALID_PLACEMENT_RULES_XML = [EOL] prepareFileName("fair-scheduler-invalidplacementrules.xml"); [EOL] private static final String FS_ONLY_FAIR_POLICY_XML = [EOL] prepareFileName("fair-scheduler-onlyfairpolicy.xml"); [EOL] private static final String FS_MIXED_POLICY_XML = [EOL] prepareFileName("fair-scheduler-orderingpolicy-mixed.xml"); [EOL] private static final String FS_NO_PLACEMENT_RULES_XML = [EOL] prepareFileName("fair-scheduler-noplacementrules.xml"); [EOL] private static final String FS_MAX_AM_SHARE_DISABLED_XML = [EOL] prepareFileName("fair-scheduler-defaultMaxAmShareDisabled.xml"); [EOL] @Mock [EOL] private FSConfigToCSConfigRuleHandler ruleHandler; [EOL] @Mock [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] @Mock [EOL] private QueuePlacementConverter placementConverter; [EOL] private FSConfigToCSConfigConverter converter; [EOL] private Configuration config; [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL] private FSConfigConverterTestCommons converterTestCommons; [EOL] private static final String FAIR_SCHEDULER_XML_INVALID = [EOL] prepareFileName("fair-scheduler-invalid.xml"); [EOL] private static final String YARN_SITE_XML = [EOL] prepareFileName("yarn-site-with-allocation-file-ref.xml"); [EOL] private static final String YARN_SITE_XML_NO_REF_TO_FS_XML = [EOL] prepareFileName("yarn-site.xml"); [EOL] private static final String YARN_SITE_XML_INVALID = [EOL] prepareFileName("yarn-site-with-invalid-allocation-file-ref.xml"); [EOL] private static final String CONVERSION_RULES_FILE = [EOL] new File("src/test/resources/conversion-rules.properties") [EOL] .getAbsolutePath(); [EOL]
@Test [EOL] public void testPerformance() { [EOL] String obj = "hello world"; [EOL] [EOL] final int numElems = 1000000; [EOL] final int numTrials = 5; [EOL] [EOL] for (int trial = 0; trial < numTrials; trial++) { [EOL] System.gc(); [EOL] { [EOL] ArrayList<String> arrayList = new ArrayList<String>(); [EOL] StopWatch sw = new StopWatch(); [EOL] sw.start(); [EOL] for (int i = 0; i < numElems; i++) { [EOL] arrayList.add(obj); [EOL] } [EOL] System.out.println(" ArrayList " + sw.now(TimeUnit.MILLISECONDS)); [EOL] } [EOL] [EOL] // test ChunkedArrayList [EOL] System.gc(); [EOL] { [EOL] ChunkedArrayList<String> chunkedList = new ChunkedArrayList<String>(); [EOL] StopWatch sw = new StopWatch(); [EOL] sw.start(); [EOL] for (int i = 0; i < numElems; i++) { [EOL] chunkedList.add(obj); [EOL] } [EOL] System.out.println("ChunkedArrayList " + sw.now(TimeUnit.MILLISECONDS)); [EOL] } [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       int int0 = 0; [EOL]       String string0 = strBuilder0.midString(0, 0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       LinkedList<Object> linkedList0 = new LinkedList<Object>(); [EOL]        [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       linkedList0.sort(comparator0); [EOL]        [EOL]       ListIterator<Object> listIterator0 = linkedList0.listIterator(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendAll((Iterator<?>) listIterator0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       int int1 = 2; [EOL]       boolean boolean0 = linkedList0.add((Object) strBuilder0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.setCharAt(2, 'l'); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       double[] doubleArray0 = new double[1]; [EOL]       doubleArray0[0] = (-2690.0); [EOL]       int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-2690.0), 2536); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testHasNonEcBlockUsingStripedIDForLoadUCFile() [EOL] throws IOException{ [EOL] // start a cluster [EOL] Configuration conf = new HdfsConfiguration(); [EOL] MiniDFSCluster cluster = null; [EOL] try { [EOL] cluster = new MiniDFSCluster.Builder(conf).numDataNodes(9) [EOL] .build(); [EOL] cluster.waitActive(); [EOL] DistributedFileSystem fs = cluster.getFileSystem(); [EOL] FSNamesystem fns = cluster.getNamesystem(); [EOL] [EOL] String testDir = "/test_block_manager"; [EOL] String testFile = "testfile_loaducfile"; [EOL] String testFilePath = testDir + "/" + testFile; [EOL] String clientName = "testUser_loaducfile"; [EOL] String clientMachine = "testMachine_loaducfile"; [EOL] long blkId = -1; [EOL] long blkNumBytes = 1024; [EOL] long timestamp = 1426222918; [EOL] [EOL] fs.mkdir(new Path(testDir), new FsPermission("755")); [EOL] Path p = new Path(testFilePath); [EOL] [EOL] DFSTestUtil.createFile(fs, p, 0, (short) 1, 1); [EOL] BlockInfoContiguous cBlk = new BlockInfoContiguous( [EOL] new Block(blkId, blkNumBytes, timestamp), (short)3); [EOL] INodeFile file = (INodeFile)fns.getFSDirectory().getINode(testFilePath); [EOL] file.toUnderConstruction(clientName, clientMachine); [EOL] file.addBlock(cBlk); [EOL] fns.enterSafeMode(false); [EOL] fns.saveNamespace(0, 0); [EOL] cluster.restartNameNodes(); [EOL] cluster.waitActive(); [EOL] fns = cluster.getNamesystem(); [EOL] assertTrue(fns.getBlockManager().hasNonEcBlockUsingStripedID()); [EOL] [EOL] cluster.shutdown(); [EOL] cluster = null; [EOL] } finally { [EOL] if (cluster != null) { [EOL] cluster.shutdown(); [EOL] } [EOL] } [EOL] } [EOL] private static final String HADOOP_2_7_ZER0_BLOCK_SIZE_TGZ = [EOL] "image-with-zero-block-size.tar.gz"; [EOL] private static final ErasureCodingPolicy testECPolicy = [EOL] SystemErasureCodingPolicies.getByID( [EOL] SystemErasureCodingPolicies.RS_10_4_POLICY_ID); [EOL]
@Test [EOL] public void testMergeMin() throws PlanningException { [EOL] [EOL] TreeMap<Long, Resource> a = new TreeMap<>(); [EOL] TreeMap<Long, Resource> b = new TreeMap<>(); [EOL] [EOL] setupArrays(a, b); [EOL] [EOL] RLESparseResourceAllocation rleA = [EOL] new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] RLESparseResourceAllocation rleB = [EOL] new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.min, 0, 60); [EOL] [EOL] System.out.println(out); [EOL] [EOL] long[] time = { 10, 22, 33, 40, 43, 50, 60 }; [EOL] int[] alloc = { 5, 10, 15, 20, 10, 0 }; [EOL] [EOL] validate(out, time, alloc); [EOL] [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRLESparseResourceAllocation.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.substringBetween("b#7v\"Z6i?umpQU", "b#7v\"Z6i?umpQU"); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[3]; [EOL]       charSequenceArray0[0] = (CharSequence) null; [EOL]       String string1 = "The character must not be null"; [EOL]       int int0 = 229; [EOL]       String string2 = StringUtils.abbreviate("The character must not be null", 229); [EOL]        [EOL]       charSequenceArray0[1] = (CharSequence) "The character must not be null"; [EOL]       charSequenceArray0[2] = (CharSequence) null; [EOL]       int int1 = StringUtils.lastIndexOfAny((CharSequence) null, charSequenceArray0); [EOL]       assertEquals(3, charSequenceArray0.length); [EOL]        [EOL]       boolean boolean0 = StringUtils.containsWhitespace(charSequenceArray0[0]); [EOL]       assertEquals(3, charSequenceArray0.length); [EOL]        [EOL]       boolean boolean1 = StringUtils.isAlphanumericSpace("The character must not be null"); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         StringUtils.abbreviate("", 229, (-1)); [EOL]         fail("Expecting exception: IllegalArgumentException"); [EOL]        [EOL]       } catch(IllegalArgumentException e) { [EOL]          // [EOL]          // Minimum abbreviation width is 4 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.StringUtils", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       String string0 = "SzpQ!4 ;U"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("SzpQ!4 ;U"); [EOL]       assertEquals(9, strBuilder0.size()); [EOL]        [EOL]       char char0 = '`'; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) "SzpQ!4 ;U", 97, '`'); [EOL]       assertEquals(106, strBuilder0.size()); [EOL]       assertEquals(106, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("ekji"); [EOL]       assertEquals(110, strBuilder0.size()); [EOL]       assertEquals(110, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(97, (long) 2817); [EOL]       assertEquals(114, strBuilder0.size()); [EOL]       assertEquals(114, strBuilder2.size()); [EOL]       assertEquals(114, strBuilder3.size()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.replaceFirst("SzpQ!4 ;U", "ekji"); [EOL]       assertEquals(109, strBuilder0.size()); [EOL]       assertEquals(109, strBuilder1.size()); [EOL]       assertEquals(109, strBuilder4.size()); [EOL]        [EOL]       String string1 = strBuilder0.getNullText(); [EOL]       assertEquals(109, strBuilder0.size()); [EOL]        [EOL]       String string2 = strBuilder1.leftString((-2254)); [EOL]       assertEquals(109, strBuilder0.size()); [EOL]       assertEquals(109, strBuilder1.size()); [EOL]        [EOL]       boolean boolean0 = strBuilder3.contains('`'); [EOL]       assertEquals(109, strBuilder0.size()); [EOL]       assertEquals(109, strBuilder2.size()); [EOL]       assertEquals(109, strBuilder3.size()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder2.replaceAll("ekji", "ekji"); [EOL]       assertEquals(109, strBuilder0.size()); [EOL]       assertEquals(109, strBuilder2.size()); [EOL]       assertEquals(109, strBuilder5.size()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(2817, (-1.0F)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2817 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testreflectionToString()  throws Throwable  { [EOL]       Object object0 = new Object(); [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.SIMPLE_STYLE; [EOL]       Class<Object> class0 = Object.class; [EOL]       String string0 = ToStringBuilder.reflectionToString(object0, toStringStyle0, true, (Class<? super Object>) class0); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testset()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer("set() is unsupported"); [EOL]       Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer()); [EOL]       strTokenizer0.forEachRemaining(consumer0); [EOL]       strTokenizer0.setIgnoreEmptyTokens(true); [EOL]       assertEquals(2, strTokenizer0.previousIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testuncapitalize()  throws Throwable  { [EOL]       String string0 = WordUtils.uncapitalize(""); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDumpingSchedulerLogs() throws Exception { [EOL] [EOL] ResourceManager mockRM = mock(ResourceManager.class); [EOL] Configuration conf = new YarnConfiguration(); [EOL] HttpServletRequest mockHsr = mockHttpServletRequestByUserName("non-admin"); [EOL] ApplicationACLsManager aclsManager = new ApplicationACLsManager(conf); [EOL] when(mockRM.getApplicationACLsManager()).thenReturn(aclsManager); [EOL] RMWebServices webSvc = [EOL] new RMWebServices(mockRM, conf, mock(HttpServletResponse.class)); [EOL] [EOL] // nothing should happen [EOL] webSvc.dumpSchedulerLogs("1", mockHsr); [EOL] waitforLogDump(50); [EOL] checkSchedulerLogFileAndCleanup(); [EOL] [EOL] conf.setBoolean(YarnConfiguration.YARN_ACL_ENABLE, true); [EOL] conf.setStrings(YarnConfiguration.YARN_ADMIN_ACL, "admin"); [EOL] aclsManager = new ApplicationACLsManager(conf); [EOL] when(mockRM.getApplicationACLsManager()).thenReturn(aclsManager); [EOL] webSvc = new RMWebServices(mockRM, conf, mock(HttpServletResponse.class)); [EOL] boolean exceptionThrown = false; [EOL] try { [EOL] webSvc.dumpSchedulerLogs("1", mockHsr); [EOL] fail("Dumping logs should fail"); [EOL] } catch (ForbiddenException ae) { [EOL] exceptionThrown = true; [EOL] } [EOL] assertTrue("ForbiddenException expected", exceptionThrown); [EOL] exceptionThrown = false; [EOL] when(mockHsr.getUserPrincipal()).thenReturn(new Principal() { [EOL] @Override [EOL] public String getName() { [EOL] return "testuser"; [EOL] } [EOL] }); [EOL] try { [EOL] webSvc.dumpSchedulerLogs("1", mockHsr); [EOL] fail("Dumping logs should fail"); [EOL] } catch (ForbiddenException ae) { [EOL] exceptionThrown = true; [EOL] } [EOL] assertTrue("ForbiddenException expected", exceptionThrown); [EOL] [EOL] when(mockHsr.getUserPrincipal()).thenReturn(new Principal() { [EOL] @Override [EOL] public String getName() { [EOL] return "admin"; [EOL] } [EOL] }); [EOL] webSvc.dumpSchedulerLogs("1", mockHsr); [EOL] waitforLogDump(50); [EOL] checkSchedulerLogFileAndCleanup(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRMWebServices.class); [EOL] private static MockRM rm; [EOL]
@Test [EOL] public void testChecksum() throws Exception { [EOL] String filename = "test1.txt"; [EOL] Path file = makeFile(filename); [EOL] assertEquals(inputChecksumSHA256, client.getFileChecksum(file)); [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestSharedCacheClientImpl.class); [EOL] public static SharedCacheClientImpl client; [EOL] public static ClientSCMProtocol cProtocol; [EOL] private static Path TEST_ROOT_DIR; [EOL] private static FileSystem localFs; [EOL] private static String input = "This is a test file."; [EOL] private static String inputChecksumSHA256 = [EOL] "f29bc64a9d3732b4b9035125fdb3285f5b6455778edca72414671e0ca3b2e0de"; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(101); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder[] strBuilderArray0 = new StrBuilder[7]; [EOL]       strBuilderArray0[0] = strBuilder0; [EOL]       strBuilderArray0[1] = strBuilder0; [EOL]       strBuilderArray0[2] = strBuilder0; [EOL]       strBuilderArray0[3] = strBuilder0; [EOL]       strBuilderArray0[4] = strBuilder0; [EOL]       strBuilderArray0[5] = strBuilder0; [EOL]       strBuilderArray0[6] = strBuilder0; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendAll(strBuilderArray0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.setNewLineText(""); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       int int0 = strBuilder0.capacity(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       strBuilder_StrBuilderWriter0.close(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StringBuffer stringBuffer0 = strBuilder0.toStringBuffer(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln(true); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetLabelsToNodes() throws Exception { [EOL] MockRM rm = new MockRM() { [EOL] protected ClientRMService createClientRMService() { [EOL] return new ClientRMService(this.rmContext, scheduler, [EOL] this.rmAppManager, this.applicationACLsManager, [EOL] this.queueACLsManager, this.getRMContext() [EOL] .getRMDelegationTokenSecretManager()); [EOL] }; [EOL] }; [EOL] rm.start(); [EOL] [EOL] NodeLabel labelX = NodeLabel.newInstance("x", false); [EOL] NodeLabel labelY = NodeLabel.newInstance("y", false); [EOL] NodeLabel labelZ = NodeLabel.newInstance("z", false); [EOL] RMNodeLabelsManager labelsMgr = rm.getRMContext().getNodeLabelManager(); [EOL] labelsMgr.addToCluserNodeLabels(ImmutableSet.of(labelX, labelY, labelZ)); [EOL] [EOL] NodeId node1A = NodeId.newInstance("host1", 1234); [EOL] NodeId node1B = NodeId.newInstance("host1", 5678); [EOL] NodeId node2A = NodeId.newInstance("host2", 1234); [EOL] NodeId node3A = NodeId.newInstance("host3", 1234); [EOL] NodeId node3B = NodeId.newInstance("host3", 5678); [EOL] Map<NodeId, Set<String>> map = new HashMap<NodeId, Set<String>>(); [EOL] map.put(node1A, ImmutableSet.of("x")); [EOL] map.put(node1B, ImmutableSet.of("z")); [EOL] map.put(node2A, ImmutableSet.of("y")); [EOL] map.put(node3A, ImmutableSet.of("y")); [EOL] map.put(node3B, ImmutableSet.of("z")); [EOL] labelsMgr.replaceLabelsOnNode(map); [EOL] [EOL] // Create a client. [EOL] Configuration conf = new Configuration(); [EOL] YarnRPC rpc = YarnRPC.create(conf); [EOL] InetSocketAddress rmAddress = rm.getClientRMService().getBindAddress(); [EOL] LOG.info("Connecting to ResourceManager at " + rmAddress); [EOL] ApplicationClientProtocol client = (ApplicationClientProtocol) rpc [EOL] .getProxy(ApplicationClientProtocol.class, rmAddress, conf); [EOL] [EOL] // Get node labels collection [EOL] GetClusterNodeLabelsResponse response = client [EOL] .getClusterNodeLabels(GetClusterNodeLabelsRequest.newInstance()); [EOL] Assert.assertTrue(response.getNodeLabelList().containsAll( [EOL] Arrays.asList(labelX, labelY, labelZ))); [EOL] [EOL] // Get labels to nodes mapping [EOL] GetLabelsToNodesResponse response1 = client [EOL] .getLabelsToNodes(GetLabelsToNodesRequest.newInstance()); [EOL] Map<String, Set<NodeId>> labelsToNodes = response1.getLabelsToNodes(); [EOL] Assert.assertTrue(labelsToNodes.keySet().containsAll( [EOL] Arrays.asList(labelX.getName(), labelY.getName(), labelZ.getName()))); [EOL] Assert.assertTrue(labelsToNodes.get(labelX.getName()).containsAll( [EOL] Arrays.asList(node1A))); [EOL] Assert.assertTrue(labelsToNodes.get(labelY.getName()).containsAll( [EOL] Arrays.asList(node2A, node3A))); [EOL] Assert.assertTrue(labelsToNodes.get(labelZ.getName()).containsAll( [EOL] Arrays.asList(node1B, node3B))); [EOL] [EOL] // Get labels to nodes mapping for specific labels [EOL] Set<String> setlabels = new HashSet<String>(Arrays.asList(new String[]{"x", [EOL] "z"})); [EOL] GetLabelsToNodesResponse response2 = client [EOL] .getLabelsToNodes(GetLabelsToNodesRequest.newInstance(setlabels)); [EOL] labelsToNodes = response2.getLabelsToNodes(); [EOL] Assert.assertTrue(labelsToNodes.keySet().containsAll( [EOL] Arrays.asList(labelX.getName(), labelZ.getName()))); [EOL] Assert.assertTrue(labelsToNodes.get(labelX.getName()).containsAll( [EOL] Arrays.asList(node1A))); [EOL] Assert.assertTrue(labelsToNodes.get(labelZ.getName()).containsAll( [EOL] Arrays.asList(node1B, node3B))); [EOL] assertThat(labelsToNodes.get(labelY.getName())).isNull(); [EOL] [EOL] rpc.stopProxy(client, conf); [EOL] rm.close(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestClientRMService.class); [EOL] private RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private String appType = "MockApp"; [EOL] private final static String QUEUE_1 = "Q-1"; [EOL] private final static String QUEUE_2 = "Q-2"; [EOL] private final static String APPLICATION_TAG_SC_PREPROCESSOR ="mytag:foo"; [EOL] private File resourceTypesFile = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       String string0 = strBuilder0.build(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, ""); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       String string1 = ""; [EOL]       StringBuffer stringBuffer0 = new StringBuffer(""); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append(stringBuffer0, 3, 0); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveElements()  throws Throwable  { [EOL]       short[] shortArray0 = new short[4]; [EOL]       short[] shortArray1 = ArrayUtils.removeElements(shortArray0, shortArray0); [EOL]       assertEquals(0, shortArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testof()  throws Throwable  { [EOL]       Integer integer0 = new Integer(0); [EOL]       Pair<Integer, Object> pair0 = Pair.of(integer0, (Object) integer0); [EOL]       int int0 = pair0.compareTo(pair0); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testEmptyChildQueues() { [EOL] FairSchedulerConfiguration fsConf = new FairSchedulerConfiguration(); [EOL] RMContext rmContext = mock(RMContext.class); [EOL] PlacementManager placementManager = new PlacementManager(); [EOL] SystemClock clock = SystemClock.getInstance(); [EOL] FairScheduler scheduler = mock(FairScheduler.class); [EOL] when(scheduler.getConf()).thenReturn(fsConf); [EOL] when(scheduler.getConfig()).thenReturn(fsConf); [EOL] when(scheduler.getRMContext()).thenReturn(rmContext); [EOL] when(rmContext.getQueuePlacementManager()).thenReturn(placementManager); [EOL] when(scheduler.getClusterResource()).thenReturn( [EOL] Resource.newInstance(1, 1)); [EOL] when(scheduler.getResourceCalculator()).thenReturn( [EOL] new DefaultResourceCalculator()); [EOL] when(scheduler.getClock()).thenReturn(clock); [EOL] AllocationConfiguration allocConf = new AllocationConfiguration(scheduler); [EOL] when(scheduler.getAllocationConfiguration()).thenReturn(allocConf); [EOL] QueueManager queueManager = new QueueManager(scheduler); [EOL] queueManager.initialize(); [EOL] [EOL] FSQueue testQueue = queueManager.getLeafQueue("test", true); [EOL] FairSchedulerQueueInfo queueInfo = [EOL] new FairSchedulerQueueInfo(testQueue, scheduler); [EOL] Collection<FairSchedulerQueueInfo> childQueues = [EOL] queueInfo.getChildQueues(); [EOL] Assert.assertNotNull(childQueues); [EOL] Assert.assertEquals("Child QueueInfo was not empty", 0, childQueues.size()); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteAll("2YZaq+Yp"); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder1.new StrBuilderReader(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = 'U'; [EOL]       charArray0[1] = 'E'; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0, 0, 0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmptyTokenAsNull()  throws Throwable  { [EOL]       char[] charArray0 = new char[2]; [EOL]       StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher(); [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(charArray0, strMatcher_NoMatcher0); [EOL]       String string0 = strTokenizer0.next(); [EOL]        [EOL]       StrMatcher.CharMatcher strMatcher_CharMatcher0 = new StrMatcher.CharMatcher('D'); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setIgnoredMatcher(strMatcher_CharMatcher0); [EOL]       assertFalse(strTokenizer1.isEmptyTokenAsNull()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsetValue()  throws Throwable  { [EOL]       MutableInt mutableInt0 = new MutableInt(); [EOL]       Float float0 = new Float(0.0F); [EOL]       mutableInt0.setValue((Number) float0); [EOL]       assertEquals(0, mutableInt0.intValue()); [EOL]   } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testdoubleValue()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.TWO_QUARTERS; [EOL]       Fraction fraction1 = fraction0.THREE_QUARTERS.negate(); [EOL]       Fraction fraction2 = fraction1.reduce(); [EOL]       assertEquals((-0.75), fraction2.doubleValue(), 0.01); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAsciiAlpha()  throws Throwable  { [EOL]       boolean boolean0 = CharUtils.isAsciiAlpha('\u000B'); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPostEntitiesWithYarnACLsEnabled() throws Exception { [EOL] AdminACLsManager oldAdminACLsManager = [EOL] timelineACLsManager.setAdminACLsManager(adminACLsManager); [EOL] try { [EOL] TimelineEntities entities = new TimelineEntities(); [EOL] TimelineEntity entity = new TimelineEntity(); [EOL] entity.setEntityId("test id 2"); [EOL] entity.setEntityType("test type 2"); [EOL] entity.setStartTime(System.currentTimeMillis()); [EOL] entity.setDomainId("domain_id_1"); [EOL] entities.addEntity(entity); [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("timeline") [EOL] .queryParam("user.name", "writer_user_1") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .type(MediaType.APPLICATION_JSON) [EOL] .post(ClientResponse.class, entities); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] TimelinePutResponse putResponse = [EOL] response.getEntity(TimelinePutResponse.class); [EOL] Assert.assertNotNull(putResponse); [EOL] Assert.assertEquals(0, putResponse.getErrors().size()); [EOL] [EOL] // override/append timeline data in the same entity with different user [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .queryParam("user.name", "writer_user_3") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .type(MediaType.APPLICATION_JSON) [EOL] .post(ClientResponse.class, entities); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] putResponse = response.getEntity(TimelinePutResponse.class); [EOL] Assert.assertNotNull(putResponse); [EOL] Assert.assertEquals(1, putResponse.getErrors().size()); [EOL] Assert.assertEquals(TimelinePutResponse.TimelinePutError.ACCESS_DENIED, [EOL] putResponse.getErrors().get(0).getErrorCode()); [EOL] [EOL] // Cross domain relationship will be rejected [EOL] entities = new TimelineEntities(); [EOL] entity = new TimelineEntity(); [EOL] entity.setEntityId("test id 3"); [EOL] entity.setEntityType("test type 2"); [EOL] entity.setStartTime(System.currentTimeMillis()); [EOL] entity.setDomainId("domain_id_2"); [EOL] entity.setRelatedEntities(Collections.singletonMap( [EOL] "test type 2", Collections.singleton("test id 2"))); [EOL] entities.addEntity(entity); [EOL] r = resource(); [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .queryParam("user.name", "writer_user_3") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .type(MediaType.APPLICATION_JSON) [EOL] .post(ClientResponse.class, entities); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] putResponse = response.getEntity(TimelinePutResponse.class); [EOL] Assert.assertNotNull(putResponse); [EOL] Assert.assertEquals(1, putResponse.getErrors().size()); [EOL] Assert.assertEquals(TimelinePutError.FORBIDDEN_RELATION, [EOL] putResponse.getErrors().get(0).getErrorCode()); [EOL] [EOL] // Make sure the entity has been added anyway even though the [EOL] // relationship is been excluded [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .path("test type 2").path("test id 3") [EOL] .queryParam("user.name", "reader_user_3") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] entity = response.getEntity(TimelineEntity.class); [EOL] Assert.assertNotNull(entity); [EOL] Assert.assertEquals("test id 3", entity.getEntityId()); [EOL] Assert.assertEquals("test type 2", entity.getEntityType()); [EOL] } finally { [EOL] timelineACLsManager.setAdminACLsManager(oldAdminACLsManager); [EOL] } [EOL] } [EOL] private static TimelineStore store; [EOL] private static TimelineACLsManager timelineACLsManager; [EOL] private static AdminACLsManager adminACLsManager; [EOL] private static long beforeTime; [EOL]
@Test (timeout = 30000) [EOL] public void testFailFullyDelete() throws IOException { [EOL] // Windows Dir.setWritable(false) does not work for directories [EOL] assumeNotWindows(); [EOL] LOG.info("Running test to verify failure of fullyDelete()"); [EOL] setupDirsAndNonWritablePermissions(); [EOL] boolean ret = FileUtil.fullyDelete(new MyFile(del)); [EOL] validateAndSetWritablePermissions(true, ret); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test [EOL] public void testConvertFSConfigurationDefaults() throws Exception { [EOL] setupFSConfigConversionFiles(true); [EOL] [EOL] ArgumentCaptor<FSConfigToCSConfigConverterParams> conversionParams = [EOL] ArgumentCaptor.forClass(FSConfigToCSConfigConverterParams.class); [EOL] [EOL] FSConfigToCSConfigArgumentHandler argumentHandler = [EOL] createArgumentHandler(); [EOL] [EOL] String[] args = getArgumentsAsArrayWithDefaults("-f", [EOL] FSConfigConverterTestCommons.FS_ALLOC_FILE, [EOL] "-r", FSConfigConverterTestCommons.CONVERSION_RULES_FILE); [EOL] argumentHandler.parseAndConvert(args); [EOL] [EOL] // validate params [EOL] verify(mockConverter).convert(conversionParams.capture()); [EOL] FSConfigToCSConfigConverterParams params = conversionParams.getValue(); [EOL] LOG.info("FS config converter parameters: " + params); [EOL] [EOL] assertEquals("Yarn site config", [EOL] FSConfigConverterTestCommons.YARN_SITE_XML, [EOL] params.getYarnSiteXmlConfig()); [EOL] assertEquals("FS xml", FSConfigConverterTestCommons.FS_ALLOC_FILE, [EOL] params.getFairSchedulerXmlConfig()); [EOL] assertEquals("Conversion rules config", [EOL] FSConfigConverterTestCommons.CONVERSION_RULES_FILE, [EOL] params.getConversionRulesConfig()); [EOL] assertFalse("Console mode", params.isConsole()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFSConfigToCSConfigArgumentHandler.class); [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL] @Mock [EOL] private FSConfigToCSConfigConverter mockConverter; [EOL] @Mock [EOL] private ConvertedConfigValidator mockValidator; [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] private ConversionOptions conversionOptions; [EOL] private FSConfigConverterTestCommons fsTestCommons; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(256); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.noneMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceAll(strMatcher0, ""); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln("HDK1o:4z@EGXArn*_"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = new StrBuilder(); [EOL]       assertTrue(strBuilder3.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append(strBuilder3, (-2074), (-2074)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.equals((Object) null); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.insert(0, (float) 0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       int int0 = strBuilder1.capacity(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       int int1 = 0; [EOL]       StrBuilder strBuilder2 = strBuilder1.append((CharSequence) strBuilder0, 0, 0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.append(strBuilder3); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder4.capacity()); [EOL]        [EOL]       char char0 = '|'; [EOL]       StrBuilder strBuilder5 = strBuilder1.replaceAll('A', '|'); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder5.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder5.validateRange(32, 32); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSpeculativeMapFetchFailure() { [EOL] // Setup a scenario where speculative task wins, first attempt killed [EOL] mockTask = createMockTask(TaskType.MAP); [EOL] runSpeculativeTaskAttemptSucceeds(TaskEventType.T_ATTEMPT_KILLED); [EOL] assertEquals(2, taskAttempts.size()); [EOL] [EOL] // speculative attempt retroactively fails from fetch failures [EOL] mockTask.handle(new TaskTAttemptFailedEvent( [EOL] taskAttempts.get(1).getAttemptId())); [EOL] [EOL] assertTaskScheduledState(); [EOL] assertEquals(3, taskAttempts.size()); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestTaskImpl.class); [EOL] private JobConf conf; [EOL] private TaskAttemptListener taskAttemptListener; [EOL] private Token<JobTokenIdentifier> jobToken; [EOL] private JobId jobId; [EOL] private Path remoteJobConfFile; [EOL] private Credentials credentials; [EOL] private Clock clock; [EOL] private MRAppMetrics metrics; [EOL] private TaskImpl mockTask; [EOL] private ApplicationId appId; [EOL] private TaskSplitMetaInfo taskSplitMetaInfo; [EOL] private String[] dataLocations = new String[0]; [EOL] private AppContext appContext; [EOL] private int startCount = 0; [EOL] private int taskCounter = 0; [EOL] private final int partition = 1; [EOL] private InlineDispatcher dispatcher; [EOL] private MockTaskAttemptEventHandler taskAttemptEventHandler; [EOL] private List<MockTaskAttemptImpl> taskAttempts; [EOL]
@Test [EOL] public void testPathToParentKeyAttribute() { [EOL] doTestPathToParentKeyAttribute(TEST_DIR_PATH); [EOL] doTestPathToParentKeyAttribute(TEST_FILE_PATH); [EOL] } [EOL] private static final Path TEST_DIR_PATH = new Path("s3a://test-bucket/myDir"); [EOL] private static final long TEST_FILE_LENGTH = 100; [EOL] private static final long TEST_MOD_TIME = 9999; [EOL] private static final long TEST_BLOCK_SIZE = 128; [EOL] private static final String TEST_ETAG = "abc"; [EOL] private static final String TEST_VERSION_ID = "def"; [EOL] private static final Path TEST_FILE_PATH = new Path(TEST_DIR_PATH, "myFile"); [EOL] private final Item testFileItem; [EOL] private final DDBPathMetadata testFilePathMetadata; [EOL] private final Item testDirItem; [EOL] private final DDBPathMetadata testDirPathMetadata; [EOL] @Rule [EOL] public final Timeout timeout = new Timeout(30 * 1000); [EOL]
@Test [EOL] public void testParseNewStyleDuplicateVcoresDefinitionPercentage() [EOL] throws Exception { [EOL] expectInvalidResourcePercentageNewStyle("75% 65%"); [EOL] parseResourceConfigValue("vcores = 75% 65%, memory-mb = 40%"); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test [EOL] public void testGetLong() { [EOL] assertNull(statistics.getLong(null)); [EOL] assertNull(statistics.getLong(NO_SUCH_OP)); [EOL] verifyStatistics(); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger( [EOL] TestDFSOpsCountStatistics.class); [EOL] private static final String NO_SUCH_OP = "no-such-dfs-operation-dude"; [EOL] private final DFSOpsCountStatistics statistics = [EOL] new DFSOpsCountStatistics(); [EOL] private final Map<OpType, AtomicLong> expectedOpsCountMap = new HashMap<>(); [EOL] @Rule [EOL] public final Timeout globalTimeout = new Timeout(10 * 1000); [EOL] @Rule [EOL] public final ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testNull()  throws Throwable  { [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       Object object0 = ObjectUtils.firstNonNull(objectArray0); [EOL]       Object object1 = ObjectUtils.defaultIfNull(object0, (Object) "org.apache.commons.lang3.ObjectUtils"); [EOL]       assertEquals("org.apache.commons.lang3.ObjectUtils", object1); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testValidation() throws IOException { [EOL] Map<String, String> destinations = new HashMap<>(); [EOL] destinations.put("ns0", "/testValidate-dest"); [EOL] try { [EOL] MountTable.newInstance("testValidate", destinations); [EOL] fail("Mount table entry should be created failed."); [EOL] } catch (Exception e) { [EOL] GenericTestUtils.assertExceptionContains( [EOL] MountTable.ERROR_MSG_MUST_START_WITH_BACK_SLASH, e); [EOL] } [EOL] [EOL] destinations.clear(); [EOL] destinations.put("ns0", "testValidate-dest"); [EOL] try { [EOL] MountTable.newInstance("/testValidate", destinations); [EOL] fail("Mount table entry should be created failed."); [EOL] } catch (Exception e) { [EOL] GenericTestUtils.assertExceptionContains( [EOL] MountTable.ERROR_MSG_ALL_DEST_MUST_START_WITH_BACK_SLASH, e); [EOL] } [EOL] [EOL] destinations.clear(); [EOL] destinations.put("", "/testValidate-dest"); [EOL] try { [EOL] MountTable.newInstance("/testValidate", destinations); [EOL] fail("Mount table entry should be created failed."); [EOL] } catch (Exception e) { [EOL] GenericTestUtils.assertExceptionContains( [EOL] MountTable.ERROR_MSG_INVAILD_DEST_NS, e); [EOL] } [EOL] [EOL] destinations.clear(); [EOL] destinations.put("ns0", "/testValidate-dest"); [EOL] MountTable record = MountTable.newInstance("/testValidate", destinations); [EOL] assertNotNull(record); [EOL] [EOL] } [EOL] private static final String SRC = "/test"; [EOL] private static final String DST_NS_0 = "ns0"; [EOL] private static final String DST_NS_1 = "ns1"; [EOL] private static final String DST_PATH_0 = "/path1"; [EOL] private static final String DST_PATH_1 = "/path/path2"; [EOL] private static final List<RemoteLocation> DST = new LinkedList<>(); [EOL] private static final Map<String, String> DST_MAP = new LinkedHashMap<>(); [EOL] private static final long DATE_CREATED = 100; [EOL] private static final long DATE_MOD = 200; [EOL] private static final long NS_COUNT = 1; [EOL] private static final long NS_QUOTA = 5; [EOL] private static final long SS_COUNT = 10; [EOL] private static final long SS_QUOTA = 100; [EOL] private static final RouterQuotaUsage QUOTA = new RouterQuotaUsage.Builder() [EOL] .fileAndDirectoryCount(NS_COUNT).quota(NS_QUOTA).spaceConsumed(SS_COUNT) [EOL] .spaceQuota(SS_QUOTA).build(); [EOL]
@Test(timeout = 4000) [EOL]   public void testCONST()  throws Throwable  { [EOL]       int int0 = ObjectUtils.CONST(1960); [EOL]       assertEquals(1960, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(97); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(0L); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testreplaceSystemProperties()  throws Throwable  { [EOL]       String string0 = StrSubstitutor.replaceSystemProperties((Object) null); [EOL]       assertNull(string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testExtractPassword() throws IOException { [EOL] File testDir = GenericTestUtils.getTestDir(); [EOL] testDir.mkdirs(); [EOL] File secretFile = new File(testDir, "secret.txt"); [EOL] Writer writer = new FileWriter(secretFile); [EOL] writer.write("hadoop"); [EOL] writer.close(); [EOL] [EOL] LdapGroupsMapping mapping = new LdapGroupsMapping(); [EOL] Assert.assertEquals("hadoop", [EOL] mapping.extractPassword(secretFile.getPath())); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger( [EOL] TestLdapGroupsMapping.class); [EOL] private static final byte[] AUTHENTICATE_SUCCESS_MSG = [EOL] {48, 12, 2, 1, 1, 97, 7, 10, 1, 0, 4, 0, 4, 0}; [EOL] private final String userDN = "CN=some_user,DC=test,DC=com"; [EOL] private static final String TEST_LDAP_URL = "ldap://test"; [EOL]
@Test(expected = HadoopIllegalArgumentException.class) [EOL] public void testNoValidInput() { [EOL] byte[][] inputs = new byte[numInputs][]; [EOL] CoderUtil.findFirstValidInput(inputs); [EOL] } [EOL] private final int numInputs = 9; [EOL] private final int chunkSize = 1024; [EOL]
@Test [EOL] public void testTimelineSchemaCreation() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.TIMELINE_SERVICE_SCHEMA_CREATOR_CLASS, [EOL] "org.apache.hadoop.yarn.server.timelineservice.storage" + [EOL] ".DummyTimelineSchemaCreator"); [EOL] TimelineSchemaCreator timelineSchemaCreator = new TimelineSchemaCreator(); [EOL] Assert.assertEquals(0, timelineSchemaCreator [EOL] .createTimelineSchema(new String[]{}, conf)); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(238); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteAll('s'); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.THREE_QUARTERS; [EOL]       boolean boolean0 = fraction0.equals(fraction0); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testof()  throws Throwable  { [EOL]       Integer integer0 = new Integer(0); [EOL]       Integer integer1 = new Integer(0); [EOL]       MutableTriple<Object, Object, Integer> mutableTriple0 = MutableTriple.of((Object) integer0, (Object) integer0, integer1); [EOL]       mutableTriple0.setLeft(integer1); [EOL]       assertTrue(integer1.equals((Object)integer0)); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testHelp() throws Exception { [EOL] ClusterCLI cli = createAndGetClusterCLI(); [EOL] [EOL] int rc = [EOL] cli.run(new String[] { "cluster", "--help" }); [EOL] assertEquals(0, rc); [EOL] [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] PrintWriter pw = new PrintWriter(baos); [EOL] pw.println("usage: yarn cluster"); [EOL] pw.println(" -dnl,--directly-access-node-label-store This is DEPRECATED, will be"); [EOL] pw.println(" removed in future releases."); [EOL] pw.println(" Directly access node label"); [EOL] pw.println(" store, with this option, all"); [EOL] pw.println(" node label related operations"); [EOL] pw.println(" will NOT connect RM. Instead,"); [EOL] pw.println(" they will access/modify stored"); [EOL] pw.println(" node labels directly. By"); [EOL] pw.println(" default, it is false (access"); [EOL] pw.println(" via RM). AND PLEASE NOTE: if"); [EOL] pw.println(" you configured"); [EOL] pw.println(" yarn.node-labels.fs-store.root-"); [EOL] pw.println(" dir to a local directory"); [EOL] pw.println(" (instead of NFS or HDFS), this"); [EOL] pw.println(" option will only work when the"); [EOL] pw.println(" command run on the machine"); [EOL] pw.println(" where RM is running. Also, this"); [EOL] pw.println(" option is UNSTABLE, could be"); [EOL] pw.println(" removed in future releases."); [EOL] pw.println(" -h,--help Displays help for all commands."); [EOL] pw.println(" -lna,--list-node-attributes List cluster node-attribute"); [EOL] pw.println(" collection"); [EOL] pw.println(" -lnl,--list-node-labels List cluster node-label"); [EOL] pw.println(" collection"); [EOL] pw.close(); [EOL] verify(sysOut).println(baos.toString("UTF-8")); [EOL] } [EOL] ByteArrayOutputStream sysOutStream; [EOL] private PrintStream sysOut; [EOL] ByteArrayOutputStream sysErrStream; [EOL] private PrintStream sysErr; [EOL] private YarnClient client = mock(YarnClient.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("0rn@[CM"); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) strTokenizer0, "0rn@[CM"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '\\'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(charArray0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.setLength(2822); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder4; [EOL]       objectArray0[1] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) '\\'; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       StrBuilder strBuilder5 = strBuilder4.appendAll(objectArray0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder6 = new StrBuilder("0rn@[CM"); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]        [EOL]       int int0 = strBuilder6.lastIndexOf("0rn@[CM"); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.append(false); [EOL]       assertFalse(strBuilder7.isEmpty()); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.appendln(1490.882886748184); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder8.isEmpty()); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder6.append(strBuilder3, 0, 2822); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]       assertFalse(strBuilder9.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] 	public void testHelloWorld_FindTModelForProcessName() throws JAXBException { [EOL] 		 [EOL] 		QName processName = new QName("http://www.jboss.org/bpel/examples/wsdl","HelloWorld"); [EOL] 		 [EOL] 		FindTModel findTModel = bpel2UDDI.createFindTModelForProcessName(processName); [EOL] 		 [EOL] 		System.out.println("***** Find TModel For ProcessName: " + processName); [EOL] if (serialize) [EOL] 		System.out.println(pFindTModel.print(findTModel)); [EOL] 		 [EOL] 		Assert.assertNotNull(findTModel.getCategoryBag()); [EOL] 	} [EOL] static BPEL2UDDI bpel2UDDI; [EOL] PrintUDDI<TModel> pTModel = new PrintUDDI<TModel>(); [EOL] PrintUDDI<FindTModel> pFindTModel = new PrintUDDI<FindTModel>(); [EOL] PrintUDDI<BindingTemplate> pBinding = new PrintUDDI<BindingTemplate>(); [EOL] ReadWSDL rw = new ReadWSDL(); [EOL] static boolean serialize=false; [EOL]
@Test(timeout = 4000) [EOL]   public void testmarkSupported()  throws Throwable  { [EOL]       String string0 = "htoXU5/8-3A+"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("htoXU5/8-3A+"); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.reverse(); [EOL]        [EOL]       char[] charArray0 = strBuilder0.toCharArray(); [EOL]        [EOL]       char char0 = 'X'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln('X'); [EOL]        [EOL]       int int0 = 8; [EOL]       StrBuilder strBuilder3 = strBuilder1.setLength(8); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder1.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       CharBuffer charBuffer0 = CharBuffer.allocate(8); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       strBuilder_StrBuilderReader0.reset(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln(charArray0, 0, 3125); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // Invalid length: 3125 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisDefaultFullDetail()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ","); [EOL]       standardToStringStyle0.appendToString(stringBuffer0, ""); [EOL]       assertTrue(standardToStringStyle0.isDefaultFullDetail()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFinalDestinationNoMagic() { [EOL] assertEquals(l("first", "2"), [EOL] finalDestination(l("first", "2"))); [EOL] } [EOL] private static final List<String> MAGIC_AT_ROOT = [EOL] list(MAGIC); [EOL] private static final List<String> MAGIC_AT_ROOT_WITH_CHILD = [EOL] list(MAGIC, "child"); [EOL] private static final List<String> MAGIC_WITH_CHILD = [EOL] list("parent", MAGIC, "child"); [EOL] private static final List<String> MAGIC_AT_WITHOUT_CHILD = [EOL] list("parent", MAGIC); [EOL] private static final List<String> DEEP_MAGIC = [EOL] list("parent1", "parent2", MAGIC, "child1", "child2"); [EOL] public static final String[] EMPTY = {}; [EOL]
@Test(timeout = 4000) [EOL]   public void testsqueeze()  throws Throwable  { [EOL]       String[] stringArray0 = new String[11]; [EOL]       String string0 = CharSetUtils.squeeze(stringArray0[1], stringArray0); [EOL]       assertNull(string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetAllFields()  throws Throwable  { [EOL]       Class<Object> class0 = Object.class; [EOL]       List<Field> list0 = FieldUtils.getAllFieldsList(class0); [EOL]       assertTrue(list0.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClusterDefault() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] // test with trailing "/" to make sure acts same as without slash [EOL] ClientResponse response = r.path("ws").path("v1").path("cluster") [EOL] .get(ClientResponse.class); [EOL] [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] verifyClusterInfo(json); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRMWebServices.class); [EOL] private static MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testmin()  throws Throwable  { [EOL]       byte byte0 = NumberUtils.min((byte)0, (byte)1, (byte) (-57)); [EOL]       assertEquals((byte) (-57), byte0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcall()  throws Throwable  { [EOL]       Callable<String> callable0 = (Callable<String>) mock(Callable.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn("", "p!,").when(callable0).call(); [EOL]       CallableBackgroundInitializer<String> callableBackgroundInitializer0 = new CallableBackgroundInitializer<String>(callable0); [EOL]       callableBackgroundInitializer0.getTaskCount(); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.initialize(); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.get(); [EOL]       assertTrue(callableBackgroundInitializer0.isStarted()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.noneMatcher(); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = '$'; [EOL]       charArray0[1] = 'B'; [EOL]       StrMatcher strMatcher1 = StrMatcher.charSetMatcher(charArray0); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.stringMatcher("Invalid startIndex: "); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf(strMatcher0); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.startsWith(""); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(true); [EOL]       assertEquals(4, strBuilder0.length()); [EOL]       assertEquals(4, strBuilder1.length()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.deleteCharAt((-1)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 30000) [EOL] public void testAppReservationWithDominantResourceCalculator() throws Exception { [EOL] CapacitySchedulerConfiguration csconf = [EOL] new CapacitySchedulerConfiguration(); [EOL] csconf.setResourceComparator(DominantResourceCalculator.class); [EOL] [EOL] YarnConfiguration conf = new YarnConfiguration(csconf); [EOL] conf.setClass(YarnConfiguration.RM_SCHEDULER, CapacityScheduler.class, [EOL] ResourceScheduler.class); [EOL] [EOL] MockRM rm = new MockRM(conf); [EOL] rm.start(); [EOL] [EOL] MockNM nm1 = rm.registerNode("127.0.0.1:1234", 10 * GB, 1); [EOL] [EOL] // register extra nodes to bump up cluster resource [EOL] MockNM nm2 = rm.registerNode("127.0.0.1:1235", 10 * GB, 4); [EOL] rm.registerNode("127.0.0.1:1236", 10 * GB, 4); [EOL] [EOL] RMApp app1 = MockRMAppSubmitter.submitWithMemory(1024, rm); [EOL] // kick the scheduling [EOL] nm1.nodeHeartbeat(true); [EOL] RMAppAttempt attempt1 = app1.getCurrentAppAttempt(); [EOL] MockAM am1 = rm.sendAMLaunched(attempt1.getAppAttemptId()); [EOL] am1.registerAppAttempt(); [EOL] SchedulerNodeReport report_nm1 = [EOL] rm.getResourceScheduler().getNodeReport(nm1.getNodeId()); [EOL] [EOL] // check node report [EOL] Assert.assertEquals(1 * GB, report_nm1.getUsedResource().getMemorySize()); [EOL] Assert.assertEquals(9 * GB, report_nm1.getAvailableResource().getMemorySize()); [EOL] [EOL] // add request for containers [EOL] am1.addRequests(new String[] { "127.0.0.1", "127.0.0.2" }, 1 * GB, 1, 1); [EOL] am1.schedule(); // send the request [EOL] [EOL] // kick the scheduler, container reservation should not happen [EOL] nm1.nodeHeartbeat(true); [EOL] Thread.sleep(1000); [EOL] AllocateResponse allocResponse = am1.schedule(); [EOL] ApplicationResourceUsageReport report = [EOL] rm.getResourceScheduler().getAppResourceUsageReport( [EOL] attempt1.getAppAttemptId()); [EOL] Assert.assertEquals(0, allocResponse.getAllocatedContainers().size()); [EOL] Assert.assertEquals(0, report.getNumReservedContainers()); [EOL] [EOL] // container should get allocated on this node [EOL] nm2.nodeHeartbeat(true); [EOL] [EOL] while (allocResponse.getAllocatedContainers().size() == 0) { [EOL] Thread.sleep(100); [EOL] allocResponse = am1.schedule(); [EOL] } [EOL] report = [EOL] rm.getResourceScheduler().getAppResourceUsageReport( [EOL] attempt1.getAppAttemptId()); [EOL] Assert.assertEquals(1, allocResponse.getAllocatedContainers().size()); [EOL] Assert.assertEquals(0, report.getNumReservedContainers()); [EOL] rm.stop(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCapacityScheduler.class); [EOL] private final static ContainerUpdates NULL_UPDATE_REQUESTS = [EOL] new ContainerUpdates(); [EOL] private ResourceManager resourceManager = null; [EOL] private RMContext mockContext; [EOL] private static final double DELTA = 0.000001; [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       int int0 = CharSequenceUtils.lastIndexOf("", 1834, 2479); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFailure() throws Exception { [EOL] AppContext mockContext = mock(AppContext.class); [EOL] OutputCommitter mockCommitter = mock(OutputCommitter.class); [EOL] Clock mockClock = mock(Clock.class); [EOL] [EOL] CommitterEventHandler handler = new CommitterEventHandler(mockContext, [EOL] mockCommitter, new TestingRMHeartbeatHandler()); [EOL] YarnConfiguration conf = new YarnConfiguration(); [EOL] conf.set(MRJobConfig.MR_AM_STAGING_DIR, stagingDir); [EOL] JobContext mockJobContext = mock(JobContext.class); [EOL] ApplicationAttemptId attemptid = [EOL] ApplicationAttemptId.fromString("appattempt_1234567890000_0001_0"); [EOL] JobId jobId = TypeConverter.toYarn( [EOL] TypeConverter.fromYarn(attemptid.getApplicationId())); [EOL] [EOL] WaitForItHandler waitForItHandler = new WaitForItHandler(); [EOL] [EOL] when(mockContext.getApplicationID()).thenReturn(attemptid.getApplicationId()); [EOL] when(mockContext.getApplicationAttemptId()).thenReturn(attemptid); [EOL] when(mockContext.getEventHandler()).thenReturn(waitForItHandler); [EOL] when(mockContext.getClock()).thenReturn(mockClock); [EOL] [EOL] doThrow(new YarnRuntimeException("Intentional Failure")).when(mockCommitter) [EOL] .commitJob(any(JobContext.class)); [EOL] [EOL] handler.init(conf); [EOL] handler.start(); [EOL] try { [EOL] handler.handle(new CommitterJobCommitEvent(jobId, mockJobContext)); [EOL] [EOL] String user = UserGroupInformation.getCurrentUser().getShortUserName(); [EOL] Path startCommitFile = MRApps.getStartJobCommitFile(conf, user, jobId); [EOL] Path endCommitSuccessFile = MRApps.getEndJobCommitSuccessFile(conf, user, [EOL] jobId); [EOL] Path endCommitFailureFile = MRApps.getEndJobCommitFailureFile(conf, user, [EOL] jobId); [EOL] [EOL] Event e = waitForItHandler.getAndClearEvent(); [EOL] assertNotNull(e); [EOL] assertTrue(e instanceof JobCommitFailedEvent); [EOL] FileSystem fs = FileSystem.get(conf); [EOL] assertTrue(fs.exists(startCommitFile)); [EOL] assertFalse(fs.exists(endCommitSuccessFile)); [EOL] assertTrue(fs.exists(endCommitFailureFile)); [EOL] verify(mockCommitter).commitJob(any(JobContext.class)); [EOL] } finally { [EOL] handler.stop(); [EOL] } [EOL] } [EOL] static String stagingDir = "target/test-staging/"; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(641); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       List<String> list0 = strBuilder_StrBuilderTokenizer0.tokenize(charArray0, 0, (-1032)); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       int int0 = 0; [EOL]       int int1 = strBuilder0.validateRange(0, 0); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(1, ""); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGeEndpointsByServiceJSON() { [EOL] System.out.println("geEndpointsByServiceJSON"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] UriContainer expResult = null; [EOL] UriContainer result = instance.geEndpointsByServiceJSON(JUDDI_SVC); [EOL] Assert.assertNotNull(result); [EOL] [EOL] [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       String string0 = "SzpQ!4 ;U"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("SzpQ!4 ;U"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       char char0 = '`'; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) "SzpQ!4 ;U", 97, '`'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("SzpQ!4 ;U"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(97, (long) 2817); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.append('`'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder1.replaceFirst("SzpQ!4 ;U", "SzpQ!4 ;U"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       String string1 = strBuilder0.getNullText(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder2.replaceAll("SzpQ!4 ;U", "SzpQ!4 ;U"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(2817, (-1.0F)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2817 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       MockThrowable mockThrowable0 = new MockThrowable("J"); [EOL]       MockThrowable mockThrowable1 = new MockThrowable("J", mockThrowable0); [EOL]       Class<String> class0 = String.class; [EOL]       int int0 = ExceptionUtils.indexOfType((Throwable) mockThrowable1, (Class<?>) class0); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testBlacklistRejection() throws Exception { [EOL] ResourceBlacklistRequest blacklistRequest = [EOL] ResourceBlacklistRequest.newInstance( [EOL] Arrays.asList("h1", "h2"), new ArrayList<>()); [EOL] List<ResourceRequest> reqs = [EOL] Arrays.asList(ResourceRequest.newInstance(PRIORITY_NORMAL, [EOL] "*", CAPABILITY_1GB, 1, true, null, OPPORTUNISTIC_REQ)); [EOL] ApplicationAttemptId appAttId = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(0L, 1), 1); [EOL] [EOL] oppCntxt.updateNodeList( [EOL] Arrays.asList( [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h1", 1234), "h1:1234", "/r1"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h2", 1234), "h2:1234", "/r2"))); [EOL] List<Container> containers = allocator.allocateContainers( [EOL] blacklistRequest, reqs, appAttId, oppCntxt, 1L, "luser"); [EOL] Assert.assertEquals(0, containers.size()); [EOL] Assert.assertEquals(1, oppCntxt.getOutstandingOpReqs().size()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger( [EOL] TestDistributedOpportunisticContainerAllocator.class); [EOL] private static final int GB = 1024; [EOL] private DistributedOpportunisticContainerAllocator allocator = null; [EOL] private OpportunisticContainerContext oppCntxt = null; [EOL] private static final Priority PRIORITY_NORMAL = Priority.newInstance(1); [EOL] private static final Resource CAPABILITY_1GB = [EOL] Resources.createResource(1 * GB); [EOL] private static final ExecutionTypeRequest OPPORTUNISTIC_REQ = [EOL] ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC, true); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ","); [EOL]       standardToStringStyle0.removeLastFieldSeparator(stringBuffer0); [EOL]       assertEquals("<size=", standardToStringStyle0.getSizeStartText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testTotalCapacityOfSubQueues() { [EOL] Configuration conf = new Configuration(); [EOL] FairCallQueue<Schedulable> fairCallQueue; [EOL] fairCallQueue = new FairCallQueue<Schedulable>(1, 1000, "ns", conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1000); [EOL] fairCallQueue = new FairCallQueue<Schedulable>(4, 1000, "ns", conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1000); [EOL] fairCallQueue = new FairCallQueue<Schedulable>(7, 1000, "ns", conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1000); [EOL] fairCallQueue = new FairCallQueue<Schedulable>(1, 1025, "ns", conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1025); [EOL] fairCallQueue = new FairCallQueue<Schedulable>(4, 1025, "ns", conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1025); [EOL] fairCallQueue = new FairCallQueue<Schedulable>(7, 1025, "ns", conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1025); [EOL] fairCallQueue = new FairCallQueue<Schedulable>(7, 1025, "ns", [EOL] new int[]{7, 6, 5, 4, 3, 2, 1}, conf); [EOL] assertThat(fairCallQueue.remainingCapacity()).isEqualTo(1025); [EOL] } [EOL] private FairCallQueue<Schedulable> fcq; [EOL]
@Test(timeout = 4000) [EOL]   public void testnullToEmpty()  throws Throwable  { [EOL]       Character[] characterArray0 = new Character[1]; [EOL]       Character[] characterArray1 = ArrayUtils.nullToEmpty(characterArray0); [EOL]       assertEquals(1, characterArray1.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testJustStop() throws Exception { [EOL] webServer.stop(); [EOL] } [EOL] @Rule [EOL] public Timeout timeout = new Timeout(30000); [EOL] private HttpFSServerWebServer webServer; [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOfType()  throws Throwable  { [EOL]       Class<Integer> class0 = Integer.class; [EOL]       int int0 = ExceptionUtils.indexOfType((Throwable) null, class0); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNodemanagerConfigurationIsUsed() { [EOL] Configuration conf = getConf(); [EOL] conf.set(YarnConfiguration.LOG_AGGREGATION_FILE_FORMATS, "TFile"); [EOL] LogAggregationFileControllerFactory factory = [EOL] new LogAggregationFileControllerFactory(conf); [EOL] LogAggregationFileController fc = factory.getFileControllerForWrite(); [EOL] [EOL] assertEquals(WRONG_ROOT_LOG_DIR_MSG, "target/app-logs/default", [EOL] fc.getRemoteRootLogDir().toString()); [EOL] assertEquals(WRONG_ROOT_LOG_DIR_SUFFIX_MSG, "log-tfile", [EOL] fc.getRemoteRootLogDirSuffix()); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger( [EOL] TestLogAggregationFileControllerFactory.class); [EOL] private static final String REMOTE_LOG_ROOT = "target/app-logs/"; [EOL] private static final String REMOTE_DEFAULT_DIR = "default/"; [EOL] private static final String APP_OWNER = "test"; [EOL] private static final String WRONG_ROOT_LOG_DIR_MSG = [EOL] "Wrong remote root log directory found."; [EOL] private static final String WRONG_ROOT_LOG_DIR_SUFFIX_MSG = [EOL] "Wrong remote root log directory suffix found."; [EOL] private static final List<Class<? extends LogAggregationFileController>> [EOL] ALL_FILE_CONTROLLERS = Arrays.asList( [EOL] TestLogAggregationFileController.class, [EOL] LogAggregationIndexedFileController.class, [EOL] LogAggregationTFileController.class); [EOL] private static final List<String> ALL_FILE_CONTROLLER_NAMES = [EOL] Arrays.asList("TestLogAggregationFileController", "IFile", "TFile"); [EOL] private ApplicationId appId = ApplicationId.newInstance( [EOL] System.currentTimeMillis(), 1); [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       HashCodeBuilder hashCodeBuilder0 = new HashCodeBuilder(37, (-1)); [EOL]       HashCodeBuilder hashCodeBuilder1 = hashCodeBuilder0.appendSuper(37); [EOL]       double[] doubleArray0 = new double[3]; [EOL]       hashCodeBuilder1.append((double) (-1)); [EOL]       doubleArray0[0] = (double) (-2563); [EOL]       doubleArray0[1] = (double) (-2563); [EOL]       doubleArray0[2] = (double) (-1); [EOL]       hashCodeBuilder0.append(doubleArray0); [EOL]       assertEquals(0, (int)hashCodeBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoLong()  throws Throwable  { [EOL]       long long0 = NumberUtils.toLong("", (long) (byte)0); [EOL]       assertEquals(0L, long0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testfloatValue()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getFraction((-1935.9095027)); [EOL]       int int0 = fraction0.getProperWhole(); [EOL]       assertEquals((-1935.9095F), fraction0.floatValue(), 0.01F); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAsciiAlpha()  throws Throwable  { [EOL]       boolean boolean0 = CharUtils.isAsciiAlphaLower('a'); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.equals((Object) null); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.insert(0, (float) 0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       int int0 = strBuilder1.capacity(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       int int1 = 0; [EOL]       StrBuilder strBuilder2 = strBuilder1.append((CharSequence) strBuilder0, 0, 0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder3 = new StrBuilder(); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.append(strBuilder3); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       char char0 = '|'; [EOL]       StrBuilder strBuilder5 = strBuilder1.replaceAll('A', '|'); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder5.getNullText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder5.validateRange(32, 32); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMain() throws Exception { [EOL] ContainerLocalizerWrapper wrapper = new ContainerLocalizerWrapper(); [EOL] ContainerLocalizer localizer = [EOL] wrapper.setupContainerLocalizerForTest(); [EOL] Random random = wrapper.random; [EOL] List<Path> localDirs = wrapper.localDirs; [EOL] Path tokenPath = wrapper.tokenPath; [EOL] LocalizationProtocol nmProxy = wrapper.nmProxy; [EOL] AbstractFileSystem spylfs = wrapper.spylfs; [EOL] mockOutDownloads(localizer); [EOL] [EOL] // verify created cache [EOL] List<Path> privCacheList = new ArrayList<Path>(); [EOL] List<Path> appCacheList = new ArrayList<Path>(); [EOL] for (Path p : localDirs) { [EOL] Path base = new Path(new Path(p, ContainerLocalizer.USERCACHE), appUser); [EOL] Path privcache = new Path(base, ContainerLocalizer.FILECACHE); [EOL] privCacheList.add(privcache); [EOL] Path appDir = [EOL] new Path(base, new Path(ContainerLocalizer.APPCACHE, appId)); [EOL] Path appcache = new Path(appDir, ContainerLocalizer.FILECACHE); [EOL] appCacheList.add(appcache); [EOL] } [EOL] [EOL] // mock heartbeat responses from NM [EOL] ResourceLocalizationSpec rsrcA = [EOL] getMockRsrc(random, LocalResourceVisibility.PRIVATE, [EOL] privCacheList.get(0)); [EOL] ResourceLocalizationSpec rsrcB = [EOL] getMockRsrc(random, LocalResourceVisibility.PRIVATE, [EOL] privCacheList.get(0)); [EOL] ResourceLocalizationSpec rsrcC = [EOL] getMockRsrc(random, LocalResourceVisibility.APPLICATION, [EOL] appCacheList.get(0)); [EOL] ResourceLocalizationSpec rsrcD = [EOL] getMockRsrc(random, LocalResourceVisibility.PRIVATE, [EOL] privCacheList.get(0)); [EOL] [EOL] when(nmProxy.heartbeat(isA(LocalizerStatus.class))) [EOL] .thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE, [EOL] Collections.singletonList(rsrcA))) [EOL] .thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE, [EOL] Collections.singletonList(rsrcB))) [EOL] .thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE, [EOL] Collections.singletonList(rsrcC))) [EOL] .thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE, [EOL] Collections.singletonList(rsrcD))) [EOL] .thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.LIVE, [EOL] Collections.<ResourceLocalizationSpec>emptyList())) [EOL] .thenReturn(new MockLocalizerHeartbeatResponse(LocalizerAction.DIE, [EOL] null)); [EOL] [EOL] LocalResource tRsrcA = rsrcA.getResource(); [EOL] LocalResource tRsrcB = rsrcB.getResource(); [EOL] LocalResource tRsrcC = rsrcC.getResource(); [EOL] LocalResource tRsrcD = rsrcD.getResource(); [EOL] doReturn( [EOL] new FakeDownload(rsrcA.getResource().getResource().getFile(), true)) [EOL] .when(localizer).download(isA(Path.class), eq(tRsrcA), [EOL] isA(UserGroupInformation.class)); [EOL] doReturn( [EOL] new FakeDownload(rsrcB.getResource().getResource().getFile(), true)) [EOL] .when(localizer).download(isA(Path.class), eq(tRsrcB), [EOL] isA(UserGroupInformation.class)); [EOL] doReturn( [EOL] new FakeDownload(rsrcC.getResource().getResource().getFile(), true)) [EOL] .when(localizer).download(isA(Path.class), eq(tRsrcC), [EOL] isA(UserGroupInformation.class)); [EOL] doReturn( [EOL] new FakeDownload(rsrcD.getResource().getResource().getFile(), true)) [EOL] .when(localizer).download(isA(Path.class), eq(tRsrcD), [EOL] isA(UserGroupInformation.class)); [EOL] [EOL] // run localization [EOL] localizer.runLocalization(nmAddr); [EOL] for (Path p : localDirs) { [EOL] Path base = new Path(new Path(p, ContainerLocalizer.USERCACHE), appUser); [EOL] Path privcache = new Path(base, ContainerLocalizer.FILECACHE); [EOL] // $x/usercache/$user/filecache [EOL] verify(spylfs).mkdir(eq(privcache), eq(CACHE_DIR_PERM), eq(false)); [EOL] Path appDir = [EOL] new Path(base, new Path(ContainerLocalizer.APPCACHE, appId)); [EOL] // $x/usercache/$user/appcache/$appId/filecache [EOL] Path appcache = new Path(appDir, ContainerLocalizer.FILECACHE); [EOL] verify(spylfs).mkdir(eq(appcache), eq(CACHE_DIR_PERM), eq(false)); [EOL] } [EOL] // verify tokens read at expected location [EOL] verify(spylfs).open(tokenPath); [EOL] [EOL] // verify downloaded resources reported to NM [EOL] verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcA.getResource()))); [EOL] verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcB.getResource()))); [EOL] verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcC.getResource()))); [EOL] verify(nmProxy).heartbeat(argThat(new HBMatches(rsrcD.getResource()))); [EOL] [EOL] // verify all HB use localizerID provided [EOL] verify(nmProxy, never()).heartbeat(argThat( [EOL] status -> !containerId.equals(status.getLocalizerId()))); [EOL] } [EOL] static final Logger LOG = [EOL] LoggerFactory.getLogger(TestContainerLocalizer.class); [EOL] static final Path basedir = [EOL] new Path("target", TestContainerLocalizer.class.getName()); [EOL] static final FsPermission CACHE_DIR_PERM = new FsPermission((short)0710); [EOL] static final FsPermission USERCACHE_DIR_PERM = new FsPermission((short) 0755); [EOL] static final String appUser = "yak"; [EOL] static final String appId = "app_RM_0"; [EOL] static final String containerId = "container_0"; [EOL] static final InetSocketAddress nmAddr = [EOL] new InetSocketAddress("foobar", 8040); [EOL]
@Test [EOL] public void testSubmitReservationNegativeRecurrenceExpression() { [EOL] ReservationSubmissionRequest request = [EOL] createSimpleReservationSubmissionRequest(1, 1, 1, 5, 3, "-1234"); [EOL] plan = null; [EOL] try { [EOL] plan = [EOL] rrValidator.validateReservationSubmissionRequest(rSystem, request, [EOL] ReservationSystemTestUtil.getNewReservationId()); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertNull(plan); [EOL] String message = e.getMessage(); [EOL] Assert.assertTrue(message [EOL] .startsWith("Negative Period : ")); [EOL] LOG.info(message); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestReservationInputValidator.class); [EOL] private static final String PLAN_NAME = "test-reservation"; [EOL] private Clock clock; [EOL] private Map<String, Plan> plans = new HashMap<String, Plan>(1); [EOL] private ReservationSystem rSystem; [EOL] private Plan plan; [EOL] private ReservationInputValidator rrValidator; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(79); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0.0F); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append((double) 79); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln((-2267)); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendln((Object) strBuilder3); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder4.deleteAll('#'); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder5.append((StringBuilder) null, 79, 44); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]       assertNull(strBuilder6.getNewLineText()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       int int0 = 2; [EOL]       StrBuilder strBuilder7 = strBuilder0.append((CharSequence) strBuilder1); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder7.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder0.replaceAll("nCIF=^XRVL:\t%AH&", "end < start"); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder8.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append((CharSequence) stringBuilder0, 2, (-211)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(79); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0.0F); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append((double) 79); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln((-2267)); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder3.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendln((Object) strBuilder3); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder1.capacity()); [EOL]       assertEquals(79, strBuilder3.capacity()); [EOL]       assertEquals(79, strBuilder4.capacity()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder2.clear(); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder2.capacity()); [EOL]       assertEquals(79, strBuilder5.capacity()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.deleteAll('#'); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder1.capacity()); [EOL]       assertEquals(79, strBuilder3.capacity()); [EOL]       assertEquals(79, strBuilder4.capacity()); [EOL]       assertEquals(79, strBuilder6.capacity()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder1.capacity()); [EOL]        [EOL]       int int0 = 2; [EOL]       StrBuilder strBuilder7 = strBuilder0.append((CharSequence) strBuilder1); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder1.capacity()); [EOL]       assertEquals(79, strBuilder7.capacity()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder0.replaceAll("nCIF=^XRVL:\t%AH&", "end < start"); [EOL]       assertEquals(79, strBuilder0.capacity()); [EOL]       assertEquals(79, strBuilder8.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append((CharSequence) stringBuilder0, 2, (-211)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(expected = WebApplicationException.class) [EOL] public void testGetBusinessDetailXML_NULL() { [EOL] System.out.println("testGetBusinessDetailXML_NULL"); [EOL] [EOL] [EOL] String id = UUID.randomUUID().toString(); [EOL] BusinessEntity expResult = null; [EOL] BusinessEntity result = instance.getBusinessDetailXML(id); [EOL] [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetRootCause()  throws Throwable  { [EOL]       MockThrowable mockThrowable0 = new MockThrowable("8z/t]?%'4"); [EOL]       String string0 = ExceptionUtils.getRootCauseMessage(mockThrowable0); [EOL]       assertEquals("MockThrowable: 8z/t]?%'4", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testWithHbaseConfAtHdfsFileSystem() throws IOException { [EOL] MiniDFSCluster hdfsCluster = null; [EOL] try { [EOL] HdfsConfiguration hdfsConfig = new HdfsConfiguration(); [EOL] hdfsCluster = new MiniDFSCluster.Builder(hdfsConfig) [EOL] .numDataNodes(1).build(); [EOL] [EOL] FileSystem fs = hdfsCluster.getFileSystem(); [EOL] Path path = new Path("/tmp/hdfs-site.xml"); [EOL] fs.copyFromLocalFile(new Path(hbaseConfigPath), path); [EOL] [EOL] // Verifying With Hbase Conf from HDFS FileSystem [EOL] Configuration conf = new Configuration(hdfsConfig); [EOL] conf.set(YarnConfiguration.TIMELINE_SERVICE_HBASE_CONFIGURATION_FILE, [EOL] path.toString()); [EOL] Configuration hbaseConfFromHdfs = [EOL] HBaseTimelineStorageUtils.getTimelineServiceHBaseConf(conf); [EOL] Assert.assertEquals("Failed to read hbase config from Hdfs FileSystem", [EOL] "test", hbaseConfFromHdfs.get("input")); [EOL] } finally { [EOL] if (hdfsCluster != null) { [EOL] hdfsCluster.shutdown(); [EOL] } [EOL] } [EOL] } [EOL] private String hbaseConfigPath = "target/hbase-site.xml"; [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       IDKey iDKey0 = new IDKey("j<w?_Kh"); [EOL]       Object object0 = new Object(); [EOL]       String[] stringArray0 = new String[5]; [EOL]       stringArray0[0] = "j<w?_Kh"; [EOL]       stringArray0[1] = "j<w?_Kh"; [EOL]       stringArray0[2] = "j<w?_Kh"; [EOL]       stringArray0[3] = "j<w?_Kh"; [EOL]       stringArray0[4] = "j<w?_Kh"; [EOL]       EqualsBuilder.reflectionEquals((Object) iDKey0, object0, stringArray0); [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       int[] intArray0 = new int[2]; [EOL]       intArray0[0] = (-504); [EOL]       intArray0[1] = 0; [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(intArray0, intArray0); [EOL]       float[] floatArray0 = new float[3]; [EOL]       floatArray0[0] = (float) (-504); [EOL]       floatArray0[1] = (float) 0; [EOL]       floatArray0[2] = (float) 0; [EOL]       float[] floatArray1 = new float[5]; [EOL]       floatArray1[0] = (float) (-504); [EOL]       floatArray1[1] = (float) (-504); [EOL]       floatArray1[2] = (float) 0; [EOL]       floatArray1[3] = (float) 0; [EOL]       floatArray1[4] = (float) 0; [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(floatArray0, floatArray1); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append((byte)0, (byte)1); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append(' ', '8'); [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append(959, 0); [EOL]       equalsBuilder5.reset(); [EOL]       assertTrue(equalsBuilder1.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetOpInfoXML() { [EOL] System.out.println("getOpInfoXML"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] OperationalInfo expResult = null; [EOL] OperationalInfo result = instance.getOpInfoXML(JUDDI_BIZ); [EOL] Assert.assertNotNull(result); [EOL] Assert.assertNotNull(result.getAuthorizedName()); [EOL] Assert.assertNotNull(result.getEntityKey()); [EOL] Assert.assertNotNull(result.getNodeID()); [EOL] [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test (timeout = 30000) [EOL] public void testListFiles() throws IOException { [EOL] //Test existing files case [EOL] File[] files = FileUtil.listFiles(partitioned); [EOL] Assert.assertEquals(2, files.length); [EOL] [EOL] //Test existing directory with no files case [EOL] File newDir = new File(tmp.getPath(),"test"); [EOL] newDir.mkdir(); [EOL] Assert.assertTrue("Failed to create test dir", newDir.exists()); [EOL] files = FileUtil.listFiles(newDir); [EOL] Assert.assertEquals(0, files.length); [EOL] newDir.delete(); [EOL] Assert.assertFalse("Failed to delete test dir", newDir.exists()); [EOL] [EOL] //Test non-existing directory case, this throws [EOL] //IOException [EOL] try { [EOL] files = FileUtil.listFiles(newDir); [EOL] Assert.fail("IOException expected on listFiles() for non-existent dir " [EOL] 		+ newDir.toString()); [EOL] } catch(IOException ioe) { [EOL] 	//Expected an IOException [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test (timeout = 30000) [EOL] public void testHasSufficientTimeElapsed() throws Exception { [EOL] // Make hasSufficientTimeElapsed public [EOL] Method method = UserGroupInformation.class [EOL] .getDeclaredMethod("hasSufficientTimeElapsed", long.class); [EOL] method.setAccessible(true); [EOL] [EOL] UserGroupInformation ugi = UserGroupInformation.getCurrentUser(); [EOL] User user = ugi.getSubject().getPrincipals(User.class).iterator().next(); [EOL] long now = System.currentTimeMillis(); [EOL] [EOL] // Using default relogin time (1 minute) [EOL] user.setLastLogin(now - 2 * 60 * 1000); // 2 minutes before "now" [EOL] assertTrue((Boolean)method.invoke(ugi, now)); [EOL] user.setLastLogin(now - 30 * 1000); // 30 seconds before "now" [EOL] assertFalse((Boolean)method.invoke(ugi, now)); [EOL] [EOL] // Using relogin time of 10 minutes [EOL] Configuration conf2 = new Configuration(conf); [EOL] conf2.setLong( [EOL] CommonConfigurationKeysPublic.HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN, [EOL] 10 * 60); [EOL] UserGroupInformation.setConfiguration(conf2); [EOL] user.setLastLogin(now - 15 * 60 * 1000); // 15 minutes before "now" [EOL] assertTrue((Boolean)method.invoke(ugi, now)); [EOL] user.setLastLogin(now - 6 * 60 * 1000); // 6 minutes before "now" [EOL] assertFalse((Boolean)method.invoke(ugi, now)); [EOL] // Restore original conf to UGI [EOL] UserGroupInformation.setConfiguration(conf); [EOL] [EOL] // Restore hasSufficientTimElapsed back to private [EOL] method.setAccessible(false); [EOL] } [EOL] static final Logger LOG = LoggerFactory.getLogger( [EOL] TestUserGroupInformation.class); [EOL] final private static String USER_NAME = "user1@HADOOP.APACHE.ORG"; [EOL] final private static String GROUP1_NAME = "group1"; [EOL] final private static String GROUP2_NAME = "group2"; [EOL] final private static String GROUP3_NAME = "group3"; [EOL] final private static String[] GROUP_NAMES = [EOL] new String[]{GROUP1_NAME, GROUP2_NAME, GROUP3_NAME}; [EOL] private static final int PERCENTILES_INTERVAL = 1; [EOL] private static Configuration conf; [EOL]
@Test [EOL] public void testJobCommit() throws Exception { [EOL] Path jobAttemptPath = jobCommitter.getJobAttemptPath(job); [EOL] FileSystem fs = jobAttemptPath.getFileSystem(conf); [EOL] [EOL] Set<String> uploads = runTasks(job, 4, 3); [EOL] assertNotEquals(0, uploads.size()); [EOL] [EOL] assertPathExists(fs, "No job attempt path", jobAttemptPath); [EOL] [EOL] jobCommitter.commitJob(job); [EOL] assertEquals("Should have aborted no uploads", [EOL] 0, results.getAborts().size()); [EOL] [EOL] assertEquals("Should have deleted no uploads", [EOL] 0, results.getDeletes().size()); [EOL] [EOL] assertEquals("Should have committed all uploads", [EOL] uploads, getCommittedIds(results.getCommits())); [EOL] [EOL] assertPathDoesNotExist(fs, "jobAttemptPath not deleted", jobAttemptPath); [EOL] [EOL] } [EOL] private static final JobID JOB_ID = new JobID("job", 1); [EOL] private static final TaskAttemptID AID = new TaskAttemptID( [EOL] new TaskID(JOB_ID, TaskType.REDUCE, 2), 3); [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestStagingCommitter.class); [EOL] private final int numThreads; [EOL] private final boolean uniqueFilenames; [EOL] private JobContext job = null; [EOL] private TaskAttemptContext tac = null; [EOL] private Configuration conf = null; [EOL] private MockedStagingCommitter jobCommitter = null; [EOL] private MockedStagingCommitter committer = null; [EOL] private S3AFileSystem mockFS = null; [EOL] private MockS3AFileSystem wrapperFS = null; [EOL] private StagingTestBase.ClientResults results = null; [EOL] private StagingTestBase.ClientErrors errors = null; [EOL] private AmazonS3 mockClient = null; [EOL] private File tmpDir; [EOL]
@Test [EOL] public void testGetPartition() { [EOL] assertEquals("year=2017/month=10", [EOL] getPartition("year=2017/month=10/part-0000.avro")); [EOL] } [EOL] private static final String DATA = "s3a://landsat-pds/data/"; [EOL] private static final Path BASE = new Path(DATA); [EOL]
@Test [EOL] public void [EOL] testParseNewStyleResourceWithPercentagesMemoryNegativeWithMoreSpaces() [EOL] throws Exception { [EOL] expectNegativePercentageNewStyle(); [EOL] parseResourceConfigValue("vcores = 75%, memory-mb = -40%"); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test [EOL] public void testWrite() throws IOException { [EOL] long length = 11111; [EOL] long fileCount = 22222; [EOL] long directoryCount = 33333; [EOL] long quota = 44444; [EOL] long spaceConsumed = 55555; [EOL] long spaceQuota = 66666; [EOL] [EOL] ContentSummary contentSummary = new ContentSummary.Builder().length(length). [EOL] fileCount(fileCount).directoryCount(directoryCount).quota(quota). [EOL] spaceConsumed(spaceConsumed).spaceQuota(spaceQuota).build(); [EOL] [EOL] DataOutput out = mock(DataOutput.class); [EOL] InOrder inOrder = inOrder(out); [EOL] [EOL] contentSummary.write(out); [EOL] inOrder.verify(out).writeLong(length); [EOL] inOrder.verify(out).writeLong(fileCount); [EOL] inOrder.verify(out).writeLong(directoryCount); [EOL] inOrder.verify(out).writeLong(quota); [EOL] inOrder.verify(out).writeLong(spaceConsumed); [EOL] inOrder.verify(out).writeLong(spaceQuota); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetInstance()  throws Throwable  { [EOL]       CharSet charSet0 = CharSet.getInstance((String[]) null); [EOL]       assertNull(charSet0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((-4387)); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       LinkedHashSet<StrBuilder> linkedHashSet0 = new LinkedHashSet<StrBuilder>(); [EOL]       assertTrue(linkedHashSet0.isEmpty()); [EOL]        [EOL]       boolean boolean0 = linkedHashSet0.add(strBuilder0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertFalse(linkedHashSet0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendAll((Iterable<?>) linkedHashSet0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(linkedHashSet0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.ensureCapacity((-4387)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.appendPadding((-764), 'x'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(linkedHashSet0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testIfUriContainsAbfs() throws Exception { [EOL] Assert.assertTrue(UriUtils.containsAbfsUrl("abfs.dfs.core.windows.net")); [EOL] Assert.assertTrue(UriUtils.containsAbfsUrl("abfs.dfs.preprod.core.windows.net")); [EOL] Assert.assertFalse(UriUtils.containsAbfsUrl("abfs.dfs.cores.windows.net")); [EOL] Assert.assertFalse(UriUtils.containsAbfsUrl("")); [EOL] Assert.assertFalse(UriUtils.containsAbfsUrl(null)); [EOL] Assert.assertFalse(UriUtils.containsAbfsUrl("abfs.dfs.cores.windows.net")); [EOL] Assert.assertFalse(UriUtils.containsAbfsUrl("xhdfs.blob.core.windows.net")); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getContentStart(); [EOL]       assertEquals("<null>", standardToStringStyle0.getNullText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.join((int[]) null, 't', 0, 0); [EOL]        [EOL]       boolean boolean0 = StringUtils.isAllUpperCase((CharSequence) null); [EOL]        [EOL]       String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null, '{'); [EOL]        [EOL]       String string1 = StringUtils.stripEnd(":;6z", (String) null);6z", string1); [EOL]        [EOL]       String string2 = StringUtils.leftPad("RWSLzV4h", 0, ""); [EOL]       assertFalse(string2.equals((Object)string1)); [EOL]        [EOL]       int int0 = StringUtils.lastIndexOf((CharSequence) ":;6z", (CharSequence) "RWSLzV4h", 0); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitByWholeSeparator("Nt{2P6~Pso'", ""); [EOL]        [EOL]       String string3 = StringUtils.join((float[]) null, 't', (-1520), 0); [EOL]        [EOL]       String string4 = StringUtils.defaultIfEmpty((String) null, ":;6z"); [EOL]       assertFalse(string4.equals((Object)string2)); [EOL]       assertTrue(string4.equals((Object)string1));6z", string4); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSortLocatedBlocks() throws IOException, URISyntaxException { [EOL] HelperFunction(null, 0); [EOL] } [EOL] public static final Logger LOG = [EOL] LoggerFactory.getLogger(TestDatanodeManager.class); [EOL] final int NUM_ITERATIONS = 500; [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtEnd()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getFieldNameValueSeparator(); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtEnd()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClusterSchedulerFifoSlash() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("cluster") [EOL] .path("scheduler/").accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] verifyClusterSchedulerFifo(json); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRMWebServices.class); [EOL] private static MockRM rm; [EOL]
@Test [EOL] public void testCidrLongRO() { [EOL] NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod, [EOL] "192.168.0.0/255.255.252.0"); [EOL] Assert.assertEquals(AccessPrivilege.READ_ONLY, [EOL] matcher.getAccessPrivilege(address1, hostname1)); [EOL] Assert.assertEquals(AccessPrivilege.NONE, [EOL] matcher.getAccessPrivilege(address2, hostname1)); [EOL] } [EOL] private final String address1 = "192.168.0.12"; [EOL] private final String address2 = "10.0.0.12"; [EOL] private final String hostname1 = "a.b.com"; [EOL] private final String hostname2 = "a.b.org"; [EOL] private static final long ExpirationPeriod = [EOL] Nfs3Constant.NFS_EXPORTS_CACHE_EXPIRYTIME_MILLIS_DEFAULT * 1000 * 1000; [EOL] private static final int CacheSize = Nfs3Constant.NFS_EXPORTS_CACHE_SIZE_DEFAULT; [EOL] private static final long NanosPerMillis = 1000000; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       Short[] shortArray0 = new Short[2]; [EOL]       Short short0 = new Short((short)20); [EOL]       shortArray0[0] = short0; [EOL]       shortArray0[1] = shortArray0[0]; [EOL]       short[] shortArray1 = ArrayUtils.toPrimitive(shortArray0); [EOL]       assertArrayEquals(new short[] {(short)20, (short)20}, shortArray1); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       Boolean boolean0 = Boolean.TRUE; [EOL]       standardToStringStyle0.isFullDetail(boolean0); [EOL]       assertEquals(">", standardToStringStyle0.getSummaryObjectEndText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbinaryToHexDigit()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[9]; [EOL]       booleanArray0[0] = true; [EOL]       char char0 = Conversion.binaryToHexDigit(booleanArray0); [EOL]       assertEquals('1', char0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetGroupsResolvable() throws Exception { [EOL] TestGroupResolvable mapping = new TestGroupResolvable(); [EOL] [EOL] List<String> groups = mapping.getGroups("user"); [EOL] assertTrue(groups.size() == 3); [EOL] assertTrue(groups.contains("abc")); [EOL] assertTrue(groups.contains("def")); [EOL] assertTrue(groups.contains("hij")); [EOL] } [EOL] private static final Logger TESTLOG = [EOL] LoggerFactory.getLogger(TestShellBasedUnixGroupsMapping.class); [EOL] private final GenericTestUtils.LogCapturer shellMappingLog = [EOL] GenericTestUtils.LogCapturer.captureLogs( [EOL] ShellBasedUnixGroupsMapping.LOG); [EOL]
@Test(timeout = SWIFT_TEST_TIMEOUT) [EOL] public void testAuthenticate() throws Throwable { [EOL] assumeEnabled(); [EOL] SwiftRestClient client = createClient(); [EOL] client.authenticate(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestSwiftRestClient.class); [EOL] private Configuration conf; [EOL] private boolean runTests; [EOL] private URI serviceURI; [EOL]
@Test(timeout = 4000) [EOL]   public void testadd()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getReducedFraction(0, 798); [EOL]       Fraction fraction1 = fraction0.add(fraction0); [EOL]       assertSame(fraction1, fraction0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer("AEhzPmLst|m|:e7J{Z"); [EOL]       standardToStringStyle0.SHORT_PREFIX_STYLE.appendFieldSeparator(stringBuffer0); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtStart()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtEnd()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SIMPLE_STYLE.setContentEnd((String) null); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtEnd()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testStop() { [EOL] String appName = "example-app"; [EOL] try { [EOL] int result = asc.actionStop(appName); [EOL] assertEquals(EXIT_SUCCESS, result); [EOL] } catch (IOException | YarnException e) { [EOL] fail(); [EOL] } [EOL] } [EOL] private static ApiServiceClient asc; [EOL] private static ApiServiceClient badAsc; [EOL] private static Server server; [EOL]
@Test(timeout = 4000) [EOL]   public void testor()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[5]; [EOL]       booleanArray0[0] = true; [EOL]       boolean boolean0 = BooleanUtils.or(booleanArray0); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmin()  throws Throwable  { [EOL]       double double0 = NumberUtils.min(0.0, 784.9377, 784.9377); [EOL]       assertEquals(0.0, double0, 0.01); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testInvalidUri() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] String responseStr = ""; [EOL] try { [EOL] responseStr = [EOL] r.path("ws").path("v1").path("applicationhistory").path("bogus") [EOL] .queryParam("user.name", USERS[round]) [EOL] .accept(MediaType.APPLICATION_JSON).get(String.class); [EOL] fail("should have thrown exception on invalid uri"); [EOL] } catch (UniformInterfaceException ue) { [EOL] ClientResponse response = ue.getResponse(); [EOL] assertResponseStatusCode(Status.NOT_FOUND, response.getStatusInfo()); [EOL] [EOL] WebServicesTestUtils.checkStringMatch( [EOL] "error string exists and shouldn't", "", responseStr); [EOL] } [EOL] } [EOL] private static ApplicationHistoryClientService historyClientService; [EOL] private static AHSWebServices ahsWebservice; [EOL] private static final String[] USERS = new String[] { "foo" , "bar" }; [EOL] private static final int MAX_APPS = 6; [EOL] private static Configuration conf; [EOL] private static FileSystem fs; [EOL] private static final String remoteLogRootDir = "target/logs/"; [EOL] private static final String rootLogDir = "target/LocalLogs"; [EOL] private static final String NM_WEBADDRESS = "test-nm-web-address:9999"; [EOL] private static final String NM_ID = "test:1234"; [EOL] private int round; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       byte[] byteArray0 = new byte[9]; [EOL]       compareToBuilder0.append((byte[]) null, byteArray0); [EOL]       assertEquals((-1), compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDeviceStateNumberTooHigh() throws IOException { [EOL] createVeSlotFile(0); [EOL] createOsStateFile(5); [EOL] when(mockCommandExecutor.getOutput()) [EOL] .thenReturn("8:1:character special file"); [EOL] when(udevUtil.getSysPath(anyInt(), anyChar())).thenReturn(testFolder); [EOL] [EOL] Set<Device> devices = discoverer.getDevicesFromPath(testFolder); [EOL] [EOL] assertEquals("Number of devices", 1, devices.size()); [EOL] Device device = devices.iterator().next(); [EOL] assertEquals("Device ID", 0, device.getId()); [EOL] assertEquals("Major number", 8, device.getMajorNumber()); [EOL] assertEquals("Minor number", 1, device.getMinorNumber()); [EOL] assertEquals("Status", "Unknown (5)", device.getStatus()); [EOL] assertFalse("Device should not be healthy", device.isHealthy()); [EOL] } [EOL] private static final Comparator<Device> DEVICE_COMPARATOR = [EOL] Comparator.comparingInt(Device::getId); [EOL] @Rule [EOL] public ExpectedException expected = ExpectedException.none(); [EOL] @Mock [EOL] private UdevUtil udevUtil; [EOL] @Mock [EOL] private CommandExecutor mockCommandExecutor; [EOL] private String testFolder; [EOL] private VEDeviceDiscoverer discoverer; [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.splitMatcher(); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.stringMatcher(""); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.stringMatcher("M?]bESD_=n"); [EOL]        [EOL]       int int0 = strBuilder0.indexOf(strMatcher0, 0); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       int int1 = strBuilder0.indexOf(strMatcher0); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       int int2 = (-65); [EOL]       String string0 = strBuilder0.midString(62, (-65)); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln((-2266.992F)); [EOL]       assertEquals(10, strBuilder0.size()); [EOL]       assertEquals(10, strBuilder1.size()); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.insert((-1), 62); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       assertEquals(0, compareToBuilder0.toComparison()); [EOL]        [EOL]       Object[] objectArray0 = new Object[6]; [EOL]       Object[] objectArray1 = new Object[3]; [EOL]       Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       compareToBuilder0.append(objectArray0, objectArray1, comparator0); [EOL]       assertEquals(1, compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       Object object0 = new Object(); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       compareToBuilder0.append((Object) null, object0, comparator0); [EOL]       char[] charArray0 = new char[9]; [EOL]       compareToBuilder0.append(charArray0, charArray0); [EOL]       assertEquals((-1), compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetUserFromPath() throws Exception { [EOL] assertEquals("bob", RegistryPathUtils [EOL] .getUsername("/registry/users/bob/services/yarn-service/test1/")); [EOL] assertEquals("bob-dev", RegistryPathUtils [EOL] .getUsername("/registry/users/bob-dev/services/yarn-service/test1")); [EOL] assertEquals("bob.dev", RegistryPathUtils [EOL] .getUsername("/registry/users/bob.dev/services/yarn-service/test1")); [EOL] } [EOL] public static final String EURO = "\u20AC"; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.capitalize("Supplied value must be a valid byte literal between -32768 and 32767: ["); [EOL]        [EOL]       int int0 = StringUtils.indexOf((CharSequence) "Supplied value must be a valid byte literal between -32768 and 32767: [", 392); [EOL]        [EOL]       String[] stringArray0 = StringUtils.splitByWholeSeparator("The Array must not be null", "Supplied value must be a valid byte literal between -32768 and 32767: ["); [EOL]        [EOL]       char[] charArray0 = new char[5]; [EOL]       charArray0[0] = '|'; [EOL]       charArray0[1] = '/'; [EOL]       charArray0[2] = ','; [EOL]       charArray0[3] = 'B'; [EOL]       charArray0[4] = 'b'; [EOL]       boolean boolean0 = StringUtils.containsOnly((CharSequence) "Supplied value must be a valid byte literal between -32768 and 32767: [", charArray0); [EOL]        [EOL]       String string1 = StringUtils.abbreviate("\r", 392, 392); [EOL]       assertFalse(string1.equals((Object)string0)); [EOL]        [EOL]       String string2 = StringUtils.replaceChars("R\"?33Lrbm5Y?s", "Minimum abbreviation width with offset is 7", "Supplied value must be a valid byte literal between -32768 and 32767: ["); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]       assertFalse(string2.equals((Object)string1)); [EOL]        [EOL]       int int1 = StringUtils.indexOfAnyBut((CharSequence) "Supplied value must be a valid byte literal between -32768 and 32767: [", (CharSequence) "Supplied value must be a valid byte literal between -32768 and 32767: ["); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitPreserveAllTokens("R\"?33Llvl5Y? "); [EOL]       assertFalse(stringArray1.equals((Object)stringArray0)); [EOL]        [EOL]       String string3 = StringUtils.strip((String) null, "_iVq9-<w--D+?HoA~d"); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoBoolean()  throws Throwable  { [EOL]       Boolean boolean0 = BooleanUtils.toBooleanObject((String) null, (String) null, (String) null, (String) null); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       BasicThreadFactory.Builder basicThreadFactory_Builder0 = new BasicThreadFactory.Builder(); [EOL]       BasicThreadFactory.Builder basicThreadFactory_Builder1 = basicThreadFactory_Builder0.priority(594); [EOL]       BasicThreadFactory basicThreadFactory0 = basicThreadFactory_Builder1.build(); [EOL]       Integer integer0 = basicThreadFactory0.getPriority(); [EOL]       assertEquals(594, (int)integer0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNotEquals() { [EOL] Path path1 = new Path("path1"); [EOL] Path path2 = new Path("path2"); [EOL] FileStatus fileStatus1 = new FileStatus(1, true, 1, 1, 1, 1, [EOL] FsPermission.valueOf("-rw-rw-rw-"), "one", "one", null, path1); [EOL] FileStatus fileStatus2 = new FileStatus(1, true, 1, 1, 1, 1, [EOL] FsPermission.valueOf("-rw-rw-rw-"), "one", "one", null, path2); [EOL] assertFalse(fileStatus1.equals(fileStatus2)); [EOL] assertFalse(fileStatus2.equals(fileStatus1)); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFileStatus.class); [EOL] static final int LENGTH = 1; [EOL] static final int REPLICATION = 2; [EOL] static final long BLKSIZE = 3; [EOL] static final long MTIME = 4; [EOL] static final long ATIME = 5; [EOL] static final String OWNER = "owner"; [EOL] static final String GROUP = "group"; [EOL] static final FsPermission PERMISSION = FsPermission.valueOf("-rw-rw-rw-"); [EOL] static final Path PATH = new Path("path"); [EOL]
@Test [EOL] public void testSymlinkFileAlreadyExists() throws IOException { [EOL] File file = new File(del, FILE); [EOL] File link = new File(del, "_link"); [EOL] [EOL] // Create a symbolic link [EOL] // The operation should succeed [EOL] int result1 = [EOL] FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath()); [EOL] [EOL] Assert.assertEquals(0, result1); [EOL] [EOL] // Create the same symbolic link [EOL] // The operation should fail and returns 1 [EOL] result1 = FileUtil.symLink(file.getAbsolutePath(), link.getAbsolutePath()); [EOL] [EOL] Assert.assertEquals(1, result1); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test [EOL] public void testMixPeriodicAndNonPeriodic() throws PlanningException { [EOL] int[] alloc = { 2, 5, 0 }; [EOL] long[] timeSteps = { 1L, 2L, 3L }; [EOL] RLESparseResourceAllocation tempPeriodic = ReservationSystemTestUtil [EOL] .generateRLESparseResourceAllocation(alloc, timeSteps); [EOL] PeriodicRLESparseResourceAllocation periodic = [EOL] new PeriodicRLESparseResourceAllocation(tempPeriodic, 10L); [EOL] [EOL] int[] alloc2 = { 10, 10, 0 }; [EOL] long[] timeSteps2 = { 12L, 13L, 14L }; [EOL] RLESparseResourceAllocation nonPeriodic = ReservationSystemTestUtil [EOL] .generateRLESparseResourceAllocation(alloc2, timeSteps2); [EOL] [EOL] RLESparseResourceAllocation merged = [EOL] RLESparseResourceAllocation.merge(nonPeriodic.getResourceCalculator(), [EOL] Resource.newInstance(100 * 1024, 100), periodic, nonPeriodic, [EOL] RLESparseResourceAllocation.RLEOperator.add, 2, 25); [EOL] [EOL] Assert.assertEquals(Resource.newInstance(5, 5), [EOL] merged.getCapacityAtTime(2L)); [EOL] Assert.assertEquals(Resource.newInstance(0, 0), [EOL] merged.getCapacityAtTime(3L)); [EOL] Assert.assertEquals(Resource.newInstance(2, 2), [EOL] merged.getCapacityAtTime(11L)); [EOL] Assert.assertEquals(Resource.newInstance(15, 15), [EOL] merged.getCapacityAtTime(12L)); [EOL] Assert.assertEquals(Resource.newInstance(10, 10), [EOL] merged.getCapacityAtTime(13L)); [EOL] Assert.assertEquals(Resource.newInstance(0, 0), [EOL] merged.getCapacityAtTime(14L)); [EOL] Assert.assertEquals(Resource.newInstance(2, 2), [EOL] merged.getCapacityAtTime(21L)); [EOL] Assert.assertEquals(Resource.newInstance(5, 5), [EOL] merged.getCapacityAtTime(22L)); [EOL] Assert.assertEquals(Resource.newInstance(0, 0), [EOL] merged.getCapacityAtTime(23L)); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestPeriodicRLESparseResourceAllocation.class); [EOL]
@Test(timeout=300000) [EOL] public void testBalancerWithRamDisk() throws Exception { [EOL] final int SEED = 0xFADED; [EOL] final short REPL_FACT = 1; [EOL] Configuration conf = new Configuration(); [EOL] [EOL] final int defaultRamDiskCapacity = 10; [EOL] final long ramDiskStorageLimit = [EOL] ((long) defaultRamDiskCapacity * DEFAULT_RAM_DISK_BLOCK_SIZE) + [EOL] (DEFAULT_RAM_DISK_BLOCK_SIZE - 1); [EOL] final long diskStorageLimit = [EOL] ((long) defaultRamDiskCapacity * DEFAULT_RAM_DISK_BLOCK_SIZE) + [EOL] (DEFAULT_RAM_DISK_BLOCK_SIZE - 1); [EOL] [EOL] initConfWithRamDisk(conf, ramDiskStorageLimit); [EOL] [EOL] cluster = new MiniDFSCluster [EOL] .Builder(conf) [EOL] .numDataNodes(1) [EOL] .storageCapacities(new long[] { ramDiskStorageLimit, diskStorageLimit }) [EOL] .storageTypes(new StorageType[] { RAM_DISK, DEFAULT }) [EOL] .build(); [EOL] [EOL] cluster.waitActive(); [EOL] // Create few files on RAM_DISK [EOL] final String METHOD_NAME = GenericTestUtils.getMethodName(); [EOL] final Path path1 = new Path("/" + METHOD_NAME + ".01.dat"); [EOL] final Path path2 = new Path("/" + METHOD_NAME + ".02.dat"); [EOL] [EOL] DistributedFileSystem fs = cluster.getFileSystem(); [EOL] DFSClient client = fs.getClient(); [EOL] DFSTestUtil.createFile(fs, path1, true, [EOL] DEFAULT_RAM_DISK_BLOCK_SIZE, 4 * DEFAULT_RAM_DISK_BLOCK_SIZE, [EOL] DEFAULT_RAM_DISK_BLOCK_SIZE, REPL_FACT, SEED, true); [EOL] DFSTestUtil.createFile(fs, path2, true, [EOL] DEFAULT_RAM_DISK_BLOCK_SIZE, 1 * DEFAULT_RAM_DISK_BLOCK_SIZE, [EOL] DEFAULT_RAM_DISK_BLOCK_SIZE, REPL_FACT, SEED, true); [EOL] [EOL] // Sleep for a short time to allow the lazy writer thread to do its job [EOL] Thread.sleep(6 * 1000); [EOL] [EOL] // Add another fresh DN with the same type/capacity without files on RAM_DISK [EOL] StorageType[][] storageTypes = new StorageType[][] {{RAM_DISK, DEFAULT}}; [EOL] long[][] storageCapacities = new long[][]{{ramDiskStorageLimit, [EOL] diskStorageLimit}}; [EOL] cluster.startDataNodes(conf, REPL_FACT, storageTypes, true, null, [EOL] null, null, storageCapacities, null, false, false, false, null); [EOL] [EOL] cluster.triggerHeartbeats(); [EOL] Collection<URI> namenodes = DFSUtil.getInternalNsRpcUris(conf); [EOL] [EOL] // Run Balancer [EOL] final BalancerParameters p = BalancerParameters.DEFAULT; [EOL] final int r = Balancer.run(namenodes, p, conf); [EOL] [EOL] // Validate no RAM_DISK block should be moved [EOL] assertEquals(ExitStatus.NO_MOVE_PROGRESS.getExitCode(), r); [EOL] [EOL] // Verify files are still on RAM_DISK [EOL] DFSTestUtil.verifyFileReplicasOnStorageType(fs, client, path1, RAM_DISK); [EOL] DFSTestUtil.verifyFileReplicasOnStorageType(fs, client, path2, RAM_DISK); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestBalancer.class); [EOL] final static long CAPACITY = 5000L; [EOL] final static String RACK0 = "/rack0"; [EOL] final static String RACK1 = "/rack1"; [EOL] final static String RACK2 = "/rack2"; [EOL] final private static String fileName = "/tmp.txt"; [EOL] final static Path filePath = new Path(fileName); [EOL] final static private String username = "balancer"; [EOL] private static String principal; [EOL] private static File baseDir; [EOL] private static String keystoresDir; [EOL] private static String sslConfDir; [EOL] private static MiniKdc kdc; [EOL] private static File keytabFile; [EOL] private MiniDFSCluster cluster; [EOL] private AtomicInteger numGetBlocksCalls; [EOL] private AtomicLong startGetBlocksTime; [EOL] private AtomicLong endGetBlocksTime; [EOL] ClientProtocol client; [EOL] static final long TIMEOUT = 40000L; [EOL] static final double CAPACITY_ALLOWED_VARIANCE = 0.005; [EOL] static final double BALANCE_ALLOWED_VARIANCE = 0.11; [EOL] static final int DEFAULT_BLOCK_SIZE = 100; [EOL] static final int DEFAULT_RAM_DISK_BLOCK_SIZE = 5 * 1024 * 1024; [EOL] private static final Random r = new Random(); [EOL] private final ErasureCodingPolicy ecPolicy = [EOL] StripedFileTestUtil.getDefaultECPolicy(); [EOL] private final int dataBlocks = ecPolicy.getNumDataUnits(); [EOL] private final int parityBlocks = ecPolicy.getNumParityUnits(); [EOL] private final int groupSize = dataBlocks + parityBlocks; [EOL] private final int cellSize = ecPolicy.getCellSize(); [EOL] private final int stripesPerBlock = 4; [EOL] private final int defaultBlockSize = cellSize * stripesPerBlock; [EOL]
@Test public void testFields() { [EOL] MyMetrics metrics = new MyMetrics(); [EOL] MetricsSource source = MetricsAnnotations.makeSource(metrics); [EOL] [EOL] metrics.c1.incr(); [EOL] metrics.c2.incr(); [EOL] metrics.g1.incr(); [EOL] metrics.g2.incr(); [EOL] metrics.g3.incr(); [EOL] metrics.g4.incr(); [EOL] metrics.r1.add(1); [EOL] metrics.s1.add(1); [EOL] metrics.rs1.add("rs1", 1); [EOL] [EOL] MetricsRecordBuilder rb = getMetrics(source); [EOL] [EOL] verify(rb).addCounter(info("C1", "C1"), 1); [EOL] verify(rb).addCounter(info("Counter2", "Counter2 desc"), 1L); [EOL] verify(rb).addGauge(info("G1", "G1"), 1); [EOL] verify(rb).addGauge(info("G2", "G2"), 1); [EOL] verify(rb).addGauge(info("G3", "g3 desc"), 1L); [EOL] verify(rb).addGauge(info("G4", "g4 desc"), 1f); [EOL] verify(rb).addCounter(info("R1NumOps", "Number of ops for r1"), 1L); [EOL] verify(rb).addGauge(info("R1AvgTime", "Average time for r1"), 1.0); [EOL] verify(rb).addCounter(info("S1NumOps", "Number of ops for s1"), 1L); [EOL] verify(rb).addGauge(info("S1AvgTime", "Average time for s1"), 1.0); [EOL] verify(rb).addCounter(info("Rs1NumOps", "Number of ops for rs1"), 1L); [EOL] verify(rb).addGauge(info("Rs1AvgTime", "Average time for rs1"), 1.0); [EOL] } [EOL]
@Test [EOL] public void testGet() { [EOL] Path path = new Path("/path"); [EOL] PathMetadata pathMeta1 = new PathMetadata( [EOL] new S3AFileStatus(true, new Path(path, "dir1"), TEST_OWNER)); [EOL] PathMetadata pathMeta2 = new PathMetadata( [EOL] new S3AFileStatus(true, new Path(path, "dir2"), TEST_OWNER)); [EOL] PathMetadata pathMeta3 = new PathMetadata( [EOL] new S3AFileStatus(123, 456, new Path(path, "file1"), 8192, TEST_OWNER, [EOL] TEST_ETAG, TEST_VERSION_ID)); [EOL] List<PathMetadata> listing = Arrays.asList(pathMeta1, pathMeta2, pathMeta3); [EOL] DirListingMetadata meta = new DirListingMetadata(path, listing, false); [EOL] assertEquals(path, meta.getPath()); [EOL] assertNotNull(meta.getListing()); [EOL] assertFalse(meta.getListing().isEmpty()); [EOL] assertTrue(meta.getListing().contains(pathMeta1)); [EOL] assertTrue(meta.getListing().contains(pathMeta2)); [EOL] assertTrue(meta.getListing().contains(pathMeta3)); [EOL] assertFalse(meta.isAuthoritative()); [EOL] assertEquals(pathMeta1, meta.get(pathMeta1.getFileStatus().getPath())); [EOL] assertEquals(pathMeta2, meta.get(pathMeta2.getFileStatus().getPath())); [EOL] assertEquals(pathMeta3, meta.get(pathMeta3.getFileStatus().getPath())); [EOL] assertNull(meta.get(new Path(path, "notfound"))); [EOL] } [EOL] private static final String TEST_OWNER = "hadoop"; [EOL] public static final String TEST_ETAG = "abc"; [EOL] public static final String TEST_VERSION_ID = "def"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testregionMatches()  throws Throwable  { [EOL]       char[] charArray0 = new char[9]; [EOL]       charArray0[1] = '|'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       boolean boolean0 = CharSequenceUtils.regionMatches(charBuffer0, false, 0, charBuffer0, 1, '|'); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       BasicThreadFactory.Builder basicThreadFactory_Builder0 = new BasicThreadFactory.Builder(); [EOL]       BasicThreadFactory basicThreadFactory0 = basicThreadFactory_Builder0.build(); [EOL]       Boolean boolean0 = basicThreadFactory0.getDaemonFlag(); [EOL]       assertNull(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetCopyFilterNonExistingClass() throws Exception { [EOL] final String filterName = [EOL] "org.apache.hadoop.tools.RegexpInConfigurationWrongFilter"; [EOL] Configuration configuration = new Configuration(false); [EOL] configuration.set(DistCpConstants.CONF_LABEL_FILTERS_CLASS, filterName); [EOL] intercept(RuntimeException.class, [EOL] DistCpConstants.CLASS_INSTANTIATION_ERROR_MSG + filterName, [EOL] () -> CopyFilter.getCopyFilter(configuration)); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens((String) null, "nStj ,MSo4WS`=."); [EOL]        [EOL]       boolean boolean0 = StringUtils.containsOnly((CharSequence) "nStj ,MSo4WS`=.", (String) null); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitByCharacterType("g"); [EOL]       assertEquals(1, stringArray1.length); [EOL]        [EOL]       String string0 = StringUtils.swapCase(""); [EOL]        [EOL]       String string1 = StringUtils.replaceChars("Y-#fu$T?im", ':', 'z'); [EOL]        [EOL]       String[] stringArray2 = StringUtils.split("Y-#fu$T?im"); [EOL]       assertEquals(1, stringArray2.length); [EOL]        [EOL]       String string2 = StringUtils.substring("", 0, 32); [EOL]        [EOL]       float[] floatArray0 = new float[0]; [EOL]       String string3 = StringUtils.join(floatArray0, 'L'); [EOL]       assertEquals(0, floatArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetFieldNameValueSeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]       standardToStringStyle0.appendCyclicObject(stringBuffer0, (String) null, stringBuffer0); [EOL]       assertEquals("=", standardToStringStyle0.getFieldNameValueSeparator()); [EOL]   } [EOL]  [EOL]
@Test [EOL] 	public void testTN_BPEL4WSProcessTModel() throws WSDLException, JAXBException, Exception { [EOL] [EOL] 		// Obtained from the .bpel file: [EOL] 		String targetNamespace = "http://example.com/travelagent"; [EOL] 		QName serviceName = new QName (targetNamespace, "ReservationAndBookingTickets"); [EOL] 		String bpelOverViewUrl = "http://localhost/registry/" + serviceName.getLocalPart() + ".bpel"; [EOL] 		 [EOL] 		// Reading the WSDL [EOL] 		Definition wsdlDefinition = rw.readWSDL("bpel/bpel-technote.wsdl"); [EOL] 		 [EOL] 	 @SuppressWarnings("unchecked") [EOL] 		Map<QName,PortType> portTypes= (Map<QName,PortType>) wsdlDefinition.getAllPortTypes(); [EOL] 	 TModel bpel4WSTModel = bpel2UDDI.createBPEL4WSProcessTModel(serviceName, targetNamespace, portTypes, bpelOverViewUrl); [EOL] 	 [EOL] 		System.out.println("***** BPEL4WS Process TModel: " + bpel4WSTModel.getName().getValue()); [EOL] if (serialize) [EOL] 		System.out.println(pTModel.print(bpel4WSTModel)); [EOL] 		 [EOL] 		Assert.assertNotNull(bpel4WSTModel); [EOL] 	} [EOL] static BPEL2UDDI bpel2UDDI; [EOL] PrintUDDI<TModel> pTModel = new PrintUDDI<TModel>(); [EOL] PrintUDDI<FindTModel> pFindTModel = new PrintUDDI<FindTModel>(); [EOL] PrintUDDI<BindingTemplate> pBinding = new PrintUDDI<BindingTemplate>(); [EOL] ReadWSDL rw = new ReadWSDL(); [EOL] static boolean serialize=false; [EOL]
@Test [EOL] public void testCompareTo() throws IOException { [EOL] Path path1 = new Path("path1"); [EOL] Path path2 = new Path("path2"); [EOL] FileStatus fileStatus1 = [EOL] new FileStatus(1, true, 1, 1, 1, 1, FsPermission.valueOf("-rw-rw-rw-"), [EOL] "one", "one", null, path1); [EOL] FileStatus fileStatus2 = [EOL] new FileStatus(1, true, 1, 1, 1, 1, FsPermission.valueOf("-rw-rw-rw-"), [EOL] "one", "one", null, path2); [EOL] assertTrue(fileStatus1.compareTo(fileStatus2) < 0); [EOL] assertTrue(fileStatus2.compareTo(fileStatus1) > 0); [EOL] [EOL] List<FileStatus> statList = new ArrayList<>(); [EOL] statList.add(fileStatus1); [EOL] statList.add(fileStatus2); [EOL] assertTrue(Collections.binarySearch(statList, fileStatus1) > -1); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFileStatus.class); [EOL] static final int LENGTH = 1; [EOL] static final int REPLICATION = 2; [EOL] static final long BLKSIZE = 3; [EOL] static final long MTIME = 4; [EOL] static final long ATIME = 5; [EOL] static final String OWNER = "owner"; [EOL] static final String GROUP = "group"; [EOL] static final FsPermission PERMISSION = FsPermission.valueOf("-rw-rw-rw-"); [EOL] static final Path PATH = new Path("path"); [EOL]
@Test(timeout = 4000) [EOL]   public void testmark()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln((long) 0); [EOL]        [EOL]       Reader reader0 = strBuilder1.asReader(); [EOL]       assertTrue(reader0.markSupported()); [EOL]        [EOL]       char[] charArray0 = strBuilder0.toCharArray(0, 0); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendNull(); [EOL]        [EOL]       ArrayList<Object> arrayList0 = new ArrayList<Object>(); [EOL]        [EOL]       boolean boolean0 = arrayList0.add((Object) "org.apache.commons.lang3.text.StrBuilder$StrBuilderReader"); [EOL]        [EOL]       ListIterator<Object> listIterator0 = arrayList0.listIterator(); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.appendWithSeparators((Iterator<?>) listIterator0, ""); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.minimizeCapacity(); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) ""; [EOL]       objectArray0[1] = (Object) ""; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder4.new StrBuilderTokenizer(); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer1 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.clone(); [EOL]        [EOL]       objectArray0[3] = (Object) strBuilder_StrBuilderTokenizer1; [EOL]       StrBuilder strBuilder5 = strBuilder0.appendWithSeparators(objectArray0, "\u0005~t3<ZfA9n`W0/IY"); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testof()  throws Throwable  { [EOL]       Integer integer0 = new Integer(36); [EOL]       ImmutableTriple<Object, Integer, String> immutableTriple0 = ImmutableTriple.of((Object) "", integer0, (String) null); [EOL]       Object object0 = immutableTriple0.getLeft(); [EOL]       assertEquals("", object0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 60000) [EOL] public void testFifoScheduling() throws Exception { [EOL] GenericTestUtils.setRootLogLevel(Level.DEBUG); [EOL] MockRM rm = new MockRM(conf); [EOL] rm.start(); [EOL] MockNM nm1 = rm.registerNode("127.0.0.1:1234", 6 * GB); [EOL] MockNM nm2 = rm.registerNode("127.0.0.2:5678", 4 * GB); [EOL] [EOL] RMApp app1 = MockRMAppSubmitter.submitWithMemory(2048, rm); [EOL] // kick the scheduling, 2 GB given to AM1, remaining 4GB on nm1 [EOL] nm1.nodeHeartbeat(true); [EOL] RMAppAttempt attempt1 = app1.getCurrentAppAttempt(); [EOL] MockAM am1 = rm.sendAMLaunched(attempt1.getAppAttemptId()); [EOL] am1.registerAppAttempt(); [EOL] SchedulerNodeReport report_nm1 = [EOL] rm.getResourceScheduler().getNodeReport(nm1.getNodeId()); [EOL] Assert.assertEquals(2 * GB, report_nm1.getUsedResource().getMemorySize()); [EOL] [EOL] RMApp app2 = MockRMAppSubmitter.submitWithMemory(2048, rm); [EOL] // kick the scheduling, 2GB given to AM, remaining 2 GB on nm2 [EOL] nm2.nodeHeartbeat(true); [EOL] RMAppAttempt attempt2 = app2.getCurrentAppAttempt(); [EOL] MockAM am2 = rm.sendAMLaunched(attempt2.getAppAttemptId()); [EOL] am2.registerAppAttempt(); [EOL] SchedulerNodeReport report_nm2 = [EOL] rm.getResourceScheduler().getNodeReport(nm2.getNodeId()); [EOL] Assert.assertEquals(2 * GB, report_nm2.getUsedResource().getMemorySize()); [EOL] [EOL] // add request for containers [EOL] am1.addRequests(new String[] { "127.0.0.1", "127.0.0.2" }, GB, 1, 1); [EOL] AllocateResponse alloc1Response = am1.schedule(); // send the request [EOL] // add request for containers [EOL] am2.addRequests(new String[] { "127.0.0.1", "127.0.0.2" }, 3 * GB, 0, 1); [EOL] AllocateResponse alloc2Response = am2.schedule(); // send the request [EOL] [EOL] // kick the scheduler, 1 GB and 3 GB given to AM1 and AM2, remaining 0 [EOL] nm1.nodeHeartbeat(true); [EOL] while (alloc1Response.getAllocatedContainers().size() < 1) { [EOL] LOG.info("Waiting for containers to be created for app 1..."); [EOL] Thread.sleep(1000); [EOL] alloc1Response = am1.schedule(); [EOL] } [EOL] while (alloc2Response.getAllocatedContainers().size() < 1) { [EOL] LOG.info("Waiting for containers to be created for app 2..."); [EOL] Thread.sleep(1000); [EOL] alloc2Response = am2.schedule(); [EOL] } [EOL] // kick the scheduler, nothing given remaining 2 GB. [EOL] nm2.nodeHeartbeat(true); [EOL] [EOL] List<Container> allocated1 = alloc1Response.getAllocatedContainers(); [EOL] Assert.assertEquals(1, allocated1.size()); [EOL] Assert.assertEquals(1 * GB, allocated1.get(0).getResource().getMemorySize()); [EOL] Assert.assertEquals(nm1.getNodeId(), allocated1.get(0).getNodeId()); [EOL] [EOL] List<Container> allocated2 = alloc2Response.getAllocatedContainers(); [EOL] Assert.assertEquals(1, allocated2.size()); [EOL] Assert.assertEquals(3 * GB, allocated2.get(0).getResource().getMemorySize()); [EOL] Assert.assertEquals(nm1.getNodeId(), allocated2.get(0).getNodeId()); [EOL] [EOL] report_nm1 = rm.getResourceScheduler().getNodeReport(nm1.getNodeId()); [EOL] report_nm2 = rm.getResourceScheduler().getNodeReport(nm2.getNodeId()); [EOL] Assert.assertEquals(0, report_nm1.getAvailableResource().getMemorySize()); [EOL] Assert.assertEquals(2 * GB, report_nm2.getAvailableResource().getMemorySize()); [EOL] [EOL] Assert.assertEquals(6 * GB, report_nm1.getUsedResource().getMemorySize()); [EOL] Assert.assertEquals(2 * GB, report_nm2.getUsedResource().getMemorySize()); [EOL] [EOL] Container c1 = allocated1.get(0); [EOL] Assert.assertEquals(GB, c1.getResource().getMemorySize()); [EOL] ContainerStatus containerStatus = [EOL] BuilderUtils.newContainerStatus(c1.getId(), ContainerState.COMPLETE, [EOL] "", 0, c1.getResource()); [EOL] nm1.containerStatus(containerStatus); [EOL] int waitCount = 0; [EOL] while (attempt1.getJustFinishedContainers().size() < 1 && waitCount++ != 20) { [EOL] LOG.info("Waiting for containers to be finished for app 1... Tried " [EOL] + waitCount + " times already.."); [EOL] Thread.sleep(1000); [EOL] } [EOL] Assert.assertEquals(1, attempt1.getJustFinishedContainers().size()); [EOL] Assert.assertEquals(1, am1.schedule().getCompletedContainersStatuses() [EOL] .size()); [EOL] report_nm1 = rm.getResourceScheduler().getNodeReport(nm1.getNodeId()); [EOL] Assert.assertEquals(5 * GB, report_nm1.getUsedResource().getMemorySize()); [EOL] [EOL] rm.stop(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFifoScheduler.class); [EOL] private final int GB = 1024; [EOL] private ResourceManager resourceManager = null; [EOL] private static Configuration conf; [EOL] private static final RecordFactory recordFactory = [EOL] RecordFactoryProvider.getRecordFactory(null); [EOL] private final static ContainerUpdates NULL_UPDATE_REQUESTS = [EOL] new ContainerUpdates(); [EOL]
@Test [EOL] public void testGetContainerReport() throws YarnException, IOException { [EOL] ClientRMService rmService = createRMService(); [EOL] RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null); [EOL] GetContainerReportRequest request = recordFactory [EOL] .newRecordInstance(GetContainerReportRequest.class); [EOL] ApplicationAttemptId attemptId = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(123456, 1), 1); [EOL] ContainerId containerId = ContainerId.newContainerId(attemptId, 1); [EOL] request.setContainerId(containerId); [EOL] [EOL] try { [EOL] GetContainerReportResponse response = rmService [EOL] .getContainerReport(request); [EOL] Assert.assertEquals(containerId, response.getContainerReport() [EOL] .getContainerId()); [EOL] } catch (ApplicationNotFoundException ex) { [EOL] Assert.fail(ex.getMessage()); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestClientRMService.class); [EOL] private RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private String appType = "MockApp"; [EOL] private final static String QUEUE_1 = "Q-1"; [EOL] private final static String QUEUE_2 = "Q-2"; [EOL] private final static String APPLICATION_TAG_SC_PREPROCESSOR ="mytag:foo"; [EOL] private File resourceTypesFile = null; [EOL]
@Test [EOL] public void testGetDomains() throws IOException { [EOL] super.testGetDomains(); [EOL] } [EOL] private FileContext fsContext; [EOL] private File fsPath; [EOL] private Configuration config = new YarnConfiguration(); [EOL]
@Test [EOL] public void testRelativizeOneLevel() { [EOL] String suffix = "year=2017"; [EOL] Path path = new Path(DATA + suffix); [EOL] assertEquals(suffix, getRelativePath(BASE, path)); [EOL] } [EOL] private static final String DATA = "s3a://landsat-pds/data/"; [EOL] private static final Path BASE = new Path(DATA); [EOL]
@Test [EOL] public void testSerializeKV() throws IOException { [EOL] final DataOutputStream dataOut = Mockito.mock(DataOutputStream.class); [EOL] [EOL] Mockito.when(dataOut.hasUnFlushedData()).thenReturn(true); [EOL] Mockito.when(dataOut.shortOfSpace(key.length + value.length + [EOL] Constants.SIZEOF_KV_LENGTH)).thenReturn(true); [EOL] final int written = serializer.serializeKV(dataOut, key, value); [EOL] [EOL] // flush once, write 4 int, and 2 byte array [EOL] Mockito.verify(dataOut, Mockito.times(1)).flush(); [EOL] Mockito.verify(dataOut, Mockito.times(4)).writeInt(anyInt()); [EOL] Mockito.verify(dataOut, Mockito.times(2)).write(any(byte[].class), [EOL] anyInt(), anyInt()); [EOL] [EOL] Assert.assertEquals(written, key.length + value.length + Constants.SIZEOF_KV_LENGTH); [EOL] } [EOL] int inputArraySize = 1000; [EOL] int bufferSize = 100; [EOL] private KV<BytesWritable, BytesWritable>[] inputArray; [EOL] final ByteArrayOutputStream result = new ByteArrayOutputStream(); [EOL] private SizedWritable key; [EOL] private SizedWritable value; [EOL] private KVSerializer serializer; [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveElements()  throws Throwable  { [EOL]       short[] shortArray0 = new short[0]; [EOL]       short[] shortArray1 = ArrayUtils.removeElements(shortArray0, shortArray0); [EOL]       assertArrayEquals(new short[] {}, shortArray1); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testset()  throws Throwable  { [EOL]       MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(2, (-113), 1, 2, (-451), 3725); [EOL]       DateUtils.iterator((Calendar) mockGregorianCalendar0, 3); [EOL]       assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62401465735000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=0,YEAR=9,MONTH=6,WEEK_OF_YEAR=31,WEEK_OF_MONTH=5,DAY_OF_MONTH=31,DAY_OF_YEAR=213,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=5,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,MINUTE=31,SECOND=5,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", mockGregorianCalendar0.toString()); [EOL]   } [EOL] } [EOL]
@Test [EOL] public void testNonSecureRunAsSubmitter() throws Exception { [EOL] Assume.assumeTrue(shouldRun()); [EOL] Assume.assumeFalse(UserGroupInformation.isSecurityEnabled()); [EOL] String expectedRunAsUser = appSubmitter; [EOL] conf.set(YarnConfiguration.NM_NONSECURE_MODE_LIMIT_USERS, "false"); [EOL] exec.setConf(conf); [EOL] File touchFile = new File(workSpace, "touch-file"); [EOL] int ret = runAndBlock("touch", touchFile.getAbsolutePath()); [EOL] [EOL] assertEquals(0, ret); [EOL] FileStatus fileStatus = [EOL] FileContext.getLocalFSFileContext().getFileStatus( [EOL] new Path(touchFile.getAbsolutePath())); [EOL] assertEquals(expectedRunAsUser, fileStatus.getOwner()); [EOL] cleanupAppFiles(expectedRunAsUser); [EOL] // reset conf [EOL] conf.unset(YarnConfiguration.NM_NONSECURE_MODE_LIMIT_USERS); [EOL] exec.setConf(conf); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLinuxContainerExecutor.class); [EOL] private static File workSpace; [EOL] private LinuxContainerExecutor exec = null; [EOL] private String appSubmitter = null; [EOL] private LocalDirsHandlerService dirsHandler; [EOL] private Configuration conf; [EOL] private FileContext files; [EOL] private int id = 0; [EOL]
@Test [EOL] public void processPathDirOrderDefaultReverse() throws IOException { [EOL] TestFile testfile01 = new TestFile("testDirectory", "testFile01"); [EOL] TestFile testfile02 = new TestFile("testDirectory", "testFile02"); [EOL] TestFile testfile03 = new TestFile("testDirectory", "testFile03"); [EOL] TestFile testfile04 = new TestFile("testDirectory", "testFile04"); [EOL] TestFile testfile05 = new TestFile("testDirectory", "testFile05"); [EOL] TestFile testfile06 = new TestFile("testDirectory", "testFile06"); [EOL] [EOL] TestFile testDir = new TestFile("", "testDirectory"); [EOL] testDir.setIsDir(true); [EOL] // add contents in non-lexigraphic order to show they get sorted [EOL] testDir.addContents(testfile01, testfile03, testfile05, testfile02, [EOL] testfile04, testfile06); [EOL] [EOL] LinkedList<PathData> pathData = new LinkedList<PathData>(); [EOL] pathData.add(testDir.getPathData()); [EOL] [EOL] PrintStream out = mock(PrintStream.class); [EOL] [EOL] Ls ls = new Ls(); [EOL] ls.out = out; [EOL] [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] options.add("-r"); [EOL] ls.processOptions(options); [EOL] String lineFormat = TestFile.computeLineFormat(pathData); [EOL] [EOL] ls.processArguments(pathData); [EOL] InOrder inOrder = inOrder(out); [EOL] inOrder.verify(out).println("Found 6 items"); [EOL] inOrder.verify(out).println(testfile06.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile05.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile04.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile03.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile02.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile01.formatLineMtime(lineFormat)); [EOL] verifyNoMoreInteractions(out); [EOL] } [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static final Date NOW = new Date(); [EOL]
@Test(timeout = 4000) [EOL]   public void testwrap()  throws Throwable  { [EOL]       String string0 = WordUtils.wrap("wil!RZ_<1#D", (-1125), (String) null, true); [EOL]       assertEquals("w\ni\nl\n!\nR\nZ\n_\n<\n1\n#\nD", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testaddYears()  throws Throwable  { [EOL]       MockDate mockDate0 = new MockDate(362L); [EOL]       Date date0 = DateUtils.addYears(mockDate0, 4); [EOL]       assertEquals("Thu Jan 01 00:00:00 GMT 1970", date0.toString()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testTopologySchedulingPerformanceWithPackPolicyWithNVLink() [EOL] throws Exception { [EOL] NvidiaGPUPluginForRuntimeV2 plugin = mockEightGPUPlugin(); [EOL] NvidiaGPUPluginForRuntimeV2 spyPlugin = spy(plugin); [EOL] Set<Device> allDevices = spyPlugin.getDevices(); [EOL] Map<String, String> env = new HashMap<>(); [EOL] env.put(NvidiaGPUPluginForRuntimeV2.TOPOLOGY_POLICY_ENV_KEY, [EOL] NvidiaGPUPluginForRuntimeV2.TOPOLOGY_POLICY_PACK); [EOL] [EOL] /** [EOL] * Analyze performance against the real data. [EOL] * Get the topology scheduling algorithm's allocation's [EOL] * average performance boost against median imagePerSecond and minimum [EOL] * imagePerSecond in certain model and batch size combinations. [EOL] * And then calculate the average performance boost. [EOL] * The average performance boost against [EOL] * median value means topology scheduler's allocation can stably [EOL] * outperforms 50% of possible allocations. [EOL] * The average performance boost against min value means the average boost [EOL] * comparing to the worst allocations in various scenarios. Which is more [EOL] * beautiful number for public promotion. [EOL] * And also the analysis shows the best performance boost against median [EOL] * and min value. [EOL] * */ [EOL] ActualPerformanceReport report = new ActualPerformanceReport(); [EOL] report.readFromFile(); [EOL] ArrayList<ActualPerformanceReport.DataRecord> dataSet = [EOL] report.getDataSet(); [EOL] assertThat(dataSet).hasSize(2952); [EOL] String[] allModels = {"alexnet", "resnet50", "vgg16", "inception3"}; [EOL] int[] batchSizes = {32, 64, 128}; [EOL] int[] gpuCounts = {2, 3, 4, 5, 6, 7}; [EOL] float totalBoostAgainstMedian = 0; [EOL] int count = 0; [EOL] float maxBoostAgainstMedian = 0; [EOL] float totalBoostAgainstMin = 0; [EOL] float maxBoostAgainstMin = 0; [EOL] for (String model : allModels) { [EOL] float totalBoostAgainstMinCertainModel = 0; [EOL] float totalBoostAgainstMedianCertainModel = 0; [EOL] float maxBoostAgainstMinCertainModel = 0; [EOL] float maxBoostAgainstMedianCertainModel = 0; [EOL] int countOfEachModel = 0; [EOL] for (int bs : batchSizes) { [EOL] for (int gpuCount: gpuCounts) { [EOL] float bstAgainstMedian = calculatePerformanceBoostAgainstMedian( [EOL] report, model, bs, gpuCount, plugin, allDevices, env); [EOL] float bstAgainstMinimum = calculatePerformanceBoostAgainstMinimum( [EOL] report, model, bs, gpuCount, plugin, allDevices, env); [EOL] totalBoostAgainstMedian += bstAgainstMedian; [EOL] totalBoostAgainstMin += bstAgainstMinimum; [EOL] count++; [EOL] if (maxBoostAgainstMedian < bstAgainstMedian) { [EOL] maxBoostAgainstMedian = bstAgainstMedian; [EOL] } [EOL] if (maxBoostAgainstMin < bstAgainstMinimum) { [EOL] maxBoostAgainstMin = bstAgainstMinimum; [EOL] } [EOL] totalBoostAgainstMinCertainModel += bstAgainstMinimum; [EOL] totalBoostAgainstMedianCertainModel += bstAgainstMedian; [EOL] if (maxBoostAgainstMinCertainModel < bstAgainstMinimum) { [EOL] maxBoostAgainstMinCertainModel = bstAgainstMinimum; [EOL] } [EOL] if (maxBoostAgainstMedianCertainModel < bstAgainstMedian) { [EOL] maxBoostAgainstMedianCertainModel = bstAgainstMedian; [EOL] } [EOL] countOfEachModel++; [EOL] } [EOL] } [EOL] LOG.info("Model:{}, The best performance boost against median value is " [EOL] + "{}", model, maxBoostAgainstMedianCertainModel); [EOL] LOG.info("Model:{}, The aggregated average performance boost against " [EOL] + "median value is {}", [EOL] model, totalBoostAgainstMedianCertainModel/countOfEachModel); [EOL] LOG.info("Model:{}, The best performance boost against min value is {}", [EOL] model, maxBoostAgainstMinCertainModel); [EOL] LOG.info("Model:{}, The aggregated average performance boost against " [EOL] + "min value is {}", [EOL] model, totalBoostAgainstMinCertainModel/countOfEachModel); [EOL] } [EOL] LOG.info("For all, the best performance boost against median value is " [EOL] + maxBoostAgainstMedian); [EOL] LOG.info("For all, the aggregated average performance boost against median " [EOL] + "value is " + totalBoostAgainstMedian/count); [EOL] LOG.info("For all, the best performance boost against min value is " [EOL] + maxBoostAgainstMin); [EOL] LOG.info("For all, the aggregated average performance boost against min " [EOL] + "value is " + totalBoostAgainstMin/count); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestNvidiaGPUPluginForRuntimeV2.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testcontains()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]        [EOL]       Stack<StrBuilder> stack0 = new Stack<StrBuilder>(); [EOL]       assertFalse(stack0.contains(strBuilder0)); [EOL]        [EOL]       LinkedHashSet<StrBuilder> linkedHashSet0 = new LinkedHashSet<StrBuilder>(stack0); [EOL]       assertFalse(stack0.contains(strBuilder0)); [EOL]       assertFalse(linkedHashSet0.contains(strBuilder0)); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendAll((Iterable<?>) linkedHashSet0); [EOL]       assertFalse(stack0.contains(strBuilder1)); [EOL]       assertFalse(linkedHashSet0.contains(strBuilder1)); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator(""); [EOL]        [EOL]       int int0 = (-1); [EOL]       StringWriter stringWriter0 = null; [EOL]       try { [EOL]         stringWriter0 = new StringWriter((-1)); [EOL]         fail("Expecting exception: IllegalArgumentException"); [EOL]        [EOL]       } catch(IllegalArgumentException e) { [EOL]          // [EOL]          // Negative buffer size [EOL]          // [EOL]          verifyException("java.io.StringWriter", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testProxyUsersWithEmptyPrefix() throws Exception { [EOL] ProxyUsers.refreshSuperUserGroupsConfiguration(new Configuration(false), [EOL] ""); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestProxyUsers.class); [EOL] private static final String REAL_USER_NAME = "proxier"; [EOL] private static final String PROXY_USER_NAME = "proxied_user"; [EOL] private static final String AUTHORIZED_PROXY_USER_NAME = "authorized_proxied_user"; [EOL] private static final String[] GROUP_NAMES = [EOL] new String[] { "foo_group" }; [EOL] private static final String[] NETGROUP_NAMES = [EOL] new String[] { "@foo_group" }; [EOL] private static final String[] OTHER_GROUP_NAMES = [EOL] new String[] { "bar_group" }; [EOL] private static final String[] SUDO_GROUP_NAMES = [EOL] new String[] { "sudo_proxied_user" }; [EOL] private static final String PROXY_IP = "1.2.3.4"; [EOL] private static final String PROXY_IP_RANGE = "10.222.0.0/16,10.113.221.221"; [EOL]
@Test(timeout = 4000) [EOL]   public void testaddContextValue()  throws Throwable  { [EOL]       ContextedException contextedException0 = new ContextedException(); [EOL]       ContextedException contextedException1 = contextedException0.addContextValue("org.apache.commons.lang3.exception.ContextedException", "org.apache.commons.lang3.exception.ContextedException"); [EOL]       String string0 = contextedException1.getMessage(); [EOL]       assertNotNull(string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       TreeSet<DecimalFormatSymbols> treeSet0 = new TreeSet<DecimalFormatSymbols>(); [EOL]       TreeSet<DecimalFormatSymbols> treeSet1 = ObjectUtils.clone(treeSet0); [EOL]       assertTrue(treeSet1.equals((Object)treeSet0)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       int[] intArray0 = new int[6]; [EOL]       int int0 = ArrayUtils.indexOf(intArray0, 564, (-310)); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test(expected = AssertionError.class) [EOL] public void testGetCostBeforeInit() { [EOL] costProvider.getCost(null); [EOL] } [EOL] private static final int QUEUE_TIME = 3; [EOL] private static final int LOCKFREE_TIME = 5; [EOL] private static final int LOCKSHARED_TIME = 7; [EOL] private static final int LOCKEXCLUSIVE_TIME = 11; [EOL] private WeightedTimeCostProvider costProvider; [EOL] private ProcessingDetails processingDetails; [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((String) null); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       Object object0 = new Object(); [EOL]        [EOL]       objectArray0[0] = object0; [EOL]       objectArray0[1] = (Object) strBuilder0; [EOL]       objectArray0[2] = (Object) null; [EOL]       objectArray0[3] = (Object) null; [EOL]       objectArray0[4] = (Object) strBuilder0; [EOL]       objectArray0[5] = (Object) strBuilder0; [EOL]       objectArray0[6] = (Object) null; [EOL]       StrMatcher strMatcher0 = StrMatcher.splitMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "length must be valid"); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendWithSeparators(objectArray0, (String) null); [EOL]       assertEquals(360, strBuilder0.capacity()); [EOL]       assertEquals(360, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append((CharSequence) strBuilder0, 31, 31); [EOL]       assertEquals(360, strBuilder0.capacity()); [EOL]       assertEquals(360, strBuilder2.capacity()); [EOL]       assertEquals(360, strBuilder3.capacity()); [EOL]        [EOL]       Reader reader0 = strBuilder0.asReader(); [EOL]       assertEquals(360, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append(1L); [EOL]       assertEquals(360, strBuilder0.capacity()); [EOL]       assertEquals(360, strBuilder4.capacity()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       int int0 = (-334); [EOL]       StrBuilder strBuilder0 = new StrBuilder((-334)); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-334), 117, 'P'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       int int1 = strBuilder0.indexOf('P'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       strBuilder_StrBuilderReader0.close(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder(117); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         stringBuilder0.insert((-334), false); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -334 [EOL]          // [EOL]          verifyException("java.lang.AbstractStringBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetEntitiesByInfoFilters() throws Exception { [EOL] Client client = createClient(); [EOL] try { [EOL] URI uri = URI.create("http://localhost:" + serverPort + "/ws/v2/" + [EOL] "timeline/clusters/cluster1/apps/app1/entities/app?" + [EOL] "infofilters=info2%20eq%203.5"); [EOL] ClientResponse resp = getResponse(client, uri); [EOL] Set<TimelineEntity> entities = [EOL] resp.getEntity(new GenericType<Set<TimelineEntity>>(){}); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] resp.getType().toString()); [EOL] assertNotNull(entities); [EOL] assertEquals(1, entities.size()); [EOL] assertTrue("Entity with id_3 should have been present in response.", [EOL] entities.contains(newEntity("app", "id_3"))); [EOL] } finally { [EOL] client.destroy(); [EOL] } [EOL] } [EOL] private static final String ROOT_DIR = new File("target", [EOL] TestTimelineReaderWebServices.class.getSimpleName()).getAbsolutePath(); [EOL] private int serverPort; [EOL] private TimelineReaderServer server; [EOL]
@Test [EOL] public void testSetBandwidth() { [EOL] final DistCpOptions.Builder builder = new DistCpOptions.Builder( [EOL] Collections.singletonList(new Path("hdfs://localhost:8020/source")), [EOL] new Path("hdfs://localhost:8020/target/")); [EOL] Assert.assertEquals(0, builder.build().getMapBandwidth(), DELTA); [EOL] [EOL] builder.withMapBandwidth(11); [EOL] Assert.assertEquals(11, builder.build().getMapBandwidth(), DELTA); [EOL] } [EOL] private static final float DELTA = 0.001f; [EOL]
@Test [EOL] public void testShortNameShell() throws BadFencingConfigurationException { [EOL] NodeFencer fencer = setupFencer(getFencerTrueCommand()); [EOL] assertTrue(fencer.fence(MOCK_TARGET)); [EOL] } [EOL] private HAServiceTarget MOCK_TARGET; [EOL] private static String FENCER_TRUE_COMMAND_UNIX = "shell(true)"; [EOL] private static String FENCER_TRUE_COMMAND_WINDOWS = "shell(rem)"; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.join((int[]) null, 't', 0, 0); [EOL]        [EOL]       boolean boolean0 = StringUtils.isAllUpperCase((CharSequence) null); [EOL]        [EOL]       String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null, '{'); [EOL]        [EOL]       String string1 = StringUtils.stripEnd(":;6z", (String) null);6z", string1); [EOL]        [EOL]       String string2 = StringUtils.leftPad("RWSLzV4h", 0, ""); [EOL]        [EOL]       int int0 = StringUtils.lastIndexOf((CharSequence) ":;6z", (CharSequence) "RWSLzV4h", 0); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitByWholeSeparator("Nt{2P6~Pso'", ""); [EOL]       assertEquals(1, stringArray1.length); [EOL]        [EOL]       String string3 = StringUtils.join((float[]) null, 't', (-1520), 0); [EOL]        [EOL]       String string4 = StringUtils.defaultIfEmpty((String) null, ":;6z");6z", string4); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetMiddle()  throws Throwable  { [EOL]       Integer integer0 = new Integer(1); [EOL]       MutableTriple<Object, String, Object> mutableTriple0 = new MutableTriple<Object, String, Object>(integer0, "6@w7}8Hh/tF{\"6_z4:", (Object) null); [EOL]       String string0 = mutableTriple0.getMiddle(); [EOL]       assertEquals("6@w7}8Hh/tF{\"6_z4:", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testReverseLookup() throws Exception { [EOL] ServiceRecord record = getMarshal().fromBytes("somepath", [EOL] CONTAINER_RECORD.getBytes()); [EOL] getRegistryDNS().register( [EOL] "/registry/users/root/services/org-apache-slider/test1/components/" [EOL] + "ctr-e50-1451931954322-0016-01-000002", [EOL] record); [EOL] [EOL] // start assessing whether correct records are available [EOL] Record[] recs = assertDNSQuery("19.0.17.172.in-addr.arpa.", Type.PTR, 1); [EOL] assertEquals("wrong result", [EOL] "httpd-1.test1.root.dev.test.", [EOL] ((PTRRecord) recs[0]).getTarget().toString()); [EOL] } [EOL] private RegistryDNS registryDNS; [EOL] private RegistryUtils.ServiceRecordMarshal marshal; [EOL] private static final String APPLICATION_RECORD = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"Slider Application Master\",\n" [EOL] + " \"external\" : [ {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.appmaster.ipc" [EOL] + "\",\n" [EOL] + " \"addressType\" : \"host/port\",\n" [EOL] + " \"protocolType\" : \"hadoop/IPC\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"host\" : \"192.168.1.5\",\n" [EOL] + " \"port\" : \"1026\"\n" [EOL] + " } ]\n" [EOL] + " }, {\n" [EOL] + " \"api\" : \"http://\",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"webui\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"http://192.168.1.5:1027\"\n" [EOL] + " } ]\n" [EOL] + " }, {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.management\"" [EOL] + ",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"REST\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"http://192.168.1.5:1027/ws/v1/slider/mgmt\"\n" [EOL] + " } ]\n" [EOL] + " } ],\n" [EOL] + " \"internal\" : [ {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.agents.secure" [EOL] + "\",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"REST\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"https://192.168.1.5:47700/ws/v1/slider/agents\"\n" [EOL] + " } ]\n" [EOL] + " }, {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.agents.oneway" [EOL] + "\",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"REST\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"https://192.168.1.5:35531/ws/v1/slider/agents\"\n" [EOL] + " } ]\n" [EOL] + " } ],\n" [EOL] + " \"yarn:id\" : \"application_1451931954322_0016\",\n" [EOL] + " \"yarn:persistence\" : \"application\"\n" [EOL] + "}\n"; [EOL] static final String CONTAINER_RECORD = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-1\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000002\",\n" [EOL] + " \"yarn:persistence\" : \"container\",\n" [EOL] + " \"yarn:ip\" : \"172.17.0.19\",\n" [EOL] + " \"yarn:hostname\" : \"host1\",\n" [EOL] + " \"yarn:component\" : \"httpd\"\n" [EOL] + "}\n"; [EOL] static final String CONTAINER_RECORD2 = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-2\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000003\",\n" [EOL] + " \"yarn:persistence\" : \"container\",\n" [EOL] + " \"yarn:ip\" : \"172.17.0.20\",\n" [EOL] + " \"yarn:hostname\" : \"host2\",\n" [EOL] + " \"yarn:component\" : \"httpd\"\n" [EOL] + "}\n"; [EOL] private static final String CONTAINER_RECORD_NO_IP = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-1\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000002\",\n" [EOL] + " \"yarn:persistence\" : \"container\",\n" [EOL] + " \"yarn:component\" : \"httpd\"\n" [EOL] + "}\n"; [EOL] private static final String CONTAINER_RECORD_YARN_PERSISTANCE_ABSENT = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-1\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000003\",\n" [EOL] + " \"yarn:ip\" : \"172.17.0.19\",\n" [EOL] + " \"yarn:hostname\" : \"0a134d6329bb\",\n" [EOL] + " \"yarn:component\" : \"httpd\"" [EOL] + "}\n"; [EOL]
@Test(timeout = 4000) [EOL]   public void testmin()  throws Throwable  { [EOL]       long[] longArray0 = new long[2]; [EOL]       longArray0[0] = 511L; [EOL]       longArray0[1] = 708L; [EOL]       long long0 = NumberUtils.min(longArray0); [EOL]       assertEquals(511L, long0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.isEmpty(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       String string0 = strBuilder0.midString(34, (-1)); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator(">R<{"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.ensureCapacity(34); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[7]; [EOL]       charArray0[0] = 'K'; [EOL]       charArray0[1] = 'S'; [EOL]       charArray0[2] = 'L'; [EOL]       charArray0[3] = 'x'; [EOL]       charArray0[4] = '`'; [EOL]       charArray0[5] = '^'; [EOL]       charArray0[6] = 'V'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.getChars(3889, 0, charArray0, (-1)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]        [EOL]       char[] charArray0 = new char[18]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       assertEquals(18, charBuffer0.capacity()); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]       assertEquals(18, charBuffer0.capacity()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]       assertEquals(50, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]       assertEquals(0, charBuffer1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]       assertEquals(50, strBuilder4.capacity()); [EOL]        [EOL]       String string0 = strBuilder4.leftString((-1)); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]       assertEquals(50, strBuilder4.capacity()); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(false); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder5.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", (-1)); [EOL]       assertEquals(32, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder6.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]       assertEquals(50, strBuilder0.capacity()); [EOL]       assertEquals(50, strBuilder4.capacity()); [EOL]       assertEquals(50, strBuilder7.capacity()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void prettifyException() { [EOL] [EOL] String pretty = AdminHelper.prettifyException( [EOL] new IllegalArgumentException("Something is wrong", [EOL] new IllegalArgumentException("Something is illegal"))); [EOL] [EOL] Assert.assertEquals( [EOL] "IllegalArgumentException: Something is wrong", [EOL] pretty); [EOL] [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       boolean[] booleanArray0 = new boolean[8]; [EOL]       CompareToBuilder compareToBuilder1 = compareToBuilder0.append(booleanArray0, booleanArray0); [EOL]       assertEquals(0, compareToBuilder1.toComparison()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       int int0 = 0; [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0); [EOL]        [EOL]       int int1 = 924; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendFixedWidthPadLeft(0, 924, 'y'); [EOL]        [EOL]       boolean boolean0 = strBuilder0.contains((String) null); [EOL]        [EOL]       char char0 = '8'; [EOL]       int int2 = strBuilder0.indexOf('8'); [EOL]        [EOL]       StrBuilder strBuilder3 = new StrBuilder((String) null); [EOL]       assertFalse(strBuilder3.equals((Object)strBuilder0)); [EOL]       assertFalse(strBuilder3.equals((Object)strBuilder2)); [EOL]       assertFalse(strBuilder3.equals((Object)strBuilder1)); [EOL]        [EOL]       StringBuffer stringBuffer0 = null; [EOL]       try { [EOL]         stringBuffer0 = new StringBuffer((CharSequence) null); [EOL]         fail("Expecting exception: NullPointerException"); [EOL]        [EOL]       } catch(NullPointerException e) { [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testinitialize()  throws Throwable  { [EOL]       Callable<String> callable0 = (Callable<String>) mock(Callable.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn((Object) null, (Object) null).when(callable0).call(); [EOL]       CallableBackgroundInitializer<String> callableBackgroundInitializer0 = new CallableBackgroundInitializer<String>(callable0); [EOL]       callableBackgroundInitializer0.getTaskCount(); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.initialize(); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.get(); [EOL]       assertTrue(callableBackgroundInitializer0.isStarted()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNetgroups () throws IOException{ [EOL] [EOL] if(!NativeCodeLoader.isNativeCodeLoaded()) { [EOL] LOG.info("Not testing netgroups, " + [EOL] "this test only runs when native code is compiled"); [EOL] return; [EOL] } [EOL] [EOL] String groupMappingClassName = [EOL] System.getProperty("TestProxyUsersGroupMapping"); [EOL] [EOL] if(groupMappingClassName == null) { [EOL] LOG.info("Not testing netgroups, no group mapping class specified, " + [EOL] "use -DTestProxyUsersGroupMapping=$className to specify " + [EOL] "group mapping class (must implement GroupMappingServiceProvider " + [EOL] "interface and support netgroups)"); [EOL] return; [EOL] } [EOL] [EOL] LOG.info("Testing netgroups using: " + groupMappingClassName); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_GROUP_MAPPING, [EOL] groupMappingClassName); [EOL] [EOL] conf.set( [EOL] DefaultImpersonationProvider.getTestProvider(). [EOL] getProxySuperuserGroupConfKey(REAL_USER_NAME), [EOL] StringUtils.join(",", Arrays.asList(NETGROUP_NAMES))); [EOL] conf.set( [EOL] DefaultImpersonationProvider.getTestProvider(). [EOL] getProxySuperuserIpConfKey(REAL_USER_NAME), [EOL] PROXY_IP); [EOL] [EOL] ProxyUsers.refreshSuperUserGroupsConfiguration(conf); [EOL] Groups groups = Groups.getUserToGroupsMappingService(conf); [EOL] [EOL] // try proxying a group that's allowed [EOL] UserGroupInformation realUserUgi = UserGroupInformation [EOL] .createRemoteUser(REAL_USER_NAME); [EOL] [EOL] UserGroupInformation proxyUserUgi = UserGroupInformation.createProxyUserForTesting( [EOL] PROXY_USER_NAME, realUserUgi, groups.getGroups(PROXY_USER_NAME).toArray( [EOL] new String[groups.getGroups(PROXY_USER_NAME).size()])); [EOL] [EOL] assertAuthorized(proxyUserUgi, PROXY_IP); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestProxyUsers.class); [EOL] private static final String REAL_USER_NAME = "proxier"; [EOL] private static final String PROXY_USER_NAME = "proxied_user"; [EOL] private static final String AUTHORIZED_PROXY_USER_NAME = "authorized_proxied_user"; [EOL] private static final String[] GROUP_NAMES = [EOL] new String[] { "foo_group" }; [EOL] private static final String[] NETGROUP_NAMES = [EOL] new String[] { "@foo_group" }; [EOL] private static final String[] OTHER_GROUP_NAMES = [EOL] new String[] { "bar_group" }; [EOL] private static final String[] SUDO_GROUP_NAMES = [EOL] new String[] { "sudo_proxied_user" }; [EOL] private static final String PROXY_IP = "1.2.3.4"; [EOL] private static final String PROXY_IP_RANGE = "10.222.0.0/16,10.113.221.221"; [EOL]
@Test [EOL] public void testConfWithMultipleOpts() throws Exception { [EOL] String[] args = new String[2]; [EOL] args[0] = "--conf=foo"; [EOL] args[1] = "--conf=bar"; [EOL] GenericOptionsParser g = new GenericOptionsParser(args); [EOL] assertEquals("1st conf param is incorrect", [EOL] "foo", g.getCommandLine().getOptionValues("conf")[0]); [EOL] assertEquals("2st conf param is incorrect", [EOL] "bar", g.getCommandLine().getOptionValues("conf")[1]); [EOL] } [EOL] File testDir; [EOL] Configuration conf; [EOL] FileSystem localFs; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNumerator()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getFraction(3421, 3421); [EOL]       int int0 = fraction0.intValue(); [EOL]       assertEquals(3421, fraction0.getNumerator()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testBuildContainerLaunchCommand() throws Exception { [EOL] AbstractProviderService providerService = new DockerProviderService(); [EOL] Component component = serviceContext.scheduler.getAllComponents().entrySet() [EOL] .iterator().next().getValue(); [EOL] ContainerLaunchService.ComponentLaunchContext clc = [EOL] createEntryPointCLCFor(testService, component, "sleep,9000"); [EOL] [EOL] ComponentInstance instance = component.getAllComponentInstances().iterator() [EOL] .next(); [EOL] Container container = mock(Container.class); [EOL] providerService.buildContainerLaunchCommand(launcher, testService, instance, [EOL] rule.getFs(), serviceContext.scheduler.getConfig(), container, clc, [EOL] null); [EOL] [EOL] Assert.assertEquals("commands", Lists.newArrayList(clc.getLaunchCommand()), [EOL] launcher.getCommands()); [EOL] } [EOL] private ServiceContext serviceContext; [EOL] private Service testService; [EOL] private AbstractLauncher launcher; [EOL] @Rule [EOL] public ServiceTestUtils.ServiceFSWatcher rule = [EOL] new ServiceTestUtils.ServiceFSWatcher(); [EOL]
@Test [EOL] public void testDefaultDnsServer() throws Exception { [EOL] String host = DNS.getDefaultHost(getLoopbackInterface(), DEFAULT); [EOL] assertThat(host, is(DNS.getDefaultHost(getLoopbackInterface()))); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestDNS.class); [EOL] private static final String DEFAULT = "default"; [EOL] private static final String DUMMY_HOSTNAME = "-DUMMY_HOSTNAME"; [EOL] private static final String INVALID_DNS_SERVER = "0.0.0.0"; [EOL]
@Test [EOL] public void testGetAllTaskTypes() { [EOL] assertEquals("The getAllTaskTypes method did not return the expected " [EOL] + "string", "(m|r|s|c|t)", TaskID.getAllTaskTypes()); [EOL] } [EOL]
@Test [EOL] public void testSetMaxShare() { [EOL] FSQueueMetrics metrics = setupMetrics(RESOURCE_NAME); [EOL] [EOL] Resource res = Resource.newInstance(2048L, 4, ImmutableMap.of(RESOURCE_NAME, [EOL] 20L)); [EOL] metrics.setMaxShare(res); [EOL] [EOL] assertEquals(getErrorMessage("maxShareMB"), [EOL] 2048L, metrics.getMaxShareMB()); [EOL] assertEquals(getErrorMessage("maxShareVcores"), [EOL] 4L, metrics.getMaxShareVirtualCores()); [EOL] assertEquals(getErrorMessage("maxShareMB"), [EOL] 2048L, metrics.getMaxShare().getMemorySize()); [EOL] assertEquals(getErrorMessage("maxShareVcores"), [EOL] 4L, metrics.getMaxShare().getVirtualCores()); [EOL] assertEquals(getErrorMessage("maxShare for resource: " + RESOURCE_NAME), [EOL] 20L, metrics.getMaxShare().getResourceValue(RESOURCE_NAME)); [EOL] [EOL] res = Resource.newInstance(2049L, 5); [EOL] metrics.setMaxShare(res); [EOL] [EOL] assertEquals(getErrorMessage("maxShareMB"), [EOL] 2049L, metrics.getMaxShareMB()); [EOL] assertEquals(getErrorMessage("maxShareVcores"), [EOL] 5L, metrics.getMaxShareVirtualCores()); [EOL] assertEquals(getErrorMessage("maxShareMB"), [EOL] 2049L, metrics.getMaxShare().getMemorySize()); [EOL] assertEquals(getErrorMessage("maxShareVcores"), [EOL] 5L, metrics.getMaxShare().getVirtualCores()); [EOL] assertEquals(getErrorMessage("maxShare for resource: " + RESOURCE_NAME), [EOL] 0, metrics.getMaxShare().getResourceValue(RESOURCE_NAME)); [EOL] } [EOL] private static final Configuration CONF = new Configuration(); [EOL] private MetricsSystem ms; [EOL] private static final String RESOURCE_NAME = "test1"; [EOL] private static final String QUEUE_NAME = "single"; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       int int0 = 0; [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer("':EFAEb.O7[9#R/\"[V"); [EOL]        [EOL]       StringBuffer stringBuffer1 = stringBuffer0.delete(0, 0); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(stringBuffer0); [EOL]        [EOL]       int int1 = strBuilder0.indexOf("x,OEdUuh6_<", 0); [EOL]        [EOL]       Locale.Category locale_Category0 = Locale.Category.DISPLAY; [EOL]       Locale.Category locale_Category1 = Locale.Category.FORMAT; [EOL]       EnumSet<Locale.Category> enumSet0 = EnumSet.of(locale_Category0, locale_Category0, locale_Category0, locale_Category1); [EOL]       assertFalse(locale_Category0.equals((Object)locale_Category1)); [EOL]       assertFalse(locale_Category1.equals((Object)locale_Category0)); [EOL]        [EOL]       Iterator<Locale.Category> iterator0 = enumSet0.iterator(); [EOL]       assertFalse(locale_Category0.equals((Object)locale_Category1)); [EOL]       assertFalse(locale_Category1.equals((Object)locale_Category0)); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.appendWithSeparators(iterator0, "x,OEdUuh6_<"); [EOL]       assertFalse(locale_Category0.equals((Object)locale_Category1)); [EOL]       assertFalse(locale_Category1.equals((Object)locale_Category0)); [EOL]        [EOL]       String string0 = ""; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.insert((-1), ""); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetFieldNameValueSeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getFieldSeparator(); [EOL]       assertEquals("=", standardToStringStyle0.getFieldNameValueSeparator()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testparseObject()  throws Throwable  { [EOL]       FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(); [EOL]       ParsePosition parsePosition0 = new ParsePosition(0); [EOL]       Object object0 = fastDateFormat0.parseObject("1/1/70 12:00 AM", parsePosition0); [EOL]       assertEquals("Fri Feb 14 20:21:21 GMT 2014", object0.toString()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testHashcode() { [EOL] [EOL] // Different pools, same block id -> different hashcode [EOL] assertNotEquals( [EOL] new ExtendedBlock(POOL_A, BLOCK_1_GS1).hashCode(), [EOL] new ExtendedBlock(POOL_B, BLOCK_1_GS1).hashCode()); [EOL] [EOL] // Same pool, different block id -> different hashcode [EOL] assertNotEquals( [EOL] new ExtendedBlock(POOL_A, BLOCK_1_GS1).hashCode(), [EOL] new ExtendedBlock(POOL_A, BLOCK_2_GS1).hashCode()); [EOL] [EOL] // Same block -> same hashcode [EOL] assertEquals( [EOL] new ExtendedBlock(POOL_A, BLOCK_1_GS1).hashCode(), [EOL] new ExtendedBlock(POOL_A, BLOCK_1_GS1).hashCode()); [EOL] [EOL] } [EOL] static final String POOL_A = "blockpool-a"; [EOL] static final String POOL_B = "blockpool-b"; [EOL] static final Block BLOCK_1_GS1 = new Block(1L, 100L, 1L); [EOL] static final Block BLOCK_1_GS2 = new Block(1L, 100L, 2L); [EOL] static final Block BLOCK_2_GS1 = new Block(2L, 100L, 1L); [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       int int0 = (-4136); [EOL]       StrBuilder strBuilder0 = new StrBuilder((-4136)); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher(); [EOL]        [EOL]       int int1 = strBuilder0.indexOf((StrMatcher) strMatcher_NoMatcher0, (-4136)); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append((Object) "_D]5>#kw<b6p@SuO"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       Writer writer0 = strBuilder1.asWriter(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.replaceAll("", ""); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       String string0 = strBuilder2.midString((-4136), (-4136)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append(true); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder3.substring((-730), 938); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -730 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testOverCapacityImbalance() { [EOL] int[][] qData = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 55, 45, 0 }, // used [EOL] { 20, 10, 10, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 2, 1, 1, 0 }, // apps [EOL] { -1, 1, 1, 0 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData); [EOL] policy.editSchedule(); [EOL] // Will not preempt for over capacity queues [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appA))); [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       double[] doubleArray0 = new double[3]; [EOL]       int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-297.21217), (int) (byte)10); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       int int0 = 107; [EOL]       StrBuilder strBuilder0 = new StrBuilder(107); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       int int1 = 0; [EOL]       StrBuilder strBuilder1 = strBuilder0.insert(0, false); [EOL]       assertEquals(5, strBuilder0.length()); [EOL]       assertEquals(5, strBuilder1.length()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.trimMatcher(); [EOL]        [EOL]       char char0 = 'w'; [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher('w'); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(""); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       StrMatcher strMatcher3 = StrMatcher.charSetMatcher(charArray0); [EOL]       assertEquals(0, charArray0.length); [EOL]        [EOL]       int int2 = strBuilder0.indexOf(strMatcher0, (-2284)); [EOL]       assertEquals(5, strBuilder0.length()); [EOL]        [EOL]       IntStream intStream0 = strBuilder0.codePoints(); [EOL]       assertEquals(5, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln(289); [EOL]       assertEquals(9, strBuilder0.length()); [EOL]       assertEquals(9, strBuilder2.length()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.deleteAll(strMatcher1); [EOL]       assertEquals(9, strBuilder0.length()); [EOL]       assertEquals(9, strBuilder3.length()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.deleteCharAt(1027); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 1027 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNullCheckGetEntityTimelines() throws Exception { [EOL] try { [EOL] store.getEntityTimelines("YARN_APPLICATION", null, null, null, null, [EOL] null); [EOL] } catch (NullPointerException e) { [EOL] Assert.fail("NPE when getEntityTimelines called with Null EntityIds"); [EOL] } [EOL] } [EOL] private static final String SAMPLE_APP_PREFIX_CACHE_TEST = "1234_000"; [EOL] private static final int CACHE_TEST_CACHE_SIZE = 5; [EOL] private static final String TEST_SUMMARY_LOG_FILE_NAME [EOL] = EntityGroupFSTimelineStore.SUMMARY_LOG_PREFIX + "test"; [EOL] private static final String TEST_DOMAIN_LOG_FILE_NAME [EOL] = EntityGroupFSTimelineStore.DOMAIN_LOG_PREFIX + "test"; [EOL] private static final Path TEST_ROOT_DIR [EOL] = new Path(System.getProperty("test.build.data", [EOL] System.getProperty("java.io.tmpdir")), [EOL] TestEntityGroupFSTimelineStore.class.getSimpleName()); [EOL] private static Configuration config = new YarnConfiguration(); [EOL] private static MiniDFSCluster hdfsCluster; [EOL] private static FileSystem fs; [EOL] private static FileContext fc; [EOL] private static FileContextTestHelper fileContextTestHelper = [EOL] new FileContextTestHelper("/tmp/TestEntityGroupFSTimelineStore"); [EOL] private static List<ApplicationId> sampleAppIds; [EOL] private static ApplicationId mainTestAppId; [EOL] private static Path mainTestAppDirPath; [EOL] private static Path testDoneDirPath; [EOL] private static Path testActiveDirPath; [EOL] private static String mainEntityLogFileName; [EOL] private EntityGroupFSTimelineStore store; [EOL] private TimelineEntity entityNew; [EOL] @Rule [EOL] public TestName currTestName = new TestName(); [EOL] private File rootDir; [EOL] private File testJar; [EOL]
@Test [EOL] public void testStateStoreUnavailable() throws IOException { [EOL] curatorFramework.close(); [EOL] testingServer.stop(); [EOL] router.getStateStore().stop(); [EOL] // The driver is not ready [EOL] assertFalse(router.getStateStore().isDriverReady()); [EOL] [EOL] // Do a heartbeat, and no exception thrown out [EOL] RouterHeartbeatService heartbeatService = [EOL] new RouterHeartbeatService(router); [EOL] heartbeatService.updateStateStore(); [EOL] } [EOL] private Router router; [EOL] private final String routerId = "router1"; [EOL] private TestingServer testingServer; [EOL] private CuratorFramework curatorFramework; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.normalizeSpace(" "); [EOL]        [EOL]       String string1 = StringUtils.abbreviate("The Array must not be null", 10); [EOL]        [EOL]       String string2 = StringUtils.repeat('', 0); [EOL]        [EOL]       String[] stringArray0 = StringUtils.splitPreserveAllTokens("", ""); [EOL]       assertEquals(0, stringArray0.length); [EOL]        [EOL]       String string3 = "\\u00"; [EOL]       String string4 = StringUtils.lowerCase(string3); [EOL]        [EOL]       String string5 = StringUtils.overlay("dyfY", "t", (-437), (-452)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       assertEquals(0, (int)compareToBuilder0.build()); [EOL]        [EOL]       CompareToBuilder compareToBuilder1 = compareToBuilder0.append(0L, (-317L)); [EOL]       char[] charArray0 = new char[2]; [EOL]       compareToBuilder1.append(charArray0, charArray0); [EOL]       assertEquals(1, (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetHostFromPrincipal() { [EOL] assertEquals("host", [EOL] SecurityUtil.getHostFromPrincipal("service/host@realm")); [EOL] assertEquals(null, [EOL] SecurityUtil.getHostFromPrincipal("service@realm")); [EOL] } [EOL] private static final String ZK_AUTH_VALUE = "a_scheme:a_password"; [EOL]
@Test [EOL] public void testWriteStringsFileSystem() throws IOException { [EOL] URI uri = tmp.toURI(); [EOL] Configuration conf = new Configuration(); [EOL] FileSystem fs = FileSystem.get(uri, conf); [EOL] Path testPath = new Path(new Path(uri), "writestrings.out"); [EOL] [EOL] Collection<String> write = Arrays.asList("over", "the", "lazy", "dog"); [EOL] [EOL] FileUtil.write(fs, testPath, write, StandardCharsets.UTF_8); [EOL] [EOL] List<String> read = [EOL] FileUtils.readLines(new File(testPath.toUri()), StandardCharsets.UTF_8); [EOL] [EOL] assertEquals(write, read); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       char[] charArray0 = new char[6]; [EOL]       Long[] longArray0 = new Long[1]; [EOL]       Long long0 = new Long(0L); [EOL]       longArray0[0] = long0; [EOL]       long[] longArray1 = ArrayUtils.toPrimitive(longArray0, (long) charArray0[2]); [EOL]       assertEquals(1, longArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.contains('5'); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testgetBusinessListJSON() { [EOL] System.out.println("testgetBusinessListJSON"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] UriContainer expResult = null; [EOL] KeyBag serviceListXML = instance.getBusinessListJSON(); [EOL] Assert.assertNotNull(serviceListXML); [EOL] Assert.assertFalse(serviceListXML.getBusinessKey().isEmpty()); [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test [EOL] public void testSetMaxAMShare() { [EOL] FSQueueMetrics metrics = setupMetrics(RESOURCE_NAME); [EOL] [EOL] Resource res = Resource.newInstance(2048L, 4, ImmutableMap.of(RESOURCE_NAME, [EOL] 20L)); [EOL] metrics.setMaxAMShare(res); [EOL] [EOL] assertEquals(getErrorMessage("maxAMShareMB"), [EOL] 2048L, metrics.getMaxAMShareMB()); [EOL] assertEquals(getErrorMessage("maxAMShareVcores"), [EOL] 4L, metrics.getMaxAMShareVCores()); [EOL] assertEquals(getErrorMessage("maxAMShareMB"), [EOL] 2048L, metrics.getMaxAMShare().getMemorySize()); [EOL] assertEquals(getErrorMessage("maxAMShareVcores"), [EOL] 4L, metrics.getMaxAMShare().getVirtualCores()); [EOL] assertEquals(getErrorMessage( [EOL] "maxAMShare for resource: " + RESOURCE_NAME), [EOL] 20L, metrics.getMaxAMShare().getResourceValue(RESOURCE_NAME)); [EOL] [EOL] res = Resource.newInstance(2049L, 5); [EOL] metrics.setMaxAMShare(res); [EOL] [EOL] assertEquals(getErrorMessage("maxAMShareMB"), [EOL] 2049L, metrics.getMaxAMShareMB()); [EOL] assertEquals(getErrorMessage("maxAMShareVcores"), [EOL] 5L, metrics.getMaxAMShareVCores()); [EOL] assertEquals(getErrorMessage("maxAMShareMB"), [EOL] 2049L, metrics.getMaxAMShare().getMemorySize()); [EOL] assertEquals(getErrorMessage("maxAMShareVcores"), [EOL] 5L, metrics.getMaxAMShare().getVirtualCores()); [EOL] assertEquals(getErrorMessage( [EOL] "maxAMShare for resource: " + RESOURCE_NAME), [EOL] 0, metrics.getMaxAMShare().getResourceValue(RESOURCE_NAME)); [EOL] } [EOL] private static final Configuration CONF = new Configuration(); [EOL] private MetricsSystem ms; [EOL] private static final String RESOURCE_NAME = "test1"; [EOL] private static final String QUEUE_NAME = "single"; [EOL]
@Test [EOL] public void testGetLinkCount() throws IOException { [EOL] //at beginning of world, check that source files have link count "1" [EOL] //since they haven't been hardlinked yet [EOL] assertEquals(1, getLinkCount(x1)); [EOL] assertEquals(1, getLinkCount(x2)); [EOL] assertEquals(1, getLinkCount(x3)); [EOL] } [EOL] final static private File TEST_DIR = GenericTestUtils.getTestDir("test/hl"); [EOL] private static String DIR = "dir_"; [EOL] private static File src = new File(TEST_DIR, DIR + "src"); [EOL] private static File tgt_mult = new File(TEST_DIR, DIR + "tgt_mult"); [EOL] private static File tgt_one = new File(TEST_DIR, DIR + "tgt_one"); [EOL] private static File x1 = new File(src, "x1"); [EOL] private static File x2 = new File(src, "x2"); [EOL] private static File x3 = new File(src, "x3"); [EOL] private static File x1_one = new File(tgt_one, "x1"); [EOL] private static File y_one = new File(tgt_one, "y"); [EOL] private static File x3_one = new File(tgt_one, "x3"); [EOL] private static File x11_one = new File(tgt_one, "x11"); [EOL] private static File x1_mult = new File(tgt_mult, "x1"); [EOL] private static File x2_mult = new File(tgt_mult, "x2"); [EOL] private static File x3_mult = new File(tgt_mult, "x3"); [EOL] private static String str1 = "11111"; [EOL] private static String str2 = "22222"; [EOL] private static String str3 = "33333"; [EOL]
@Test(timeout=10000) [EOL] public void testInterruptOnDisk() throws Exception { [EOL] final int FETCHER = 7; [EOL] Path p = new Path("file:///tmp/foo"); [EOL] Path pTmp = OnDiskMapOutput.getTempPath(p, FETCHER); [EOL] FileSystem mFs = mock(FileSystem.class, RETURNS_DEEP_STUBS); [EOL] IFileWrappedMapOutput<Text,Text> odmo = [EOL] spy(new OnDiskMapOutput<Text,Text>(map1ID, mm, 100L, job, [EOL] FETCHER, true, mFs, p)); [EOL] when(mm.reserve(any(TaskAttemptID.class), anyLong(), anyInt())) [EOL] .thenReturn(odmo); [EOL] doNothing().when(mm).waitForResource(); [EOL] when(ss.getHost()).thenReturn(host); [EOL] [EOL] String replyHash = SecureShuffleUtils.generateHash(encHash.getBytes(), key); [EOL] when(connection.getResponseCode()).thenReturn(200); [EOL] when(connection.getHeaderField( [EOL] SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH)).thenReturn(replyHash); [EOL] ShuffleHeader header = new ShuffleHeader(map1ID.toString(), 10, 10, 1); [EOL] ByteArrayOutputStream bout = new ByteArrayOutputStream(); [EOL] header.write(new DataOutputStream(bout)); [EOL] final StuckInputStream in = [EOL] new StuckInputStream(new ByteArrayInputStream(bout.toByteArray())); [EOL] when(connection.getInputStream()).thenReturn(in); [EOL] when(connection.getHeaderField(ShuffleHeader.HTTP_HEADER_NAME)) [EOL] .thenReturn(ShuffleHeader.DEFAULT_HTTP_HEADER_NAME); [EOL] when(connection.getHeaderField(ShuffleHeader.HTTP_HEADER_VERSION)) [EOL] .thenReturn(ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION); [EOL] doAnswer(new Answer<Void>() { [EOL] public Void answer(InvocationOnMock ignore) throws IOException { [EOL] in.close(); [EOL] return null; [EOL] } [EOL] }).when(connection).disconnect(); [EOL] [EOL] Fetcher<Text,Text> underTest = new FakeFetcher<Text,Text>(job, id, ss, mm, [EOL] r, metrics, except, key, connection, FETCHER); [EOL] underTest.start(); [EOL] // wait for read in inputstream [EOL] in.waitForFetcher(); [EOL] underTest.shutDown(); [EOL] underTest.join(); // rely on test timeout to kill if stuck [EOL] [EOL] assertTrue(in.wasClosedProperly()); [EOL] verify(mFs).create(eq(pTmp)); [EOL] verify(mFs).delete(eq(pTmp), eq(false)); [EOL] verify(odmo).abort(); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFetcher.class); [EOL] JobConf job = null; [EOL] JobConf jobWithRetry = null; [EOL] TaskAttemptID id = null; [EOL] ShuffleSchedulerImpl<Text, Text> ss = null; [EOL] MergeManagerImpl<Text, Text> mm = null; [EOL] Reporter r = null; [EOL] ShuffleClientMetrics metrics = null; [EOL] ExceptionReporter except = null; [EOL] SecretKey key = null; [EOL] HttpURLConnection connection = null; [EOL] Counters.Counter allErrs = null; [EOL] final String encHash = "vFE234EIFCiBgYs2tCXY/SjT8Kg="; [EOL] final MapHost host = new MapHost("localhost", "http://localhost:8080/"); [EOL] final TaskAttemptID map1ID = TaskAttemptID.forName("attempt_0_1_m_1_1"); [EOL] final TaskAttemptID map2ID = TaskAttemptID.forName("attempt_0_1_m_2_1"); [EOL] FileSystem fs = null; [EOL] @Rule public TestName name = new TestName(); [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(false, false); [EOL]       byte[] byteArray0 = new byte[1]; [EOL]       byteArray0[0] = (byte) (-34); [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(byteArray0, byteArray0); [EOL]       float[] floatArray0 = new float[6]; [EOL]       floatArray0[0] = (float) (byte) (-34); [EOL]       floatArray0[1] = (float) (byte) (-34); [EOL]       floatArray0[2] = (float) (byte) (-34); [EOL]       floatArray0[3] = (float) (byte) (-34); [EOL]       floatArray0[4] = (float) (byte) (-34); [EOL]       floatArray0[5] = (float) (byte) (-34); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append((float[]) null, floatArray0); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append((float) (byte) (-34), (-1.0F)); [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append((double) (-34.0F), (double) (byte) (-34)); [EOL]       char[] charArray0 = new char[0]; [EOL]       EqualsBuilder equalsBuilder6 = equalsBuilder5.append(charArray0, charArray0); [EOL]       assertSame(equalsBuilder6, equalsBuilder5); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       long long0 = strBuilder_StrBuilderReader0.skip(0L); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseShortClassName()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       boolean boolean0 = standardToStringStyle0.isUseFieldNames(); [EOL]       assertFalse(standardToStringStyle0.isUseShortClassName()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testHdfsFileStatusWithEcPolicy() throws IOException { [EOL] final long now = Time.now(); [EOL] final String parent = "/dir"; [EOL] ErasureCodingPolicy dummyEcPolicy = new ErasureCodingPolicy("ecPolicy1", [EOL] new ECSchema("EcSchema", 1, 1), 1024 * 2, (byte) 1); [EOL] final HdfsFileStatus status = new HdfsFileStatus.Builder() [EOL] .length(1001L) [EOL] .replication(3) [EOL] .blocksize(1L << 26) [EOL] .mtime(now) [EOL] .atime(now + 10) [EOL] .perm(new FsPermission((short) 0644)) [EOL] .owner("user") [EOL] .group("group") [EOL] .symlink(DFSUtil.string2Bytes("bar")) [EOL] .path(DFSUtil.string2Bytes("foo")) [EOL] .fileId(HdfsConstants.GRANDFATHER_INODE_ID) [EOL] .ecPolicy(dummyEcPolicy) [EOL] .flags(EnumSet.allOf(Flags.class)) [EOL] .build(); [EOL] [EOL] final FileStatus fstatus = toFileStatus(status, parent); [EOL] System.out.println("status = " + status); [EOL] System.out.println("fstatus = " + fstatus); [EOL] final String json = JsonUtil.toJsonString(status, true); [EOL] System.out.println("json = " + json.replace(",", ",\n ")); [EOL] final HdfsFileStatus s2 = [EOL] JsonUtilClient.toFileStatus((Map<?, ?>) READER.readValue(json), true); [EOL] final FileStatus fs2 = toFileStatus(s2, parent); [EOL] System.out.println("s2 = " + s2); [EOL] System.out.println("fs2 = " + fs2); [EOL] Assert.assertEquals(status.getErasureCodingPolicy(), [EOL] s2.getErasureCodingPolicy()); [EOL] Assert.assertEquals(fstatus, fs2); [EOL] } [EOL] private static final ObjectReader READER = [EOL] new ObjectMapper().readerFor(Map.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(false, false); [EOL]       assertTrue(equalsBuilder1.build()); [EOL]        [EOL]       double[] doubleArray0 = new double[4]; [EOL]       doubleArray0[0] = 1.0; [EOL]       doubleArray0[1] = (-690.4802009552836); [EOL]       doubleArray0[2] = 765.3743487472304; [EOL]       doubleArray0[3] = 0.0; [EOL]       double[] doubleArray1 = new double[4]; [EOL]       doubleArray1[0] = 0.0; [EOL]       doubleArray1[1] = 0.0; [EOL]       doubleArray1[2] = (-690.4802009552836); [EOL]       doubleArray1[3] = 1.0; [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(doubleArray0, doubleArray1); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append((-690.4802009552836), (-1445.7440248)); [EOL]       Integer integer0 = new Integer((-4784)); [EOL]       EqualsBuilder.isRegistered(integer0, "]lEx>?>"); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append(1.1F, 1.1F); [EOL]       equalsBuilder4.append(406, 406); [EOL]       assertFalse(equalsBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNMAuditLoggerWithIP() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] RPC.setProtocolEngine(conf, TestRpcService.class, ProtobufRpcEngine2.class); [EOL] [EOL] // Create server side implementation [EOL] MyTestRPCServer serverImpl = new MyTestRPCServer(); [EOL] BlockingService service = TestRpcServiceProtos.TestProtobufRpcProto [EOL] .newReflectiveBlockingService(serverImpl); [EOL] [EOL] // start the IPC server [EOL] Server server = new RPC.Builder(conf) [EOL] .setProtocol(TestRpcBase.TestRpcService.class) [EOL] .setInstance(service).setBindAddress("0.0.0.0") [EOL] .setPort(0).setNumHandlers(5).setVerbose(true).build(); [EOL] [EOL] server.start(); [EOL] [EOL] InetSocketAddress addr = NetUtils.getConnectAddress(server); [EOL] [EOL] // Make a client connection and test the audit log [EOL] TestRpcService proxy = RPC.getProxy(TestRpcService.class, [EOL] TestProtocol.versionID, addr, conf); [EOL] // Start the testcase [EOL] TestProtos.EmptyRequestProto pingRequest = [EOL] TestProtos.EmptyRequestProto.newBuilder().build(); [EOL] proxy.ping(null, pingRequest); [EOL] [EOL] server.stop(); [EOL] RPC.stopProxy(proxy); [EOL] } [EOL] private static final String USER = "test"; [EOL] private static final String OPERATION = "oper"; [EOL] private static final String TARGET = "tgt"; [EOL] private static final String DESC = "description of an audit log"; [EOL] private static final ApplicationId APPID = mock(ApplicationId.class); [EOL] private static final ContainerId CONTAINERID = mock(ContainerId.class); [EOL]
@Test [EOL] public void testSkipAMContainer() { [EOL] int[][] qData = new int[][] { [EOL] // / A B [EOL] { 100, 50, 50 }, // abs [EOL] { 100, 100, 100 }, // maxcap [EOL] { 100, 100, 0 }, // used [EOL] { 70, 20, 50 }, // pending [EOL] { 0, 0, 0 }, // reserved [EOL] { 5, 4, 1 }, // apps [EOL] { -1, 1, 1 }, // req granularity [EOL] { 2, 0, 0 }, // subqueues [EOL] }; [EOL] setAMContainer = true; [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData); [EOL] policy.editSchedule(); [EOL] [EOL] // By skipping AM Container, all other 24 containers of appD will be [EOL] // preempted [EOL] verify(mDisp, times(24)).handle(argThat(new IsPreemptionRequestFor(appD))); [EOL] [EOL] // By skipping AM Container, all other 24 containers of appC will be [EOL] // preempted [EOL] verify(mDisp, times(24)).handle(argThat(new IsPreemptionRequestFor(appC))); [EOL] [EOL] // Since AM containers of appC and appD are saved, 2 containers from appB [EOL] // has to be preempted. [EOL] verify(mDisp, times(2)).handle(argThat(new IsPreemptionRequestFor(appB))); [EOL] setAMContainer = false; [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test [EOL] public void testSeedGeneration() { [EOL] long masterSeed1 = 42; [EOL] long masterSeed2 = 43; [EOL] [EOL] assertTrue("Deterministic seeding", [EOL] getSeed("stream1", masterSeed1) == getSeed("stream1", masterSeed1)); [EOL] assertTrue("Deterministic seeding", [EOL] getSeed("stream2", masterSeed2) == getSeed("stream2", masterSeed2)); [EOL] assertTrue("Different streams", [EOL] getSeed("stream1", masterSeed1) != getSeed("stream2", masterSeed1)); [EOL] assertTrue("Different master seeds", [EOL] getSeed("stream1", masterSeed1) != getSeed("stream1", masterSeed2)); [EOL] } [EOL]
@Test(expected = ConfigurationException.class) [EOL] public void testGetUDDIClientNoConfig() throws Exception { [EOL] System.out.println("testGetUDDIClientNoConfig"); [EOL] [EOL] [EOL] String random = UUID.randomUUID().toString(); [EOL] ServletContext req = createNiceMock(ServletContext.class); [EOL] [EOL] req.setAttribute(JUDDI_CLIENT_NAME, null); [EOL] expect(req.getInitParameter(WebHelper.JUDDI_CLIENT_NAME)).andReturn(null).times(0, 1); [EOL] req.setAttribute(UDDI_CLIENT_CONFIG_FILE, random); [EOL] expect(req.getInitParameter(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(random).times(0, 1); [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] //using default config [EOL] // expect(req.getInitParameter(WebHelper.UDDI_CLIENT_NAME)).andReturn(null).times(0, 2); [EOL] // expect(req.getInitParameter(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(null).times(0, 2); [EOL] // expect(req.getInitParameter(WebHelper.JUDDI_CLIENT_TRANSPORT)).andReturn(null).times(0, 2); [EOL] //expect(req.getAttribute(WebHelper.JUDDI_CLIENT_NAME)).andReturn(null).times(0, 2); [EOL] //using default config [EOL] // expect(req.getAttribute(WebHelper.UDDI_CLIENT_NAME)).andReturn(null).times(0, 2); [EOL] //expect(req.getAttribute(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(null).times(0, 2); [EOL] //expect(req.getAttribute(WebHelper.JUDDI_CLIENT_TRANSPORT)).andReturn(null).times(0, 2); [EOL] [EOL] replay(req); [EOL] [EOL] UDDIClient result = WebHelper.getUDDIClient(req); [EOL] Assert.assertNotNull(result); [EOL] } [EOL]
@Test [EOL] public void testDistributedProtocol() { [EOL] [EOL] YarnConfiguration conf = new YarnConfiguration(); [EOL] try { [EOL] ServerRMProxy.createRMProxy(conf, DistributedSchedulingAMProtocol.class); [EOL] } catch (Exception e) { [EOL] Assert.fail("DistributedSchedulingAMProtocol fail in non HA"); [EOL] } [EOL] [EOL] // HA is enabled [EOL] conf.setBoolean(YarnConfiguration.RM_HA_ENABLED, true); [EOL] conf.set(YarnConfiguration.RM_HA_IDS, "rm1,rm2"); [EOL] conf.set(HAUtil.addSuffix(YarnConfiguration.RM_HOSTNAME, "rm1"), "0.0.0.0"); [EOL] conf.set(HAUtil.addSuffix(YarnConfiguration.RM_HOSTNAME, "rm2"), "0.0.0.0"); [EOL] try { [EOL] ServerRMProxy.createRMProxy(conf, DistributedSchedulingAMProtocol.class); [EOL] } catch (Exception e) { [EOL] Assert.fail("DistributedSchedulingAMProtocol fail in HA"); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetWithTtlExpired() throws Exception { [EOL] // arrange [EOL] S3AFileStatus fileStatus = mock(S3AFileStatus.class); [EOL] Path path = new Path("/file"); [EOL] when(fileStatus.getPath()).thenReturn(path); [EOL] PathMetadata pm = new PathMetadata(fileStatus); [EOL] pm.setLastUpdated(100L); [EOL] [EOL] MetadataStore ms = mock(MetadataStore.class); [EOL] when(ms.get(path, false)).thenReturn(pm); [EOL] [EOL] ITtlTimeProvider timeProvider = [EOL] mock(ITtlTimeProvider.class); [EOL] when(timeProvider.getNow()).thenReturn(101L); [EOL] when(timeProvider.getMetadataTtl()).thenReturn(1L); [EOL] [EOL] // act [EOL] final PathMetadata pmExpired = S3Guard.getWithTtl(ms, path, timeProvider, [EOL] false, false); [EOL] [EOL] // assert [EOL] assertNull(pmExpired); [EOL] } [EOL] public static final String MS_FILE_1 = "s3a://bucket/dir/ms-file1"; [EOL] public static final String MS_FILE_2 = "s3a://bucket/dir/ms-file2"; [EOL] public static final String S3_FILE_3 = "s3a://bucket/dir/s3-file3"; [EOL] public static final String S3_DIR_4 = "s3a://bucket/dir/s3-dir4"; [EOL] public static final Path DIR_PATH = new Path("s3a://bucket/dir"); [EOL] private MetadataStore ms; [EOL] private ITtlTimeProvider timeProvider; [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[2]; [EOL]       int int0 = ArrayUtils.indexOf(booleanArray0, true, 17); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@SuppressWarnings("unchecked") [EOL] @Test [EOL] public void testNodeUpAferAWhile() throws Exception { [EOL] for (int i = 0; i < TEST_RETRIES; i++) { [EOL] String connectString = zkServer.getConnectString(); [EOL] Configuration conf = getSecretConf(connectString); [EOL] DelegationTokenManager tm1 = new DelegationTokenManager(conf, new Text("bla")); [EOL] tm1.init(); [EOL] Token<DelegationTokenIdentifier> token1 = [EOL] (Token<DelegationTokenIdentifier>) tm1.createToken( [EOL] UserGroupInformation.getCurrentUser(), "foo"); [EOL] Assert.assertNotNull(token1); [EOL] Token<DelegationTokenIdentifier> token2 = [EOL] (Token<DelegationTokenIdentifier>) tm1.createToken( [EOL] UserGroupInformation.getCurrentUser(), "bar"); [EOL] Assert.assertNotNull(token2); [EOL] Token<DelegationTokenIdentifier> token3 = [EOL] (Token<DelegationTokenIdentifier>) tm1.createToken( [EOL] UserGroupInformation.getCurrentUser(), "boo"); [EOL] Assert.assertNotNull(token3); [EOL] [EOL] tm1.verifyToken(token1); [EOL] tm1.verifyToken(token2); [EOL] tm1.verifyToken(token3); [EOL] [EOL] // Cancel one token [EOL] tm1.cancelToken(token1, "foo"); [EOL] [EOL] // Start second node after some time.. [EOL] Thread.sleep(1000); [EOL] DelegationTokenManager tm2 = new DelegationTokenManager(conf, new Text("bla")); [EOL] tm2.init(); [EOL] [EOL] tm2.verifyToken(token2); [EOL] tm2.verifyToken(token3); [EOL] try { [EOL] verifyTokenFail(tm2, token1); [EOL] fail("Expected InvalidToken"); [EOL] } catch (SecretManager.InvalidToken it) { [EOL] // Ignore [EOL] } [EOL] [EOL] // Create a new token thru the new ZKDTSM [EOL] Token<DelegationTokenIdentifier> token4 = [EOL] (Token<DelegationTokenIdentifier>) tm2.createToken( [EOL] UserGroupInformation.getCurrentUser(), "xyz"); [EOL] Assert.assertNotNull(token4); [EOL] tm2.verifyToken(token4); [EOL] tm1.verifyToken(token4); [EOL] [EOL] // Bring down tm2 [EOL] verifyDestroy(tm2, conf); [EOL] [EOL] // Start third node after some time.. [EOL] Thread.sleep(1000); [EOL] DelegationTokenManager tm3 = new DelegationTokenManager(conf, new Text("bla")); [EOL] tm3.init(); [EOL] [EOL] tm3.verifyToken(token2); [EOL] tm3.verifyToken(token3); [EOL] tm3.verifyToken(token4); [EOL] try { [EOL] verifyTokenFail(tm3, token1); [EOL] fail("Expected InvalidToken"); [EOL] } catch (SecretManager.InvalidToken it) { [EOL] // Ignore [EOL] } [EOL] [EOL] verifyDestroy(tm3, conf); [EOL] verifyDestroy(tm1, conf); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestZKDelegationTokenSecretManager.class); [EOL] protected static final int TEST_RETRIES = 2; [EOL] protected static final int RETRY_COUNT = 5; [EOL] protected static final int RETRY_WAIT = 1000; [EOL] protected static final long DAY_IN_SECS = 86400; [EOL] protected TestingServer zkServer; [EOL] @Rule [EOL] public Timeout globalTimeout = new Timeout(300000); [EOL]
@Test(timeout = 4000) [EOL]   public void testisAfterRange()  throws Throwable  { [EOL]       Integer integer0 = new Integer((-929)); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn((-929)).when(comparator0).compare(any() , any()); [EOL]       Range<Object> range0 = Range.between((Object) integer0, (Object) integer0, comparator0); [EOL]       boolean boolean0 = range0.isAfterRange((Range<Object>) null); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       String string0 = "SzpQ!4 ;U"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("SzpQ!4 ;U"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       char char0 = '`'; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) "SzpQ!4 ;U", 97, '`'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("ekji"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendSeparator('`'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.insert(97, (long) 2817); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder4.appendln(stringBuilder0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder1.replaceFirst("SzpQ!4 ;U", "ekji"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder2.replaceAll("ekji", "ekji"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder7.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(2817, (float) '`'); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2817 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       char[] charArray0 = new char[2]; [EOL]       int int0 = ArrayUtils.indexOf(charArray0, 'J', (int) (short) (-1)); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmarkSupported()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(1354); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]        [EOL]       StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getQuoteMatcher(); [EOL]        [EOL]       StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setQuoteMatcher(strMatcher0); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteFirst(strMatcher0); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.append('E'); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.charAt(2193); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2193 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       assertEquals(0, (int)compareToBuilder0.build()); [EOL]        [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       Object[] objectArray1 = new Object[4]; [EOL]       CompareToBuilder compareToBuilder1 = compareToBuilder0.append(objectArray0, objectArray1); [EOL]       int[] intArray0 = new int[6]; [EOL]       compareToBuilder1.append(intArray0, intArray0); [EOL]       assertEquals(1, (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetChildTrustStore() throws Exception { [EOL] ProxyCA proxyCA = new ProxyCA(); [EOL] proxyCA.init(); [EOL] byte[] truststoreBytes = proxyCA.getChildTrustStore("password"); [EOL] KeyStore truststore = KeyStoreTestUtil.bytesToKeyStore(truststoreBytes, [EOL] "password"); [EOL] Assert.assertEquals(1, truststore.size()); [EOL] X509Certificate caCert = [EOL] (X509Certificate) truststore.getCertificate("client"); [EOL] [EOL] // check CA cert [EOL] checkCACert(caCert); [EOL] Assert.assertEquals(proxyCA.getCaCert(), caCert); [EOL] [EOL] // verify signature on CA cert [EOL] PublicKey caPublicKey = caCert.getPublicKey(); [EOL] caCert.verify(caPublicKey); [EOL] [EOL] // verify CA public key matches private key [EOL] PrivateKey caPrivateKey = [EOL] proxyCA.getX509KeyManager().getPrivateKey(null); [EOL] checkPrivatePublicKeys(caPrivateKey, caPublicKey); [EOL] Assert.assertEquals(proxyCA.getCaKeyPair().getPublic(), caPublicKey); [EOL] Assert.assertEquals(proxyCA.getCaKeyPair().getPrivate(), caPrivateKey); [EOL] } [EOL]
@Test [EOL] public void testBadFlex() { [EOL] String appName = "unknown_app"; [EOL] HashMap<String, String> componentCounts = new HashMap<String, String>(); [EOL] try { [EOL] int result = badAsc.actionFlex(appName, componentCounts); [EOL] assertEquals(EXIT_EXCEPTION_THROWN, result); [EOL] } catch (IOException | YarnException e) { [EOL] fail(); [EOL] } [EOL] } [EOL] private static ApiServiceClient asc; [EOL] private static ApiServiceClient badAsc; [EOL] private static Server server; [EOL]
@Test [EOL] public void testAllocationLatencyMetrics() throws Exception { [EOL] oppCntxt = spy(oppCntxt); [EOL] OpportunisticSchedulerMetrics metrics = [EOL] mock(OpportunisticSchedulerMetrics.class); [EOL] when(oppCntxt.getOppSchedulerMetrics()).thenReturn(metrics); [EOL] ResourceBlacklistRequest blacklistRequest = [EOL] ResourceBlacklistRequest.newInstance( [EOL] Collections.emptyList(), Collections.emptyList()); [EOL] List<ResourceRequest> reqs = Arrays.asList( [EOL] ResourceRequest.newInstance(PRIORITY_NORMAL, "*", CAPABILITY_1GB, 2, [EOL] true, null, OPPORTUNISTIC_REQ), [EOL] ResourceRequest.newInstance(PRIORITY_NORMAL, "h6", CAPABILITY_1GB, 2, [EOL] true, null, OPPORTUNISTIC_REQ), [EOL] ResourceRequest.newInstance(PRIORITY_NORMAL, "/r3", CAPABILITY_1GB, 2, [EOL] true, null, OPPORTUNISTIC_REQ)); [EOL] ApplicationAttemptId appAttId = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(0L, 1), 1); [EOL] [EOL] oppCntxt.updateNodeList( [EOL] Arrays.asList( [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h3", 1234), "h3:1234", "/r2"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h2", 1234), "h2:1234", "/r1"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h5", 1234), "h5:1234", "/r1"), [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h4", 1234), "h4:1234", "/r2"))); [EOL] [EOL] List<Container> containers = allocator.allocateContainers( [EOL] blacklistRequest, reqs, appAttId, oppCntxt, 1L, "luser"); [EOL] LOG.info("Containers: {}", containers); [EOL] Assert.assertEquals(2, containers.size()); [EOL] // for each allocated container, latency should be added. [EOL] verify(metrics, times(2)).addAllocateOLatencyEntry(anyLong()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger( [EOL] TestDistributedOpportunisticContainerAllocator.class); [EOL] private static final int GB = 1024; [EOL] private DistributedOpportunisticContainerAllocator allocator = null; [EOL] private OpportunisticContainerContext oppCntxt = null; [EOL] private static final Priority PRIORITY_NORMAL = Priority.newInstance(1); [EOL] private static final Resource CAPABILITY_1GB = [EOL] Resources.createResource(1 * GB); [EOL] private static final ExecutionTypeRequest OPPORTUNISTIC_REQ = [EOL] ExecutionTypeRequest.newInstance(ExecutionType.OPPORTUNISTIC, true); [EOL]
@Test [EOL] public void processPathWithQuotasByStorageTypesHeader() throws Exception { [EOL] Path path = new Path("mockfs:/test"); [EOL] [EOL] when(mockFs.getFileStatus(eq(path))).thenReturn(fileStat); [EOL] [EOL] PrintStream out = mock(PrintStream.class); [EOL] [EOL] Count count = new Count(); [EOL] count.out = out; [EOL] [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] options.add("-q"); [EOL] options.add("-v"); [EOL] options.add("-t"); [EOL] options.add("all"); [EOL] options.add("dummy"); [EOL] count.processOptions(options); [EOL] String withStorageTypeHeader = [EOL] // <----13---> <-------17------> <----13-----> <------17-------> [EOL] " NVDIMM_QUOTA REM_NVDIMM_QUOTA " + [EOL] " SSD_QUOTA REM_SSD_QUOTA DISK_QUOTA REM_DISK_QUOTA " + [EOL] // <----13---> <-------17------> [EOL] "ARCHIVE_QUOTA REM_ARCHIVE_QUOTA PROVIDED_QUOTA REM_PROVIDED_QUOTA " + [EOL] "PATHNAME"; [EOL] verify(out).println(withStorageTypeHeader); [EOL] verifyNoMoreInteractions(out); [EOL] } [EOL] private static final String WITH_QUOTAS = "Content summary with quotas"; [EOL] private static final String NO_QUOTAS = "Content summary without quotas"; [EOL] private static final String HUMAN = "human: "; [EOL] private static final String BYTES = "bytes: "; [EOL] private static final String QUOTAS_AND_USAGE = "quotas and usage"; [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static FileStatus fileStat; [EOL]
@Test [EOL] public void testQueueSizeBasedWeightDisabled() { [EOL] converter = builder.build(); [EOL] [EOL] converter.convertQueueHierarchy(rootQueue); [EOL] [EOL] assertNoValueForQueues(ALL_QUEUES, [EOL] ".ordering-policy.fair.enable-size-based-weight", csConfig); [EOL] } [EOL] private static final float MAX_AM_SHARE_DEFAULT = 0.16f; [EOL] private static final int MAX_APPS_DEFAULT = 15; [EOL] private static final Resource CLUSTER_RESOURCE = [EOL] Resource.newInstance(16384, 16); [EOL] private final static Set<String> ALL_QUEUES = [EOL] Sets.newHashSet("root", [EOL] "root.default", [EOL] "root.admins", [EOL] "root.users", [EOL] "root.admins.alice", [EOL] "root.admins.bob", [EOL] "root.users.joe", [EOL] "root.users.john"); [EOL] private static final String FILE_PREFIX = "file:"; [EOL] private static final String FAIR_SCHEDULER_XML = [EOL] prepareFileName("fair-scheduler-conversion.xml"); [EOL] private FSQueueConverter converter; [EOL] private Configuration yarnConfig; [EOL] private Configuration csConfig; [EOL] private FairScheduler fs; [EOL] private FSQueue rootQueue; [EOL] private ConversionOptions conversionOptions; [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] private FSQueueConverterBuilder builder; [EOL] @Mock [EOL] private FSConfigToCSConfigRuleHandler ruleHandler; [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testFraction()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getReducedFraction(0, 798); [EOL]       int int0 = fraction0.getNumerator(); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetRootCauseMessage()  throws Throwable  { [EOL]       String string0 = ExceptionUtils.getRootCauseMessage((Throwable) null); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout=120000) [EOL] public void testRandomLong() throws Exception { [EOL] OsSecureRandom random = getOsSecureRandom(); [EOL] [EOL] long rand1 = random.nextLong(); [EOL] long rand2 = random.nextLong(); [EOL] while (rand1 == rand2) { [EOL] rand2 = random.nextLong(); [EOL] } [EOL] random.close(); [EOL] } [EOL]
@Test [EOL] public void testNodeInfoDefault() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("node").path("info") [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] verifyNodeInfo(json); [EOL] } [EOL] private static final long NM_RESOURCE_VALUE = 1000L; [EOL] private static NodeManager.NMContext nmContext; [EOL] private static ResourceView resourceView; [EOL] private static ApplicationACLsManager aclsManager; [EOL] private static LocalDirsHandlerService dirsHandler; [EOL] private static WebApp nmWebApp; [EOL] private static final String LOGSERVICEWSADDR = "test:1234"; [EOL] private static final String LOG_MESSAGE = "log message\n"; [EOL] private static final File testRootDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName()); [EOL] private static File testLogDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName() + "LogDir"); [EOL] private static File testRemoteLogDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName() + "remote-log-dir"); [EOL]
@Test [EOL] public void testHSSlash() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("history/") [EOL] .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] assertEquals("incorrect number of elements", 1, json.length()); [EOL] verifyHSInfo(json.getJSONObject("historyInfo"), appContext); [EOL] } [EOL] private static Configuration conf = new Configuration(); [EOL] private static HistoryContext appContext; [EOL] private static HsWebApp webApp; [EOL]
@Test (timeout = 30000) [EOL] public void testFailFullyDeleteContents() throws IOException { [EOL] // Windows Dir.setWritable(false) does not work for directories [EOL] assumeNotWindows(); [EOL] LOG.info("Running test to verify failure of fullyDeleteContents()"); [EOL] setupDirsAndNonWritablePermissions(); [EOL] boolean ret = FileUtil.fullyDeleteContents(new MyFile(del)); [EOL] validateAndSetWritablePermissions(true, ret); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.minimizeCapacity(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.append('U'); [EOL]       assertEquals(1, strBuilder0.size()); [EOL]       assertEquals(1, strBuilder1.size()); [EOL]       assertEquals(1, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder3.new StrBuilderTokenizer(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer1 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.cloneReset(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       StrMatcher.NoMatcher strMatcher_NoMatcher0 = (StrMatcher.NoMatcher)strBuilder_StrBuilderTokenizer0.getQuoteMatcher(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer2 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.setTrimmerMatcher(strMatcher_NoMatcher0); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       String string0 = strBuilder0.leftString(2026); [EOL]       assertEquals(1, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendFixedWidthPadRight((Object) strBuilder_StrBuilderTokenizer1, 2026, '('); [EOL]       assertEquals(2027, strBuilder0.size()); [EOL]       assertEquals(2027, strBuilder1.size()); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]       assertEquals(2027, strBuilder4.size()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder4.insert(2026, 0.0F); [EOL]       assertEquals(2030, strBuilder0.size()); [EOL]       assertEquals(2030, strBuilder1.size()); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]       assertEquals(2030, strBuilder4.size()); [EOL]       assertEquals(2030, strBuilder5.size()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.append(0L); [EOL]       assertEquals(2031, strBuilder0.size()); [EOL]       assertEquals(2031, strBuilder1.size()); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]       assertEquals(2031, strBuilder4.size()); [EOL]       assertEquals(2031, strBuilder6.size()); [EOL]        [EOL]       String string1 = strBuilder_StrBuilderTokenizer0.previousToken(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder6.setCharAt(97, '+'); [EOL]       assertEquals(2031, strBuilder0.size()); [EOL]       assertEquals(2031, strBuilder1.size()); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]       assertEquals(2031, strBuilder4.size()); [EOL]       assertEquals(2031, strBuilder6.size()); [EOL]       assertEquals(2031, strBuilder7.size()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(2031, strBuilder0.size()); [EOL]        [EOL]       strBuilder_StrBuilderReader0.close(); [EOL]       assertEquals(2031, strBuilder0.size()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderTokenizer0.hasPrevious(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       objectArray0[0] = (Object) "java.vendor.url"; [EOL]       objectArray0[1] = (Object) "U"; [EOL]       objectArray0[2] = (Object) strBuilder2; [EOL]       objectArray0[3] = (Object) strBuilder_StrBuilderTokenizer1; [EOL]       objectArray0[4] = (Object) "U"; [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer3 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.cloneReset(); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       objectArray0[5] = (Object) strBuilder_StrBuilderTokenizer3; [EOL]       objectArray0[6] = (Object) strBuilder_StrBuilderTokenizer0; [EOL]       StrBuilder strBuilder8 = strBuilder2.appendln("java.vendor.url", objectArray0); [EOL]       assertEquals(2047, strBuilder0.size()); [EOL]       assertEquals(2047, strBuilder1.size()); [EOL]       assertEquals(2047, strBuilder2.size()); [EOL]       assertEquals(2047, strBuilder8.size()); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer(" -~*ui'"); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder8.appendln(stringBuffer0, (-1229), 2026); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcompare()  throws Throwable  { [EOL]       Object object0 = new Object(); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(0).when(comparator0).compare(any() , any()); [EOL]       Range<Object> range0 = Range.between(object0, object0, comparator0); [EOL]       boolean boolean0 = range0.equals((Object) null); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       char char0 = 'j'; [EOL]       Iterable<Object> iterable0 = null; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterable<?>) null, "b0}RRkoCl[.="); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       int int0 = strBuilder0.indexOf('j', 815); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       char char1 = '8'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendSeparator('j', '8'); [EOL]       assertEquals(1, strBuilder0.size()); [EOL]       assertEquals(1, strBuilder1.size()); [EOL]       assertEquals(1, strBuilder2.size()); [EOL]        [EOL]       int int1 = 516; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.insert(516, false); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 516 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testaddAll()  throws Throwable  { [EOL]       char[] charArray0 = new char[9]; [EOL]       char[] charArray1 = ArrayUtils.addAll(charArray0, charArray0); [EOL]       assertEquals(18, charArray1.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testReadWithKnownLength() throws IOException { [EOL] String line = "hello world"; [EOL] byte[] inputBytes = line.getBytes(Charsets.UTF_8); [EOL] DataInputBuffer in = new DataInputBuffer(); [EOL] Text text = new Text(); [EOL] [EOL] in.reset(inputBytes, inputBytes.length); [EOL] text.readWithKnownLength(in, 5); [EOL] assertEquals("hello", text.toString()); [EOL] assertEquals(5, text.getTextLength()); [EOL] [EOL] // Read longer length, make sure it lengthens [EOL] in.reset(inputBytes, inputBytes.length); [EOL] text.readWithKnownLength(in, 7); [EOL] assertEquals("hello w", text.toString()); [EOL] assertEquals(7, text.getTextLength()); [EOL] [EOL] // Read shorter length, make sure it shortens [EOL] in.reset(inputBytes, inputBytes.length); [EOL] text.readWithKnownLength(in, 2); [EOL] assertEquals("he", text.toString()); [EOL] assertEquals(2, text.getTextLength()); [EOL] } [EOL] private static final int NUM_ITERATIONS = 100; [EOL] private static final Random RANDOM = new Random(1); [EOL] private static final int RAND_LEN = -1; [EOL]
@Test [EOL] public void testForceKillApplicationEmptyRequest() [EOL] throws YarnException, IOException, InterruptedException { [EOL] LOG.info( [EOL] "Test FederationClientInterceptor: Force Kill Application - Empty"); [EOL] try { [EOL] interceptor.forceKillApplication(null); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertTrue(e.getMessage().startsWith( [EOL] "Missing forceKillApplication request or ApplicationId.")); [EOL] } [EOL] try { [EOL] interceptor [EOL] .forceKillApplication(KillApplicationRequest.newInstance(null)); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertTrue(e.getMessage().startsWith( [EOL] "Missing forceKillApplication request or ApplicationId.")); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFederationClientInterceptor.class); [EOL] private TestableFederationClientInterceptor interceptor; [EOL] private MemoryFederationStateStore stateStore; [EOL] private FederationStateStoreTestUtil stateStoreUtil; [EOL] private List<SubClusterId> subClusters; [EOL] private String user = "test-user"; [EOL] private final static int NUM_SUBCLUSTER = 4; [EOL]
@Test(timeout = 4000) [EOL]   public void testbinaryToHexDigit()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[2]; [EOL]       booleanArray0[0] = true; [EOL]       char char0 = Conversion.binaryToHexDigit(booleanArray0, 0); [EOL]       assertEquals('1', char0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNetgroups() throws Exception { [EOL] [EOL] if(!NativeCodeLoader.isNativeCodeLoaded()) { [EOL] LOG.info("Not testing netgroups, " + [EOL] "this test only runs when native code is compiled"); [EOL] return; [EOL] } [EOL] [EOL] String groupMappingClassName = [EOL] System.getProperty("TestAccessControlListGroupMapping"); [EOL] [EOL] if(groupMappingClassName == null) { [EOL] LOG.info("Not testing netgroups, no group mapping class specified, " + [EOL] "use -DTestAccessControlListGroupMapping=$className to specify " + [EOL] "group mapping class (must implement GroupMappingServiceProvider " + [EOL] "interface and support netgroups)"); [EOL] return; [EOL] } [EOL] [EOL] LOG.info("Testing netgroups using: " + groupMappingClassName); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_GROUP_MAPPING, [EOL] groupMappingClassName); [EOL] [EOL] Groups groups = Groups.getUserToGroupsMappingService(conf); [EOL] [EOL] AccessControlList acl; [EOL] [EOL] // create these ACLs to populate groups cache [EOL] acl = new AccessControlList("ja my"); // plain [EOL] acl = new AccessControlList("sinatra ratpack,@lasVegas"); // netgroup [EOL] acl = new AccessControlList(" somegroup,@someNetgroup"); // no user [EOL] [EOL] // this ACL will be used for testing ACLs [EOL] acl = new AccessControlList("carlPerkins ratpack,@lasVegas"); [EOL] acl.addGroup("@memphis"); [EOL] [EOL] // validate the netgroups before and after rehresh to make [EOL] // sure refresh works correctly [EOL] validateNetgroups(groups, acl); [EOL] groups.refresh(); [EOL] validateNetgroups(groups, acl); [EOL] [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestAccessControlList.class); [EOL]
@Test [EOL] public void testGetRollOverLogMaxSize() { [EOL] String fileControllerName = "testController"; [EOL] String remoteDirConf = String.format( [EOL] YarnConfiguration.LOG_AGGREGATION_REMOTE_APP_LOG_DIR_FMT, [EOL] fileControllerName); [EOL] Configuration conf = new Configuration(); [EOL] LogAggregationIndexedFileController fileFormat [EOL] = new LogAggregationIndexedFileController(); [EOL] long defaultRolloverSize = 10L * 1024 * 1024 * 1024; [EOL] [EOL] // test local filesystem [EOL] fileFormat.initialize(conf, fileControllerName); [EOL] assertThat(fileFormat.getRollOverLogMaxSize(conf)) [EOL] .isEqualTo(defaultRolloverSize); [EOL] [EOL] // test file system supporting append [EOL] conf.set(remoteDirConf, "webhdfs://localhost/path"); [EOL] fileFormat.initialize(conf, fileControllerName); [EOL] assertThat(fileFormat.getRollOverLogMaxSize(conf)) [EOL] .isEqualTo(defaultRolloverSize); [EOL] [EOL] // test file system not supporting append [EOL] conf.set(remoteDirConf, "s3a://test/path"); [EOL] fileFormat.initialize(conf, fileControllerName); [EOL] assertThat(fileFormat.getRollOverLogMaxSize(conf)).isZero(); [EOL] } [EOL] private final String rootLocalLogDir = "target/LocalLogs"; [EOL] private final Path rootLocalLogDirPath = new Path(rootLocalLogDir); [EOL] private final String remoteLogDir = "target/remote-app"; [EOL] private static final FsPermission LOG_FILE_UMASK = FsPermission [EOL] .createImmutable((short) (0777)); [EOL] private static final UserGroupInformation USER_UGI = UserGroupInformation [EOL] .createRemoteUser("testUser"); [EOL] private static final String ZERO_FILE = "zero"; [EOL] private FileSystem fs; [EOL] private ApplicationId appId; [EOL] private ContainerId containerId; [EOL] private NodeId nodeId; [EOL] private ByteArrayOutputStream sysOutStream; [EOL]
@Test [EOL] public void testGetPrincipalNamesFromKeytabWithPattern() throws IOException { [EOL] createKeyTab(testKeytab, testPrincipals); [EOL] // read the keytab file [EOL] // look for principals with HTTP as the first part [EOL] Pattern httpPattern = Pattern.compile("HTTP/.*"); [EOL] String[] httpPrincipals = [EOL] KerberosUtil.getPrincipalNames(testKeytab, httpPattern); [EOL] Assert.assertNotNull("principals cannot be null", httpPrincipals); [EOL] [EOL] int expectedSize = 0; [EOL] List<String> httpPrincipalList = Arrays.asList(httpPrincipals); [EOL] for (String principal : testPrincipals) { [EOL] if (httpPattern.matcher(principal).matches()) { [EOL] Assert.assertTrue("missing principal "+principal, [EOL] httpPrincipalList.contains(principal)); [EOL] expectedSize++; [EOL] } [EOL] } [EOL] Assert.assertEquals(expectedSize, httpPrincipals.length); [EOL] } [EOL] static String testKeytab = "test.keytab"; [EOL] static String[] testPrincipals = new String[]{ [EOL] "HTTP@testRealm", [EOL] "test/testhost@testRealm", [EOL] "HTTP/testhost@testRealm", [EOL] "HTTP1/testhost@testRealm", [EOL] "HTTP/testhostanother@testRealm" [EOL] }; [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(767); [EOL]       assertEquals(767, strBuilder0.capacity()); [EOL]        [EOL]       Class<String> class0 = String.class; [EOL]       ServiceLoader<String> serviceLoader0 = ServiceLoader.loadInstalled(class0); [EOL]        [EOL]       Class<StrBuilder> class1 = StrBuilder.class; [EOL]       ServiceLoader<StrBuilder> serviceLoader1 = ServiceLoader.loadInstalled(class1); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterable<?>) serviceLoader0, "d"); [EOL]       assertEquals(767, strBuilder0.capacity()); [EOL]       assertEquals(767, strBuilder1.capacity()); [EOL]        [EOL]       int int0 = strBuilder1.capacity(); [EOL]       assertEquals(767, strBuilder0.capacity()); [EOL]       assertEquals(767, strBuilder1.capacity()); [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testNoRootDir() throws Throwable { [EOL] shouldDelete(ROOT, true); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestDeletedDirTracker.class); [EOL] public static final Path ROOT = new Path("hdfs://namenode/"); [EOL] public static final Path DIR1 = new Path(ROOT, "dir1"); [EOL] public static final Path FILE0 = new Path(ROOT, "file0"); [EOL] public static final Path DIR1_FILE1 = new Path(DIR1, "file1"); [EOL] public static final Path DIR1_FILE2 = new Path(DIR1, "file2"); [EOL] public static final Path DIR1_DIR3 = new Path(DIR1, "dir3"); [EOL] public static final Path DIR1_DIR3_DIR4 = new Path(DIR1_DIR3, "dir4"); [EOL] public static final Path DIR1_DIR3_DIR4_FILE_3 = [EOL] new Path(DIR1_DIR3_DIR4, "file1"); [EOL] private DeletedDirTracker tracker; [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseIdentityHashCode()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       Boolean boolean0 = Boolean.TRUE; [EOL]       standardToStringStyle0.isFullDetail(boolean0); [EOL]       assertTrue(standardToStringStyle0.isUseIdentityHashCode()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFitsInDiagnosticsCollector() { [EOL] if (resourceCalculator instanceof DefaultResourceCalculator) { [EOL] // required-resource = (0, 0) [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(1, 1))); [EOL] [EOL] // required-resource = (0, 1) [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(1, 1))); [EOL] [EOL] // required-resource = (1, 0) [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(1, 1))); [EOL] [EOL] // required-resource = (1, 1) [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(1, 1))); [EOL] } else if (resourceCalculator instanceof DominantResourceCalculator) { [EOL] // required-resource = (0, 0) [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 0), [EOL] newResource(1, 1))); [EOL] [EOL] // required-resource = (0, 1) [EOL] assertEquals(ImmutableSet.of(ResourceInformation.VCORES_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(ResourceInformation.VCORES_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(0, 1), [EOL] newResource(1, 1))); [EOL] [EOL] // required-resource = (1, 0) [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 0), [EOL] newResource(1, 1))); [EOL] [EOL] // required-resource = (1, 1) [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI, [EOL] ResourceInformation.VCORES_URI), resourceCalculator [EOL] .getInsufficientResourceNames(newResource(1, 1), newResource(0, 0))); [EOL] assertEquals(ImmutableSet.of(ResourceInformation.MEMORY_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(0, 1))); [EOL] assertEquals(ImmutableSet.of(ResourceInformation.VCORES_URI), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(1, 0))); [EOL] assertEquals(ImmutableSet.of(), [EOL] resourceCalculator.getInsufficientResourceNames(newResource(1, 1), [EOL] newResource(1, 1))); [EOL] } [EOL] } [EOL] private static final String EXTRA_RESOURCE_NAME = "test"; [EOL] private final ResourceCalculator resourceCalculator; [EOL]
@Test(timeout = 4000) [EOL]   public void testcontains()  throws Throwable  { [EOL]       LinkedList<Integer> linkedList0 = new LinkedList<Integer>(); [EOL]        [EOL]       Iterator<Integer> iterator0 = linkedList0.iterator(); [EOL]        [EOL]       String string0 = StringUtils.join(iterator0, "The character must not be null"); [EOL]        [EOL]       int int0 = StringUtils.indexOf((CharSequence) "The character must not be null", (CharSequence) "The character must not be null"); [EOL]        [EOL]       Integer integer0 = linkedList0.pollFirst(); [EOL]       assertFalse(linkedList0.contains(int0)); [EOL]        [EOL]       String string1 = StringUtils.chomp(""); [EOL]        [EOL]       String string2 = StringUtils.lowerCase(""); [EOL]        [EOL]       int int1 = StringUtils.indexOfAny((CharSequence) "The character must not be null", ""); [EOL]        [EOL]       String[] stringArray0 = new String[5]; [EOL]       stringArray0[0] = ""; [EOL]       stringArray0[1] = ""; [EOL]       stringArray0[2] = ""; [EOL]       stringArray0[3] = ""; [EOL]       stringArray0[4] = ""; [EOL]       String string3 = StringUtils.join(stringArray0); [EOL]        [EOL]       String[] stringArray1 = StringUtils.stripAll(stringArray0, (String) null); [EOL]        [EOL]       String string4 = StringUtils.substringBefore("kytsDAH*4", "kytsDAH*4"); [EOL]        [EOL]       String string5 = StringUtils.lowerCase(""); [EOL]        [EOL]       int int2 = StringUtils.indexOfDifference((CharSequence) "", (CharSequence) ""); [EOL]        [EOL]       String string6 = StringUtils.appendIfMissing("", "", stringArray0); [EOL]        [EOL]       int int3 = StringUtils.indexOfDifference((CharSequence[]) stringArray0); [EOL]        [EOL]       String string7 = StringUtils.removeEndIgnoreCase("", ""); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testToStringHumanWithQuota() { [EOL] long fileAndDirCount = 222255555; [EOL] long quota = 222256578; [EOL] long spaceConsumed = 1073741825; [EOL] long spaceQuota = 1; [EOL] [EOL] QuotaUsage quotaUsage = new QuotaUsage.Builder(). [EOL] fileAndDirectoryCount(fileAndDirCount).quota(quota). [EOL] spaceConsumed(spaceConsumed).spaceQuota(spaceQuota).build(); [EOL] String expected = " 212.0 M 1023 1 " [EOL] + " -1 G "; [EOL] assertEquals(expected, quotaUsage.toString(true)); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisIgnoreEmptyTokens()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(); [EOL]       strTokenizer0.getContent(); [EOL]       assertTrue(strTokenizer0.isIgnoreEmptyTokens()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClusterSchedulerFifoXML() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("cluster") [EOL] .path("scheduler").accept(MediaType.APPLICATION_XML) [EOL] .get(ClientResponse.class); [EOL] [EOL] assertEquals(MediaType.APPLICATION_XML + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] String xml = response.getEntity(String.class); [EOL] verifySchedulerFifoXML(xml); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRMWebServices.class); [EOL] private static MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.removeStart(":lRC9;Q#I/x!xtF", ":lRC9;Q#I/x!xtF"); [EOL]        [EOL]       String string1 = StringUtils.chomp("2", ""); [EOL]        [EOL]       int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) "", (CharSequence) "2"); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[6]; [EOL]       charSequenceArray0[0] = (CharSequence) ""; [EOL]       charSequenceArray0[1] = (CharSequence) "2"; [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       charSequenceArray0[3] = (CharSequence) ""; [EOL]       charSequenceArray0[4] = (CharSequence) "2"; [EOL]       charSequenceArray0[5] = (CharSequence) "2"; [EOL]       int int1 = StringUtils.indexOfDifference(charSequenceArray0); [EOL]       assertEquals(6, charSequenceArray0.length); [EOL]        [EOL]       boolean boolean0 = StringUtils.isAlphaSpace(charSequenceArray0[2]); [EOL]       assertEquals(6, charSequenceArray0.length); [EOL]        [EOL]       String string2 = StringUtils.removeEnd("2", (String) null); [EOL]        [EOL]       boolean boolean1 = StringUtils.containsOnly((CharSequence) "2", "4H*M`VvBKe5Oj^M&g;"); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsetVariablePrefix()  throws Throwable  { [EOL]       HashMap<String, String> hashMap0 = new HashMap<String, String>(); [EOL]       StrLookup<String> strLookup0 = StrLookup.mapLookup((Map<String, String>) hashMap0); [EOL]       StrSubstitutor strSubstitutor0 = new StrSubstitutor(strLookup0, "Variable prefix matcher must not be null!", "Variable prefix matcher must not be null!", 'k'); [EOL]       strSubstitutor0.setEnableSubstitutionInVariables(true); [EOL]       strSubstitutor0.setVariablePrefix('$'); [EOL]       assertTrue(strSubstitutor0.isEnableSubstitutionInVariables()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testQueuePreemptionDisabledWhenGlobalPreemptionDisabled() { [EOL] converter = builder.build(); [EOL] [EOL] converter.convertQueueHierarchy(rootQueue); [EOL] [EOL] assertNoValueForQueues(ALL_QUEUES, ".disable_preemption", csConfig); [EOL] } [EOL] private static final float MAX_AM_SHARE_DEFAULT = 0.16f; [EOL] private static final int MAX_APPS_DEFAULT = 15; [EOL] private static final Resource CLUSTER_RESOURCE = [EOL] Resource.newInstance(16384, 16); [EOL] private final static Set<String> ALL_QUEUES = [EOL] Sets.newHashSet("root", [EOL] "root.default", [EOL] "root.admins", [EOL] "root.users", [EOL] "root.admins.alice", [EOL] "root.admins.bob", [EOL] "root.users.joe", [EOL] "root.users.john"); [EOL] private static final String FILE_PREFIX = "file:"; [EOL] private static final String FAIR_SCHEDULER_XML = [EOL] prepareFileName("fair-scheduler-conversion.xml"); [EOL] private FSQueueConverter converter; [EOL] private Configuration yarnConfig; [EOL] private Configuration csConfig; [EOL] private FairScheduler fs; [EOL] private FSQueue rootQueue; [EOL] private ConversionOptions conversionOptions; [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] private FSQueueConverterBuilder builder; [EOL] @Mock [EOL] private FSConfigToCSConfigRuleHandler ruleHandler; [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("Invalid startIndex: "); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) strTokenizer0, "Invalid startIndex: "); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '\\'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(charArray0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertEquals(160, strBuilder0.capacity()); [EOL]       assertEquals(160, strBuilder1.capacity()); [EOL]       assertEquals(160, strBuilder2.capacity()); [EOL]       assertEquals(160, strBuilder3.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.setLength(2822); [EOL]       assertEquals(5644, strBuilder0.capacity()); [EOL]       assertEquals(5644, strBuilder4.capacity()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) '\\'; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       StrBuilder strBuilder5 = strBuilder4.appendAll(objectArray0); [EOL]       assertEquals(5644, strBuilder0.capacity()); [EOL]       assertEquals(5644, strBuilder4.capacity()); [EOL]       assertEquals(5644, strBuilder5.capacity()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(strBuilder1, 0, 2822); [EOL]       assertEquals(11552, strBuilder0.capacity()); [EOL]       assertEquals(11552, strBuilder1.capacity()); [EOL]       assertEquals(11552, strBuilder6.capacity()); [EOL]        [EOL]       int int0 = strBuilder6.lastIndexOf("Invalid startIndex: "); [EOL]       assertEquals(11552, strBuilder0.capacity()); [EOL]       assertEquals(11552, strBuilder1.capacity()); [EOL]       assertEquals(11552, strBuilder6.capacity()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.append(false); [EOL]       assertEquals(11552, strBuilder7.capacity()); [EOL]       assertEquals(11552, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.appendln(1490.882886748184); [EOL]       assertEquals(11552, strBuilder0.capacity()); [EOL]       assertEquals(11552, strBuilder8.capacity()); [EOL]       assertEquals(11552, strBuilder1.capacity()); [EOL]        [EOL]       strBuilder8.buffer = charArray0; [EOL]       assertEquals(1, strBuilder0.capacity()); [EOL]       assertEquals(1, strBuilder8.capacity()); [EOL]       assertEquals(1, strBuilder1.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder6.append(strBuilder3, 0, 2822); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNodeHealthReportIsNotNull() throws Exception{ [EOL] String host1 = "host1"; [EOL] final int memory = 4 * 1024; [EOL] [EOL] NodeStatus mockNodeStatus = createMockNodeStatus(); [EOL] [EOL] org.apache.hadoop.yarn.server.resourcemanager.NodeManager nm1 = [EOL] registerNode(host1, 1234, 2345, NetworkTopology.DEFAULT_RACK, [EOL] Resources.createResource(memory, 1), mockNodeStatus); [EOL] nm1.heartbeat(); [EOL] nm1.heartbeat(); [EOL] Collection<RMNode> values = resourceManager.getRMContext().getRMNodes().values(); [EOL] for (RMNode ni : values) { [EOL] assertNotNull(ni.getHealthReport()); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestResourceManager.class); [EOL] private ResourceManager resourceManager = null; [EOL] @Rule [EOL] public ExpectedException thrown = ExpectedException.none(); [EOL] private FSConfigConverterTestCommons converterTestCommons; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((-1)); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.spaceMatcher(); [EOL]        [EOL]       String string0 = "iVO"; [EOL]       StrMatcher strMatcher1 = StrMatcher.stringMatcher("iVO"); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher("x~DPyO[EG\"4:"); [EOL]        [EOL]       StrMatcher strMatcher3 = StrMatcher.charSetMatcher("iVO"); [EOL]        [EOL]       int int0 = strBuilder0.indexOf(strMatcher0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = new StrBuilder(0); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher4 = StrMatcher.spaceMatcher(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.replaceFirst(strMatcher4, (String) null); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]       assertTrue(strBuilder2.isEmpty()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.equalsIgnoreCase(strBuilder1); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert((-1), "%;$c19wXmzsg6Q"); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       int int0 = (-302); [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.setLength((-302)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -302 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       String string0 = BooleanUtils.toString(false, "Pl=kr", "T(yEy"); [EOL]       assertEquals("T(yEy", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitMsb0ToInt()  throws Throwable  { [EOL]       int int0 = Conversion.hexDigitMsb0ToInt('3'); [EOL]       assertEquals(12, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       String string0 = BooleanUtils.toString(false, "", ""); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testOnCall() throws IOException { [EOL] this.handler = new NativeCollectorOnlyHandler(taskContext, nativeHandler, pusher, combiner); [EOL] boolean thrown = false; [EOL] try { [EOL] handler.onCall(new Command(-1), null); [EOL] } catch(final IOException e) { [EOL] thrown = true; [EOL] } [EOL] Assert.assertTrue("exception thrown", thrown); [EOL] [EOL] final String expectedOutputPath = StringUtils.join(File.separator, [EOL] new String[] {LOCAL_DIR, "output", "file.out"}); [EOL] final String expectedOutputIndexPath = StringUtils.join(File.separator, [EOL] new String[] {LOCAL_DIR, "output", "file.out.index"}); [EOL] final String expectedSpillPath = StringUtils.join(File.separator, [EOL] new String[] {LOCAL_DIR, "output", "spill0.out"}); [EOL] [EOL] final String outputPath = handler.onCall( [EOL] NativeCollectorOnlyHandler.GET_OUTPUT_PATH, null).readString(); [EOL] Assert.assertEquals(expectedOutputPath, outputPath); [EOL] [EOL] final String outputIndexPath = handler.onCall( [EOL] NativeCollectorOnlyHandler.GET_OUTPUT_INDEX_PATH, null).readString(); [EOL] Assert.assertEquals(expectedOutputIndexPath, outputIndexPath); [EOL] [EOL] final String spillPath = handler.onCall( [EOL] NativeCollectorOnlyHandler.GET_SPILL_PATH, null).readString(); [EOL] Assert.assertEquals(expectedSpillPath, spillPath); [EOL] } [EOL] private NativeCollectorOnlyHandler handler; [EOL] private INativeHandler nativeHandler; [EOL] private BufferPusher pusher; [EOL] private ICombineHandler combiner; [EOL] private TaskContext taskContext; [EOL] private static final String LOCAL_DIR = TestConstants.NATIVETASK_TEST_DIR + "/local"; [EOL]
@Test (timeout = 30000) [EOL] public void testComplexGet() throws IOException { [EOL] String rootDir = new File(System.getProperty( [EOL] "test.build.data", "/tmp")).getAbsolutePath(); [EOL] File testFile = null; [EOL] String processIdInFile = Shell.WINDOWS ? [EOL] " container_1353742680940_0002_01_000001 " : [EOL] " 23 "; [EOL] String expectedProcessId = processIdInFile.trim(); [EOL] try { [EOL] testFile = new File(rootDir, "temp.txt"); [EOL] PrintWriter fileWriter = new PrintWriter(testFile); [EOL] fileWriter.println(" "); [EOL] fileWriter.println(""); [EOL] fileWriter.println("abc"); [EOL] fileWriter.println("-123"); [EOL] fileWriter.println("-123 "); [EOL] fileWriter.println(processIdInFile); [EOL] fileWriter.println("6236"); [EOL] fileWriter.close(); [EOL] String processId = null; [EOL] [EOL] processId = ProcessIdFileReader.getProcessId( [EOL] new Path(rootDir + Path.SEPARATOR + "temp.txt")); [EOL] Assert.assertEquals(expectedProcessId, processId); [EOL] [EOL] } finally { [EOL] if (testFile != null [EOL] && testFile.exists()) { [EOL] testFile.delete(); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void testRollingMonitorIntervalGreaterThanSet() { [EOL] this.conf.set(YarnConfiguration.MIN_LOG_ROLLING_INTERVAL_SECONDS, "1800"); [EOL] this.conf.set(YarnConfiguration [EOL] .NM_LOG_AGGREGATION_ROLL_MONITORING_INTERVAL_SECONDS, "2700"); [EOL] LogAggregationService logAggregationService = [EOL] new LogAggregationService(dispatcher, this.context, this.delSrvc, [EOL] super.dirsHandler); [EOL] logAggregationService.init(this.conf); [EOL] [EOL] long interval = logAggregationService.getRollingMonitorInterval(); [EOL] assertEquals(2700L, interval); [EOL] } [EOL] private Map<ApplicationAccessType, String> acls = createAppAcls(); [EOL] private static final String[] EMPTY_FILES = new String[] {"zero"}; [EOL] private static RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private File remoteRootLogDir = new File("target", this.getClass() [EOL] .getName() + "-remoteLogDir"); [EOL] DrainDispatcher dispatcher; [EOL] EventHandler<Event> appEventHandler; [EOL] private NodeId nodeId = NodeId.newInstance("0.0.0.0", 5555); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.removeEndIgnoreCase("NIa|", ""); [EOL]        [EOL]       String string1 = StringUtils.join((long[]) null, '_'); [EOL]        [EOL]       boolean boolean0 = StringUtils.endsWithIgnoreCase("NIa|", (CharSequence) null); [EOL]        [EOL]       String string2 = StringUtils.chop(""); [EOL]        [EOL]       String string3 = StringUtils.substring((String) null, Integer.MAX_VALUE, Integer.MAX_VALUE); [EOL]        [EOL]       String string4 = StringUtils.chomp("Array element "); [EOL]        [EOL]       String string5 = StringUtils.repeat("The Character must not be null", 4517); [EOL]        [EOL]       short[] shortArray0 = new short[1]; [EOL]       shortArray0[0] = (short)0; [EOL]       String string6 = StringUtils.join(shortArray0, '_', Integer.MAX_VALUE, (int) (short)0); [EOL]       assertEquals(1, shortArray0.length); [EOL]        [EOL]       ArrayDeque<CharBuffer> arrayDeque0 = new ArrayDeque<CharBuffer>(); [EOL]        [EOL]       Iterator<CharBuffer> iterator0 = arrayDeque0.descendingIterator(); [EOL]        [EOL]       String string7 = StringUtils.join(iterator0, '_'); [EOL]        [EOL]       char[] charArray0 = new char[5]; [EOL]       charArray0[0] = '_'; [EOL]       charArray0[1] = '_'; [EOL]       charArray0[2] = '_'; [EOL]       charArray0[3] = '_'; [EOL]       charArray0[4] = '_'; [EOL]       String string8 = StringUtils.join(charArray0, '_', (-1752), (-3540)); [EOL]       assertEquals(5, charArray0.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCreateReservation() { [EOL] ResourceManager rm = setupResourceManager(); [EOL] ClientRMService clientService = rm.getClientRMService(); [EOL] Clock clock = new UTCClock(); [EOL] long arrival = clock.getTime(); [EOL] long duration = 60000; [EOL] long deadline = (long) (arrival + 1.05 * duration); [EOL] ReservationSubmissionRequest sRequest = [EOL] submitReservationTestHelper(clientService, arrival, deadline, duration); [EOL] [EOL] // Submit the reservation again with the same request and make sure it [EOL] // passes. [EOL] try { [EOL] clientService.submitReservation(sRequest); [EOL] } catch (Exception e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] [EOL] // Submit the reservation with the same reservation id but different [EOL] // reservation definition, and ensure YarnException is thrown. [EOL] arrival = clock.getTime(); [EOL] ReservationDefinition rDef = sRequest.getReservationDefinition(); [EOL] rDef.setArrival(arrival + duration); [EOL] sRequest.setReservationDefinition(rDef); [EOL] try { [EOL] clientService.submitReservation(sRequest); [EOL] Assert.fail("Reservation submission should fail if a duplicate " [EOL] + "reservation id is used, but the reservation definition has been " [EOL] + "updated."); [EOL] } catch (Exception e) { [EOL] Assert.assertTrue(e instanceof YarnException); [EOL] } [EOL] [EOL] rm.stop(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestClientRMService.class); [EOL] private RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private String appType = "MockApp"; [EOL] private final static String QUEUE_1 = "Q-1"; [EOL] private final static String QUEUE_2 = "Q-2"; [EOL] private final static String APPLICATION_TAG_SC_PREPROCESSOR ="mytag:foo"; [EOL] private File resourceTypesFile = null; [EOL]
@Test [EOL] public void testAddReservation() { [EOL] Plan plan = new InMemoryPlan(queueMetrics, policy, agent, totalCapacity, 1L, [EOL] resCalc, minAlloc, maxAlloc, planName, replanner, true, context); [EOL] ReservationId reservationID = [EOL] ReservationSystemTestUtil.getNewReservationId(); [EOL] int[] alloc = { 10, 10, 10, 10, 10, 10 }; [EOL] int start = 100; [EOL] ReservationAllocation rAllocation = [EOL] createReservationAllocation(reservationID, start, alloc); [EOL] Assert.assertNull(plan.getReservationById(reservationID)); [EOL] try { [EOL] plan.addReservation(rAllocation, false); [EOL] } catch (PlanningException e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] doAssertions(plan, rAllocation); [EOL] checkAllocation(plan, alloc, start, 0); [EOL] } [EOL] private String user = "yarn"; [EOL] private String planName = "test-reservation"; [EOL] private ResourceCalculator resCalc; [EOL] private Resource minAlloc; [EOL] private Resource maxAlloc; [EOL] private Resource totalCapacity; [EOL] private Clock clock; [EOL] private QueueMetrics queueMetrics; [EOL] private SharingPolicy policy; [EOL] private ReservationAgent agent; [EOL] private Planner replanner; [EOL] private RMContext context; [EOL] private long maxPeriodicity; [EOL]
@Test [EOL] public void testAllocationIncrementMemoryNonDefaultUnit() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RESOURCE_TYPES + "." + [EOL] ResourceInformation.MEMORY_MB.getName() + [EOL] FairSchedulerConfiguration.INCREMENT_ALLOCATION, "1 Gi"); [EOL] FairSchedulerConfiguration fsc = new FairSchedulerConfiguration(conf); [EOL] Resource minimum = Resources.createResource(0L, 0); [EOL] Resource maximum = [EOL] Resources.createResource(Long.MAX_VALUE, Integer.MAX_VALUE); [EOL] Resource increment = fsc.getIncrementAllocation(); [EOL] DominantResourceCalculator resourceCalculator = [EOL] new DominantResourceCalculator(); [EOL] assertEquals(1024L, resourceCalculator.normalize( [EOL] Resources.createResource(1023L), minimum, maximum, increment) [EOL] .getMemorySize()); [EOL] assertEquals(1024L, resourceCalculator.normalize( [EOL] Resources.createResource(1024L), minimum, maximum, increment) [EOL] .getMemorySize()); [EOL] assertEquals(2048L, resourceCalculator.normalize( [EOL] Resources.createResource(1025L), minimum, maximum, increment) [EOL] .getMemorySize()); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveElement()  throws Throwable  { [EOL]       int[] intArray0 = new int[18]; [EOL]       int[] intArray1 = ArrayUtils.removeElements(intArray0, intArray0); [EOL]       assertEquals(0, intArray1.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testLocalBCFKSProvider() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] final Path ksPath = new Path(tmpDir.toString(), "test.bcfks"); [EOL] final String ourUrl = LocalBouncyCastleFipsKeyStoreProvider.SCHEME_NAME + [EOL] "://file" + ksPath.toUri(); [EOL] conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, ourUrl); [EOL] [EOL] exception.expect(IOException.class); [EOL] exception.expectMessage("Can't create keystore"); [EOL] List<CredentialProvider> providers = [EOL] CredentialProviderFactory.getProviders(conf); [EOL] assertTrue("BCFKS needs additional JDK setup", providers.isEmpty()); [EOL] } [EOL] public static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCredentialProviderFactory.class); [EOL] @Rule [EOL] public final TestName test = new TestName(); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL] private static char[] chars = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', [EOL] 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', [EOL] 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', [EOL] 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', [EOL] '2', '3', '4', '5', '6', '7', '8', '9',}; [EOL] private static final File tmpDir = GenericTestUtils.getTestDir("creds"); [EOL]
@Test(timeout = 4000) [EOL]   public void testfloatValue()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getFraction(2374, 0, 2374); [EOL]       Fraction fraction1 = Fraction.getReducedFraction(0, 2374); [EOL]       Fraction fraction2 = fraction0.ONE_HALF.multiplyBy(fraction1); [EOL]       assertEquals(2374.0F, fraction0.floatValue(), 0.01F); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetMatchingAccessibleConstructor()  throws Throwable  { [EOL]       Class<Annotation> class0 = Annotation.class; [EOL]       Class<Object>[] classArray0 = (Class<Object>[]) Array.newInstance(Class.class, 0); [EOL]       Constructor<Annotation> constructor0 = ConstructorUtils.getMatchingAccessibleConstructor(class0, (Class<?>[]) classArray0); [EOL]       assertNull(constructor0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetInfoServer() throws IOException, URISyntaxException { [EOL] HdfsConfiguration conf = new HdfsConfiguration(); [EOL] [EOL] URI httpsport = DFSUtil.getInfoServer(null, conf, "https"); [EOL] assertEquals(new URI("https", null, "0.0.0.0", [EOL] DFS_NAMENODE_HTTPS_PORT_DEFAULT, null, null, null), httpsport); [EOL] [EOL] URI httpport = DFSUtil.getInfoServer(null, conf, "http"); [EOL] assertEquals(new URI("http", null, "0.0.0.0", [EOL] DFS_NAMENODE_HTTP_PORT_DEFAULT, null, null, null), httpport); [EOL] [EOL] URI httpAddress = DFSUtil.getInfoServer(new InetSocketAddress( [EOL] "localhost", 8020), conf, "http"); [EOL] assertEquals( [EOL] URI.create("http://localhost:" + DFS_NAMENODE_HTTP_PORT_DEFAULT), [EOL] httpAddress); [EOL] } [EOL] static final String NS1_NN_ADDR = "ns1-nn.example.com:8020"; [EOL] static final String NS1_NN1_ADDR = "ns1-nn1.example.com:8020"; [EOL] static final String NS1_NN2_ADDR = "ns1-nn2.example.com:8020"; [EOL] static final String NS1_NN1_HTTPS_ADDR = "ns1-nn1.example.com:50740"; [EOL] static final String NS1_NN1_HTTP_ADDR = "ns1-nn1.example.com:50070"; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       int int0 = 107; [EOL]       StrBuilder strBuilder0 = new StrBuilder(107); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       int int1 = 0; [EOL]       StrBuilder strBuilder1 = strBuilder0.insert(0, false); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.trimMatcher(); [EOL]        [EOL]       char char0 = 'w'; [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher('w'); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(""); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       StrMatcher strMatcher3 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       int int2 = strBuilder0.indexOf(strMatcher0, (-2284)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       IntStream intStream0 = strBuilder0.codePoints(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln(289); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.deleteAll(strMatcher1); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.deleteCharAt(1027); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 1027 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(false); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder2 = strBuilder0.insert(0, (String) null); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       Writer writer0 = strBuilder2.asWriter(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher(':'); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("vSi.a.bur[", 3954); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.trim(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       int int1 = 6; [EOL]       StrBuilder strBuilder5 = strBuilder3.append(6); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strMatcher0.isMatch(charArray0, 3954); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 60000) [EOL] public void testRequestWithInvalidAuthorization() throws Exception { [EOL] HttpServletRequest request = Mockito.mock(HttpServletRequest.class); [EOL] HttpServletResponse response = Mockito.mock(HttpServletResponse.class); [EOL] [EOL] final Base64 base64 = new Base64(0); [EOL] String credentials = "bjones:invalidpassword"; [EOL] Mockito.when(request.getHeader(AUTHORIZATION_HEADER)) [EOL] .thenReturn(base64.encodeToString(credentials.getBytes())); [EOL] Assert.assertNull(handler.authenticate(request, response)); [EOL] Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER, BASIC); [EOL] Mockito.verify(response).addHeader(WWW_AUTHENTICATE_HEADER, NEGOTIATE); [EOL] Mockito.verify(response).setStatus(HttpServletResponse.SC_UNAUTHORIZED); [EOL] } [EOL] private KerberosSecurityTestcase krbTest = new KerberosSecurityTestcase(); [EOL] private MultiSchemeAuthenticationHandler handler; [EOL]
@Test [EOL] public void testGetUDDIClientRandom() throws Exception { [EOL] System.out.println("testGetUDDIClientRandom"); [EOL] [EOL] String random = UUID.randomUUID().toString(); [EOL] ServletContext req = createNiceMock(ServletContext.class); [EOL] req.setAttribute(UDDI_CLIENT_NAME, random); [EOL] req.setAttribute(JUDDI_CLIENT_NAME, null); [EOL] expect(req.getInitParameter(WebHelper.JUDDI_CLIENT_NAME)).andReturn(null).times(0, 1); [EOL] expect(req.getInitParameter(WebHelper.UDDI_CLIENT_NAME)).andReturn(random).times(0, 1); [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] //using default config [EOL] // expect(req.getInitParameter(WebHelper.UDDI_CLIENT_NAME)).andReturn(null).times(0, 2); [EOL] // expect(req.getInitParameter(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(null).times(0, 2); [EOL] // expect(req.getInitParameter(WebHelper.JUDDI_CLIENT_TRANSPORT)).andReturn(null).times(0, 2); [EOL] //expect(req.getAttribute(WebHelper.JUDDI_CLIENT_NAME)).andReturn(null).times(0, 2); [EOL] //using default config [EOL] // expect(req.getAttribute(WebHelper.UDDI_CLIENT_NAME)).andReturn(null).times(0, 2); [EOL] //expect(req.getAttribute(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(null).times(0, 2); [EOL] //expect(req.getAttribute(WebHelper.JUDDI_CLIENT_TRANSPORT)).andReturn(null).times(0, 2); [EOL] [EOL] replay(req); [EOL] [EOL] UDDIClient result = WebHelper.getUDDIClient(req); [EOL] Assert.assertNotNull(result); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendNull(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StringBuffer stringBuffer0 = strBuilder1.toStringBuffer(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       String string0 = strBuilder0.toString(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       boolean boolean0 = strBuilder1.isEmpty(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testread()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("hZ3CNnc|]e"); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-963), 104, '/'); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.tabMatcher(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.deleteAll(strMatcher0); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = '/'; [EOL]       charArray0[1] = '/'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       Buffer buffer0 = charBuffer0.flip(); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       strBuilder_StrBuilderReader0.close(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append((long) 104); [EOL]        [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       TreeSet<Object> treeSet0 = new TreeSet<Object>(comparator0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.appendWithSeparators((Iterable<?>) treeSet0, "hZ3CNnc|]e"); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.ensureCapacity(104); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]        [EOL]       List<String> list0 = strBuilder_StrBuilderTokenizer0.tokenize(charArray0, (-963), (-3316)); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder1.replaceFirst(strMatcher0, "Windows NT"); [EOL]        [EOL]       char[] charArray1 = new char[2]; [EOL]        [EOL]       charArray1[0] = '/'; [EOL]       charArray1[1] = '/'; [EOL]       StrBuilder strBuilder7 = strBuilder0.appendln(charArray1); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln("hZ3CNnc|]e", 121, 97); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testis()  throws Throwable  { [EOL]       Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(0).when(comparator0).compare(anyString() , anyString()); [EOL]       Range<String> range0 = Range.is("", comparator0); [EOL]       boolean boolean0 = range0.equals(""); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout=10000) [EOL] public void testReadLock() throws Exception { [EOL] String testname = name.getMethodName(); [EOL] InstrumentedReadWriteLock readWriteLock = new InstrumentedReadWriteLock( [EOL] true, testname, LOG, 2000, 300); [EOL] final AutoCloseableLock readLock = new AutoCloseableLock( [EOL] readWriteLock.readLock()); [EOL] final AutoCloseableLock writeLock = new AutoCloseableLock( [EOL] readWriteLock.writeLock()); [EOL] try (AutoCloseableLock lock = readLock.acquire()) { [EOL] Thread competingReadThread = new Thread() { [EOL] @Override [EOL] public void run() { [EOL] assertTrue(readLock.tryLock()); [EOL] readLock.release(); [EOL] } [EOL] }; [EOL] competingReadThread.start(); [EOL] competingReadThread.join(); [EOL] Thread competingWriteThread = new Thread() { [EOL] @Override [EOL] public void run() { [EOL] assertFalse(writeLock.tryLock()); [EOL] } [EOL] }; [EOL] competingWriteThread.start(); [EOL] competingWriteThread.join(); [EOL] } [EOL] } [EOL] static final Logger LOG = LoggerFactory.getLogger( [EOL] TestInstrumentedReadWriteLock.class); [EOL] @Rule [EOL] public TestName name = new TestName(); [EOL]
@Test(expected=IllegalArgumentException.class) [EOL] public void testAddStorageWithDifferentBlock() throws Exception { [EOL] BlockInfo blockInfo1 = new BlockInfoContiguous(new Block(1000L), (short) 3); [EOL] BlockInfo blockInfo2 = new BlockInfoContiguous(new Block(1001L), (short) 3); [EOL] [EOL] final DatanodeStorageInfo storage = DFSTestUtil.createDatanodeStorageInfo( [EOL] "storageID", "127.0.0.1"); [EOL] blockInfo1.addStorage(storage, blockInfo2); [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger("org.apache.hadoop.hdfs.TestBlockInfo"); [EOL]
@Test(timeout = 4000) [EOL]   public void testavailableLocaleList()  throws Throwable  { [EOL]       List<Locale> list0 = LocaleUtils.availableLocaleList(); [EOL]       assertEquals(160, list0.size()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testShouldCopy() { [EOL] Assert.assertTrue(new TrueCopyFilter().shouldCopy(new Path("fake"))); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testsetFieldSeparatorAtStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.setFieldSeparatorAtStart(true); [EOL]       boolean boolean0 = standardToStringStyle0.isFieldSeparatorAtStart(); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveElements()  throws Throwable  { [EOL]       double[] doubleArray0 = new double[0]; [EOL]       double[] doubleArray1 = ArrayUtils.removeElements(doubleArray0, doubleArray0); [EOL]       assertEquals(0, doubleArray1.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSuccessfulBaseCase() throws Exception { [EOL] removeStandbyNameDirs(); [EOL] [EOL] // skip the first NN, its up [EOL] for (int index = 1; index < maxNNCount; index++) { [EOL] try { [EOL] cluster.restartNameNode(index); [EOL] fail("Did not throw"); [EOL] } catch (IOException ioe) { [EOL] GenericTestUtils.assertExceptionContains( [EOL] "storage directory does not exist or is not accessible", ioe); [EOL] } [EOL] [EOL] int expectedCheckpointTxId = (int)NameNodeAdapter.getNamesystem(nn0) [EOL] .getFSImage().getMostRecentCheckpointTxId(); [EOL] [EOL] int rc = BootstrapStandby.run(new String[] { "-nonInteractive" }, [EOL] cluster.getConfiguration(index)); [EOL] assertEquals(0, rc); [EOL] [EOL] // Should have copied over the namespace from the active [EOL] FSImageTestUtil.assertNNHasCheckpoints(cluster, index, [EOL] ImmutableList.of(expectedCheckpointTxId)); [EOL] } [EOL] [EOL] // We should now be able to start the standbys successfully. [EOL] restartNameNodesFromIndex(1); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestBootstrapStandby.class); [EOL] private static final int maxNNCount = 3; [EOL] private static final int STARTING_PORT = 20000; [EOL] private MiniDFSCluster cluster; [EOL] private NameNode nn0; [EOL]
@Test [EOL] public void testRemoteRootLogDirIsCreatedWithCorrectGroupOwner() [EOL] throws IOException { [EOL] this.conf.set(YarnConfiguration.NM_LOG_DIRS, localLogDir.getAbsolutePath()); [EOL] Path aNewFile = new Path(String.valueOf("tmp"+System.currentTimeMillis())); [EOL] this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR, aNewFile.getName()); [EOL] [EOL] LogAggregationService logAggregationService = new LogAggregationService( [EOL] dispatcher, this.context, this.delSrvc, super.dirsHandler); [EOL] logAggregationService.init(this.conf); [EOL] logAggregationService.start(); [EOL] [EOL] ApplicationId appId = ApplicationId.newInstance( [EOL] System.currentTimeMillis(), 1); [EOL] LogAggregationContext contextWithAMAndFailed = [EOL] Records.newRecord(LogAggregationContext.class); [EOL] contextWithAMAndFailed.setLogAggregationPolicyClassName( [EOL] AMOrFailedContainerLogAggregationPolicy.class.getName()); [EOL] logAggregationService.handle(new LogHandlerAppStartedEvent(appId, [EOL] this.user, null, this.acls, contextWithAMAndFailed)); [EOL] dispatcher.await(); [EOL] [EOL] String targetGroup = [EOL] UserGroupInformation.getLoginUser().getPrimaryGroupName(); [EOL] FileSystem fs = FileSystem.get(this.conf); [EOL] FileStatus fileStatus = fs.getFileStatus(aNewFile); [EOL] Assert.assertEquals("The new aggregate file is not successfully created", [EOL] fileStatus.getGroup(), targetGroup); [EOL] [EOL] fs.delete(aNewFile, true); [EOL] logAggregationService.stop(); [EOL] } [EOL] private Map<ApplicationAccessType, String> acls = createAppAcls(); [EOL] private static final String[] EMPTY_FILES = new String[] {"zero"}; [EOL] private static RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private File remoteRootLogDir = new File("target", this.getClass() [EOL] .getName() + "-remoteLogDir"); [EOL] DrainDispatcher dispatcher; [EOL] EventHandler<Event> appEventHandler; [EOL] private NodeId nodeId = NodeId.newInstance("0.0.0.0", 5555); [EOL]
@Test [EOL] public void testGetNode() { [EOL] [EOL] NodeInfo responseGet = interceptor.getNode("testGetNode"); [EOL] [EOL] Assert.assertNotNull(responseGet); [EOL] Assert.assertEquals(NUM_SUBCLUSTER - 1, responseGet.getLastHealthUpdate()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFederationInterceptorREST.class); [EOL] private final static int NUM_SUBCLUSTER = 4; [EOL] private static final int BAD_REQUEST = 400; [EOL] private static final int ACCEPTED = 202; [EOL] private static String user = "test-user"; [EOL] private TestableFederationInterceptorREST interceptor; [EOL] private MemoryFederationStateStore stateStore; [EOL] private FederationStateStoreTestUtil stateStoreUtil; [EOL] private List<SubClusterId> subClusters; [EOL]
@Test [EOL] public void testNamedLoggersWithoutSpecifiedPrimary() { [EOL] assertTrue(helper.record("foo", 0).shouldLog()); [EOL] assertTrue(helper.record("bar", 0).shouldLog()); [EOL] [EOL] assertFalse(helper.record("foo", LOG_PERIOD / 2).shouldLog()); [EOL] assertFalse(helper.record("bar", LOG_PERIOD / 2).shouldLog()); [EOL] [EOL] assertTrue(helper.record("foo", LOG_PERIOD).shouldLog()); [EOL] assertTrue(helper.record("bar", LOG_PERIOD).shouldLog()); [EOL] [EOL] assertFalse(helper.record("foo", (LOG_PERIOD * 3) / 2).shouldLog()); [EOL] assertFalse(helper.record("bar", (LOG_PERIOD * 3) / 2).shouldLog()); [EOL] [EOL] assertFalse(helper.record("bar", LOG_PERIOD * 2).shouldLog()); [EOL] assertTrue(helper.record("foo", LOG_PERIOD * 2).shouldLog()); [EOL] assertTrue(helper.record("bar", LOG_PERIOD * 2).shouldLog()); [EOL] } [EOL] private static final int LOG_PERIOD = 100; [EOL] private LogThrottlingHelper helper; [EOL] private FakeTimer timer; [EOL]
@Test [EOL] public void testInvalidUri2() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] String responseStr = ""; [EOL] try { [EOL] responseStr = r.accept(MediaType.APPLICATION_JSON).get(String.class); [EOL] fail("should have thrown exception on invalid uri"); [EOL] } catch (UniformInterfaceException ue) { [EOL] ClientResponse response = ue.getResponse(); [EOL] assertResponseStatusCode(Status.NOT_FOUND, response.getStatusInfo()); [EOL] WebServicesTestUtils.checkStringMatch( [EOL] "error string exists and shouldn't", "", responseStr); [EOL] } [EOL] } [EOL] private static final long NM_RESOURCE_VALUE = 1000L; [EOL] private static NodeManager.NMContext nmContext; [EOL] private static ResourceView resourceView; [EOL] private static ApplicationACLsManager aclsManager; [EOL] private static LocalDirsHandlerService dirsHandler; [EOL] private static WebApp nmWebApp; [EOL] private static final String LOGSERVICEWSADDR = "test:1234"; [EOL] private static final String LOG_MESSAGE = "log message\n"; [EOL] private static final File testRootDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName()); [EOL] private static File testLogDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName() + "LogDir"); [EOL] private static File testRemoteLogDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName() + "remote-log-dir"); [EOL]
@Test [EOL] public void testCreateServletException() throws IOException { [EOL] StringWriter writer = new StringWriter(); [EOL] PrintWriter printWriter = new PrintWriter(writer); [EOL] HttpServletResponse response = Mockito.mock(HttpServletResponse.class); [EOL] Mockito.when(response.getWriter()).thenReturn(printWriter); [EOL] int status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR; [EOL] Exception ex = new IOException("Hello IOEX"); [EOL] HttpExceptionUtils.createServletExceptionResponse(response, status, ex); [EOL] Mockito.verify(response).setStatus(status); [EOL] Mockito.verify(response).setContentType(Mockito.eq("application/json")); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Map json = mapper.readValue(writer.toString(), Map.class); [EOL] json = (Map) json.get(HttpExceptionUtils.ERROR_JSON); [EOL] Assert.assertEquals(IOException.class.getName(), [EOL] json.get(HttpExceptionUtils.ERROR_CLASSNAME_JSON)); [EOL] Assert.assertEquals(IOException.class.getSimpleName(), [EOL] json.get(HttpExceptionUtils.ERROR_EXCEPTION_JSON)); [EOL] Assert.assertEquals("Hello IOEX", [EOL] json.get(HttpExceptionUtils.ERROR_MESSAGE_JSON)); [EOL] } [EOL]
@Test(expected = FederationPolicyInitializationException.class) [EOL] public void nullConf() throws Exception { [EOL] context.setSubClusterPolicyConfiguration(null); [EOL] FederationPolicyInitializationContextValidator.validate(context, [EOL] MockPolicyManager.class.getCanonicalName()); [EOL] } [EOL] private SubClusterPolicyConfiguration goodConfig; [EOL] private SubClusterResolver goodSR; [EOL] private FederationStateStoreFacade goodFacade; [EOL] private SubClusterId goodHome; [EOL] private FederationPolicyInitializationContext context; [EOL]
@Test(timeout = 4000) [EOL]   public void testnext()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getCSVInstance(); [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setIgnoreEmptyTokens(false); [EOL]       assertEquals(0, strTokenizer1.nextIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetArrayEnd()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]        [EOL]       standardToStringStyle0.setNullText(""); [EOL]       assertEquals("}", standardToStringStyle0.getArrayEnd()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testWithNodeLabelUpdateEnabled() throws Exception { [EOL] conf.setLong(YarnConfiguration.RM_NODE_LABELS_PROVIDER_FETCH_INTERVAL_MS, [EOL] 1000); [EOL] MockRM rm = new MockRM(conf); [EOL] rm.init(conf); [EOL] rm.getRMContext().getRMDelegatedNodeLabelsUpdater().nodeLabelsUpdateInterval [EOL] = 3 * 1000; [EOL] rm.start(); [EOL] [EOL] RMNodeLabelsManager mgr = rm.getRMContext().getNodeLabelManager(); [EOL] mgr.addToCluserNodeLabelsWithDefaultExclusivity(ImmutableSet.of("x", "y")); [EOL] [EOL] NodeId nodeId = toNodeId("h1:1234"); [EOL] assertEquals(0, mgr.getLabelsOnNode(nodeId).size()); [EOL] updateNodeLabels(nodeId, "x"); [EOL] registerNode(rm, nodeId); [EOL] Thread.sleep(4000); [EOL] assertCollectionEquals(ImmutableSet.of("x"), mgr.getLabelsOnNode(nodeId)); [EOL] [EOL] // Ensure that node labels are updated if NodeLabelsProvider [EOL] // gives different labels [EOL] updateNodeLabels(nodeId, "y"); [EOL] Thread.sleep(4000); [EOL] assertCollectionEquals(ImmutableSet.of("y"), mgr.getLabelsOnNode(nodeId)); [EOL] [EOL] rm.stop(); [EOL] } [EOL] private YarnConfiguration conf; [EOL] private static Map<NodeId, Set<NodeLabel>> nodeLabelsMap = Maps.newHashMap(); [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       char[] charArray0 = new char[6]; [EOL]       int int0 = ArrayUtils.indexOf(charArray0, 'L'); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testget()  throws Throwable  { [EOL]       JavaVersion javaVersion0 = JavaVersion.get("1.2"); [EOL]       assertEquals(JavaVersion.JAVA_1_2, javaVersion0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetStringBuffer()  throws Throwable  { [EOL]       Object object0 = new Object(); [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.MULTI_LINE_STYLE; [EOL]       StringBuffer stringBuffer0 = new StringBuffer("Jj^%^wj"); [EOL]       ToStringBuilder toStringBuilder0 = new ToStringBuilder(object0, toStringStyle0, stringBuffer0); [EOL]       StringBuffer stringBuffer1 = toStringBuilder0.getStringBuffer(); [EOL]       assertEquals(29, stringBuffer1.length()); [EOL]   } [EOL]  [EOL]
@Test(expected = WebApplicationException.class) [EOL] public void testGetOpInfoJSON_NULL() { [EOL] System.out.println("getOpInfoJSON_NULL"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] OperationalInfo expResult = null; [EOL] OperationalInfo result = instance.getOpInfoJSON(id); [EOL] [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testsetTrimmerMatcher()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer("Invalid offset: ", "Invalid offset: "); [EOL]       StrMatcher strMatcher0 = StrMatcher.stringMatcher("Invalid offset: "); [EOL]       strTokenizer0.setQuoteMatcher(strMatcher0); [EOL]       strTokenizer0.setTrimmerMatcher(strMatcher0); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setDelimiterChar('%'); [EOL]       String[] stringArray0 = strTokenizer1.getTokenArray(); [EOL]       assertEquals(0, stringArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       assertEquals(0, compareToBuilder0.toComparison()); [EOL]        [EOL]       boolean[] booleanArray0 = new boolean[5]; [EOL]       booleanArray0[0] = true; [EOL]       boolean[] booleanArray1 = new boolean[5]; [EOL]       compareToBuilder0.append(booleanArray0, booleanArray1); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSubtract() { [EOL] assertEquals(createResource(1, 0), [EOL] subtract(createResource(2, 1), createResource(1, 1))); [EOL] assertEquals(createResource(0, 1), [EOL] subtract(createResource(1, 2), createResource(1, 1))); [EOL] assertEquals(createResource(2, 2, 0), [EOL] subtract(createResource(3, 3, 0), createResource(1, 1, 0))); [EOL] assertEquals(createResource(1, 1, 2), [EOL] subtract(createResource(2, 2, 3), createResource(1, 1, 1))); [EOL] } [EOL] private static final String INVALID_RESOURCE_MSG = "Invalid resource value"; [EOL] private static final String EXTRA_RESOURCE_TYPE = "resource2"; [EOL] private String resourceTypesFile; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetMiddle()  throws Throwable  { [EOL]       ImmutableTriple<Object, String, String> immutableTriple0 = ImmutableTriple.of((Object) null, "c(j,I&N$orhDD/xljLT", "c(j,I&N$orhDD/xljLT"); [EOL]       String string0 = immutableTriple0.getMiddle(); [EOL]       assertEquals("c(j,I&N$orhDD/xljLT", string0); [EOL]   } [EOL] } [EOL]
@Test [EOL] public void testGetSingleJobCounter() throws IOException { [EOL] appController.singleJobCounter(); [EOL] assertEquals(SingleCounterPage.class, appController.getClazz()); [EOL] } [EOL] private AppControllerForTest appController; [EOL] private RequestContext ctx; [EOL] private Job job; [EOL] private static final String taskId = "task_01_01_m_01"; [EOL]
@Test [EOL] public void testJoinElection() { [EOL] elector.joinElection(data); [EOL] Mockito.verify(mockZK, Mockito.times(1)).create(ZK_LOCK_NAME, data, [EOL] Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, elector, mockZK); [EOL] } [EOL] private ZooKeeper mockZK; [EOL] private int count; [EOL] private ActiveStandbyElectorCallback mockApp; [EOL] private final byte[] data = new byte[8]; [EOL] private ActiveStandbyElectorTester elector; [EOL] private static final String ZK_PARENT_NAME = "/parent/node"; [EOL] private static final String ZK_LOCK_NAME = ZK_PARENT_NAME + "/" + [EOL] ActiveStandbyElector.LOCK_FILENAME; [EOL] private static final String ZK_BREADCRUMB_NAME = ZK_PARENT_NAME + "/" + [EOL] ActiveStandbyElector.BREADCRUMB_FILENAME; [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]       byte[] byteArray0 = new byte[0]; [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.appendDetail(stringBuffer0, "", byteArray0); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtStart()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDefaultNamenode() throws IOException { [EOL] HdfsConfiguration conf = new HdfsConfiguration(); [EOL] final String hdfs_default = "hdfs://localhost:9999/"; [EOL] conf.set(FS_DEFAULT_NAME_KEY, hdfs_default); [EOL] // If DFS_FEDERATION_NAMESERVICES is not set, verify that [EOL] // default namenode address is returned. [EOL] Map<String, Map<String, InetSocketAddress>> addrMap = [EOL] DFSUtil.getNNServiceRpcAddresses(conf); [EOL] assertEquals(1, addrMap.size()); [EOL] [EOL] Map<String, InetSocketAddress> defaultNsMap = addrMap.get(null); [EOL] assertEquals(1, defaultNsMap.size()); [EOL] [EOL] assertEquals(9999, defaultNsMap.get(null).getPort()); [EOL] } [EOL] static final String NS1_NN_ADDR = "ns1-nn.example.com:8020"; [EOL] static final String NS1_NN1_ADDR = "ns1-nn1.example.com:8020"; [EOL] static final String NS1_NN2_ADDR = "ns1-nn2.example.com:8020"; [EOL] static final String NS1_NN1_HTTPS_ADDR = "ns1-nn1.example.com:50740"; [EOL] static final String NS1_NN1_HTTP_ADDR = "ns1-nn1.example.com:50070"; [EOL]
@Test [EOL] public void [EOL] testParseNewStyleResourceWithPercentagesCustomResourceNegativeWithSpaces() [EOL] throws Exception { [EOL] expectNegativeValueOfResource("test1"); [EOL] parseResourceConfigValue(" vcores = 2 , memory-mb = 5120 , test1 = -4 "); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.setSizeStartText((String) null); [EOL]       assertEquals("<size=", standardToStringStyle0.getSizeStartText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       Class<Annotation> class0 = Annotation.class; [EOL]       Annotation annotation0 = mock(Annotation.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn("qw)\"0^d").when(annotation0).toString(); [EOL]       doReturn(class0, class0).when(annotation0).annotationType(); [EOL]       String string0 = AnnotationUtils.toString(annotation0); [EOL]       assertNotNull(string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testTrailingSlashInInputPath() throws IOException { [EOL] // Check mount points beneath the path with trailing slash. [EOL] getMountPoints(true); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestMountTableResolver.class); [EOL] private static final int TEST_MAX_CACHE_SIZE = 10; [EOL] private MountTableResolver mountTable; [EOL]
@Test [EOL] public void testComputeAvailableContainers() throws Exception { [EOL] Resource clusterAvailableResources = Resource.newInstance(81920, 40); [EOL] [EOL] Resource nonZeroResource = Resource.newInstance(1024, 2); [EOL] [EOL] int expectedNumberOfContainersForMemory = 80; [EOL] int expectedNumberOfContainersForCPU = 20; [EOL] [EOL] verifyDifferentResourceTypes(clusterAvailableResources, nonZeroResource, [EOL] expectedNumberOfContainersForMemory, [EOL] expectedNumberOfContainersForCPU); [EOL] [EOL] Resource zeroMemoryResource = Resource.newInstance(0, [EOL] nonZeroResource.getVirtualCores()); [EOL] [EOL] verifyDifferentResourceTypes(clusterAvailableResources, zeroMemoryResource, [EOL] Integer.MAX_VALUE, [EOL] expectedNumberOfContainersForCPU); [EOL] [EOL] Resource zeroCpuResource = Resource.newInstance( [EOL] nonZeroResource.getMemorySize(), 0); [EOL] [EOL] verifyDifferentResourceTypes(clusterAvailableResources, zeroCpuResource, [EOL] expectedNumberOfContainersForMemory, [EOL] expectedNumberOfContainersForMemory); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtEnd()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getSummaryObjectStartText(); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtEnd()); [EOL]   } [EOL]  [EOL]
@Test (timeout = 30000) [EOL] public void testNoSideEffects() throws IOException { [EOL] assumeNotWindows(); [EOL] String dir = buildBufferDir(ROOT, 0); [EOL] try { [EOL] conf.set(CONTEXT, dir); [EOL] File result = dirAllocator.createTmpFileForWrite(FILENAME, -1, conf); [EOL] assertTrue(result.delete()); [EOL] assertTrue(result.getParentFile().delete()); [EOL] assertFalse(new File(dir).exists()); [EOL] } finally { [EOL] Shell.execCommand(Shell.getSetPermissionCommand("u+w", false, [EOL] BUFFER_DIR_ROOT)); [EOL] rmBufferDirs(); [EOL] } [EOL] } [EOL] final static private Configuration conf = new Configuration(); [EOL] final static private String BUFFER_DIR_ROOT = "build/test/temp"; [EOL] final static private String ABSOLUTE_DIR_ROOT; [EOL] final static private String QUALIFIED_DIR_ROOT; [EOL] final static private Path BUFFER_PATH_ROOT = new Path(BUFFER_DIR_ROOT); [EOL] final static private File BUFFER_ROOT = new File(BUFFER_DIR_ROOT); [EOL] final static private String CONTEXT = "mapred.local.dir"; [EOL] final static private String FILENAME = "block"; [EOL] final static private LocalDirAllocator dirAllocator = [EOL] new LocalDirAllocator(CONTEXT); [EOL] static LocalFileSystem localFs; [EOL] final static int SMALL_FILE_SIZE = 100; [EOL] final static private String RELATIVE = "/RELATIVE"; [EOL] final static private String ABSOLUTE = "/ABSOLUTE"; [EOL] final static private String QUALIFIED = "/QUALIFIED"; [EOL] final private String ROOT; [EOL] final private String PREFIX; [EOL] static final int TRIALS = 100; [EOL]
@Test [EOL] public void testListReservationsByTimeInterval() { [EOL] ResourceManager rm = setupResourceManager(); [EOL] ClientRMService clientService = rm.getClientRMService(); [EOL] Clock clock = new UTCClock(); [EOL] long arrival = clock.getTime(); [EOL] long duration = 60000; [EOL] long deadline = (long) (arrival + 1.05 * duration); [EOL] ReservationSubmissionRequest sRequest = [EOL] submitReservationTestHelper(clientService, arrival, deadline, duration); [EOL] [EOL] // List reservations, search by a point in time within the reservation [EOL] // range. [EOL] arrival = clock.getTime(); [EOL] ReservationId reservationID = sRequest.getReservationId(); [EOL] ReservationListRequest request = ReservationListRequest.newInstance( [EOL] ReservationSystemTestUtil.reservationQ, "", arrival + duration / 2, [EOL] arrival + duration / 2, true); [EOL] [EOL] ReservationListResponse response = null; [EOL] try { [EOL] response = clientService.listReservations(request); [EOL] } catch (Exception e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] Assert.assertNotNull(response); [EOL] Assert.assertEquals(1, response.getReservationAllocationState().size()); [EOL] Assert.assertEquals(response.getReservationAllocationState().get(0) [EOL] .getReservationId().getId(), reservationID.getId()); [EOL] // List reservations, search by time within reservation interval. [EOL] request = ReservationListRequest.newInstance( [EOL] ReservationSystemTestUtil.reservationQ, "", 1, Long.MAX_VALUE, true); [EOL] [EOL] response = null; [EOL] try { [EOL] response = clientService.listReservations(request); [EOL] } catch (Exception e) { [EOL] Assert.fail(e.getMessage()); [EOL] } [EOL] Assert.assertNotNull(response); [EOL] Assert.assertEquals(1, response.getReservationAllocationState().size()); [EOL] Assert.assertEquals(response.getReservationAllocationState().get(0) [EOL] .getReservationId().getId(), reservationID.getId()); [EOL] // Verify that the full resource allocations exist. [EOL] Assert.assertTrue(response.getReservationAllocationState().get(0) [EOL] .getResourceAllocationRequests().size() > 0); [EOL] [EOL] // Verify that the full RDL is returned. [EOL] ReservationRequests reservationRequests = [EOL] response.getReservationAllocationState().get(0) [EOL] .getReservationDefinition().getReservationRequests(); [EOL] Assert.assertEquals("R_ALL", [EOL] reservationRequests.getInterpreter().toString()); [EOL] Assert.assertTrue(reservationRequests.getReservationResources().get(0) [EOL] .getDuration() == duration); [EOL] [EOL] rm.stop(); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestClientRMService.class); [EOL] private RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private String appType = "MockApp"; [EOL] private final static String QUEUE_1 = "Q-1"; [EOL] private final static String QUEUE_2 = "Q-2"; [EOL] private final static String APPLICATION_TAG_SC_PREPROCESSOR ="mytag:foo"; [EOL] private File resourceTypesFile = null; [EOL]
@Test [EOL] public void testFromYarnJobReport() throws Exception { [EOL] int jobStartTime = 612354; [EOL] int jobFinishTime = 612355; [EOL] JobState state = JobState.RUNNING; [EOL] JobId jobId = Records.newRecord(JobId.class); [EOL] JobReport jobReport = Records.newRecord(JobReport.class); [EOL] ApplicationId applicationId = ApplicationId.newInstance(0, 0); [EOL] jobId.setAppId(applicationId); [EOL] jobId.setId(0); [EOL] jobReport.setJobId(jobId); [EOL] jobReport.setJobState(state); [EOL] jobReport.setStartTime(jobStartTime); [EOL] jobReport.setFinishTime(jobFinishTime); [EOL] jobReport.setUser("TestTypeConverter-user"); [EOL] jobReport.setJobPriority(Priority.newInstance(0)); [EOL] JobStatus jobStatus = TypeConverter.fromYarn(jobReport, "dummy-jobfile"); [EOL] Assert.assertEquals(jobStartTime, jobStatus.getStartTime()); [EOL] Assert.assertEquals(jobFinishTime, jobStatus.getFinishTime()); [EOL] Assert.assertEquals(state.toString(), jobStatus.getState().toString()); [EOL] Assert.assertEquals(JobPriority.DEFAULT, jobStatus.getPriority()); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("0rn@[CM"); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) strTokenizer0, "0rn@[CM"); [EOL]       assertEquals(27, strBuilder0.size()); [EOL]       assertEquals(27, strBuilder1.size()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '\\'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(charArray0); [EOL]       assertEquals(29, strBuilder0.size()); [EOL]       assertEquals(29, strBuilder1.size()); [EOL]       assertEquals(29, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertEquals(81, strBuilder0.size()); [EOL]       assertEquals(81, strBuilder1.size()); [EOL]       assertEquals(81, strBuilder2.size()); [EOL]       assertEquals(81, strBuilder3.size()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.setLength(2822); [EOL]       assertEquals(2822, strBuilder0.size()); [EOL]       assertEquals(2822, strBuilder4.size()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder4; [EOL]       objectArray0[1] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) '\\'; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       StrBuilder strBuilder5 = strBuilder4.appendAll(objectArray0); [EOL]       assertEquals(3005, strBuilder0.size()); [EOL]       assertEquals(3005, strBuilder4.size()); [EOL]       assertEquals(3005, strBuilder5.size()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(strBuilder1, 0, 2822); [EOL]       assertEquals(5828, strBuilder0.size()); [EOL]       assertEquals(5828, strBuilder1.size()); [EOL]       assertEquals(5828, strBuilder6.size()); [EOL]        [EOL]       int int0 = strBuilder6.lastIndexOf("0rn@[CM"); [EOL]       assertEquals(5828, strBuilder0.size()); [EOL]       assertEquals(5828, strBuilder1.size()); [EOL]       assertEquals(5828, strBuilder6.size()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.append(false); [EOL]       assertEquals(5833, strBuilder7.size()); [EOL]       assertEquals(5833, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.appendln(1490.882886748184); [EOL]       assertEquals(5851, strBuilder0.size()); [EOL]       assertEquals(5851, strBuilder8.size()); [EOL]       assertEquals(5851, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder6.append(strBuilder3, 0, 2822); [EOL]       assertEquals(8673, strBuilder0.size()); [EOL]       assertEquals(8673, strBuilder9.size()); [EOL]       assertEquals(8673, strBuilder1.size()); [EOL]       assertEquals(8673, strBuilder2.size()); [EOL]       assertEquals(8673, strBuilder3.size()); [EOL]       assertEquals(8673, strBuilder6.size()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder5.new StrBuilderReader(); [EOL]       assertEquals(8673, strBuilder0.size()); [EOL]       assertEquals(8673, strBuilder4.size()); [EOL]       assertEquals(8673, strBuilder5.size()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder_StrBuilderReader0.read(charArray0, (-2133), (-915)); [EOL]         fail("Expecting exception: IndexOutOfBoundsException"); [EOL]        [EOL]       } catch(IndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder$StrBuilderReader", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test (timeout = 15000) [EOL] public void testFetchFinishedApplictionLogs() throws Exception { [EOL] String remoteLogRootDir = "target/logs/"; [EOL] conf.setBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED, true); [EOL] conf [EOL] .set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR, remoteLogRootDir); [EOL] conf.setBoolean(YarnConfiguration.YARN_ACL_ENABLE, true); [EOL] conf.set(YarnConfiguration.YARN_ADMIN_ACL, "admin"); [EOL] FileSystem fs = FileSystem.get(conf); [EOL] [EOL] UserGroupInformation ugi = UserGroupInformation.getCurrentUser(); [EOL] ApplicationId appId = ApplicationId.newInstance(0, 1); [EOL] ApplicationAttemptId appAttemptId1 = [EOL] ApplicationAttemptId.newInstance(appId, 1); [EOL] ApplicationAttemptId appAttemptId2 = [EOL] ApplicationAttemptId.newInstance(appId, 2); [EOL] ContainerId containerId0 = ContainerId.newContainerId(appAttemptId1, 0); [EOL] ContainerId containerId1 = ContainerId.newContainerId(appAttemptId1, 1); [EOL] ContainerId containerId2 = ContainerId.newContainerId(appAttemptId1, 2); [EOL] ContainerId containerId3 = ContainerId.newContainerId(appAttemptId2, 3); [EOL] final NodeId nodeId = NodeId.newInstance("localhost", 1234); [EOL] [EOL] // create local logs [EOL] String rootLogDir = "target/LocalLogs"; [EOL] Path rootLogDirPath = new Path(rootLogDir); [EOL] if (fs.exists(rootLogDirPath)) { [EOL] fs.delete(rootLogDirPath, true); [EOL] } [EOL] assertTrue(fs.mkdirs(rootLogDirPath)); [EOL] [EOL] Path appLogsDir = new Path(rootLogDirPath, appId.toString()); [EOL] if (fs.exists(appLogsDir)) { [EOL] fs.delete(appLogsDir, true); [EOL] } [EOL] assertTrue(fs.mkdirs(appLogsDir)); [EOL] [EOL] List<String> rootLogDirs = Arrays.asList(rootLogDir); [EOL] [EOL] List<String> logTypes = new ArrayList<String>(); [EOL] logTypes.add("syslog"); [EOL] // create container logs in localLogDir [EOL] createContainerLogInLocalDir(appLogsDir, containerId1, fs, logTypes, [EOL] ImmutableList.of("empty")); [EOL] createContainerLogInLocalDir(appLogsDir, containerId2, fs, logTypes, [EOL] Collections.emptyList()); [EOL] // create two logs for container3 in localLogDir [EOL] logTypes.add("stdout"); [EOL] logTypes.add("stdout1234"); [EOL] createContainerLogInLocalDir(appLogsDir, containerId3, fs, logTypes, [EOL] Collections.emptyList()); [EOL] [EOL] Path path = [EOL] new Path(remoteLogRootDir + ugi.getShortUserName() [EOL] + "/bucket-logs-tfile/0001/application_0_0001"); [EOL] if (fs.exists(path)) { [EOL] fs.delete(path, true); [EOL] } [EOL] assertTrue(fs.mkdirs(path)); [EOL] [EOL] // upload container logs into remote directory [EOL] // the first two logs is empty. When we try to read first two logs, [EOL] // we will meet EOF exception, but it will not impact other logs. [EOL] // Other logs should be read successfully. [EOL] uploadEmptyContainerLogIntoRemoteDir(ugi, conf, rootLogDirs, nodeId, [EOL] containerId0, path, fs); [EOL] uploadEmptyContainerLogIntoRemoteDir(ugi, conf, rootLogDirs, nodeId, [EOL] containerId1, path, fs); [EOL] uploadContainerLogIntoRemoteDir(ugi, conf, rootLogDirs, nodeId, [EOL] containerId1, path, fs); [EOL] uploadContainerLogIntoRemoteDir(ugi, conf, rootLogDirs, nodeId, [EOL] containerId2, path, fs); [EOL] uploadContainerLogIntoRemoteDir(ugi, conf, rootLogDirs, nodeId, [EOL] containerId3, path, fs); [EOL] [EOL] YarnClient mockYarnClient = [EOL] createMockYarnClient( [EOL] YarnApplicationState.FINISHED, ugi.getShortUserName()); [EOL] LogsCLI cli = new LogsCLIForTest(mockYarnClient) { [EOL] @Override [EOL] public ContainerReport getContainerReport(String containerIdStr) [EOL] throws YarnException, IOException { [EOL] ContainerReport mockReport = mock(ContainerReport.class); [EOL] doReturn(nodeId).when(mockReport).getAssignedNode(); [EOL] doReturn("http://localhost:2345").when(mockReport).getNodeHttpAddress(); [EOL] return mockReport; [EOL] } [EOL] }; [EOL] cli.setConf(conf); [EOL] [EOL] int exitCode = cli.run(new String[] { "-applicationId", appId.toString() }); [EOL] LOG.info(sysOutStream.toString()); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] // Check fetching data for application attempt with applicationId defined [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-applicationAttemptId", appAttemptId1.toString()}); [EOL] LOG.info(sysOutStream.toString()); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] // Check fetching data for application attempt without application defined [EOL] exitCode = cli.run(new String[] { [EOL] "-applicationAttemptId", appAttemptId1.toString()}); [EOL] LOG.info(sysOutStream.toString()); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files_pattern", ".*"}); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files", "*"}); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] int fullSize = sysOutStream.toByteArray().length; [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files", "stdout"}); [EOL] assertTrue(exitCode == 0); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] // Check backward compatibility for -logFiles [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-logFiles", "stdout"}); [EOL] assertTrue("Failed with -logFiles", exitCode == 0); [EOL] assertFalse("Failed with -logFiles", sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertFalse("Failed with -logFiles", sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertFalse("Failed with -logFiles", sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue("Failed with -logFiles", sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertFalse("Failed with -logFiles", sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertFalse("Failed with -logFiles", sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] // Check -log_files supercedes -logFiles [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files", "stdout", "-logFiles", "syslog"}); [EOL] assertTrue("Failed with -logFiles and -log_files", exitCode == 0); [EOL] assertFalse("Failed with -logFiles and -log_files", [EOL] sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertFalse("Failed with -logFiles and -log_files", [EOL] sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertFalse("Failed with -logFiles and -log_files", [EOL] sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue("Failed with -logFiles and -log_files", [EOL] sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertFalse("Failed with -logFiles and -log_files", [EOL] sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertFalse("Failed with -logFiles and -log_files", [EOL] sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files_pattern", "std*"}); [EOL] assertTrue(exitCode == 0); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId2, "syslog"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout1234"))); [EOL] assertFalse(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files", "123"}); [EOL] assertTrue(exitCode == -1); [EOL] assertTrue(sysErrStream.toString().contains( [EOL] "Can not find any log file matching the pattern: [123] " [EOL] + "for the application: " + appId.toString())); [EOL] sysErrStream.reset(); [EOL] [EOL] // specify the bytes which is larger than the actual file size, [EOL] // we would get the full logs [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-log_files", "*", "-size", "10000" }); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toByteArray().length == fullSize); [EOL] sysOutStream.reset(); [EOL] [EOL] // uploaded two logs for container1. The first log is empty. [EOL] // The second one is not empty. [EOL] // We can still successfully read logs for container1. [EOL] exitCode = [EOL] cli.run(new String[] { "-applicationId", appId.toString(), [EOL] "-nodeAddress", nodeId.toString(), "-containerId", [EOL] containerId1.toString() }); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId1, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains("LogLastModifiedTime")); [EOL] assertTrue(!sysOutStream.toString().contains( [EOL] "Logs for container " + containerId1.toString() [EOL] + " are not present in this log-file.")); [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-containerId", containerId3.toString(), "-log_files", "123" }); [EOL] assertTrue(exitCode == -1); [EOL] assertTrue(sysErrStream.toString().contains( [EOL] "Can not find any log file matching the pattern: [123] " [EOL] + "for the container: " + containerId3 [EOL] + " within the application: " + appId.toString())); [EOL] sysErrStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-containerId", containerId3.toString(), "-log_files", "stdout" }); [EOL] assertTrue(exitCode == 0); [EOL] int fullContextSize = sysOutStream.toByteArray().length; [EOL] String fullContext = sysOutStream.toString(); [EOL] sysOutStream.reset(); [EOL] [EOL] String logMessage = logMessage(containerId3, "stdout"); [EOL] int fileContentSize = logMessage.getBytes().length; [EOL] StringBuilder sb = new StringBuilder(); [EOL] String endOfFile = "End of LogType:stdout"; [EOL] sb.append("\n" + endOfFile + "\n"); [EOL] sb.append(StringUtils.repeat("*", endOfFile.length() + 50) [EOL] + "\n\n"); [EOL] int tailContentSize = sb.toString().length(); [EOL] // specify how many bytes we should get from logs [EOL] // specify a position number, it would get the first n bytes from [EOL] // container log [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-containerId", containerId3.toString(), "-log_files", "stdout", [EOL] "-size", "5"}); [EOL] assertTrue(exitCode == 0); [EOL] Assert.assertEquals(new String(logMessage.getBytes(), 0, 5), [EOL] new String(sysOutStream.toByteArray(), [EOL] (fullContextSize - fileContentSize - tailContentSize), 5)); [EOL] sysOutStream.reset(); [EOL] [EOL] // specify how many bytes we should get from an empty log [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-containerId", containerId1.toString(), "-log_files", "empty", [EOL] "-size", "5"}); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] createEmptyLog("empty"))); [EOL] sysOutStream.reset(); [EOL] [EOL] // specify a negative number, it would get the last n bytes from [EOL] // container log [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-containerId", containerId3.toString(), "-log_files", "stdout", [EOL] "-size", "-5"}); [EOL] assertTrue(exitCode == 0); [EOL] Assert.assertEquals(new String(logMessage.getBytes(), [EOL] logMessage.getBytes().length - 5, 5), [EOL] new String(sysOutStream.toByteArray(), [EOL] (fullContextSize - fileContentSize - tailContentSize), 5)); [EOL] sysOutStream.reset(); [EOL] [EOL] long negative = (fullContextSize + 1000) * (-1); [EOL] exitCode = cli.run(new String[] {"-applicationId", appId.toString(), [EOL] "-containerId", containerId3.toString(), "-log_files", "stdout", [EOL] "-size", Long.toString(negative)}); [EOL] assertTrue(exitCode == 0); [EOL] Assert.assertEquals(fullContext, sysOutStream.toString()); [EOL] sysOutStream.reset(); [EOL] [EOL] // Uploaded the empty log for container0. [EOL] // We should see the message showing the log for container0 [EOL] // are not present. [EOL] exitCode = [EOL] cli.run(new String[] { "-applicationId", appId.toString(), [EOL] "-nodeAddress", nodeId.toString(), "-containerId", [EOL] containerId0.toString() }); [EOL] assertTrue(exitCode == -1); [EOL] assertTrue(sysErrStream.toString().contains( [EOL] "Can not find any log file matching the pattern")); [EOL] sysErrStream.reset(); [EOL] [EOL] // uploaded two logs for container3. The first log is named as syslog. [EOL] // The second one is named as stdout. [EOL] exitCode = [EOL] cli.run(new String[] { "-applicationId", appId.toString(), [EOL] "-nodeAddress", nodeId.toString(), "-containerId", [EOL] containerId3.toString() }); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] sysOutStream.reset(); [EOL] [EOL] // set -log_files option as stdout [EOL] // should only print log with the name as stdout [EOL] exitCode = [EOL] cli.run(new String[] { "-applicationId", appId.toString(), [EOL] "-nodeAddress", nodeId.toString(), "-containerId", [EOL] containerId3.toString() , "-log_files", "stdout"}); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(!sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] sysOutStream.reset(); [EOL] [EOL] YarnClient mockYarnClientWithException = [EOL] createMockYarnClientWithException(); [EOL] cli = new LogsCLIForTest(mockYarnClientWithException); [EOL] cli.setConf(conf); [EOL] [EOL] exitCode = [EOL] cli.run(new String[] { "-applicationId", appId.toString(), [EOL] "-containerId", containerId3.toString() }); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] containerId3 + " on " + LogAggregationUtils.getNodeString(nodeId))); [EOL] sysOutStream.reset(); [EOL] [EOL] // The same should also work without the applicationId [EOL] exitCode = [EOL] cli.run(new String[] { "-containerId", containerId3.toString() }); [EOL] assertTrue(exitCode == 0); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "syslog"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] logMessage(containerId3, "stdout"))); [EOL] assertTrue(sysOutStream.toString().contains( [EOL] containerId3 + " on " + LogAggregationUtils.getNodeString(nodeId))); [EOL] sysOutStream.reset(); [EOL] [EOL] exitCode = cli.run(new String[] { "-containerId", "invalid_container" }); [EOL] assertTrue(exitCode == -1); [EOL] assertTrue(sysErrStream.toString().contains( [EOL] "Invalid ContainerId specified")); [EOL] sysErrStream.reset(); [EOL] [EOL] fs.delete(new Path(remoteLogRootDir), true); [EOL] fs.delete(new Path(rootLogDir), true); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLogsCLI.class); [EOL] ByteArrayOutputStream sysOutStream; [EOL] private PrintStream sysOut; [EOL] ByteArrayOutputStream sysErrStream; [EOL] private PrintStream sysErr; [EOL] private Configuration conf; [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitToBinary()  throws Throwable  { [EOL]       boolean[] booleanArray0 = Conversion.hexDigitToBinary('8'); [EOL]       assertEquals(4, booleanArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisSuccessful()  throws Throwable  { [EOL]       MultiBackgroundInitializer multiBackgroundInitializer0 = new MultiBackgroundInitializer(); [EOL]       MultiBackgroundInitializer.MultiBackgroundInitializerResults multiBackgroundInitializer_MultiBackgroundInitializerResults0 = multiBackgroundInitializer0.initialize(); [EOL]       boolean boolean0 = multiBackgroundInitializer_MultiBackgroundInitializerResults0.isSuccessful(); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testBecomeActiveBeforeServiceHealthy() throws Exception { [EOL] mockNoPriorActive(); [EOL] WatchedEvent mockEvent = Mockito.mock(WatchedEvent.class); [EOL] Mockito.when(mockEvent.getType()).thenReturn(Event.EventType.None); [EOL] // session expired should enter safe mode [EOL] // But for first time, before the SERVICE_HEALTY i.e. appData is set, [EOL] // should not enter the election. [EOL] Mockito.when(mockEvent.getState()).thenReturn(Event.KeeperState.Expired); [EOL] elector.processWatchEvent(mockZK, mockEvent); [EOL] // joinElection should not be called. [EOL] Mockito.verify(mockZK, Mockito.times(0)).create(ZK_LOCK_NAME, null, [EOL] Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, elector, mockZK); [EOL] } [EOL] private ZooKeeper mockZK; [EOL] private int count; [EOL] private ActiveStandbyElectorCallback mockApp; [EOL] private final byte[] data = new byte[8]; [EOL] private ActiveStandbyElectorTester elector; [EOL] private static final String ZK_PARENT_NAME = "/parent/node"; [EOL] private static final String ZK_LOCK_NAME = ZK_PARENT_NAME + "/" + [EOL] ActiveStandbyElector.LOCK_FILENAME; [EOL] private static final String ZK_BREADCRUMB_NAME = ZK_PARENT_NAME + "/" + [EOL] ActiveStandbyElector.BREADCRUMB_FILENAME; [EOL]
@Test [EOL] public void testResourceIsInUseHasAnActiveApp() throws Exception { [EOL] FileSystem fs = mock(FileSystem.class); [EOL] CleanerMetrics metrics = mock(CleanerMetrics.class); [EOL] SCMStore store = mock(SCMStore.class); [EOL] [EOL] FileStatus resource = mock(FileStatus.class); [EOL] when(resource.getPath()).thenReturn(new Path(ROOT + "/a/b/c/abc")); [EOL] // resource is stale [EOL] when(store.isResourceEvictable(isA(String.class), isA(FileStatus.class))) [EOL] .thenReturn(true); [EOL] // but still has appIds [EOL] when(store.removeResource(isA(String.class))).thenReturn(false); [EOL] [EOL] CleanerTask task = [EOL] createSpiedTask(fs, store, metrics, new ReentrantLock()); [EOL] [EOL] // process the resource [EOL] task.processSingleResource(resource); [EOL] [EOL] // metrics should record a processed file (but not delete) [EOL] verify(metrics).reportAFileProcess(); [EOL] verify(metrics, never()).reportAFileDelete(); [EOL] } [EOL] private static final String ROOT = [EOL] YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT; [EOL] private static final long SLEEP_TIME = [EOL] YarnConfiguration.DEFAULT_SCM_CLEANER_RESOURCE_SLEEP_MS; [EOL] private static final int NESTED_LEVEL = [EOL] YarnConfiguration.DEFAULT_SHARED_CACHE_NESTED_LEVEL; [EOL]
@Test [EOL] public void testNodeInABlacklistSubCluster() throws YarnException { [EOL] // Blacklist SubCluster3 [EOL] String subClusterToBlacklist = "subcluster3"; [EOL] // Remember the current value of subcluster3 [EOL] Float value = [EOL] getPolicyInfo().getRouterPolicyWeights().get(subClusterToBlacklist); [EOL] getPolicyInfo().getRouterPolicyWeights() [EOL] .put(new SubClusterIdInfo(subClusterToBlacklist), 0.0f); [EOL] initializePolicy(new YarnConfiguration()); [EOL] [EOL] FederationPoliciesTestUtil [EOL] .initializePolicyContext(getFederationPolicyContext(), getPolicy(), [EOL] getPolicyInfo(), getActiveSubclusters(), new Configuration()); [EOL] [EOL] List<ResourceRequest> requests = new ArrayList<ResourceRequest>(); [EOL] boolean relaxLocality = true; [EOL] requests.add(ResourceRequest [EOL] .newInstance(Priority.UNDEFINED, "node4", Resource.newInstance(10, 1), [EOL] 1, relaxLocality)); [EOL] requests.add(ResourceRequest [EOL] .newInstance(Priority.UNDEFINED, "rack1", Resource.newInstance(10, 1), [EOL] 1)); [EOL] requests.add(ResourceRequest [EOL] .newInstance(Priority.UNDEFINED, ResourceRequest.ANY, [EOL] Resource.newInstance(10, 1), 1)); [EOL] ApplicationSubmissionContext asc = ApplicationSubmissionContext [EOL] .newInstance(null, null, null, null, null, false, false, 0, [EOL] Resources.none(), null, false, null, null); [EOL] asc.setAMContainerResourceRequests(requests); [EOL] [EOL] try { [EOL] SubClusterId targetId = [EOL] ((FederationRouterPolicy) getPolicy()).getHomeSubcluster(asc, null); [EOL] // The selected subcluster HAS no to be the same as the one blacklisted. [EOL] Assert.assertNotEquals(targetId.getId(), subClusterToBlacklist); [EOL] } catch (FederationPolicyException e) { [EOL] Assert.fail(); [EOL] } [EOL] [EOL] // Set again the previous value for the other tests [EOL] getPolicyInfo().getRouterPolicyWeights() [EOL] .put(new SubClusterIdInfo(subClusterToBlacklist), value); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testmax()  throws Throwable  { [EOL]       long long0 = NumberUtils.max(373L, 0L, (-891L)); [EOL]       assertEquals(373L, long0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetRootCauseStackTrace()  throws Throwable  { [EOL]       MockThrowable mockThrowable0 = new MockThrowable(); [EOL]       MockThrowable mockThrowable1 = new MockThrowable("", mockThrowable0); [EOL]       mockThrowable0.initCause(mockThrowable1); [EOL]       String[] stringArray0 = ExceptionUtils.getRootCauseStackTrace(mockThrowable1); [EOL]       assertEquals(2, stringArray0.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testInvalidAccept() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] String responseStr = ""; [EOL] try { [EOL] responseStr = r.path("ws").path("v1").path("history") [EOL] .accept(MediaType.TEXT_PLAIN).get(String.class); [EOL] fail("should have thrown exception on invalid uri"); [EOL] } catch (UniformInterfaceException ue) { [EOL] ClientResponse response = ue.getResponse(); [EOL] assertResponseStatusCode(Status.INTERNAL_SERVER_ERROR, [EOL] response.getStatusInfo()); [EOL] WebServicesTestUtils.checkStringMatch( [EOL] "error string exists and shouldn't", "", responseStr); [EOL] } [EOL] } [EOL] private static Configuration conf = new Configuration(); [EOL] private static HistoryContext appContext; [EOL] private static HsWebApp webApp; [EOL]
@Test [EOL] public void testGetDomains() throws Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("timeline") [EOL] .path("domain") [EOL] .queryParam("owner", "owner_1") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] TimelineDomains domains = response.getEntity(TimelineDomains.class); [EOL] Assert.assertEquals(2, domains.getDomains().size()); [EOL] for (int i = 0; i < domains.getDomains().size(); ++i) { [EOL] verifyDomain(domains.getDomains().get(i), [EOL] i == 0 ? "domain_id_4" : "domain_id_1"); [EOL] } [EOL] } [EOL] private static TimelineStore store; [EOL] private static TimelineACLsManager timelineACLsManager; [EOL] private static AdminACLsManager adminACLsManager; [EOL] private static long beforeTime; [EOL]
@Test [EOL] public void testEncrypt() throws Exception { [EOL] System.out.println("encrypt"); [EOL] String str = "test"; [EOL] AES128Cryptor instance = new AES128Cryptor(); [EOL] String result = instance.encrypt(str); [EOL] assertNotEquals(str, result); [EOL] } [EOL]
@SuppressWarnings("deprecation") [EOL] @Test [EOL] public void testForeignClass() { [EOL] MapWritable inMap = new MapWritable(); [EOL] inMap.put(new Text("key"), new UTF8("value")); [EOL] inMap.put(new Text("key2"), new UTF8("value2")); [EOL] MapWritable outMap = new MapWritable(inMap); [EOL] MapWritable copyOfCopy = new MapWritable(outMap); [EOL] assertEquals(1, copyOfCopy.getNewClasses()); [EOL] } [EOL]
@Test public void testLoadFirst() throws Exception { [EOL] String filename = getTestFilename("hadoop-metrics2-p1"); [EOL] new ConfigBuilder().add("p1.foo", "p1foo").save(filename); [EOL] [EOL] MetricsConfig mc = MetricsConfig.create("p1"); [EOL] MetricsConfig mc2 = MetricsConfig.create("p1", "na1", "na2", filename); [EOL] Configuration expected = new ConfigBuilder().add("foo", "p1foo").config; [EOL] [EOL] assertEq(expected, mc); [EOL] assertEq(expected, mc2); [EOL] } [EOL] static final Logger LOG = LoggerFactory.getLogger(TestMetricsConfig.class); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getSummaryObjectStartText(); [EOL]       assertEquals("<size=", standardToStringStyle0.getSizeStartText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testConvertBlockKey() { [EOL] BlockKey key = getBlockKey(1); [EOL] BlockKeyProto keyProto = PBHelper.convert(key); [EOL] BlockKey key1 = PBHelper.convert(keyProto); [EOL] compare(key, key1); [EOL] } [EOL] private static final double DELTA = 0.000001; [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       compareToBuilder0.append('?', 'h'); [EOL]       compareToBuilder0.append(false, true); [EOL]       assertEquals((-1), compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(false); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln((-3134.9556F)); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(0, (String) null); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.appendln((-1270.0144F)); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       String string1 = strBuilder3.leftString(0); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       Writer writer0 = strBuilder3.asWriter(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher(':'); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("vSi.a.bur[", 3954); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder5.trim(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]       assertNull(strBuilder6.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder7 = new StrBuilder(); [EOL]       assertNull(strBuilder7.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder4.appendln((Object) strBuilder7); [EOL]       assertNull(strBuilder8.getNewLineText()); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]       assertNull(strBuilder7.getNewLineText()); [EOL]        [EOL]       int int1 = 6; [EOL]       StrBuilder strBuilder9 = strBuilder5.append(6); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder9.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strMatcher0.isMatch(charArray0, 3954); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testFraction()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getFraction(0, 2004, 3923); [EOL]       assertEquals(0.51083356F, fraction0.floatValue(), 0.01F); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       Byte[] byteArray0 = new Byte[1]; [EOL]       Byte byte0 = new Byte((byte)0); [EOL]       byteArray0[0] = byte0; [EOL]       byte[] byteArray1 = ArrayUtils.toPrimitive(byteArray0); [EOL]       assertEquals(1, byteArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.DEFAULT_STYLE.setSizeEndText("AEhzPmLst|m|:e7J{Z"); [EOL]       assertEquals(">", standardToStringStyle0.getSummaryObjectEndText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] 	public void testWSDLBindingModel() throws WSDLException, JAXBException, ConfigurationException, Exception { [EOL] [EOL] 		// Reading the WSDL [EOL] 		Definition wsdlDefinition = rw.readWSDL("wsdl/HelloWorld.wsdl"); [EOL] 		String wsdlURL = wsdlDefinition.getDocumentBaseURI(); [EOL] 		 [EOL] 		Properties properties = new Properties(); [EOL] 		properties.put("keyDomain", "juddi.apache.org"); [EOL] 		WSDL2UDDI wsdl2UDDI = new WSDL2UDDI(null, new URLLocalizerDefaultImpl(), properties); [EOL] 		Set<TModel> tModels = new HashSet<TModel>(); [EOL] 	 @SuppressWarnings("unchecked") [EOL] 		Map<QName,Binding> bindings= (Map<QName,Binding>) wsdlDefinition.getAllBindings(); [EOL] 	 Set<TModel> bindingTModels = wsdl2UDDI.createWSDLBindingTModels(wsdlURL, bindings); [EOL] 	 tModels.addAll(bindingTModels); [EOL] 	 [EOL] 		for (TModel tModel : tModels) { [EOL] 			System.out.println("UDDI Binding TModel " + tModel.getName().getValue()); [EOL] if (serialize) [EOL] 			System.out.println(pTModel.print(tModel)); [EOL] 		} [EOL] 		Assert.assertEquals(1,tModels.size()); [EOL] 	} [EOL] PrintUDDI<TModel> pTModel = new PrintUDDI<TModel>(); [EOL] ReadWSDL rw = new ReadWSDL(); [EOL] static boolean serialize = false; [EOL]
@Test(timeout = 4000) [EOL]   public void teststop()  throws Throwable  { [EOL]       StopWatch stopWatch0 = new StopWatch(); [EOL]       stopWatch0.start(); [EOL]       System.setCurrentTimeMillis(0L); [EOL]       long long0 = stopWatch0.getTime(); [EOL]       assertEquals((-1392409281L), long0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       int int0 = 0; [EOL]       String string0 = strBuilder0.midString(0, 0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       LinkedList<Object> linkedList0 = new LinkedList<Object>(); [EOL]        [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       linkedList0.sort(comparator0); [EOL]        [EOL]       ListIterator<Object> listIterator0 = linkedList0.listIterator(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendAll((Iterator<?>) listIterator0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       int int1 = 2; [EOL]       boolean boolean0 = linkedList0.add((Object) strBuilder0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.setCharAt(2, 'l'); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testLoggingWithMultipleValues() { [EOL] assertTrue(helper.record(1).shouldLog()); [EOL] [EOL] for (int i = 0; i < 4; i++) { [EOL] timer.advance(LOG_PERIOD / 5); [EOL] int base = i % 2 == 0 ? 0 : 1; [EOL] assertFalse(helper.record(base, base * 2).shouldLog()); [EOL] } [EOL] [EOL] timer.advance(LOG_PERIOD); [EOL] LogAction action = helper.record(0.5, 1.0); [EOL] assertTrue(action.shouldLog()); [EOL] assertEquals(5, action.getCount()); [EOL] for (int i = 1; i <= 2; i++) { [EOL] assertEquals(0.5 * i, action.getStats(i - 1).getMean(), 0.01); [EOL] assertEquals(1.0 * i, action.getStats(i - 1).getMax(), 0.01); [EOL] assertEquals(0.0, action.getStats(i - 1).getMin(), 0.01); [EOL] } [EOL] } [EOL] private static final int LOG_PERIOD = 100; [EOL] private LogThrottlingHelper helper; [EOL] private FakeTimer timer; [EOL]
@Test(timeout = 4000) [EOL]   public void testmin()  throws Throwable  { [EOL]       float[] floatArray0 = new float[1]; [EOL]       floatArray0[0] = 242.8578F; [EOL]       float float0 = IEEE754rUtils.min(floatArray0); [EOL]       assertEquals(242.8578F, float0, 0.01F); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMergeSubtract() throws PlanningException { [EOL] [EOL] TreeMap<Long, Resource> a = new TreeMap<>(); [EOL] TreeMap<Long, Resource> b = new TreeMap<>(); [EOL] [EOL] setupArrays(a, b); [EOL] [EOL] RLESparseResourceAllocation rleA = [EOL] new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] RLESparseResourceAllocation rleB = [EOL] new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.subtract, 0, 60); [EOL] [EOL] System.out.println(out); [EOL] [EOL] long[] time = { 10, 11, 20, 22, 30, 33, 43, 50, 60 }; [EOL] int[] alloc = { 5, 0, 5, 0, 5, 0, 10, -10 }; [EOL] [EOL] validate(out, time, alloc); [EOL] [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRLESparseResourceAllocation.class); [EOL]
@Test [EOL] public void testGetEntityWithYarnACLsEnabled() throws Exception { [EOL] AdminACLsManager oldAdminACLsManager = [EOL] timelineACLsManager.setAdminACLsManager(adminACLsManager); [EOL] try { [EOL] TimelineEntities entities = new TimelineEntities(); [EOL] TimelineEntity entity = new TimelineEntity(); [EOL] entity.setEntityId("test id 3"); [EOL] entity.setEntityType("test type 3"); [EOL] entity.setStartTime(System.currentTimeMillis()); [EOL] entity.setDomainId("domain_id_1"); [EOL] entities.addEntity(entity); [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("timeline") [EOL] .queryParam("user.name", "writer_user_1") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .type(MediaType.APPLICATION_JSON) [EOL] .post(ClientResponse.class, entities); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] TimelinePutResponse putResponse = [EOL] response.getEntity(TimelinePutResponse.class); [EOL] Assert.assertEquals(0, putResponse.getErrors().size()); [EOL] // verify the system data will not be exposed [EOL] // 1. No field specification [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .path("test type 3").path("test id 3") [EOL] .queryParam("user.name", "reader_user_1") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] entity = response.getEntity(TimelineEntity.class); [EOL] Assert.assertNull(entity.getPrimaryFilters().get( [EOL] TimelineStore.SystemFilter.ENTITY_OWNER.toString())); [EOL] // 2. other field [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .path("test type 3").path("test id 3") [EOL] .queryParam("fields", "relatedentities") [EOL] .queryParam("user.name", "reader_user_1") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] entity = response.getEntity(TimelineEntity.class); [EOL] Assert.assertNull(entity.getPrimaryFilters().get( [EOL] TimelineStore.SystemFilter.ENTITY_OWNER.toString())); [EOL] // 3. primaryfilters field [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .path("test type 3").path("test id 3") [EOL] .queryParam("fields", "primaryfilters") [EOL] .queryParam("user.name", "reader_user_1") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] entity = response.getEntity(TimelineEntity.class); [EOL] Assert.assertNull(entity.getPrimaryFilters().get( [EOL] TimelineStore.SystemFilter.ENTITY_OWNER.toString())); [EOL] [EOL] // get entity with other user [EOL] response = r.path("ws").path("v1").path("timeline") [EOL] .path("test type 3").path("test id 3") [EOL] .queryParam("user.name", "reader_user_2") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] assertResponseStatusCode(Status.FORBIDDEN, response.getStatusInfo()); [EOL] } finally { [EOL] timelineACLsManager.setAdminACLsManager(oldAdminACLsManager); [EOL] } [EOL] } [EOL] private static TimelineStore store; [EOL] private static TimelineACLsManager timelineACLsManager; [EOL] private static AdminACLsManager adminACLsManager; [EOL] private static long beforeTime; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmptyTokenAsNull()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]        [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       strTokenizer0.setTrimmerMatcher((StrMatcher) null); [EOL]       assertTrue(strTokenizer0.isEmptyTokenAsNull()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbinaryBeMsb0ToHexDigit()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[9]; [EOL]       booleanArray0[5] = true; [EOL]       booleanArray0[7] = true; [EOL]       char char0 = Conversion.binaryBeMsb0ToHexDigit(booleanArray0, (int) (short)0); [EOL]       assertEquals('a', char0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAbout() throws Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r [EOL] .path("ws").path("v1").path("applicationhistory").path("about") [EOL] .queryParam("user.name", USERS[round]) [EOL] .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] TimelineAbout actualAbout = response.getEntity(TimelineAbout.class); [EOL] TimelineAbout expectedAbout = [EOL] TimelineUtils.createTimelineAbout("Generic History Service API"); [EOL] Assert.assertNotNull( [EOL] "Timeline service about response is null", actualAbout); [EOL] Assert.assertEquals(expectedAbout.getAbout(), actualAbout.getAbout()); [EOL] Assert.assertEquals(expectedAbout.getTimelineServiceVersion(), [EOL] actualAbout.getTimelineServiceVersion()); [EOL] Assert.assertEquals(expectedAbout.getTimelineServiceBuildVersion(), [EOL] actualAbout.getTimelineServiceBuildVersion()); [EOL] Assert.assertEquals(expectedAbout.getTimelineServiceVersionBuiltOn(), [EOL] actualAbout.getTimelineServiceVersionBuiltOn()); [EOL] Assert.assertEquals(expectedAbout.getHadoopVersion(), [EOL] actualAbout.getHadoopVersion()); [EOL] Assert.assertEquals(expectedAbout.getHadoopBuildVersion(), [EOL] actualAbout.getHadoopBuildVersion()); [EOL] Assert.assertEquals(expectedAbout.getHadoopVersionBuiltOn(), [EOL] actualAbout.getHadoopVersionBuiltOn()); [EOL] } [EOL] private static ApplicationHistoryClientService historyClientService; [EOL] private static AHSWebServices ahsWebservice; [EOL] private static final String[] USERS = new String[] { "foo" , "bar" }; [EOL] private static final int MAX_APPS = 6; [EOL] private static Configuration conf; [EOL] private static FileSystem fs; [EOL] private static final String remoteLogRootDir = "target/logs/"; [EOL] private static final String rootLogDir = "target/LocalLogs"; [EOL] private static final String NM_WEBADDRESS = "test-nm-web-address:9999"; [EOL] private static final String NM_ID = "test:1234"; [EOL] private int round; [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       float[] floatArray0 = new float[7]; [EOL]       int int0 = ArrayUtils.indexOf(floatArray0, 0.0F, (-1)); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSeek() throws Exception { [EOL] Path seekTestFilePath = new Path(this.testRootDir + "/" [EOL] + "seekTestFile"); [EOL] long fileSize = 5 * Unit.MB; [EOL] [EOL] ContractTestUtils.generateTestFile( [EOL] this.fs, seekTestFilePath, fileSize, 256, 255); [EOL] LOG.info("5MB file for seek test has created."); [EOL] [EOL] FSDataInputStream inputStream = this.fs.open(seekTestFilePath); [EOL] int seekTimes = 5; [EOL] for (int i = 0; i != seekTimes; i++) { [EOL] long pos = fileSize / (seekTimes - i) - 1; [EOL] inputStream.seek(pos); [EOL] assertTrue("expected position at: " + [EOL] pos + ", but got: " + inputStream.getPos(), [EOL] inputStream.getPos() == pos); [EOL] LOG.info("completed seeking at pos: " + inputStream.getPos()); [EOL] } [EOL] LOG.info("begin to random position seeking test..."); [EOL] Random random = new Random(); [EOL] for (int i = 0; i < seekTimes; i++) { [EOL] long pos = Math.abs(random.nextLong()) % fileSize; [EOL] LOG.info("seeking for pos: " + pos); [EOL] inputStream.seek(pos); [EOL] assertTrue("expected position at: " + [EOL] pos + ", but got: " + inputStream.getPos(), [EOL] inputStream.getPos() == pos); [EOL] LOG.info("completed seeking at pos: " + inputStream.getPos()); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCosNInputStream.class); [EOL] private FileSystem fs; [EOL] private Path testRootDir; [EOL]
@Test [EOL] public void testCopyStrategy() { [EOL] DistCpOptions options = OptionsParser.parse(new String[] { [EOL] "-strategy", [EOL] "dynamic", [EOL] "-f", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] assertThat(options.getCopyStrategy()).isEqualTo("dynamic"); [EOL] [EOL] options = OptionsParser.parse(new String[] { [EOL] "-f", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] assertThat(options.getCopyStrategy()).isEqualTo(DistCpConstants.UNIFORMSIZE); [EOL] } [EOL] private static final float DELTA = 0.001f; [EOL]
@Test [EOL] public void testHostsFileReader() throws Exception { [EOL] [EOL] FileWriter efw = new FileWriter(excludesFile); [EOL] FileWriter ifw = new FileWriter(includesFile); [EOL] [EOL] efw.write("#DFS-Hosts-excluded\n"); [EOL] efw.write("somehost1\n"); [EOL] efw.write("#This-is-comment\n"); [EOL] efw.write("somehost2\n"); [EOL] efw.write("somehost3 # host3\n"); [EOL] efw.write("somehost4\n"); [EOL] efw.write("somehost4 somehost5\n"); [EOL] efw.close(); [EOL] [EOL] ifw.write("#Hosts-in-DFS\n"); [EOL] ifw.write("somehost1\n"); [EOL] ifw.write("somehost2\n"); [EOL] ifw.write("somehost3\n"); [EOL] ifw.write("#This-is-comment\n"); [EOL] ifw.write("somehost4 # host4\n"); [EOL] ifw.write("somehost4 somehost5\n"); [EOL] ifw.close(); [EOL] [EOL] HostsFileReader hfp = new HostsFileReader(includesFile, excludesFile); [EOL] [EOL] int includesLen = hfp.getHosts().size(); [EOL] int excludesLen = hfp.getExcludedHosts().size(); [EOL] [EOL] assertEquals(5, includesLen); [EOL] assertEquals(5, excludesLen); [EOL] [EOL] assertTrue(hfp.getHosts().contains("somehost5")); [EOL] assertFalse(hfp.getHosts().contains("host3")); [EOL] [EOL] assertTrue(hfp.getExcludedHosts().contains("somehost5")); [EOL] assertFalse(hfp.getExcludedHosts().contains("host4")); [EOL] [EOL] // test for refreshing hostreader wit new include/exclude host files [EOL] String newExcludesFile = HOSTS_TEST_DIR + "/dfs1.exclude"; [EOL] String newIncludesFile = HOSTS_TEST_DIR + "/dfs1.include"; [EOL] [EOL] efw = new FileWriter(newExcludesFile); [EOL] ifw = new FileWriter(newIncludesFile); [EOL] [EOL] efw.write("#DFS-Hosts-excluded\n"); [EOL] efw.write("node1\n"); [EOL] efw.close(); [EOL] [EOL] ifw.write("#Hosts-in-DFS\n"); [EOL] ifw.write("node2\n"); [EOL] ifw.close(); [EOL] [EOL] hfp.refresh(newIncludesFile, newExcludesFile); [EOL] assertTrue(hfp.getExcludedHosts().contains("node1")); [EOL] assertTrue(hfp.getHosts().contains("node2")); [EOL] [EOL] HostDetails hostDetails = hfp.getHostDetails(); [EOL] assertTrue(hostDetails.getExcludedHosts().contains("node1")); [EOL] assertTrue(hostDetails.getIncludedHosts().contains("node2")); [EOL] assertEquals(newIncludesFile, hostDetails.getIncludesFile()); [EOL] assertEquals(newExcludesFile, hostDetails.getExcludesFile()); [EOL] } [EOL] final String HOSTS_TEST_DIR = GenericTestUtils.getTestDir().getAbsolutePath(); [EOL] File EXCLUDES_FILE = new File(HOSTS_TEST_DIR, "dfs.exclude"); [EOL] File INCLUDES_FILE = new File(HOSTS_TEST_DIR, "dfs.include"); [EOL] String excludesFile = HOSTS_TEST_DIR + "/dfs.exclude"; [EOL] String includesFile = HOSTS_TEST_DIR + "/dfs.include"; [EOL] private String excludesXmlFile = HOSTS_TEST_DIR + "/dfs.exclude.xml"; [EOL]
@Test [EOL] public void testShufflePermissions() throws Exception { [EOL] JobConf conf = new JobConf(); [EOL] conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY, "077"); [EOL] conf.set(MRConfig.LOCAL_DIR, TEST_ROOT_DIR.getAbsolutePath()); [EOL] MapOutputFile mof = new MROutputFiles(); [EOL] mof.setConf(conf); [EOL] TaskAttemptID attemptId = new TaskAttemptID("12345", 1, TaskType.MAP, 1, 1); [EOL] MapTask mockTask = mock(MapTask.class); [EOL] doReturn(mof).when(mockTask).getMapOutputFile(); [EOL] doReturn(attemptId).when(mockTask).getTaskID(); [EOL] doReturn(new Progress()).when(mockTask).getSortPhase(); [EOL] TaskReporter mockReporter = mock(TaskReporter.class); [EOL] doReturn(new Counter()).when(mockReporter).getCounter( [EOL] any(TaskCounter.class)); [EOL] MapOutputCollector.Context ctx = new MapOutputCollector.Context(mockTask, [EOL] conf, mockReporter); [EOL] MapOutputBuffer<Object, Object> mob = new MapOutputBuffer<>(); [EOL] mob.init(ctx); [EOL] mob.flush(); [EOL] mob.close(); [EOL] Path outputFile = mof.getOutputFile(); [EOL] FileSystem lfs = FileSystem.getLocal(conf); [EOL] FsPermission perms = lfs.getFileStatus(outputFile).getPermission(); [EOL] Assert.assertEquals("Incorrect output file perms", [EOL] (short)0640, perms.toShort()); [EOL] Path indexFile = mof.getOutputIndexFile(); [EOL] perms = lfs.getFileStatus(indexFile).getPermission(); [EOL] Assert.assertEquals("Incorrect index file perms", [EOL] (short)0640, perms.toShort()); [EOL] } [EOL] private static File TEST_ROOT_DIR = new File( [EOL] System.getProperty("test.build.data", [EOL] System.getProperty("java.io.tmpdir", "/tmp")), [EOL] TestMapTask.class.getName()); [EOL]
@Test [EOL] public void testConvertFSConfigurationErrorHandling() throws Exception { [EOL] setupFSConfigConversionFiles(true); [EOL] [EOL] String[] args = getArgumentsAsArrayWithDefaults("-f", [EOL] FSConfigConverterTestCommons.FS_ALLOC_FILE, [EOL] "-r", FSConfigConverterTestCommons.CONVERSION_RULES_FILE, "-p"); [EOL] FSConfigToCSConfigArgumentHandler argumentHandler = [EOL] createArgumentHandler(); [EOL] [EOL] Mockito.doThrow(UnsupportedPropertyException.class) [EOL] .when(mockConverter) [EOL] .convert(ArgumentMatchers.any(FSConfigToCSConfigConverterParams.class)); [EOL] int retVal = argumentHandler.parseAndConvert(args); [EOL] assertEquals("Return value", -1, retVal); [EOL] assertTrue("Error content missing", fsTestCommons.getErrContent() [EOL] .toString().contains("Unsupported property/setting encountered")); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFSConfigToCSConfigArgumentHandler.class); [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL] @Mock [EOL] private FSConfigToCSConfigConverter mockConverter; [EOL] @Mock [EOL] private ConvertedConfigValidator mockValidator; [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] private ConversionOptions conversionOptions; [EOL] private FSConfigConverterTestCommons fsTestCommons; [EOL]
@Test [EOL] public void testGetEntityByClusterAndApp() throws Exception { [EOL] // Cluster and AppId should be enough to get an entity. [EOL] TimelineEntity result = reader.getEntity( [EOL] new TimelineReaderContext("cluster1", null, null, null, "app1", "app", [EOL] "id_1"), [EOL] new TimelineDataToRetrieve(null, null, null, null, null, null)); [EOL] Assert.assertEquals( [EOL] (new TimelineEntity.Identifier("app", "id_1")).toString(), [EOL] result.getIdentifier().toString()); [EOL] Assert.assertEquals((Long)1425016502000L, result.getCreatedTime()); [EOL] Assert.assertEquals(0, result.getConfigs().size()); [EOL] Assert.assertEquals(0, result.getMetrics().size()); [EOL] } [EOL] private static final String ROOT_DIR = new File("target", [EOL] TestFileSystemTimelineReaderImpl.class.getSimpleName()).getAbsolutePath(); [EOL] private FileSystemTimelineReaderImpl reader; [EOL]
@Test [EOL] public void testCleanName() { [EOL] // permutations of dot placements [EOL] final String clean = "clean"; [EOL] final String dotted = "not.clean"; [EOL] final String multiDot = "more.un.clean"; [EOL] final String seqDot = "not..clean"; [EOL] final String unTrimmed = " .invalid. "; // not really a valid queue [EOL] [EOL] String cleaned = cleanName(clean); [EOL] assertEquals("Name was changed and it should not", clean, cleaned); [EOL] cleaned = cleanName(dotted); [EOL] assertFalse("Cleaned name contains dots and it should not", [EOL] cleaned.contains(DOT)); [EOL] cleaned = cleanName(multiDot); [EOL] assertFalse("Cleaned name contains dots and it should not", [EOL] cleaned.contains(DOT)); [EOL] assertNotEquals("Multi dot failed: wrong replacements found", [EOL] cleaned.indexOf(DOT_REPLACEMENT), [EOL] cleaned.lastIndexOf(DOT_REPLACEMENT)); [EOL] cleaned = cleanName(seqDot); [EOL] assertFalse("Cleaned name contains dots and it should not", [EOL] cleaned.contains(DOT)); [EOL] assertNotEquals("Sequential dot failed: wrong replacements found", [EOL] cleaned.indexOf(DOT_REPLACEMENT), [EOL] cleaned.lastIndexOf(DOT_REPLACEMENT)); [EOL] cleaned = cleanName(unTrimmed); [EOL] assertTrue("Trimming start failed: space not removed or dot not replaced", [EOL] cleaned.startsWith(DOT_REPLACEMENT)); [EOL] assertTrue("Trimming end failed: space not removed or dot not replaced", [EOL] cleaned.endsWith(DOT_REPLACEMENT)); [EOL] } [EOL]
@Test [EOL] public void testPutNullPath() { [EOL] Path path = new Path("/path"); [EOL] DirListingMetadata meta = new DirListingMetadata(path, null, false); [EOL] exception.expect(NullPointerException.class); [EOL] exception.expectMessage(notNullValue(String.class)); [EOL] meta.put(new PathMetadata(new S3AFileStatus(true, null, TEST_OWNER))); [EOL] } [EOL] private static final String TEST_OWNER = "hadoop"; [EOL] public static final String TEST_ETAG = "abc"; [EOL] public static final String TEST_VERSION_ID = "def"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testcapitalize()  throws Throwable  { [EOL]       String string0 = WordUtils.capitalizeFully((String) null); [EOL]       assertNull(string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMoveApplicationAdminTargetQueue() throws Exception { [EOL] ApplicationId applicationId = getApplicationId(1); [EOL] UserGroupInformation aclUGI = UserGroupInformation.getCurrentUser(); [EOL] QueueACLsManager queueAclsManager = getQueueAclManager("allowed_queue", [EOL] QueueACL.ADMINISTER_QUEUE, aclUGI); [EOL] ApplicationACLsManager appAclsManager = getAppAclManager(); [EOL] ClientRMService rmService = [EOL] createClientRMServiceForMoveApplicationRequest(applicationId, [EOL] aclUGI.getShortUserName(), appAclsManager, queueAclsManager); [EOL] [EOL] // user is admin move to queue in acl [EOL] MoveApplicationAcrossQueuesRequest moveAppRequest = [EOL] MoveApplicationAcrossQueuesRequest.newInstance(applicationId, [EOL] "allowed_queue"); [EOL] rmService.moveApplicationAcrossQueues(moveAppRequest); [EOL] [EOL] // user is admin move to queue not in acl [EOL] moveAppRequest = MoveApplicationAcrossQueuesRequest.newInstance( [EOL] applicationId, "not_allowed"); [EOL] [EOL] try { [EOL] rmService.moveApplicationAcrossQueues(moveAppRequest); [EOL] Assert.fail("The request should fail with an AccessControlException"); [EOL] } catch (YarnException rex) { [EOL] Assert.assertTrue("AccessControlException is expected", [EOL] rex.getCause() instanceof AccessControlException); [EOL] } [EOL] [EOL] // ACL is owned by "moveuser", move is performed as a different user [EOL] aclUGI = UserGroupInformation.createUserForTesting("moveuser", [EOL] new String[]{}); [EOL] queueAclsManager = getQueueAclManager("move_queue", [EOL] QueueACL.ADMINISTER_QUEUE, aclUGI); [EOL] appAclsManager = getAppAclManager(); [EOL] ClientRMService rmService2 = [EOL] createClientRMServiceForMoveApplicationRequest(applicationId, [EOL] aclUGI.getShortUserName(), appAclsManager, queueAclsManager); [EOL] [EOL] // no access to this queue [EOL] MoveApplicationAcrossQueuesRequest moveAppRequest2 = [EOL] MoveApplicationAcrossQueuesRequest. [EOL] newInstance(applicationId, "move_queue"); [EOL] [EOL] try { [EOL] rmService2.moveApplicationAcrossQueues(moveAppRequest2); [EOL] Assert.fail("The request should fail with an AccessControlException"); [EOL] } catch (YarnException rex) { [EOL] Assert.assertTrue("AccessControlException is expected", [EOL] rex.getCause() instanceof AccessControlException); [EOL] } [EOL] [EOL] // execute the move as the acl owner [EOL] // access to the queue OK: user allowed in this queue [EOL] aclUGI.doAs(new PrivilegedExceptionAction<Object>() { [EOL] @Override [EOL] public Object run() throws Exception { [EOL] return rmService2.moveApplicationAcrossQueues(moveAppRequest2); [EOL] } [EOL] }); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestClientRMService.class); [EOL] private RecordFactory recordFactory = RecordFactoryProvider [EOL] .getRecordFactory(null); [EOL] private String appType = "MockApp"; [EOL] private final static String QUEUE_1 = "Q-1"; [EOL] private final static String QUEUE_2 = "Q-2"; [EOL] private final static String APPLICATION_TAG_SC_PREPROCESSOR ="mytag:foo"; [EOL] private File resourceTypesFile = null; [EOL]
@Test [EOL] public void testNormalizeHostName() { [EOL] String oneHost = "1.kanyezone.appspot.com"; [EOL] try { [EOL] InetAddress.getByName(oneHost); [EOL] } catch (UnknownHostException e) { [EOL] Assume.assumeTrue("Network not resolving "+ oneHost, false); [EOL] } [EOL] List<String> hosts = Arrays.asList("127.0.0.1", [EOL] "localhost", oneHost, "UnknownHost123"); [EOL] List<String> normalizedHosts = NetUtils.normalizeHostNames(hosts); [EOL] String summary = "original [" + StringUtils.join(hosts, ", ") + "]" [EOL] + " normalized [" + StringUtils.join(normalizedHosts, ", ") + "]"; [EOL] // when ipaddress is normalized, same address is expected in return [EOL] assertEquals(summary, hosts.get(0), normalizedHosts.get(0)); [EOL] // for normalizing a resolvable hostname, resolved ipaddress is expected in return [EOL] assertFalse("Element 1 equal "+ summary, [EOL] normalizedHosts.get(1).equals(hosts.get(1))); [EOL] assertEquals(summary, hosts.get(0), normalizedHosts.get(1)); [EOL] // this address HADOOP-8372: when normalizing a valid resolvable hostname start with numeric, [EOL] // its ipaddress is expected to return [EOL] assertFalse("Element 2 equal " + summary, [EOL] normalizedHosts.get(2).equals(hosts.get(2))); [EOL] // return the same hostname after normalizing a irresolvable hostname. [EOL] assertEquals(summary, hosts.get(3), normalizedHosts.get(3)); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestNetUtils.class); [EOL] private static final int DEST_PORT = 4040; [EOL] private static final String DEST_PORT_NAME = Integer.toString(DEST_PORT); [EOL] private static final int LOCAL_PORT = 8080; [EOL] private static final String LOCAL_PORT_NAME = Integer.toString(LOCAL_PORT); [EOL] static final long TIME_FUDGE_MILLIS = 200; [EOL] static NetUtilsTestResolver resolver; [EOL] static Configuration config; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoBoolean()  throws Throwable  { [EOL]       Boolean boolean0 = BooleanUtils.toBooleanObject((String) null, "g,SXP", "w#4xU.0t'5b#", (String) null); [EOL]       assertNull(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseIdentityHashCode()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SIMPLE_STYLE.setContentEnd((String) null); [EOL]       assertTrue(standardToStringStyle0.isUseIdentityHashCode()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmax()  throws Throwable  { [EOL]       byte byte0 = NumberUtils.max((byte) (-92), (byte) (-44), (byte) (-44)); [EOL]       assertEquals((byte) (-44), byte0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNegativeFinishTimes() { [EOL] long elapsed = Times.elapsed(5, -10, false); [EOL] Assert.assertEquals("Elapsed time is not -1", -1, elapsed); [EOL] } [EOL]
@Test [EOL] public void testSignature() throws Exception { [EOL] Signer signer = new Signer(createStringSignerSecretProvider()); [EOL] String s1 = signer.sign("ok"); [EOL] String s2 = signer.sign("ok"); [EOL] String s3 = signer.sign("wrong"); [EOL] Assert.assertEquals(s1, s2); [EOL] Assert.assertNotEquals(s1, s3); [EOL] } [EOL]
@Test [EOL] public void testGetApplication() throws Exception { [EOL] ApplicationId applicationId = [EOL] ApplicationId.fromString("application_1234_0001"); [EOL] TimelineEntity entity = client.getApplicationEntity(applicationId, [EOL] null, null); [EOL] Assert.assertEquals("mockApp1", entity.getId()); [EOL] } [EOL] private TimelineReaderClient client; [EOL]
@Test [EOL] public void testGetRecommended() throws Exception { [EOL] AppStoreController ac = Mockito.mock(AppStoreController.class); [EOL] List<AppStoreEntry> actual = new ArrayList<AppStoreEntry>(); [EOL] when(ac.get()).thenReturn(actual); [EOL] final List<AppStoreEntry> result = ac.get(); [EOL] assertEquals(result, actual); [EOL] } [EOL] private AppStoreController controller; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetFragmentInSeconds()  throws Throwable  { [EOL]       String[] stringArray0 = new String[1]; [EOL]       stringArray0[0] = ""; [EOL]       Date date0 = DateUtils.parseDateStrictly("", stringArray0); [EOL]       long long0 = DateUtils.getFragmentInSeconds(date0, 12); [EOL]       assertEquals(21L, long0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDataNodeInfoPBHelper() { [EOL] DatanodeID id = DFSTestUtil.getLocalDatanodeID(); [EOL] DatanodeInfo dnInfos0 = new DatanodeInfoBuilder().setNodeID(id) [EOL] .build(); [EOL] dnInfos0.setCapacity(3500L); [EOL] dnInfos0.setDfsUsed(1000L); [EOL] dnInfos0.setNonDfsUsed(2000L); [EOL] dnInfos0.setRemaining(500L); [EOL] HdfsProtos.DatanodeInfoProto dnproto = PBHelperClient.convert(dnInfos0); [EOL] DatanodeInfo dnInfos1 = PBHelperClient.convert(dnproto); [EOL] compare(dnInfos0, dnInfos1); [EOL] assertEquals(dnInfos0.getNonDfsUsed(), dnInfos1.getNonDfsUsed()); [EOL] [EOL] //Testing without nonDfs field [EOL] HdfsProtos.DatanodeInfoProto.Builder b = [EOL] HdfsProtos.DatanodeInfoProto.newBuilder(); [EOL] b.setId(PBHelperClient.convert(id)).setCapacity(3500L).setDfsUsed(1000L) [EOL] .setRemaining(500L); [EOL] DatanodeInfo dnInfos3 = PBHelperClient.convert(b.build()); [EOL] assertEquals(dnInfos0.getNonDfsUsed(), dnInfos3.getNonDfsUsed()); [EOL] } [EOL] private static final double DELTA = 0.000001; [EOL]
@Test [EOL] public void testMultiply() { [EOL] assertEquals(createResource(4, 2), multiply(createResource(2, 1), 2)); [EOL] assertEquals(createResource(4, 2, 0), multiply(createResource(2, 1), 2)); [EOL] assertEquals(createResource(2, 4), multiply(createResource(1, 2), 2)); [EOL] assertEquals(createResource(2, 4, 0), multiply(createResource(1, 2), 2)); [EOL] assertEquals(createResource(6, 6, 0), multiply(createResource(3, 3, 0), 2)); [EOL] assertEquals(createResource(4, 4, 6), multiply(createResource(2, 2, 3), 2)); [EOL] } [EOL] private static final String INVALID_RESOURCE_MSG = "Invalid resource value"; [EOL] private static final String EXTRA_RESOURCE_TYPE = "resource2"; [EOL] private String resourceTypesFile; [EOL]
@Test [EOL] public void testInputWithEquals() throws Exception { [EOL] Text in = getAuditString("1970-01-01 00:00:11,000", "fakeUser", [EOL] "listStatus", "day=1970", "null"); [EOL] AuditReplayCommand expected = new AuditReplayCommand(1000, "fakeUser", [EOL] "listStatus", "day=1970", "null", "0.0.0.0"); [EOL] assertEquals(expected, parser.parse(in, Function.identity())); [EOL] } [EOL] private static final long START_TIMESTAMP = 10000; [EOL] private AuditLogDirectParser parser; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("java.library.path"); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator('h'); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendPadding(5, 'd'); [EOL]        [EOL]       int int0 = strBuilder0.indexOf('d'); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.append((CharSequence) strBuilder1); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendln('h'); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendFixedWidthPadRight((Object) strBuilder2, (-1089), 'd'); [EOL]        [EOL]       char[] charArray0 = new char[5]; [EOL]       charArray0[0] = 'd'; [EOL]       charArray0[1] = '%'; [EOL]       IntStream intStream0 = strBuilder2.chars(); [EOL]        [EOL]       Reader reader0 = strBuilder0.asReader(); [EOL]        [EOL]       charArray0[2] = 'd'; [EOL]       charArray0[3] = 'h'; [EOL]       charArray0[4] = 'd'; [EOL]       char[] charArray1 = strBuilder3.getChars(charArray0); [EOL]       assertFalse(charArray1.equals((Object)charArray0)); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.quoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder2.replace(strMatcher0, "org.apache.commons.lang3.text.StrBuilder$StrBuilderTokenizer", 5, 5, 5); [EOL]        [EOL]       IntStream intStream1 = strBuilder6.chars(); [EOL]       assertFalse(intStream1.equals((Object)intStream0)); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.insert(18, (-1835.44)); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder2.setLength(18); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder7.appendWithSeparators((Iterator<?>) null, "java.library.path"); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPreserveUserOnDirectory() throws IOException { [EOL] FileSystem fs = FileSystem.get(config); [EOL] EnumSet<FileAttribute> attributes = EnumSet.of(FileAttribute.USER); [EOL] [EOL] Path dst = new Path("/tmp/abc"); [EOL] Path src = new Path("/tmp/src"); [EOL] [EOL] createDirectory(fs, src); [EOL] createDirectory(fs, dst); [EOL] [EOL] fs.setPermission(src, fullPerm); [EOL] fs.setOwner(src, "somebody", "somebody-group"); [EOL] [EOL] fs.setPermission(dst, noPerm); [EOL] fs.setOwner(dst, "nobody", "nobody-group"); [EOL] [EOL] CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src)); [EOL] [EOL] DistCpUtils.preserve(fs, dst, srcStatus, attributes, false); [EOL] [EOL] CopyListingFileStatus dstStatus = new CopyListingFileStatus(fs.getFileStatus(dst)); [EOL] [EOL] // FileStatus.equals only compares path field, must explicitly compare all fields [EOL] Assert.assertFalse(srcStatus.getPermission().equals(dstStatus.getPermission())); [EOL] Assert.assertTrue(srcStatus.getOwner().equals(dstStatus.getOwner())); [EOL] Assert.assertFalse(srcStatus.getGroup().equals(dstStatus.getGroup())); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestDistCpUtils.class); [EOL] private static final Configuration config = new Configuration(); [EOL] private static MiniDFSCluster cluster; [EOL] private static final FsPermission fullPerm = new FsPermission((short) 777); [EOL] private static final FsPermission almostFullPerm = new FsPermission((short) 666); [EOL] private static final FsPermission noPerm = new FsPermission((short) 0); [EOL] private static Random rand = new Random(); [EOL]
@Test(timeout = 4000) [EOL]   public void testmarkSupported()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]        [EOL]       StrBuilder strBuilder1 = new StrBuilder(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append(strBuilder1); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendNewLine(); [EOL]        [EOL]       boolean boolean0 = strBuilder3.equals((Object) strBuilder0); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder3.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       strBuilder_StrBuilderReader0.reset(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       strBuilder_StrBuilderReader0.reset(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0, 0, 0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       charArray0[0] = ':'; [EOL]       String string0 = strBuilder0.substring(0, 0); [EOL]        [EOL]       charArray0[1] = ')'; [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charArray0, 0, 0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       int int2 = strBuilder2.indexOf("=.j", 1810); [EOL]        [EOL]       String string1 = strBuilder0.getNullText(); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]        [EOL]       List<String> list0 = strBuilder_StrBuilderTokenizer0.tokenize(charArray0, 0, 0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.appendNull(); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFormatIdempotent() throws Throwable { [EOL] assertConverted("xn--lzg", RegistryPathUtils.encodeForRegistry(EURO)); [EOL] } [EOL] public static final String EURO = "\u20AC"; [EOL]
@Test(timeout = 30000) [EOL] public void testResourcePluginManagerInitialization() throws Exception { [EOL] final ResourcePluginManager rpm = stubResourcePluginmanager(); [EOL] nm = new ResourcePluginMockNM(rpm); [EOL] [EOL] nm.init(conf); [EOL] verify(rpm).initialize( [EOL] any(Context.class)); [EOL] } [EOL] private NodeManager nm; [EOL] private String tempResourceTypesFile; [EOL]
@Test (timeout = 30000) [EOL] public void testDirsNotExist() throws Exception { [EOL] assumeNotWindows(); [EOL] String dir2 = buildBufferDir(ROOT, 2); [EOL] String dir3 = buildBufferDir(ROOT, 3); [EOL] try { [EOL] conf.set(CONTEXT, dir2 + "," + dir3); [EOL] [EOL] // create the first file, and then figure the round-robin sequence [EOL] createTempFile(SMALL_FILE_SIZE); [EOL] int firstDirIdx = (dirAllocator.getCurrentDirectoryIndex() == 0) ? 2 : 3; [EOL] int secondDirIdx = (firstDirIdx == 2) ? 3 : 2; [EOL] [EOL] // check if tmp dirs are allocated in a round-robin manner [EOL] validateTempDirCreation(buildBufferDir(ROOT, firstDirIdx)); [EOL] validateTempDirCreation(buildBufferDir(ROOT, secondDirIdx)); [EOL] validateTempDirCreation(buildBufferDir(ROOT, firstDirIdx)); [EOL] } finally { [EOL] rmBufferDirs(); [EOL] } [EOL] } [EOL] final static private Configuration conf = new Configuration(); [EOL] final static private String BUFFER_DIR_ROOT = "build/test/temp"; [EOL] final static private String ABSOLUTE_DIR_ROOT; [EOL] final static private String QUALIFIED_DIR_ROOT; [EOL] final static private Path BUFFER_PATH_ROOT = new Path(BUFFER_DIR_ROOT); [EOL] final static private File BUFFER_ROOT = new File(BUFFER_DIR_ROOT); [EOL] final static private String CONTEXT = "mapred.local.dir"; [EOL] final static private String FILENAME = "block"; [EOL] final static private LocalDirAllocator dirAllocator = [EOL] new LocalDirAllocator(CONTEXT); [EOL] static LocalFileSystem localFs; [EOL] final static int SMALL_FILE_SIZE = 100; [EOL] final static private String RELATIVE = "/RELATIVE"; [EOL] final static private String ABSOLUTE = "/ABSOLUTE"; [EOL] final static private String QUALIFIED = "/QUALIFIED"; [EOL] final private String ROOT; [EOL] final private String PREFIX; [EOL] static final int TRIALS = 100; [EOL]
@Test [EOL] public void testGetGroups() { [EOL] String user = "user"; [EOL] List<String> expResult = Collections.emptyList(); [EOL] List<String> result = ngm.getGroups(user); [EOL] [EOL] assertEquals("No groups should be returned", [EOL] expResult, result); [EOL] [EOL] ngm.cacheGroupsAdd(Arrays.asList(new String[] {"group1", "group2"})); [EOL] result = ngm.getGroups(user); [EOL] [EOL] assertEquals("No groups should be returned", [EOL] expResult, result); [EOL] [EOL] ngm.cacheGroupsRefresh(); [EOL] result = ngm.getGroups(user); [EOL] [EOL] assertEquals("No groups should be returned", [EOL] expResult, result); [EOL] } [EOL] private NullGroupsMapping ngm; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetFieldSeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer("^e"); [EOL]       standardToStringStyle0.appendIdentityHashCode(stringBuffer0, (Object) null); [EOL]       assertEquals(",", standardToStringStyle0.getFieldSeparator()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNoRetryOnAccessControlException() throws Exception { [EOL] RetryPolicy policy = mock(RetryPolicy.class); [EOL] RetryPolicy realPolicy = RetryPolicies.failoverOnNetworkException(5); [EOL] setupMockPolicy(policy, realPolicy); [EOL] [EOL] UnreliableInterface unreliable = (UnreliableInterface) RetryProxy.create( [EOL] UnreliableInterface.class, unreliableImpl, policy); [EOL] [EOL] try { [EOL] unreliable.failsWithAccessControlExceptionEightTimes(); [EOL] fail("Should fail"); [EOL] } catch (AccessControlException e) { [EOL] // expected [EOL] verify(policy, times(1)).shouldRetry(any(Exception.class), anyInt(), [EOL] anyInt(), anyBoolean()); [EOL] assertEquals(RetryDecision.FAIL, caughtRetryAction.action); [EOL] } [EOL] } [EOL] private UnreliableImplementation unreliableImpl; [EOL] private RetryAction caughtRetryAction = null; [EOL]
@Test [EOL] public void testGetFsAction(){ [EOL] FTPFileSystem ftp = new FTPFileSystem(); [EOL] int[] accesses = new int[] {FTPFile.USER_ACCESS, FTPFile.GROUP_ACCESS, [EOL] FTPFile.WORLD_ACCESS}; [EOL] FsAction[] actions = FsAction.values(); [EOL] for(int i = 0; i < accesses.length; i++){ [EOL] for(int j = 0; j < actions.length; j++){ [EOL] enhancedAssertEquals(actions[j], ftp.getFsAction(accesses[i], [EOL] getFTPFileOf(accesses[i], actions[j]))); [EOL] } [EOL] } [EOL] } [EOL] private FtpTestServer server; [EOL] private java.nio.file.Path testDir; [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(180000); [EOL]
@Test(timeout = 4000) [EOL]   public void testisSameLength()  throws Throwable  { [EOL]       char[] charArray0 = new char[5]; [EOL]       boolean boolean0 = ArrayUtils.isSameLength(charArray0, charArray0); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDifferentSpecifiedPolicies() { [EOL] BlockStoragePolicySuite bsps = BlockStoragePolicySuite.createDefaultSuite(); [EOL] StoragePolicySummary sts = new StoragePolicySummary(bsps.getAllPolicies()); [EOL] BlockStoragePolicy hot = bsps.getPolicy("HOT"); [EOL] BlockStoragePolicy warm = bsps.getPolicy("WARM"); [EOL] BlockStoragePolicy cold = bsps.getPolicy("COLD"); [EOL] //DISK:3 [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK,StorageType.DISK},warm); [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK,StorageType.DISK},cold); [EOL] //DISK:1,ARCHIVE:2 [EOL] sts.add(new StorageType[]{StorageType.DISK, [EOL] StorageType.ARCHIVE,StorageType.ARCHIVE},hot); [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.DISK,StorageType.ARCHIVE},warm); [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.ARCHIVE,StorageType.DISK},cold); [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.ARCHIVE,StorageType.DISK},cold); [EOL] //ARCHIVE:3 [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.ARCHIVE,StorageType.ARCHIVE},hot); [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.ARCHIVE,StorageType.ARCHIVE},hot); [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.ARCHIVE,StorageType.ARCHIVE},warm); [EOL] sts.add(new StorageType[]{StorageType.ARCHIVE, [EOL] StorageType.ARCHIVE,StorageType.ARCHIVE},cold); [EOL] Map<String, Long> actualOutput = convertToStringMap(sts); [EOL] Assert.assertEquals(9,actualOutput.size()); [EOL] Map<String, Long> expectedOutput = new HashMap<>(); [EOL] expectedOutput.put("HOT|DISK:3(HOT)", 2l); [EOL] expectedOutput.put("COLD|DISK:1,ARCHIVE:2(WARM)", 2l); [EOL] expectedOutput.put("HOT|ARCHIVE:3(COLD)", 2l); [EOL] expectedOutput.put("WARM|DISK:3(HOT)", 1l); [EOL] expectedOutput.put("COLD|DISK:3(HOT)", 1l); [EOL] expectedOutput.put("WARM|ARCHIVE:3(COLD)", 1l); [EOL] expectedOutput.put("WARM|DISK:1,ARCHIVE:2(WARM)", 1l); [EOL] expectedOutput.put("COLD|ARCHIVE:3(COLD)", 1l); [EOL] expectedOutput.put("HOT|DISK:1,ARCHIVE:2(WARM)", 1l); [EOL] Assert.assertEquals(expectedOutput,actualOutput); [EOL] } [EOL]
@Test [EOL] public void testListStatusSimple() throws IOException { [EOL] Configuration conf = new Configuration(); [EOL] conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS, numThreads); [EOL] [EOL] List<Path> expectedPaths = configureTestSimple(conf, localFs); [EOL] [EOL] Job job = Job.getInstance(conf); [EOL] FileInputFormat<?, ?> fif = new TextInputFormat(); [EOL] List<FileStatus> statuses = fif.listStatus(job); [EOL] [EOL] verifyFileStatuses(expectedPaths, statuses, localFs); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFileInputFormat.class); [EOL] private static String testTmpDir = System.getProperty("test.build.data", "/tmp"); [EOL] private static final Path TEST_ROOT_DIR = new Path(testTmpDir, "TestFIF"); [EOL] private static FileSystem localFs; [EOL] private int numThreads; [EOL]
@Test [EOL] public void testDeadzone() { [EOL] int[][] qData = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 39, 43, 21 }, // used [EOL] { 10, 10, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL] conf.setFloat( [EOL] CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY, [EOL] (float) 0.1); [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData); [EOL] policy.editSchedule(); [EOL] // ignore 10% overcapacity to avoid jitter [EOL] verify(mDisp, never()).handle(isA(ContainerPreemptEvent.class)); [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test [EOL] public void testNoCommitAction() throws IOException { [EOL] TaskAttemptContext taskAttemptContext = getTaskAttemptContext(config); [EOL] JobContext jobContext = new JobContextImpl( [EOL] taskAttemptContext.getConfiguration(), [EOL] taskAttemptContext.getTaskAttemptID().getJobID()); [EOL] OutputCommitter committer = new CopyCommitter(null, taskAttemptContext); [EOL] committer.commitJob(jobContext); [EOL] Assert.assertEquals("Commit Successful", taskAttemptContext.getStatus()); [EOL] [EOL] //Test for idempotent commit [EOL] committer.commitJob(jobContext); [EOL] Assert.assertEquals("Commit Successful", taskAttemptContext.getStatus()); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestCopyCommitter.class); [EOL] private static final Random rand = new Random(); [EOL] private static final long BLOCK_SIZE = 1024; [EOL] private static final Credentials CREDENTIALS = new Credentials(); [EOL] public static final int PORT = 39737; [EOL] private static Configuration clusterConfig; [EOL] private static MiniDFSCluster cluster; [EOL] private Configuration config; [EOL]
@Test [EOL] public void testInfoSlash() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("mapreduce") [EOL] .path("info/").accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] assertEquals("incorrect number of elements", 1, json.length()); [EOL] verifyAMInfo(json.getJSONObject("info"), appContext); [EOL] } [EOL] private static Configuration conf = new Configuration(); [EOL] private static MockAppContext appContext; [EOL]
@Test(timeout = 4000) [EOL]   public void testisMatch()  throws Throwable  { [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]       char[] charArray0 = new char[5]; [EOL]       charArray0[0] = '['; [EOL]       int int0 = strMatcher0.isMatch(charArray0, 0); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test (timeout = 30000) [EOL] public void testUnZip() throws IOException { [EOL] // make sa simple zip [EOL] final File simpleZip = new File(del, FILE); [EOL] OutputStream os = new FileOutputStream(simpleZip); [EOL] ZipOutputStream tos = new ZipOutputStream(os); [EOL] try { [EOL] ZipEntry ze = new ZipEntry("foo"); [EOL] byte[] data = "some-content".getBytes("UTF-8"); [EOL] ze.setSize(data.length); [EOL] tos.putNextEntry(ze); [EOL] tos.write(data); [EOL] tos.closeEntry(); [EOL] tos.flush(); [EOL] tos.finish(); [EOL] } finally { [EOL] tos.close(); [EOL] } [EOL] [EOL] // successfully unzip it into an existing dir: [EOL] FileUtil.unZip(simpleZip, tmp); [EOL] // check result: [EOL] assertTrue(new File(tmp, "foo").exists()); [EOL] assertEquals(12, new File(tmp, "foo").length()); [EOL] [EOL] final File regularFile = new File(tmp, "QuickBrownFoxJumpsOverTheLazyDog"); [EOL] regularFile.createNewFile(); [EOL] assertTrue(regularFile.exists()); [EOL] try { [EOL] FileUtil.unZip(simpleZip, regularFile); [EOL] assertTrue("An IOException expected.", false); [EOL] } catch (IOException ioe) { [EOL] // okay [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.substringBefore("(?: s|[s&&[^ ]])s*", "(?: s|[s&&[^ ]])s*"); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = 'K'; [EOL]       int int0 = StringUtils.indexOfAny((CharSequence) "", charArray0); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       String string1 = StringUtils.lowerCase("4QSejn\"zyIHEF~:m|C"); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCountersFromHistoryServer() throws Exception { [EOL] MRClientProtocol historyServerProxy = mock(MRClientProtocol.class); [EOL] when(historyServerProxy.getCounters(getCountersRequest())).thenReturn( [EOL] getCountersResponseFromHistoryServer()); [EOL] ResourceMgrDelegate rm = mock(ResourceMgrDelegate.class); [EOL] when(rm.getApplicationReport(TypeConverter.toYarn(oldJobId).getAppId())) [EOL] .thenReturn(null); [EOL] ClientServiceDelegate clientServiceDelegate = getClientServiceDelegate( [EOL] historyServerProxy, rm); [EOL] [EOL] Counters counters = TypeConverter.toYarn(clientServiceDelegate.getJobCounters(oldJobId)); [EOL] Assert.assertNotNull(counters); [EOL] Assert.assertEquals(1001, counters.getCounterGroup("dummyCounters").getCounter("dummyCounter").getValue()); [EOL] } [EOL] private JobID oldJobId = JobID.forName("job_1315895242400_2"); [EOL] private org.apache.hadoop.mapreduce.v2.api.records.JobId jobId = TypeConverter [EOL] .toYarn(oldJobId); [EOL] private boolean isAMReachableFromClient; [EOL]
@Test [EOL] public void testProxyUserConfiguration() { [EOL] FilterContainer container = Mockito.mock(FilterContainer.class); [EOL] for (int i = 0; i < 3; ++i) { [EOL] Configuration conf = new YarnConfiguration(); [EOL] switch (i) { [EOL] case 0: [EOL] // hadoop.proxyuser prefix [EOL] conf.set("hadoop.proxyuser.foo.hosts", "*"); [EOL] conf.set("hadoop.proxyuser.foo.users", "*"); [EOL] conf.set("hadoop.proxyuser.foo.groups", "*"); [EOL] break; [EOL] case 1: [EOL] // yarn.timeline-service.http-authentication.proxyuser prefix [EOL] conf.set(TIMELINE_HTTP_AUTH_PREFIX + "proxyuser.foo.hosts", "*"); [EOL] conf.set(TIMELINE_HTTP_AUTH_PREFIX + "proxyuser.foo.users", "*"); [EOL] conf.set(TIMELINE_HTTP_AUTH_PREFIX + "proxyuser.foo.groups", "*"); [EOL] break; [EOL] case 2: [EOL] // hadoop.proxyuser prefix has been overwritten by [EOL] // yarn.timeline-service.http-authentication.proxyuser prefix [EOL] conf.set("hadoop.proxyuser.foo.hosts", "bar"); [EOL] conf.set("hadoop.proxyuser.foo.users", "bar"); [EOL] conf.set("hadoop.proxyuser.foo.groups", "bar"); [EOL] conf.set(TIMELINE_HTTP_AUTH_PREFIX + "proxyuser.foo.hosts", "*"); [EOL] conf.set(TIMELINE_HTTP_AUTH_PREFIX + "proxyuser.foo.users", "*"); [EOL] conf.set(TIMELINE_HTTP_AUTH_PREFIX + "proxyuser.foo.groups", "*"); [EOL] break; [EOL] default: [EOL] break; [EOL] } [EOL] [EOL] TimelineAuthenticationFilterInitializer initializer = [EOL] new TimelineAuthenticationFilterInitializer(); [EOL] initializer.initFilter(container, conf); [EOL] Assert.assertEquals( [EOL] "*", initializer.filterConfig.get("proxyuser.foo.hosts")); [EOL] Assert.assertEquals( [EOL] "*", initializer.filterConfig.get("proxyuser.foo.users")); [EOL] Assert.assertEquals( [EOL] "*", initializer.filterConfig.get("proxyuser.foo.groups")); [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testadd()  throws Throwable  { [EOL]       short[] shortArray0 = new short[3]; [EOL]       short[] shortArray1 = ArrayUtils.add(shortArray0, 0, (short)0); [EOL]       assertArrayEquals(new short[] {(short)0, (short)0, (short)0, (short)0}, shortArray1); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testComponentwiseMax() { [EOL] assertEquals(createResource(2, 2), [EOL] componentwiseMax(createResource(1, 1), createResource(2, 2))); [EOL] assertEquals(createResource(2, 2), [EOL] componentwiseMax(createResource(2, 2), createResource(1, 1))); [EOL] assertEquals(createResource(2, 2), [EOL] componentwiseMax(createResource(1, 2), createResource(2, 1))); [EOL] assertEquals(createResource(2, 2, 2), [EOL] componentwiseMax(createResource(1, 1, 1), createResource(2, 2, 2))); [EOL] assertEquals(createResource(2, 2, 2), [EOL] componentwiseMax(createResource(2, 2, 2), createResource(1, 1))); [EOL] assertEquals(createResource(2, 2, 3), [EOL] componentwiseMax(createResource(1, 2, 2), createResource(2, 1, 3))); [EOL] assertEquals(createResource(2, 2, 1), [EOL] componentwiseMax(createResource(2, 2, 0), createResource(2, 1, 1))); [EOL] } [EOL] private static final String INVALID_RESOURCE_MSG = "Invalid resource value"; [EOL] private static final String EXTRA_RESOURCE_TYPE = "resource2"; [EOL] private String resourceTypesFile; [EOL]
@Test(timeout = 60000) [EOL] public void testRemove() throws Exception { [EOL] HdfsFileStatus status = nn.getRpcServer().getFileInfo(testdir); [EOL] long dirId = status.getFileId(); [EOL] int namenodeId = Nfs3Utils.getNamenodeId(config); [EOL] XDR xdr_req = new XDR(); [EOL] FileHandle handle = new FileHandle(dirId, namenodeId); [EOL] REMOVE3Request req = new REMOVE3Request(handle, "bar"); [EOL] req.serialize(xdr_req); [EOL] [EOL] // Attempt by an unpriviledged user should fail. [EOL] REMOVE3Response response1 = nfsd.remove(xdr_req.asReadOnlyWrap(), [EOL] securityHandlerUnpriviledged, [EOL] new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3ERR_ACCES, [EOL] response1.getStatus()); [EOL] [EOL] // Attempt by a priviledged user should pass. [EOL] REMOVE3Response response2 = nfsd.remove(xdr_req.asReadOnlyWrap(), [EOL] securityHandler, new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3_OK, [EOL] response2.getStatus()); [EOL] } [EOL] static DistributedFileSystem hdfs; [EOL] static MiniDFSCluster cluster = null; [EOL] static NfsConfiguration config = new NfsConfiguration(); [EOL] static HdfsAdmin dfsAdmin; [EOL] static NameNode nn; [EOL] static Nfs3 nfs; [EOL] static RpcProgramNfs3 nfsd; [EOL] static SecurityHandler securityHandler; [EOL] static SecurityHandler securityHandlerUnpriviledged; [EOL] static String testdir = "/tmp"; [EOL] private static final String TEST_KEY = "test_key"; [EOL] private static FileSystemTestHelper fsHelper; [EOL] private static File testRootDir; [EOL] private static final EnumSet<CreateEncryptionZoneFlag> NO_TRASH = [EOL] EnumSet.of(CreateEncryptionZoneFlag.NO_TRASH); [EOL]
@Test(timeout = 4000) [EOL]   public void testand()  throws Throwable  { [EOL]       Boolean[] booleanArray0 = new Boolean[2]; [EOL]       Boolean boolean0 = BooleanUtils.toBooleanObject("vjm@8I}9pL-9$^D", "vjm@8I}9pL-9$^D", "", "Wx/fR7^T5S\" >9P["); [EOL]       booleanArray0[0] = boolean0; [EOL]       Boolean boolean1 = Boolean.valueOf("vjm@8I}9pL-9$^D"); [EOL]       booleanArray0[1] = boolean1; [EOL]       Boolean boolean2 = BooleanUtils.and(booleanArray0); [EOL]       assertFalse(boolean2); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       int[] intArray0 = ArrayUtils.toPrimitive((Integer[]) null); [EOL]       assertNull(intArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       objectArray0[0] = (Object) null; [EOL]       objectArray0[1] = (Object) strBuilder0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) null; [EOL]       objectArray0[4] = (Object) null; [EOL]       objectArray0[5] = (Object) null; [EOL]       objectArray0[6] = (Object) strBuilder0; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln((String) null, objectArray0); [EOL]         fail("Expecting exception: NullPointerException"); [EOL]        [EOL]       } catch(NullPointerException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("~dYL7CZ`YIZ7"); [EOL]       assertEquals(44, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter(); [EOL]       assertEquals(44, strBuilder0.capacity()); [EOL]        [EOL]       strBuilder_StrBuilderWriter0.close(); [EOL]       assertEquals(44, strBuilder0.capacity()); [EOL]   } [EOL]  [EOL]
@Test(expected=IllegalArgumentException.class) [EOL] public void testAllocationIncrementInvalidUnit() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RESOURCE_TYPES + "." + [EOL] ResourceInformation.MEMORY_MB.getName() + [EOL] FairSchedulerConfiguration.INCREMENT_ALLOCATION, "1 Xi"); [EOL] new FairSchedulerConfiguration(conf).getIncrementAllocation(); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test [EOL] public void testRelativizeSelf() { [EOL] assertEquals("", getRelativePath(BASE, BASE)); [EOL] } [EOL] private static final String DATA = "s3a://landsat-pds/data/"; [EOL] private static final Path BASE = new Path(DATA); [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(1354); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]        [EOL]       StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getQuoteMatcher(); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setQuoteMatcher(strMatcher0); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteFirst(strMatcher0); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]       assertEquals(1354, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.append('E'); [EOL]       assertEquals(1354, strBuilder0.capacity()); [EOL]       assertEquals(1354, strBuilder1.capacity()); [EOL]       assertEquals(1354, strBuilder2.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.charAt(2193); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2193 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClientRetriesIfMaxAttemptsNotSet() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] KMSClientProvider p1 = mock(KMSClientProvider.class); [EOL] when(p1.createKey(Mockito.anyString(), Mockito.any(Options.class))) [EOL] .thenThrow(new ConnectTimeoutException("p1")); [EOL] KMSClientProvider p2 = mock(KMSClientProvider.class); [EOL] when(p2.createKey(Mockito.anyString(), Mockito.any(Options.class))) [EOL] .thenThrow(new ConnectTimeoutException("p2")); [EOL] [EOL] when(p1.getKMSUrl()).thenReturn("p1"); [EOL] when(p2.getKMSUrl()).thenReturn("p2"); [EOL] [EOL] LoadBalancingKMSClientProvider kp = new LoadBalancingKMSClientProvider( [EOL] new KMSClientProvider[] {p1, p2}, 0, conf); [EOL] try { [EOL] kp.createKey("test3", new Options(conf)); [EOL] fail("Should fail"); [EOL] } catch (Exception e) { [EOL] assert (e instanceof ConnectTimeoutException); [EOL] } [EOL] verify(p1, Mockito.times(2)).createKey(Mockito.eq("test3"), [EOL] Mockito.any(Options.class)); [EOL] verify(p2, Mockito.times(1)).createKey(Mockito.eq("test3"), [EOL] Mockito.any(Options.class)); [EOL] } [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(30 * 1000); [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.chop("T"); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[8]; [EOL]       charSequenceArray0[0] = (CharSequence) "T"; [EOL]       charSequenceArray0[1] = (CharSequence) "T"; [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       charSequenceArray0[3] = (CharSequence) ""; [EOL]       charSequenceArray0[4] = (CharSequence) "T"; [EOL]       charSequenceArray0[5] = (CharSequence) "T"; [EOL]       charSequenceArray0[6] = (CharSequence) ""; [EOL]       charSequenceArray0[7] = (CharSequence) "T"; [EOL]       boolean boolean0 = StringUtils.startsWithAny("", charSequenceArray0); [EOL]        [EOL]       String string1 = StringUtils.removePattern("", ""); [EOL]       assertTrue(string1.equals((Object)string0)); [EOL]        [EOL]       String string2 = StringUtils.substring((String) null, (-4043)); [EOL]        [EOL]       String string3 = StringUtils.trim((String) null); [EOL]        [EOL]       boolean boolean1 = StringUtils.containsOnly((CharSequence) null, (String) null); [EOL]        [EOL]       boolean boolean2 = StringUtils.isAllUpperCase(charSequenceArray0[0]); [EOL]        [EOL]       String[] stringArray0 = new String[3]; [EOL]       stringArray0[0] = "T"; [EOL]       stringArray0[1] = ""; [EOL]       stringArray0[2] = ""; [EOL]       String[] stringArray1 = StringUtils.stripAll(stringArray0); [EOL]       assertFalse(stringArray1.equals((Object)stringArray0)); [EOL]        [EOL]       boolean boolean3 = StringUtils.isWhitespace(charSequenceArray0[4]); [EOL]        [EOL]       int int0 = StringUtils.getLevenshteinDistance((CharSequence) "", charSequenceArray0[2], 0); [EOL]        [EOL]       boolean boolean4 = StringUtils.containsNone(charSequenceArray0[6], "{FakYXNQUOHZ"); [EOL]        [EOL]       long[] longArray0 = new long[2]; [EOL]       longArray0[0] = 1885L; [EOL]       longArray0[1] = (long) 0; [EOL]       String string4 = StringUtils.join(longArray0, 'S', 285, 0); [EOL]       assertTrue(string4.equals((Object)string1)); [EOL]        [EOL]       String[] stringArray2 = StringUtils.splitPreserveAllTokens("LaKB", "{FakYXNQUOHZ", (-4043)); [EOL]       assertFalse(stringArray2.equals((Object)stringArray0)); [EOL]       assertFalse(stringArray2.equals((Object)stringArray1)); [EOL]        [EOL]       byte[] byteArray0 = new byte[7]; [EOL]       byteArray0[0] = (byte)21; [EOL]       byteArray0[1] = (byte)0; [EOL]       byteArray0[2] = (byte)16; [EOL]       byteArray0[3] = (byte) (-1); [EOL]       byteArray0[4] = (byte)3; [EOL]       byteArray0[5] = (byte)64; [EOL]       byteArray0[6] = (byte)36; [EOL]       try {  [EOL]         StringUtils.toString(byteArray0, ""); [EOL]         fail("Expecting exception: UnsupportedEncodingException"); [EOL]        [EOL]       } catch(UnsupportedEncodingException e) { [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmark()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("D:qv{0F`Yb3&H^f*N2", (-1)); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]        [EOL]       String string0 = strBuilder4.leftString((-1)); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(false); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", (-1)); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys();2|T ")); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0);2|T ")); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAscii()  throws Throwable  { [EOL]       boolean boolean0 = CharUtils.isAsciiControl('\uDC42'); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNoNextPendingAsk() { [EOL] FSLeafQueue queue = Mockito.mock(FSLeafQueue.class); [EOL] ApplicationAttemptId applicationAttemptId = createAppAttemptId(1, 1); [EOL] RMContext rmContext = Mockito.mock(RMContext.class); [EOL] ConcurrentMap<ApplicationId, RMApp> rmApps = new ConcurrentHashMap<>(); [EOL] RMApp rmApp = Mockito.mock(RMApp.class); [EOL] rmApps.put(applicationAttemptId.getApplicationId(), rmApp); [EOL] ApplicationSubmissionContext appContext = [EOL] Mockito.mock(ApplicationSubmissionContext.class); [EOL] Mockito.when(appContext.getUnmanagedAM()).thenReturn(false); [EOL] Mockito.when(appContext.getLogAggregationContext()) [EOL] .thenReturn(Mockito.mock(LogAggregationContext.class)); [EOL] Mockito.when(rmApp.getApplicationSchedulingEnvs()) [EOL] .thenReturn(new HashMap<>()); [EOL] Mockito.when(rmApp.getApplicationSubmissionContext()) [EOL] .thenReturn(appContext); [EOL] Mockito.when(rmContext.getRMApps()).thenReturn(rmApps); [EOL] Mockito.when(rmContext.getYarnConfiguration()).thenReturn(conf); [EOL] FSAppAttempt schedulerApp = [EOL] new FSAppAttempt(scheduler, applicationAttemptId, "user1", queue, [EOL] null, rmContext); [EOL] schedulerApp.setAmRunning(false); [EOL] FSSchedulerNode schedulerNode = Mockito.mock(FSSchedulerNode.class); [EOL] [EOL] Resource resource = schedulerApp.assignContainer(schedulerNode); [EOL] [EOL] assertEquals(Resources.none(), resource); [EOL] } [EOL]
@Test (timeout = 5000) [EOL] public void testRunCommandwithPriority() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.setInt(YarnConfiguration.NM_CONTAINER_EXECUTOR_SCHED_PRIORITY, 2); [EOL] String[] command = containerExecutor.getRunCommand("echo", "group1", "user", null, conf); [EOL] if (Shell.WINDOWS) { [EOL] // windows doesn't currently support [EOL] assertEquals("first command should be the run command for the platform", [EOL] Shell.WINUTILS, command[0]); [EOL] } else { [EOL] assertEquals("first command should be nice", "nice", command[0]); [EOL] assertEquals("second command should be -n", "-n", command[1]); [EOL] assertEquals("third command should be the priority", Integer.toString(2), [EOL] command[2]); [EOL] } [EOL] [EOL] // test with negative number [EOL] conf.setInt(YarnConfiguration.NM_CONTAINER_EXECUTOR_SCHED_PRIORITY, -5); [EOL] command = containerExecutor.getRunCommand("echo", "group1", "user", null, conf); [EOL] if (Shell.WINDOWS) { [EOL] // windows doesn't currently support [EOL] assertEquals("first command should be the run command for the platform", [EOL] Shell.WINUTILS, command[0]); [EOL] } else { [EOL] assertEquals("first command should be nice", "nice", command[0]); [EOL] assertEquals("second command should be -n", "-n", command[1]); [EOL] assertEquals("third command should be the priority", Integer.toString(-5), [EOL] command[2]); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestContainerExecutor.class); [EOL] private ContainerExecutor containerExecutor = new DefaultContainerExecutor(); [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       assertEquals(0, compareToBuilder0.toComparison()); [EOL]        [EOL]       compareToBuilder0.append(1359, 43); [EOL]       assertEquals(1, compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmin()  throws Throwable  { [EOL]       int int0 = NumberUtils.min(5226, 5226, 5226); [EOL]       assertEquals(5226, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testInputBuffer() throws IOException { [EOL] final int size = 100; [EOL] final InputBuffer input1 = new InputBuffer(BufferType.DIRECT_BUFFER, size); [EOL] assertThat(input1.getType()).isEqualTo(BufferType.DIRECT_BUFFER); [EOL] [EOL] assertThat(input1.position()).isZero(); [EOL] assertThat(input1.length()).isZero(); [EOL] assertThat(input1.remaining()).isZero(); [EOL] assertThat(input1.capacity()).isEqualTo(size); [EOL] [EOL] final InputBuffer input2 = new InputBuffer(BufferType.HEAP_BUFFER, size); [EOL] assertThat(input2.getType()).isEqualTo(BufferType.HEAP_BUFFER); [EOL] [EOL] assertThat(input2.position()).isZero(); [EOL] assertThat(input2.length()).isZero(); [EOL] assertThat(input2.remaining()).isZero(); [EOL] assertThat(input2.capacity()).isEqualTo(size); [EOL] [EOL] final InputBuffer input3 = new InputBuffer(new byte[size]); [EOL] assertThat(input3.getType()).isEqualTo(BufferType.HEAP_BUFFER); [EOL] [EOL] assertThat(input3.position()).isZero(); [EOL] assertThat(input3.length()).isZero(); [EOL] assertThat(input3.remaining()).isZero(); [EOL] assertThat(input3.capacity()).isEqualTo(size); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetArraySeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.setArraySeparator((String) null); [EOL]       String string0 = standardToStringStyle0.getArraySeparator(); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(79); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0.0F); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append((double) 79); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln((-2267)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendln((Object) strBuilder3); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder2.clear(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder2.isEmpty()); [EOL]       assertTrue(strBuilder5.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.deleteAll('#'); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]       assertTrue(strBuilder3.isEmpty()); [EOL]       assertTrue(strBuilder4.isEmpty()); [EOL]       assertTrue(strBuilder6.isEmpty()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       int int0 = 2; [EOL]       StrBuilder strBuilder7 = strBuilder0.append((CharSequence) strBuilder1); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]       assertTrue(strBuilder7.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder0.replaceAll("nCIF=^XRVL:\t%AH&", "end < start"); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder8.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append((CharSequence) stringBuilder0, 2, (-211)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testreverse()  throws Throwable  { [EOL]       short[] shortArray0 = new short[1]; [EOL]       ArrayUtils.reverse(shortArray0); [EOL]       assertArrayEquals(new short[] {(short)0}, shortArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(6); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.ensureCapacity(6); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendNull(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrMatcher.TrimMatcher strMatcher_TrimMatcher0 = new StrMatcher.TrimMatcher(); [EOL]        [EOL]       int int0 = strBuilder2.indexOf((StrMatcher) strMatcher_TrimMatcher0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       ArrayDeque<Integer> arrayDeque0 = new ArrayDeque<Integer>((-1)); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendAll((Iterable<?>) arrayDeque0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder("v@1?:{"); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         stringBuilder0.insert((-1), (CharSequence) strBuilder2, (-1), 6); [EOL]         fail("Expecting exception: IndexOutOfBoundsException"); [EOL]        [EOL]       } catch(IndexOutOfBoundsException e) { [EOL]          // [EOL]          // dstOffset -1 [EOL]          // [EOL]          verifyException("java.lang.AbstractStringBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAllocateSingleDevice() [EOL] throws ResourceHandlerException, IOException { [EOL] setupTestDirectoryWithScript(); [EOL] plugin = new NECVEPlugin(envProvider, defaultSearchDirs, udevUtil); [EOL] Set<Device> available = new HashSet<>(); [EOL] Device device = getTestDevice(0); [EOL] available.add(device); [EOL] [EOL] Set<Device> allocated = plugin.allocateDevices(available, 1, env); [EOL] [EOL] assertEquals("No. of devices", 1, allocated.size()); [EOL] Device allocatedDevice = allocated.iterator().next(); [EOL] assertSame("Device", device, allocatedDevice); [EOL] } [EOL] private static final String DEFAULT_SCRIPT_NAME = "nec-ve-get.py"; [EOL] private static final String[] EMPTY_SEARCH_DIRS = new String[] {}; [EOL] private static final Comparator<Device> DEVICE_COMPARATOR = [EOL] Comparator.comparingInt(Device::getId); [EOL] private Function<String, String> envProvider; [EOL] private Map<String, String> env; [EOL] private String[] defaultSearchDirs; [EOL] private Function<String[], CommandExecutor> [EOL] commandExecutorProvider; [EOL] private String testFolder; [EOL] @Mock [EOL] private CommandExecutor mockCommandExecutor; [EOL] @Mock [EOL] private UdevUtil udevUtil; [EOL] private String defaultScriptOutput; [EOL] private NECVEPlugin plugin; [EOL]
@Test [EOL] public void testGetAuthenticator() throws Exception { [EOL] Authenticator authenticator = Mockito.mock(Authenticator.class); [EOL] [EOL] AuthenticatedURL aURL = new AuthenticatedURL(authenticator); [EOL] Assert.assertEquals(authenticator, aURL.getAuthenticator()); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(false); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln((-3134.9556F)); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(0, (String) null); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       Writer writer0 = strBuilder3.asWriter(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher(':'); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("vSi.a.bur[", 3954); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder4.trim(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       int int1 = 6; [EOL]       StrBuilder strBuilder6 = strBuilder4.append(6); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]       assertNull(strBuilder6.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strMatcher0.isMatch(charArray0, 3954); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testToString() { [EOL] ProcessingDetails details = new ProcessingDetails(TimeUnit.MICROSECONDS); [EOL] details.set(Timing.ENQUEUE, 10); [EOL] details.set(Timing.QUEUE, 20, TimeUnit.MILLISECONDS); [EOL] [EOL] assertEquals("enqueueTime=10 queueTime=20000 handlerTime=0 " + [EOL] "processingTime=0 lockfreeTime=0 lockwaitTime=0 locksharedTime=0 " + [EOL] "lockexclusiveTime=0 responseTime=0", details.toString()); [EOL] } [EOL]
@Test(timeout = 30000) [EOL] public void testInitDistCp() throws Exception { [EOL] String testRoot = nnUri + "/user/foo/testdir." + getMethodName(); [EOL] DistributedFileSystem fs = [EOL] (DistributedFileSystem) FileSystem.get(URI.create(nnUri), conf); [EOL] createFiles(fs, testRoot, srcfiles); [EOL] [EOL] Path src = new Path(testRoot, SRCDAT); [EOL] Path dst = new Path(testRoot, DSTDAT); [EOL] // set permission. [EOL] fs.setPermission(src, FsPermission.createImmutable((short) 020)); [EOL] [EOL] FedBalanceContext context = buildContext(src, dst, MOUNT); [EOL] DistCpProcedure dcProcedure = [EOL] new DistCpProcedure("distcp-procedure", null, 1000, context); [EOL] [EOL] // submit distcp. [EOL] try { [EOL] dcProcedure.initDistCp(); [EOL] } catch (RetryException e) { [EOL] } [EOL] fs.delete(new Path(src, "a"), true); [EOL] // wait until job done. [EOL] executeProcedure(dcProcedure, Stage.DIFF_DISTCP, [EOL] () -> dcProcedure.initDistCp()); [EOL] assertTrue(fs.exists(dst)); [EOL] // Because we used snapshot, the file should be copied. [EOL] assertTrue(fs.exists(new Path(dst, "a"))); [EOL] cleanup(fs, new Path(testRoot)); [EOL] } [EOL] private static MiniDFSCluster cluster; [EOL] private static Configuration conf; [EOL] static final String MOUNT = "mock_mount_point"; [EOL] private static final String SRCDAT = "srcdat"; [EOL] private static final String DSTDAT = "dstdat"; [EOL] private static final long BLOCK_SIZE = 1024; [EOL] private static final long FILE_SIZE = BLOCK_SIZE * 100; [EOL] private FileEntry[] srcfiles = [EOL] {new FileEntry(SRCDAT, true), new FileEntry(SRCDAT + "/a", false), [EOL] new FileEntry(SRCDAT + "/b", true), [EOL] new FileEntry(SRCDAT + "/b/c", false)}; [EOL] private static String nnUri; [EOL]
@Test [EOL] public void testFailsOnInactive() throws IOException { [EOL] servlet = new IsActiveServlet() { [EOL] @Override [EOL] protected boolean isActive() { [EOL] return false; [EOL] } [EOL] }; [EOL] [EOL] doGet(); [EOL] verify(resp, atLeastOnce()).sendError( [EOL] eq(HttpServletResponse.SC_METHOD_NOT_ALLOWED), [EOL] eq(IsActiveServlet.RESPONSE_NOT_ACTIVE)); [EOL] } [EOL] private IsActiveServlet servlet; [EOL] private HttpServletRequest req; [EOL] private HttpServletResponse resp; [EOL] private ByteArrayOutputStream respOut; [EOL]
@Test(timeout = 4000) [EOL]   public void testis()  throws Throwable  { [EOL]       Range<String> range0 = Range.is("Elements in a range must not be null: element1="); [EOL]       boolean boolean0 = range0.isEndedBy(""); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testCompareToDate() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare testCompareToDate"); [EOL] TModelInstanceDetails lhs = new TModelInstanceDetails(); [EOL] lhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] lhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] lhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] lhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("asdasd"); [EOL] TModelInstanceDetails rhs = new TModelInstanceDetails(); [EOL] [EOL] rhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] rhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] rhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("asdasdasd"); [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", false, true, false); [EOL] [EOL] int result = instance.compare(lhs, rhs); [EOL] //Assert.assertTrue("result " + result,result < 0); [EOL] [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       String string0 = "#Vd[("; [EOL]       StrBuilder strBuilder0 = new StrBuilder("#Vd[("); [EOL]       assertEquals(5, strBuilder0.size()); [EOL]        [EOL]       int int0 = 7; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.delete(7, 1542); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       compareToBuilder0.append((-463.38F), (-1.0F)); [EOL]       byte[] byteArray0 = new byte[9]; [EOL]       compareToBuilder0.append(byteArray0, byteArray0); [EOL]       assertEquals((-1), (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 100000) [EOL] public void testGetMapOutputInfo() throws Exception { [EOL] final ArrayList<Throwable> failures = new ArrayList<Throwable>(1); [EOL] Configuration conf = new Configuration(); [EOL] conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY, 0); [EOL] conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS, 3); [EOL] conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION, [EOL] "simple"); [EOL] UserGroupInformation.setConfiguration(conf); [EOL] conf.set(YarnConfiguration.NM_LOCAL_DIRS, ABS_LOG_DIR.getAbsolutePath()); [EOL] ApplicationId appId = ApplicationId.newInstance(12345, 1); [EOL] String appAttemptId = "attempt_12345_1_m_1_0"; [EOL] String user = "randomUser"; [EOL] String reducerId = "0"; [EOL] List<File> fileMap = new ArrayList<File>(); [EOL] createShuffleHandlerFiles(ABS_LOG_DIR, user, appId.toString(), appAttemptId, [EOL] conf, fileMap); [EOL] AuxiliaryLocalPathHandler pathHandler = new TestAuxiliaryLocalPathHandler(); [EOL] ShuffleHandler shuffleHandler = new ShuffleHandler() { [EOL] @Override [EOL] protected Shuffle getShuffle(Configuration conf) { [EOL] // replace the shuffle handler with one stubbed for testing [EOL] return new Shuffle(conf) { [EOL] @Override [EOL] protected void populateHeaders(List<String> mapIds, [EOL] String outputBaseStr, String user, int reduce, [EOL] HttpRequest request, HttpResponse response, [EOL] boolean keepAliveParam, Map<String, MapOutputInfo> infoMap) [EOL] throws IOException { [EOL] // Only set response headers and skip everything else [EOL] // send some dummy value for content-length [EOL] super.setResponseHeaders(response, keepAliveParam, 100); [EOL] } [EOL] @Override [EOL] protected void verifyRequest(String appid, [EOL] ChannelHandlerContext ctx, HttpRequest request, [EOL] HttpResponse response, URL requestUri) throws IOException { [EOL] // Do nothing. [EOL] } [EOL] @Override [EOL] protected void sendError(ChannelHandlerContext ctx, String message, [EOL] HttpResponseStatus status) { [EOL] if (failures.size() == 0) { [EOL] failures.add(new Error(message)); [EOL] ctx.getChannel().close(); [EOL] } [EOL] } [EOL] @Override [EOL] protected ChannelFuture sendMapOutput(ChannelHandlerContext ctx, [EOL] Channel ch, String user, String mapId, int reduce, [EOL] MapOutputInfo info) throws IOException { [EOL] // send a shuffle header [EOL] ShuffleHeader header = [EOL] new ShuffleHeader("attempt_12345_1_m_1_0", 5678, 5678, 1); [EOL] DataOutputBuffer dob = new DataOutputBuffer(); [EOL] header.write(dob); [EOL] return ch.write(wrappedBuffer(dob.getData(), 0, dob.getLength())); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] shuffleHandler.setAuxiliaryLocalPathHandler(pathHandler); [EOL] shuffleHandler.init(conf); [EOL] try { [EOL] shuffleHandler.start(); [EOL] DataOutputBuffer outputBuffer = new DataOutputBuffer(); [EOL] outputBuffer.reset(); [EOL] Token<JobTokenIdentifier> jt = [EOL] new Token<JobTokenIdentifier>("identifier".getBytes(), [EOL] "password".getBytes(), new Text(user), new Text("shuffleService")); [EOL] jt.write(outputBuffer); [EOL] shuffleHandler [EOL] .initializeApplication(new ApplicationInitializationContext(user, [EOL] appId, ByteBuffer.wrap(outputBuffer.getData(), 0, [EOL] outputBuffer.getLength()))); [EOL] URL url = [EOL] new URL( [EOL] "http://127.0.0.1:" [EOL] + shuffleHandler.getConfig().get( [EOL] ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) [EOL] + "/mapOutput?job=job_12345_0001&reduce=" + reducerId [EOL] + "&map=attempt_12345_1_m_1_0"); [EOL] HttpURLConnection conn = (HttpURLConnection) url.openConnection(); [EOL] conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME, [EOL] ShuffleHeader.DEFAULT_HTTP_HEADER_NAME); [EOL] conn.setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION, [EOL] ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION); [EOL] conn.connect(); [EOL] try { [EOL] DataInputStream is = new DataInputStream(conn.getInputStream()); [EOL] ShuffleHeader header = new ShuffleHeader(); [EOL] header.readFields(is); [EOL] is.close(); [EOL] } catch (EOFException e) { [EOL] // ignore [EOL] } [EOL] Assert.assertEquals("sendError called due to shuffle error", [EOL] 0, failures.size()); [EOL] } finally { [EOL] shuffleHandler.stop(); [EOL] FileUtil.fullyDelete(ABS_LOG_DIR); [EOL] } [EOL] } [EOL] static final long MiB = 1024 * 1024; [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestShuffleHandler.class); [EOL] private static final File ABS_LOG_DIR = GenericTestUtils.getTestDir( [EOL] TestShuffleHandler.class.getSimpleName() + "LocDir"); [EOL]
@Test [EOL] public void testRemoteAddrWithUntrustedProxy() { [EOL] assertEquals(proxyAddr, getRemoteAddr(clientAddr, proxyAddr, false)); [EOL] } [EOL] private final Configuration conf = new HdfsConfiguration(); [EOL] private static String clientAddr = "1.1.1.1"; [EOL] private static String chainedClientAddr = clientAddr+", 2.2.2.2"; [EOL] private static String proxyAddr = "3.3.3.3"; [EOL]
@Test(timeout = 4000) [EOL]   public void testsetEmptyTokenAsNull()  throws Throwable  { [EOL]       char[] charArray0 = new char[1]; [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getCSVInstance(charArray0); [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       strTokenizer0.next(); [EOL]       assertEquals(1, strTokenizer0.nextIndex()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAuxServicesManifestPermissions() throws IOException { [EOL] Assume.assumeTrue(useManifest); [EOL] Configuration conf = getABConf(); [EOL] FileSystem fs = FileSystem.get(conf); [EOL] fs.setPermission(new Path(manifest.getAbsolutePath()), FsPermission [EOL] .createImmutable((short) 0777)); [EOL] AuxServices aux = new AuxServices(MOCK_AUX_PATH_HANDLER, [EOL] MOCK_CONTEXT, MOCK_DEL_SERVICE); [EOL] aux.init(conf); [EOL] assertEquals(0, aux.getServices().size()); [EOL] [EOL] fs.setPermission(new Path(manifest.getAbsolutePath()), FsPermission [EOL] .createImmutable((short) 0775)); [EOL] aux = new AuxServices(MOCK_AUX_PATH_HANDLER, [EOL] MOCK_CONTEXT, MOCK_DEL_SERVICE); [EOL] aux.init(conf); [EOL] assertEquals(0, aux.getServices().size()); [EOL] [EOL] fs.setPermission(new Path(manifest.getAbsolutePath()), FsPermission [EOL] .createImmutable((short) 0755)); [EOL] fs.setPermission(new Path(rootDir.getAbsolutePath()), FsPermission [EOL] .createImmutable((short) 0775)); [EOL] aux = new AuxServices(MOCK_AUX_PATH_HANDLER, [EOL] MOCK_CONTEXT, MOCK_DEL_SERVICE); [EOL] aux.init(conf); [EOL] assertEquals(0, aux.getServices().size()); [EOL] [EOL] fs.setPermission(new Path(rootDir.getAbsolutePath()), FsPermission [EOL] .createImmutable((short) 0755)); [EOL] aux = new AuxServices(MOCK_AUX_PATH_HANDLER, [EOL] MOCK_CONTEXT, MOCK_DEL_SERVICE); [EOL] aux.init(conf); [EOL] assertEquals(2, aux.getServices().size()); [EOL] [EOL] conf.set(YarnConfiguration.YARN_ADMIN_ACL, ""); [EOL] aux = new AuxServices(MOCK_AUX_PATH_HANDLER, [EOL] MOCK_CONTEXT, MOCK_DEL_SERVICE); [EOL] aux.init(conf); [EOL] assertEquals(0, aux.getServices().size()); [EOL] [EOL] conf.set(YarnConfiguration.YARN_ADMIN_ACL, UserGroupInformation [EOL] .getCurrentUser().getShortUserName()); [EOL] aux = new AuxServices(MOCK_AUX_PATH_HANDLER, [EOL] MOCK_CONTEXT, MOCK_DEL_SERVICE); [EOL] aux.init(conf); [EOL] assertEquals(2, aux.getServices().size()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestAuxServices.class); [EOL] private static final File TEST_DIR = new File( [EOL] System.getProperty("test.build.data", [EOL] System.getProperty("java.io.tmpdir")), [EOL] TestAuxServices.class.getName()); [EOL] private final static AuxiliaryLocalPathHandler MOCK_AUX_PATH_HANDLER = [EOL] mock(AuxiliaryLocalPathHandler.class); [EOL] private final static Context MOCK_CONTEXT = mock(Context.class); [EOL] private final static DeletionService MOCK_DEL_SERVICE = mock( [EOL] DeletionService.class); [EOL] private final Boolean useManifest; [EOL] private File rootDir = GenericTestUtils.getTestDir(getClass() [EOL] .getSimpleName()); [EOL] private File manifest = new File(rootDir, "manifest.txt"); [EOL] private ObjectMapper mapper = new ObjectMapper(); [EOL]
@Test [EOL] public void testAAAALookup() throws Exception { [EOL] ServiceRecord record = getMarshal().fromBytes("somepath", [EOL] CONTAINER_RECORD.getBytes()); [EOL] getRegistryDNS().register( [EOL] "/registry/users/root/services/org-apache-slider/test1/components/" [EOL] + "ctr-e50-1451931954322-0016-01-000002", [EOL] record); [EOL] [EOL] // start assessing whether correct records are available [EOL] Record[] recs = assertDNSQuery( [EOL] "ctr-e50-1451931954322-0016-01-000002.dev.test.", Type.AAAA, 1); [EOL] assertEquals("wrong result", "172.17.0.19", [EOL] ((AAAARecord) recs[0]).getAddress().getHostAddress()); [EOL] [EOL] recs = assertDNSQuery("httpd-1.test1.root.dev.test.", Type.AAAA, 1); [EOL] assertTrue("not an ARecord", recs[0] instanceof AAAARecord); [EOL] } [EOL] private RegistryDNS registryDNS; [EOL] private RegistryUtils.ServiceRecordMarshal marshal; [EOL] private static final String APPLICATION_RECORD = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"Slider Application Master\",\n" [EOL] + " \"external\" : [ {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.appmaster.ipc" [EOL] + "\",\n" [EOL] + " \"addressType\" : \"host/port\",\n" [EOL] + " \"protocolType\" : \"hadoop/IPC\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"host\" : \"192.168.1.5\",\n" [EOL] + " \"port\" : \"1026\"\n" [EOL] + " } ]\n" [EOL] + " }, {\n" [EOL] + " \"api\" : \"http://\",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"webui\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"http://192.168.1.5:1027\"\n" [EOL] + " } ]\n" [EOL] + " }, {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.management\"" [EOL] + ",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"REST\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"http://192.168.1.5:1027/ws/v1/slider/mgmt\"\n" [EOL] + " } ]\n" [EOL] + " } ],\n" [EOL] + " \"internal\" : [ {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.agents.secure" [EOL] + "\",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"REST\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"https://192.168.1.5:47700/ws/v1/slider/agents\"\n" [EOL] + " } ]\n" [EOL] + " }, {\n" [EOL] + " \"api\" : \"classpath:org.apache.hadoop.yarn.service.agents.oneway" [EOL] + "\",\n" [EOL] + " \"addressType\" : \"uri\",\n" [EOL] + " \"protocolType\" : \"REST\",\n" [EOL] + " \"addresses\" : [ {\n" [EOL] + " \"uri\" : \"https://192.168.1.5:35531/ws/v1/slider/agents\"\n" [EOL] + " } ]\n" [EOL] + " } ],\n" [EOL] + " \"yarn:id\" : \"application_1451931954322_0016\",\n" [EOL] + " \"yarn:persistence\" : \"application\"\n" [EOL] + "}\n"; [EOL] static final String CONTAINER_RECORD = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-1\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000002\",\n" [EOL] + " \"yarn:persistence\" : \"container\",\n" [EOL] + " \"yarn:ip\" : \"172.17.0.19\",\n" [EOL] + " \"yarn:hostname\" : \"host1\",\n" [EOL] + " \"yarn:component\" : \"httpd\"\n" [EOL] + "}\n"; [EOL] static final String CONTAINER_RECORD2 = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-2\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000003\",\n" [EOL] + " \"yarn:persistence\" : \"container\",\n" [EOL] + " \"yarn:ip\" : \"172.17.0.20\",\n" [EOL] + " \"yarn:hostname\" : \"host2\",\n" [EOL] + " \"yarn:component\" : \"httpd\"\n" [EOL] + "}\n"; [EOL] private static final String CONTAINER_RECORD_NO_IP = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-1\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000002\",\n" [EOL] + " \"yarn:persistence\" : \"container\",\n" [EOL] + " \"yarn:component\" : \"httpd\"\n" [EOL] + "}\n"; [EOL] private static final String CONTAINER_RECORD_YARN_PERSISTANCE_ABSENT = "{\n" [EOL] + " \"type\" : \"JSONServiceRecord\",\n" [EOL] + " \"description\" : \"httpd-1\",\n" [EOL] + " \"external\" : [ ],\n" [EOL] + " \"internal\" : [ ],\n" [EOL] + " \"yarn:id\" : \"container_e50_1451931954322_0016_01_000003\",\n" [EOL] + " \"yarn:ip\" : \"172.17.0.19\",\n" [EOL] + " \"yarn:hostname\" : \"0a134d6329bb\",\n" [EOL] + " \"yarn:component\" : \"httpd\"" [EOL] + "}\n"; [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(32); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteAll((String) null); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       Object[] objectArray0 = new Object[9]; [EOL]       objectArray0[0] = (Object) null; [EOL]       objectArray0[1] = (Object) strBuilder0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       objectArray0[4] = (Object) strBuilder1; [EOL]       objectArray0[5] = (Object) strBuilder1; [EOL]       objectArray0[6] = (Object) strBuilder1; [EOL]       objectArray0[7] = (Object) null; [EOL]       objectArray0[8] = (Object) strBuilder1; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln((String) null, objectArray0); [EOL]         fail("Expecting exception: NullPointerException"); [EOL]        [EOL]       } catch(NullPointerException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testHSXML() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("history") [EOL] .accept(MediaType.APPLICATION_XML).get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_XML + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] String xml = response.getEntity(String.class); [EOL] verifyHSInfoXML(xml, appContext); [EOL] } [EOL] private static Configuration conf = new Configuration(); [EOL] private static HistoryContext appContext; [EOL] private static HsWebApp webApp; [EOL]
@Test(expected = AWSBadRequestException.class) [EOL] public void testNoRetryOfBadRequestNonIdempotent() throws Throwable { [EOL] invoker.retry("test", null, false, [EOL] () -> { [EOL] throw serviceException(400, "bad request"); [EOL] }); [EOL] } [EOL] private static final Configuration FAST_RETRY_CONF; [EOL] private static final ConnectTimeoutException [EOL] HADOOP_CONNECTION_TIMEOUT_EX = new ConnectTimeoutException("hadoop"); [EOL] private static final Local.ConnectTimeoutException [EOL] LOCAL_CONNECTION_TIMEOUT_EX [EOL] = new Local.ConnectTimeoutException("local"); [EOL] private static final org.apache.http.conn.ConnectTimeoutException [EOL] HTTP_CONNECTION_TIMEOUT_EX [EOL] = new org.apache.http.conn.ConnectTimeoutException("apache"); [EOL] private static final SocketTimeoutException SOCKET_TIMEOUT_EX [EOL] = new SocketTimeoutException("socket"); [EOL] private static final int ACTIVE_RETRY_LIMIT = RETRY_LIMIT_DEFAULT; [EOL] private static final int RETRIES_TOO_MANY = ACTIVE_RETRY_LIMIT + 10; [EOL] public static final int SAFE_RETRY_COUNT = 5; [EOL] private static final S3ARetryPolicy RETRY_POLICY = [EOL] new S3ARetryPolicy(FAST_RETRY_CONF); [EOL] private int retryCount; [EOL] private Invoker invoker = new Invoker(RETRY_POLICY, [EOL] (text, e, retries, idempotent) -> retryCount++); [EOL] private static final AmazonClientException CLIENT_TIMEOUT_EXCEPTION = [EOL] new AmazonClientException(new Local.ConnectTimeoutException("timeout")); [EOL] private static final AmazonServiceException BAD_REQUEST = serviceException( [EOL] AWSBadRequestException.STATUS_CODE, [EOL] "bad request"); [EOL]
@Test [EOL] public void testORConstraintAssignment() [EOL] throws InvalidAllocationTagsQueryException { [EOL] AllocationTagsManager tm = new AllocationTagsManager(rmContext); [EOL] PlacementConstraintManagerService pcm = [EOL] new MemoryPlacementConstraintManager(); [EOL] // Register App1 with anti-affinity constraint map. [EOL] pcm.registerApplication(appId1, constraintMap4); [EOL] RMNode n0r1 = rmNodes.get(0); [EOL] RMNode n1r1 = rmNodes.get(1); [EOL] RMNode n2r2 = rmNodes.get(2); [EOL] RMNode n3r2 = rmNodes.get(3); [EOL] [EOL] /** [EOL] * Place container: [EOL] * n0: hbase-m(1) [EOL] * n1: "" [EOL] * n2: hbase-rs(1) [EOL] * n3: "" [EOL] */ [EOL] tm.addContainer(n0r1.getNodeID(), [EOL] newContainerId(appId1, 1), ImmutableSet.of("hbase-m")); [EOL] tm.addContainer(n2r2.getNodeID(), [EOL] newContainerId(appId1, 2), ImmutableSet.of("hbase-rs")); [EOL] Assert.assertEquals(1L, tm.getAllocationTagsWithCount(n0r1.getNodeID()) [EOL] .get("hbase-m").longValue()); [EOL] Assert.assertEquals(1L, tm.getAllocationTagsWithCount(n2r2.getNodeID()) [EOL] .get("hbase-rs").longValue()); [EOL] [EOL] SchedulerNode schedulerNode0 =newSchedulerNode(n0r1.getHostName(), [EOL] n0r1.getRackName(), n0r1.getNodeID()); [EOL] SchedulerNode schedulerNode1 =newSchedulerNode(n1r1.getHostName(), [EOL] n1r1.getRackName(), n1r1.getNodeID()); [EOL] SchedulerNode schedulerNode2 =newSchedulerNode(n2r2.getHostName(), [EOL] n2r2.getRackName(), n2r2.getNodeID()); [EOL] SchedulerNode schedulerNode3 =newSchedulerNode(n3r2.getHostName(), [EOL] n3r2.getRackName(), n3r2.getNodeID()); [EOL] [EOL] // n0 and n2 should be qualified for allocation as [EOL] // they either have hbase-m or hbase-rs tag [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag1), schedulerNode0, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag1), schedulerNode1, pcm, tm)); [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag1), schedulerNode2, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag1), schedulerNode3, pcm, tm)); [EOL] [EOL] /** [EOL] * Place container: [EOL] * n0: hbase-m(1) [EOL] * n1: "" [EOL] * n2: hbase-rs(1) [EOL] * n3: hbase-rs(1) [EOL] */ [EOL] tm.addContainer(n3r2.getNodeID(), [EOL] newContainerId(appId1, 2), ImmutableSet.of("hbase-rs")); [EOL] // n3 is qualified now because it is allocated with hbase-rs tag [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag1), schedulerNode3, pcm, tm)); [EOL] [EOL] /** [EOL] * Place container: [EOL] * n0: hbase-m(1) [EOL] * n1: "" [EOL] * n2: hbase-rs(1), spark(1) [EOL] * n3: hbase-rs(1) [EOL] */ [EOL] // Place [EOL] tm.addContainer(n2r2.getNodeID(), [EOL] newContainerId(appId1, 3), ImmutableSet.of("spark")); [EOL] // According to constraint, "zk" is allowed to be placed on a node [EOL] // has "hbase-m" tag OR a node has both "hbase-rs" and "spark" tags. [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag2), schedulerNode0, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag2), schedulerNode1, pcm, tm)); [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag2), schedulerNode2, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints(appId1, [EOL] createSchedulingRequest(sourceTag2), schedulerNode3, pcm, tm)); [EOL] } [EOL] private List<RMNode> rmNodes; [EOL] private RMContext rmContext; [EOL] private static final int GB = 1024; [EOL] private ApplicationId appId1; [EOL] private PlacementConstraint c1, c2, c3, c4, c5, c6, c7; [EOL] private Set<String> sourceTag1, sourceTag2; [EOL] private Map<Set<String>, PlacementConstraint> constraintMap1, [EOL] constraintMap2, constraintMap3, constraintMap4; [EOL] private AtomicLong requestID = new AtomicLong(0); [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.stripEnd("~@!LXZ6YxCtw", ""); [EOL]        [EOL]       String string1 = StringUtils.substringAfter("p{InCombiningDiacriticalMarks}+", "'fJ"); [EOL]       assertFalse(string1.equals((Object)string0)); [EOL]        [EOL]       String string2 = StringUtils.difference("p{InCombiningDiacriticalMarks}+", "~@!LXZ6YxCtw"); [EOL]       assertFalse(string2.equals((Object)string1)); [EOL]       assertTrue(string2.equals((Object)string0)); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetContentSummary() throws IOException { [EOL] // GetContentSummary of a dir [EOL] fSys.mkdirs(new Path("/newDir/dirFoo")); [EOL] ContentSummary cs = fSys.getContentSummary(new Path("/newDir/dirFoo")); [EOL] Assert.assertEquals(-1L, cs.getQuota()); [EOL] Assert.assertEquals(-1L, cs.getSpaceQuota()); [EOL] } [EOL] FileSystem fSys; [EOL] FileSystem fSysTarget; [EOL] Path chrootedTo; [EOL] FileSystemTestHelper fileSystemTestHelper; [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.charMatcher('h'); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceAll(", Length: 0", ", Length: 0"); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       Object[] objectArray0 = new Object[6]; [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer1 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.clone(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer2 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.cloneReset(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendFixedWidthPadLeft((Object) strBuilder_StrBuilderTokenizer2, 773, '5'); [EOL]       assertEquals(773, strBuilder0.size()); [EOL]       assertEquals(773, strBuilder2.size()); [EOL]        [EOL]       objectArray0[1] = (Object) strBuilder_StrBuilderTokenizer1; [EOL]       objectArray0[3] = (Object) strMatcher0; [EOL]       objectArray0[4] = (Object) ", Length: 0"; [EOL]       objectArray0[5] = (Object) strMatcher0; [EOL]       StrBuilder strBuilder3 = strBuilder1.appendSeparator(""); [EOL]       assertEquals(773, strBuilder0.size()); [EOL]       assertEquals(773, strBuilder1.size()); [EOL]       assertEquals(773, strBuilder3.size()); [EOL]        [EOL]       char[] charArray0 = new char[6]; [EOL]       charArray0[0] = 'h'; [EOL]       charArray0[1] = 'h'; [EOL]       charArray0[2] = 'h'; [EOL]       charArray0[3] = 'h'; [EOL]       charArray0[4] = 'h'; [EOL]       charArray0[5] = 'h'; [EOL]       int int0 = strBuilder0.indexOf(strMatcher0); [EOL]       assertEquals(773, strBuilder0.size()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAddResourceConcurrency() throws Exception { [EOL] startEmptyStore(); [EOL] final String key = "key1"; [EOL] int count = 5; [EOL] ExecutorService exec = HadoopExecutors.newFixedThreadPool(count); [EOL] List<Future<String>> futures = new ArrayList<Future<String>>(count); [EOL] final CountDownLatch start = new CountDownLatch(1); [EOL] for (int i = 0; i < count; i++) { [EOL] final String fileName = "foo-" + i + ".jar"; [EOL] Callable<String> task = new Callable<String>() { [EOL] public String call() throws Exception { [EOL] start.await(); [EOL] String result = store.addResource(key, fileName); [EOL] System.out.println("fileName: " + fileName + ", result: " + result); [EOL] return result; [EOL] } [EOL] }; [EOL] futures.add(exec.submit(task)); [EOL] } [EOL] // start them all at the same time [EOL] start.countDown(); [EOL] // check the result; they should all agree with the value [EOL] Set<String> results = new HashSet<String>(); [EOL] for (Future<String> future: futures) { [EOL] results.add(future.get()); [EOL] } [EOL] assertSame(1, results.size()); [EOL] exec.shutdown(); [EOL] } [EOL] private InMemorySCMStore store; [EOL] private AppChecker checker; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       int int0 = StringUtils.ordinalIndexOf((CharSequence) null, (CharSequence) null, (-2586)); [EOL]        [EOL]       int int1 = StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null); [EOL]        [EOL]       String string0 = StringUtils.center("6~L @37EEQ$", (-2586), "The character must not be null"); [EOL]        [EOL]       int int2 = StringUtils.length("6~L @37EEQ$"); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[1]; [EOL]       charSequenceArray0[0] = (CharSequence) "6~L @37EEQ$"; [EOL]       String string1 = StringUtils.appendIfMissingIgnoreCase("6~L @37EEQ$", "6~L @37EEQ$", charSequenceArray0); [EOL]       assertEquals(1, charSequenceArray0.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAbsoluteVcoresNegativeWithSpaces() throws Exception { [EOL] expectNegativeValueOfResource("vcores"); [EOL] parseResourceConfigValue("-2 vcores, 5120 mb"); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testcapitalize()  throws Throwable  { [EOL]       String string0 = WordUtils.capitalizeFully("C"); [EOL]       assertEquals("C", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSiteAssignMultipleConversion() { [EOL] yarnConfig.setBoolean(FairSchedulerConfiguration.ASSIGN_MULTIPLE, true); [EOL] [EOL] converter.convertSiteProperties(yarnConfig, yarnConvertedConfig, false, [EOL] false); [EOL] [EOL] assertTrue("Assign multiple", [EOL] yarnConvertedConfig.getBoolean( [EOL] CapacitySchedulerConfiguration.ASSIGN_MULTIPLE_ENABLED, [EOL] false)); [EOL] } [EOL] private Configuration yarnConfig; [EOL] private FSYarnSiteConverter converter; [EOL] private Configuration yarnConvertedConfig; [EOL]
@Test(timeout=120000) [EOL] public void testDestroyAllShellProcesses() throws Throwable { [EOL] Assume.assumeFalse(WINDOWS); [EOL] StringBuffer sleepCommand = new StringBuffer(); [EOL] sleepCommand.append("sleep 200"); [EOL] String[] shellCmd = {"bash", "-c", sleepCommand.toString()}; [EOL] final ShellCommandExecutor shexc1 = new ShellCommandExecutor(shellCmd); [EOL] final ShellCommandExecutor shexc2 = new ShellCommandExecutor(shellCmd); [EOL] [EOL] Thread shellThread1 = new Thread() { [EOL] @Override [EOL] public void run() { [EOL] try { [EOL] shexc1.execute(); [EOL] } catch(IOException ioe) { [EOL] //ignore IOException from thread interrupt [EOL] } [EOL] } [EOL] }; [EOL] Thread shellThread2 = new Thread() { [EOL] @Override [EOL] public void run() { [EOL] try { [EOL] shexc2.execute(); [EOL] } catch(IOException ioe) { [EOL] //ignore IOException from thread interrupt [EOL] } [EOL] } [EOL] }; [EOL] [EOL] shellThread1.start(); [EOL] shellThread2.start(); [EOL] GenericTestUtils.waitFor(new Supplier<Boolean>() { [EOL] @Override [EOL] public Boolean get() { [EOL] return shexc1.getProcess() != null; [EOL] } [EOL] }, 10, 10000); [EOL] [EOL] GenericTestUtils.waitFor(new Supplier<Boolean>() { [EOL] @Override [EOL] public Boolean get() { [EOL] return shexc2.getProcess() != null; [EOL] } [EOL] }, 10, 10000); [EOL] [EOL] Shell.destroyAllShellProcesses(); [EOL] shexc1.getProcess().waitFor(); [EOL] shexc2.getProcess().waitFor(); [EOL] } [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(30000); [EOL] @Rule [EOL] public TestName methodName = new TestName(); [EOL] private File rootTestDir = GenericTestUtils.getTestDir(); [EOL] private File methodDir; [EOL]
@Test(timeout = 4000) [EOL]   public void testintToHex()  throws Throwable  { [EOL]       char char0 = Conversion.intToHexDigitMsb0(2); [EOL]       assertEquals('4', char0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(2134); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) null, ""); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]       assertEquals(2134, strBuilder1.capacity()); [EOL]        [EOL]       int int0 = strBuilder0.indexOf(""); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.deleteFirst((StrMatcher) null); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]       assertEquals(2134, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendAll((Iterator<?>) null); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]       assertEquals(2134, strBuilder2.capacity()); [EOL]       assertEquals(2134, strBuilder3.capacity()); [EOL]        [EOL]       CharSequence charSequence0 = strBuilder2.subSequence(0, 0); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]       assertEquals(2134, strBuilder2.capacity()); [EOL]        [EOL]       String string0 = strBuilder0.getNullText(); [EOL]       assertEquals(2134, strBuilder0.capacity()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFlex() { [EOL] String appName = "example-app"; [EOL] HashMap<String, String> componentCounts = new HashMap<String, String>(); [EOL] try { [EOL] int result = asc.actionFlex(appName, componentCounts); [EOL] assertEquals(EXIT_SUCCESS, result); [EOL] } catch (IOException | YarnException e) { [EOL] fail(); [EOL] } [EOL] } [EOL] private static ApiServiceClient asc; [EOL] private static ApiServiceClient badAsc; [EOL] private static Server server; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(true); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[4]; [EOL]       charArray0[0] = '^'; [EOL]       charArray0[1] = '?'; [EOL]       charArray0[2] = 'U'; [EOL]       charArray0[3] = '4'; [EOL]       StrBuilder strBuilder2 = strBuilder1.insert(2, charArray0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln((-3134.9556F)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder4 = strBuilder3.insert(0, (String) null); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       Writer writer0 = strBuilder4.asWriter(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher(':'); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("vSi.a.bur[", 3954); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       char[] charArray1 = new char[0]; [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray1); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder5.trim(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       int int1 = 6; [EOL]       StrBuilder strBuilder7 = strBuilder5.append(6); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder7.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strMatcher0.isMatch(charArray1, 3954); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.replaceChars("', has a length less than 2", 'E', 'E'); [EOL]        [EOL]       String string1 = StringUtils.replace("', has a length less than 2", "', has a length less than 2", "', has a length less than 2"); [EOL]       assertTrue(string1.equals((Object)string0)); [EOL]        [EOL]       boolean boolean0 = StringUtils.contains((CharSequence) "', has a length less than 2", (CharSequence) "', has a length less than 2"); [EOL]        [EOL]       boolean boolean1 = StringUtils.isAlphanumericSpace("', has a length less than 2"); [EOL]        [EOL]       String string2 = StringUtils.difference("', has a length less than 2", "', has a length less than 2"); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]       assertFalse(string2.equals((Object)string1)); [EOL]        [EOL]       String string3 = "', has a length less than 2"; [EOL]       String string4 = StringUtils.removeStart("", "', has a length less than 2"); [EOL]       assertFalse(string4.equals((Object)string3)); [EOL]       assertFalse(string4.equals((Object)string1)); [EOL]       assertFalse(string4.equals((Object)string0)); [EOL]       assertTrue(string4.equals((Object)string2)); [EOL]        [EOL]       int int0 = StringUtils.indexOfDifference((CharSequence) "', has a length less than 2", (CharSequence) "', has a length less than 2"); [EOL]        [EOL]       String string5 = StringUtils.substringAfterLast("', has a length less than 2", "', has a length less than 2"); [EOL]       assertTrue(string5.equals((Object)string4)); [EOL]       assertFalse(string5.equals((Object)string1)); [EOL]       assertFalse(string5.equals((Object)string3)); [EOL]       assertFalse(string5.equals((Object)string0)); [EOL]        [EOL]       boolean boolean2 = StringUtils.isAllUpperCase("', has a length less than 2"); [EOL]        [EOL]       int int1 = (-76); [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         StringUtils.abbreviate("x", (-76), (-1)); [EOL]         fail("Expecting exception: IllegalArgumentException"); [EOL]        [EOL]       } catch(IllegalArgumentException e) { [EOL]          // [EOL]          // Minimum abbreviation width is 4 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.StringUtils", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 10000) [EOL] public void testAddStoppedChildInStop() throws Throwable { [EOL] CompositeService parent = new CompositeService("parent"); [EOL] BreakableService child = new BreakableService(); [EOL] child.init(new Configuration()); [EOL] child.start(); [EOL] child.stop(); [EOL] parent.init(new Configuration()); [EOL] parent.start(); [EOL] parent.stop(); [EOL] AddSiblingService.addChildToService(parent, child); [EOL] } [EOL] private static final int NUM_OF_SERVICES = 5; [EOL] private static final int FAILED_SERVICE_SEQ_NUMBER = 2; [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCompositeService.class); [EOL] private static final boolean STOP_ONLY_STARTED_SERVICES = [EOL] CompositeServiceImpl.isPolicyToStopOnlyStartedServices(); [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       int int0 = ArrayUtils.lastIndexOf((boolean[]) null, true); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisNumber()  throws Throwable  { [EOL]       boolean boolean0 = NumberUtils.isNumber("."); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(expected = NumberFormatException.class) [EOL] public void testCompareToNotNumberData() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare testCompareToNotNumberData"); [EOL] TModelInstanceDetails lhs = new TModelInstanceDetails(); [EOL] lhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] lhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] lhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] lhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("xyz"); [EOL] TModelInstanceDetails rhs = new TModelInstanceDetails(); [EOL] [EOL] rhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] rhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] rhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("xyz"); [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", true, false, false); [EOL] int expResult = 0; [EOL] int result = instance.compare(lhs, rhs); [EOL] } [EOL]
@Test(timeout = 30000) [EOL] public void testDeleteSnapshot() throws Exception { [EOL] Path snapRootPath = new Path("/snapPath"); [EOL] Path chRootedSnapRootPath = new Path("/a/b/snapPath"); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] conf.setClass("fs.mockfs.impl", MockFileSystem.class, FileSystem.class); [EOL] [EOL] URI chrootUri = URI.create("mockfs://foo/a/b"); [EOL] ChRootedFileSystem chrootFs = new ChRootedFileSystem(chrootUri, conf); [EOL] FileSystem mockFs = ((FilterFileSystem) chrootFs.getRawFileSystem()) [EOL] .getRawFileSystem(); [EOL] [EOL] chrootFs.deleteSnapshot(snapRootPath, "snap1"); [EOL] verify(mockFs).deleteSnapshot(chRootedSnapRootPath, "snap1"); [EOL] } [EOL] FileSystem fSys; [EOL] FileSystem fSysTarget; [EOL] Path chrootedTo; [EOL] FileSystemTestHelper fileSystemTestHelper; [EOL]
@Test [EOL] public void addChildren() { [EOL] @SuppressWarnings("unchecked") [EOL] Deque<Expression> expressions = mock(Deque.class); [EOL] test.addChildren(expressions); [EOL] verify(expr).addChildren(expressions); [EOL] verifyNoMoreInteractions(expr); [EOL] } [EOL] private Expression expr; [EOL] private FilterExpression test; [EOL] @Rule [EOL] public Timeout globalTimeout = new Timeout(10000); [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.chop("T"); [EOL]        [EOL]       String string1 = StringUtils.removePattern("", ""); [EOL]       assertTrue(string1.equals((Object)string0)); [EOL]        [EOL]       String string2 = StringUtils.substring((String) null, (-4035)); [EOL]        [EOL]       boolean boolean0 = StringUtils.isAllLowerCase(""); [EOL]        [EOL]       boolean boolean1 = StringUtils.isAllUpperCase(""); [EOL]        [EOL]       String[] stringArray0 = new String[3]; [EOL]       stringArray0[0] = "T"; [EOL]       stringArray0[1] = ""; [EOL]       stringArray0[2] = ""; [EOL]       String[] stringArray1 = StringUtils.stripAll(stringArray0); [EOL]       assertFalse(stringArray1.equals((Object)stringArray0)); [EOL]        [EOL]       boolean boolean2 = StringUtils.isWhitespace("T"); [EOL]        [EOL]       int int0 = StringUtils.getLevenshteinDistance((CharSequence) "", (CharSequence) "T", 0); [EOL]        [EOL]       boolean boolean3 = StringUtils.containsNone((CharSequence) "T", "{FakYXNQUOHZ"); [EOL]        [EOL]       boolean boolean4 = StringUtils.contains((CharSequence) "", 0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testincrement()  throws Throwable  { [EOL]       Byte byte0 = new Byte((byte)0); [EOL]       MutableLong mutableLong0 = new MutableLong((Number) byte0); [EOL]       mutableLong0.increment(); [EOL]       mutableLong0.toLong(); [EOL]       assertEquals(1, mutableLong0.intValue()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       int int0 = 7; [EOL]       StrBuilder strBuilder0 = new StrBuilder(7); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.trim(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       int int1 = 0; [EOL]       int int2 = 32; [EOL]       StrBuilder strBuilder2 = strBuilder0.insert(0, 32); [EOL]       assertEquals(2, strBuilder0.size()); [EOL]       assertEquals(2, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append('r'); [EOL]       assertEquals(3, strBuilder0.size()); [EOL]       assertEquals(3, strBuilder1.size()); [EOL]       assertEquals(3, strBuilder3.size()); [EOL]        [EOL]       Integer integer0 = new Integer(0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.clear(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder4.size()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.quoteMatcher(); [EOL]        [EOL]       String string0 = ")[C$#_(U9,]+>eub7]}"; [EOL]       StrBuilder strBuilder5 = strBuilder0.appendln(false); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]       assertEquals(6, strBuilder5.size()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.replaceAll(strMatcher0, ")[C$#_(U9,]+>eub7]}"); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]       assertEquals(6, strBuilder4.size()); [EOL]       assertEquals(6, strBuilder6.size()); [EOL]        [EOL]       char char0 = 'c'; [EOL]       int int3 = strBuilder0.lastIndexOf('c', 7); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder2.appendSeparator("Solaris"); [EOL]       assertEquals(13, strBuilder0.size()); [EOL]       assertEquals(13, strBuilder2.size()); [EOL]       assertEquals(13, strBuilder7.size()); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder1.new StrBuilderWriter(); [EOL]       assertEquals(13, strBuilder0.size()); [EOL]       assertEquals(13, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder4.appendFixedWidthPadRight((Object) "java.vm.specification.version", 81, '0'); [EOL]       assertEquals(94, strBuilder8.size()); [EOL]       assertEquals(94, strBuilder0.size()); [EOL]       assertEquals(94, strBuilder4.size()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder_StrBuilderWriter0.write("J~TQzXP^tZ:~", 7, 519); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String[] stringArray0 = new String[2]; [EOL]       stringArray0[0] = "o&$W$9Myt(-BI6CNQZ"; [EOL]       String string0 = " v](>;:r<Bi6i@@h-"; [EOL]       stringArray0[1] = " v](>;:r<Bi6i@@h-"; [EOL]       String string1 = StringUtils.getCommonPrefix(stringArray0); [EOL]       assertEquals(2, stringArray0.length); [EOL]        [EOL]       boolean boolean0 = StringUtils.isBlank(" v](>;:r<Bi6i@@h-"); [EOL]        [EOL]       String string2 = StringUtils.left("P{", Integer.MAX_VALUE); [EOL]        [EOL]       boolean boolean1 = StringUtils.containsIgnoreCase("P{", ""); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         StringUtils.abbreviate("P{", Integer.MAX_VALUE, (-3384)); [EOL]         fail("Expecting exception: IllegalArgumentException"); [EOL]        [EOL]       } catch(IllegalArgumentException e) { [EOL]          // [EOL]          // Minimum abbreviation width is 4 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.StringUtils", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testWildCard() { [EOL] //create MachineList with a list of of IPs [EOL] MachineList ml = new MachineList("*"); [EOL] [EOL] //test for inclusion with any IP [EOL] assertTrue(ml.includes("10.119.103.112")); [EOL] assertTrue(ml.includes("1.2.3.4")); [EOL] } [EOL] private static String IP_LIST = "10.119.103.110,10.119.103.112,10.119.103.114"; [EOL] private static String IP_LIST_SPACES = [EOL] " 10.119.103.110 , 10.119.103.112,10.119.103.114 ,10.119.103.110, "; [EOL] private static String CIDR_LIST = "10.222.0.0/16,10.241.23.0/24"; [EOL] private static String CIDR_LIST1 = "10.222.0.0/16"; [EOL] private static String CIDR_LIST2 = "10.241.23.0/24"; [EOL] private static String INVALID_CIDR = "10.241/24"; [EOL] private static String IP_CIDR_LIST = [EOL] "10.222.0.0/16,10.119.103.110,10.119.103.112,10.119.103.114,10.241.23.0/24"; [EOL] private static String HOST_LIST = "host1,host4"; [EOL] private static String HOSTNAME_IP_CIDR_LIST = [EOL] "host1,10.222.0.0/16,10.119.103.110,10.119.103.112,10.119.103.114,10.241.23.0/24,host4,"; [EOL]
@Test(timeout = 4000) [EOL]   public void testsplit()  throws Throwable  { [EOL]       System.setCurrentTimeMillis(0L); [EOL]       StopWatch stopWatch0 = new StopWatch(); [EOL]       stopWatch0.start(); [EOL]       stopWatch0.split(); [EOL]       String string0 = stopWatch0.toSplitString(); [EOL]       assertNotNull(string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.remove("null comparator", '.'); [EOL]        [EOL]       int int0 = StringUtils.getLevenshteinDistance((CharSequence) "null comparator", (CharSequence) "null comparator", 64); [EOL]        [EOL]       String string1 = StringUtils.replace("null comparator", "null comparator", "Minimum abbreviation width with offset is 7", (-809)); [EOL]       assertFalse(string1.equals((Object)string0)); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       boolean boolean0 = StringUtils.containsOnly((CharSequence) "Minimum abbreviation width with offset is 7", charArray0); [EOL]        [EOL]       String[] stringArray0 = StringUtils.substringsBetween("Minimum abbreviation width with offset is 7", "null comparator", "9'A"); [EOL]        [EOL]       String string2 = StringUtils.removeStart("Minimum abbreviation width with offset is 7", "null comparator"); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]       assertTrue(string2.equals((Object)string1)); [EOL]        [EOL]       boolean boolean1 = StringUtils.isAsciiPrintable("Minimum abbreviation width with offset is 7"); [EOL]        [EOL]       String string3 = StringUtils.replacePattern("", "", ""); [EOL]       assertFalse(string3.equals((Object)string0)); [EOL]       assertFalse(string3.equals((Object)string1)); [EOL]       assertFalse(string3.equals((Object)string2)); [EOL]        [EOL]       boolean boolean2 = StringUtils.isAsciiPrintable("Minimum abbreviation width with offset is 7"); [EOL]        [EOL]       String string4 = StringUtils.deleteWhitespace("null comparator"); [EOL]       assertFalse(string4.equals((Object)string0)); [EOL]       assertFalse(string4.equals((Object)string3)); [EOL]       assertFalse(string4.equals((Object)string1)); [EOL]       assertFalse(string4.equals((Object)string2)); [EOL]        [EOL]       String string5 = StringUtils.getCommonPrefix((String[]) null); [EOL]       assertFalse(string5.equals((Object)string0)); [EOL]       assertFalse(string5.equals((Object)string4)); [EOL]       assertFalse(string5.equals((Object)string1)); [EOL]       assertTrue(string5.equals((Object)string3)); [EOL]       assertFalse(string5.equals((Object)string2)); [EOL]        [EOL]       boolean boolean3 = StringUtils.isAlphanumericSpace(""); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("org.apache.commons.lang3.text.StrBuilder"); [EOL]       assertEquals(40, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator('2'); [EOL]       assertEquals(41, strBuilder0.length()); [EOL]       assertEquals(41, strBuilder1.length()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertEquals(41, strBuilder0.length()); [EOL]       assertEquals(41, strBuilder1.length()); [EOL]        [EOL]       StringWriter stringWriter0 = new StringWriter(); [EOL]        [EOL]       StringBuffer stringBuffer0 = stringWriter0.getBuffer(); [EOL]       assertEquals(0, stringBuffer0.length()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append(stringBuffer0); [EOL]       assertEquals(41, strBuilder0.length()); [EOL]       assertEquals(0, stringBuffer0.length()); [EOL]       assertEquals(41, strBuilder2.length()); [EOL]        [EOL]       strBuilder0.hashCode(); [EOL]       assertEquals(41, strBuilder0.length()); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("org.apache.commons.lang3.text.StrBuilder", 870); [EOL]       assertEquals(41, strBuilder0.length()); [EOL]        [EOL]       int int1 = strBuilder0.lastIndexOf('', 0); [EOL]       assertEquals(41, strBuilder0.length()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtranslate()  throws Throwable  { [EOL]       OctalUnescaper octalUnescaper0 = new OctalUnescaper(); [EOL]       StringWriter stringWriter0 = new StringWriter(); [EOL]       char[] charArray0 = new char[4]; [EOL]       charArray0[0] = '\\'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       int int0 = octalUnescaper0.translate((CharSequence) charBuffer0, 0, (Writer) stringWriter0); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("b-K~^"); [EOL]       assertEquals(5, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendNewLine(); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]       assertEquals(6, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.append((StringBuilder) null); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]       assertEquals(6, strBuilder1.size()); [EOL]       assertEquals(6, strBuilder2.size()); [EOL]        [EOL]       boolean boolean0 = strBuilder1.equals(strBuilder0); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]       assertEquals(6, strBuilder1.size()); [EOL]        [EOL]       int int0 = strBuilder0.capacity(); [EOL]       assertEquals(6, strBuilder0.size()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = 'p'; [EOL]       int int1 = 96; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(31, charArray0, 96, (-886)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 31 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbinaryToHexDigitMsb0_4bits()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[7]; [EOL]       booleanArray0[0] = true; [EOL]       booleanArray0[1] = true; [EOL]       booleanArray0[3] = true; [EOL]       char char0 = Conversion.binaryToHexDigitMsb0_4bits(booleanArray0); [EOL]       assertEquals('d', char0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 30000) [EOL] public void testFilterAppsByAggregatedStatus() throws Exception { [EOL] try (MiniYARNCluster yarnCluster = [EOL] new MiniYARNCluster(TestHadoopArchiveLogs.class.getSimpleName(), [EOL] 1, 1, 1, 1)) { [EOL] Configuration conf = new Configuration(); [EOL] conf.setBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED, true); [EOL] yarnCluster.init(conf); [EOL] yarnCluster.start(); [EOL] conf = yarnCluster.getConfig(); [EOL] [EOL] RMContext rmContext = yarnCluster.getResourceManager().getRMContext(); [EOL] RMAppImpl appImpl1 = (RMAppImpl)createRMApp(1, conf, rmContext, [EOL] LogAggregationStatus.DISABLED); [EOL] RMAppImpl appImpl2 = (RMAppImpl)createRMApp(2, conf, rmContext, [EOL] LogAggregationStatus.FAILED); [EOL] RMAppImpl appImpl3 = (RMAppImpl)createRMApp(3, conf, rmContext, [EOL] LogAggregationStatus.NOT_START); [EOL] RMAppImpl appImpl4 = (RMAppImpl)createRMApp(4, conf, rmContext, [EOL] LogAggregationStatus.SUCCEEDED); [EOL] RMAppImpl appImpl5 = (RMAppImpl)createRMApp(5, conf, rmContext, [EOL] LogAggregationStatus.RUNNING); [EOL] RMAppImpl appImpl6 = (RMAppImpl)createRMApp(6, conf, rmContext, [EOL] LogAggregationStatus.RUNNING_WITH_FAILURE); [EOL] RMAppImpl appImpl7 = (RMAppImpl)createRMApp(7, conf, rmContext, [EOL] LogAggregationStatus.TIME_OUT); [EOL] RMAppImpl appImpl8 = (RMAppImpl)createRMApp(8, conf, rmContext, [EOL] LogAggregationStatus.SUCCEEDED); [EOL] rmContext.getRMApps().put(appImpl1.getApplicationId(), appImpl1); [EOL] rmContext.getRMApps().put(appImpl2.getApplicationId(), appImpl2); [EOL] rmContext.getRMApps().put(appImpl3.getApplicationId(), appImpl3); [EOL] rmContext.getRMApps().put(appImpl4.getApplicationId(), appImpl4); [EOL] rmContext.getRMApps().put(appImpl5.getApplicationId(), appImpl5); [EOL] rmContext.getRMApps().put(appImpl6.getApplicationId(), appImpl6); [EOL] rmContext.getRMApps().put(appImpl7.getApplicationId(), appImpl7); [EOL] // appImpl8 is not in the RM [EOL] [EOL] HadoopArchiveLogs hal = new HadoopArchiveLogs(conf); [EOL] Assert.assertEquals(0, hal.eligibleApplications.size()); [EOL] hal.eligibleApplications.add( [EOL] new HadoopArchiveLogs.AppInfo(appImpl1.getApplicationId().toString(), [EOL] USER)); [EOL] hal.eligibleApplications.add( [EOL] new HadoopArchiveLogs.AppInfo(appImpl2.getApplicationId().toString(), [EOL] USER)); [EOL] hal.eligibleApplications.add( [EOL] new HadoopArchiveLogs.AppInfo(appImpl3.getApplicationId().toString(), [EOL] USER)); [EOL] HadoopArchiveLogs.AppInfo app4 = [EOL] new HadoopArchiveLogs.AppInfo(appImpl4.getApplicationId().toString(), [EOL] USER); [EOL] hal.eligibleApplications.add(app4); [EOL] hal.eligibleApplications.add( [EOL] new HadoopArchiveLogs.AppInfo(appImpl5.getApplicationId().toString(), [EOL] USER)); [EOL] hal.eligibleApplications.add( [EOL] new HadoopArchiveLogs.AppInfo(appImpl6.getApplicationId().toString(), [EOL] USER)); [EOL] HadoopArchiveLogs.AppInfo app7 = [EOL] new HadoopArchiveLogs.AppInfo(appImpl7.getApplicationId().toString(), [EOL] USER); [EOL] hal.eligibleApplications.add(app7); [EOL] HadoopArchiveLogs.AppInfo app8 = [EOL] new HadoopArchiveLogs.AppInfo(appImpl8.getApplicationId().toString(), [EOL] USER); [EOL] hal.eligibleApplications.add(app8); [EOL] Assert.assertEquals(8, hal.eligibleApplications.size()); [EOL] hal.filterAppsByAggregatedStatus(); [EOL] Assert.assertEquals(3, hal.eligibleApplications.size()); [EOL] Assert.assertTrue(hal.eligibleApplications.contains(app4)); [EOL] Assert.assertTrue(hal.eligibleApplications.contains(app7)); [EOL] Assert.assertTrue(hal.eligibleApplications.contains(app8)); [EOL] } [EOL] } [EOL] private static final long CLUSTER_TIMESTAMP = System.currentTimeMillis(); [EOL] private static final String USER = System.getProperty("user.name"); [EOL] private static final int FILE_SIZE_INCREMENT = 4096; [EOL] private static final byte[] DUMMY_DATA = new byte[FILE_SIZE_INCREMENT]; [EOL]
@Test [EOL] public void testNamedCommitterFactoryNullPath() throws Throwable { [EOL] Configuration conf = new Configuration(); [EOL] // set up for the schema factory [EOL] conf.set(COMMITTER_FACTORY_CLASS, NAMED_COMMITTER_FACTORY); [EOL] conf.set(NAMED_COMMITTER_CLASS, SimpleCommitter.class.getName()); [EOL] SimpleCommitter sc = createCommitter( [EOL] NamedCommitterFactory.class, [EOL] SimpleCommitter.class, [EOL] null, conf); [EOL] assertNull(sc.getOutputPath()); [EOL] } [EOL] private static final String HTTP_COMMITTER_FACTORY = String.format( [EOL] COMMITTER_FACTORY_SCHEME_PATTERN, "http"); [EOL] private static final Path HTTP_PATH = new Path("http://hadoop.apache.org/"); [EOL] private static final Path HDFS_PATH = new Path("hdfs://localhost:8081/"); [EOL] private TaskAttemptID taskAttemptID = [EOL] new TaskAttemptID("local", 0, TaskType.MAP, 1, 2); [EOL]
@Test [EOL] public void shutdownHookManager() { [EOL] assertNotNull("No ShutdownHookManager", mgr); [EOL] assertEquals(0, mgr.getShutdownHooksInOrder().size()); [EOL] Hook hook1 = new Hook("hook1", 0, false); [EOL] Hook hook2 = new Hook("hook2", 0, false); [EOL] Hook hook3 = new Hook("hook3", 1000, false); [EOL] Hook hook4 = new Hook("hook4", 25000, true); [EOL] Hook hook5 = new Hook("hook5", [EOL] (SERVICE_SHUTDOWN_TIMEOUT_DEFAULT + 1) * 1000, true); [EOL] [EOL] mgr.addShutdownHook(hook1, 0); [EOL] assertTrue(mgr.hasShutdownHook(hook1)); [EOL] assertEquals(1, mgr.getShutdownHooksInOrder().size()); [EOL] assertEquals(hook1, mgr.getShutdownHooksInOrder().get(0).getHook()); [EOL] assertTrue(mgr.removeShutdownHook(hook1)); [EOL] assertFalse(mgr.hasShutdownHook(hook1)); [EOL] assertFalse(mgr.removeShutdownHook(hook1)); [EOL] [EOL] mgr.addShutdownHook(hook1, 0); [EOL] assertTrue(mgr.hasShutdownHook(hook1)); [EOL] assertEquals(1, mgr.getShutdownHooksInOrder().size()); [EOL] assertEquals(SERVICE_SHUTDOWN_TIMEOUT_DEFAULT, [EOL] mgr.getShutdownHooksInOrder().get(0).getTimeout()); [EOL] [EOL] mgr.addShutdownHook(hook2, 1); [EOL] assertTrue(mgr.hasShutdownHook(hook1)); [EOL] assertTrue(mgr.hasShutdownHook(hook2)); [EOL] assertEquals(2, mgr.getShutdownHooksInOrder().size()); [EOL] assertEquals(hook2, mgr.getShutdownHooksInOrder().get(0).getHook()); [EOL] assertEquals(hook1, mgr.getShutdownHooksInOrder().get(1).getHook()); [EOL] [EOL] // Test hook finish without timeout [EOL] mgr.addShutdownHook(hook3, 2, 4, TimeUnit.SECONDS); [EOL] assertTrue(mgr.hasShutdownHook(hook3)); [EOL] assertEquals(hook3, mgr.getShutdownHooksInOrder().get(0).getHook()); [EOL] assertEquals(4, mgr.getShutdownHooksInOrder().get(0).getTimeout()); [EOL] [EOL] // Test hook finish with timeout; highest priority [EOL] int hook4timeout = 2; [EOL] mgr.addShutdownHook(hook4, 3, hook4timeout, TimeUnit.SECONDS); [EOL] assertTrue(mgr.hasShutdownHook(hook4)); [EOL] assertEquals(hook4, mgr.getShutdownHooksInOrder().get(0).getHook()); [EOL] assertEquals(2, mgr.getShutdownHooksInOrder().get(0).getTimeout()); [EOL] [EOL] // a default timeout hook and verify it gets the default timeout [EOL] mgr.addShutdownHook(hook5, 5); [EOL] ShutdownHookManager.HookEntry hookEntry5 = mgr.getShutdownHooksInOrder() [EOL] .get(0); [EOL] assertEquals(hook5, hookEntry5.getHook()); [EOL] assertEquals("default timeout not used", [EOL] ShutdownHookManager.getShutdownTimeout(new Configuration()), [EOL] hookEntry5.getTimeout()); [EOL] assertEquals("hook priority", 5, hookEntry5.getPriority()); [EOL] // remove this to avoid a longer sleep in the test run [EOL] assertTrue("failed to remove " + hook5, [EOL] mgr.removeShutdownHook(hook5)); [EOL] [EOL] [EOL] // now execute the hook shutdown sequence [EOL] INVOCATION_COUNT.set(0); [EOL] LOG.info("invoking executeShutdown()"); [EOL] int timeouts = mgr.executeShutdown(); [EOL] LOG.info("Shutdown completed"); [EOL] assertEquals("Number of timed out hooks", 1, timeouts); [EOL] [EOL] List<ShutdownHookManager.HookEntry> hooks [EOL] = mgr.getShutdownHooksInOrder(); [EOL] [EOL] // analyze the hooks [EOL] for (ShutdownHookManager.HookEntry entry : hooks) { [EOL] Hook hook = (Hook) entry.getHook(); [EOL] assertTrue("Was not invoked " + hook, hook.invoked); [EOL] // did any hook raise an exception? [EOL] hook.maybeThrowAssertion(); [EOL] } [EOL] [EOL] // check the state of some of the invoked hooks [EOL] // hook4 was invoked first, but it timed out. [EOL] assertEquals("Expected to be invoked first " + hook4, [EOL] 1, hook4.invokedOrder); [EOL] assertFalse("Expected to time out " + hook4, hook4.completed); [EOL] [EOL] [EOL] // hook1 completed, but in order after the others, so its start time [EOL] // is the longest. [EOL] assertTrue("Expected to complete " + hook1, hook1.completed); [EOL] long invocationInterval = hook1.startTime - hook4.startTime; [EOL] assertTrue("invocation difference too short " + invocationInterval, [EOL] invocationInterval >= hook4timeout * 1000); [EOL] assertTrue("sleeping hook4 blocked other threads for " + invocationInterval, [EOL] invocationInterval < hook4.sleepTime); [EOL] [EOL] // finally, clear the hooks [EOL] mgr.clearShutdownHooks(); [EOL] // and verify that the hooks are empty [EOL] assertFalse(mgr.hasShutdownHook(hook1)); [EOL] assertEquals("shutdown hook list is not empty", [EOL] 0, [EOL] mgr.getShutdownHooksInOrder().size()); [EOL] } [EOL] static final Logger LOG = [EOL] LoggerFactory.getLogger(TestShutdownHookManager.class.getName()); [EOL] private final ShutdownHookManager mgr = new ShutdownHookManager(); [EOL] private static final AtomicInteger INVOCATION_COUNT = new AtomicInteger(); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       int int0 = 79; [EOL]       StrBuilder strBuilder0 = new StrBuilder(79); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0.0F); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append((double) 79); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       int int1 = (-2267); [EOL]       StrBuilder strBuilder3 = strBuilder1.appendln((Object) strBuilder1); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.deleteAll('o'); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder3.getNewLineText()); [EOL]       assertNull(strBuilder4.getNewLineText()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.replaceAll("nCIF=^XRVL:\t%AH&", "end < start"); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder5.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append((CharSequence) stringBuilder0, 79, (-211)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.stripAccents((String) null); [EOL]        [EOL]       boolean boolean0 = StringUtils.containsIgnoreCase((CharSequence) null, (CharSequence) null); [EOL]        [EOL]       boolean boolean1 = StringUtils.isAsciiPrintable((CharSequence) null); [EOL]        [EOL]       String string1 = StringUtils.removeEnd((String) null, "%"); [EOL]        [EOL]       boolean boolean2 = StringUtils.containsWhitespace((CharSequence) null); [EOL]        [EOL]       String string2 = StringUtils.substring("4q57|=FQji9Xaa?i", 0, 591); [EOL]        [EOL]       int int0 = StringUtils.lastIndexOf((CharSequence) "4q57|=FQji9Xaa?i", (CharSequence) "4q57|=FQji9Xaa?i"); [EOL]        [EOL]       boolean boolean3 = StringUtils.isWhitespace((CharSequence) null); [EOL]        [EOL]       String string3 = StringUtils.upperCase((String) null); [EOL]        [EOL]       String string4 = StringUtils.difference("4q57|=FQji9Xaa?i", "4q57|=FQji9Xaa?i"); [EOL]       assertFalse(string4.equals((Object)string2)); [EOL]        [EOL]       String string5 = StringUtils.chop((String) null); [EOL]        [EOL]       boolean boolean4 = StringUtils.isAlphaSpace((CharSequence) null); [EOL]        [EOL]       boolean boolean5 = StringUtils.isEmpty((CharSequence) null); [EOL]        [EOL]       String[] stringArray0 = new String[6]; [EOL]       stringArray0[0] = null; [EOL]       stringArray0[1] = null; [EOL]       stringArray0[2] = ""; [EOL]       stringArray0[3] = null; [EOL]       stringArray0[4] = null; [EOL]       stringArray0[5] = "4q57|=FQji9Xaa?i"; [EOL]       String[] stringArray1 = StringUtils.stripAll(stringArray0); [EOL]       assertFalse(stringArray1.equals((Object)stringArray0)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testshortToBinary()  throws Throwable  { [EOL]       boolean[] booleanArray0 = Conversion.hexDigitMsb0ToBinary('C'); [EOL]       boolean[] booleanArray1 = Conversion.shortToBinary((short) (-314), (short) (-314), booleanArray0, (-1), (-1)); [EOL]       assertTrue(Arrays.equals(new boolean[] {true, true, false, false}, booleanArray1)); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCustomResourceRequestedUnitIsGreaterThanAvailableUnit2() { [EOL] Resource requestedResource = ResourceTypesTestHelper.newResource(1, 1, [EOL] ImmutableMap.<String, String>builder().put("custom-resource-1", "11M") [EOL] .build()); [EOL] [EOL] Resource availableResource = [EOL] ResourceTypesTestHelper.newResource(1, 1, [EOL] ImmutableMap.of("custom-resource-1", "1G")); [EOL] [EOL] try { [EOL] SchedulerUtils.checkResourceRequestAgainstAvailableResource( [EOL] requestedResource, availableResource); [EOL] } catch (InvalidResourceRequestException e) { [EOL] fail(String.format( [EOL] "Resource request should be accepted. Requested: %s, available: %s", [EOL] requestedResource, availableResource)); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestSchedulerUtils.class); [EOL] private static Resource configuredMaxAllocation; [EOL] private RMContext rmContext = getMockRMContext(); [EOL] private static YarnConfiguration conf = new YarnConfiguration(); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetRawMessage()  throws Throwable  { [EOL]       ContextedException contextedException0 = new ContextedException(""); [EOL]       String string0 = contextedException0.getRawMessage(); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testRMDownRestoreForJobStatusBeforeGetAMReport() [EOL] throws IOException { [EOL] Configuration conf = new YarnConfiguration(); [EOL] conf.setInt(MRJobConfig.MR_CLIENT_MAX_RETRIES, 3); [EOL] [EOL] conf.set(MRConfig.FRAMEWORK_NAME, MRConfig.YARN_FRAMEWORK_NAME); [EOL] conf.setBoolean(MRJobConfig.JOB_AM_ACCESS_DISABLED, [EOL] !isAMReachableFromClient); [EOL] MRClientProtocol historyServerProxy = mock(MRClientProtocol.class); [EOL] when(historyServerProxy.getJobReport(any(GetJobReportRequest.class))) [EOL] .thenReturn(getJobReportResponse()); [EOL] ResourceMgrDelegate rmDelegate = mock(ResourceMgrDelegate.class); [EOL] try { [EOL] when(rmDelegate.getApplicationReport(jobId.getAppId())).thenThrow( [EOL] new java.lang.reflect.UndeclaredThrowableException(new IOException( [EOL] "Connection refuced1"))).thenThrow( [EOL] new java.lang.reflect.UndeclaredThrowableException(new IOException( [EOL] "Connection refuced2"))) [EOL] .thenReturn(getFinishedApplicationReport()); [EOL] ClientServiceDelegate clientServiceDelegate = new ClientServiceDelegate( [EOL] conf, rmDelegate, oldJobId, historyServerProxy); [EOL] JobStatus jobStatus = clientServiceDelegate.getJobStatus(oldJobId); [EOL] verify(rmDelegate, times(3)).getApplicationReport( [EOL] any(ApplicationId.class)); [EOL] Assert.assertNotNull(jobStatus); [EOL] } catch (YarnException e) { [EOL] throw new IOException(e); [EOL] } [EOL] } [EOL] private JobID oldJobId = JobID.forName("job_1315895242400_2"); [EOL] private org.apache.hadoop.mapreduce.v2.api.records.JobId jobId = TypeConverter [EOL] .toYarn(oldJobId); [EOL] private boolean isAMReachableFromClient; [EOL]
@Test [EOL] public void testToStringNoShowQuota() { [EOL] long length = 11111; [EOL] long fileCount = 22222; [EOL] long directoryCount = 33333; [EOL] long quota = 44444; [EOL] long spaceConsumed = 55555; [EOL] long spaceQuota = 66665; [EOL] [EOL] ContentSummary contentSummary = new ContentSummary.Builder().length(length). [EOL] fileCount(fileCount).directoryCount(directoryCount).quota(quota). [EOL] spaceConsumed(spaceConsumed).spaceQuota(spaceQuota).build(); [EOL] String expected = " 33333 22222 11111 "; [EOL] assertEquals(expected, contentSummary.toString(false)); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.SIMPLE_STYLE; [EOL]       Integer integer0 = new Integer(36); [EOL]       Class<Integer> class0 = Integer.class; [EOL]       String string0 = ReflectionToStringBuilder.toString(integer0, toStringStyle0, true, true, (Class<? super Integer>) class0); [EOL]       assertEquals("36,1360826667806852920,4,2147483647,-2147483648,32,int,{0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9},{0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9},{0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z},{9,99,999,9999,99999,999999,9999999,99999999,999999999,2147483647}", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMkDirs() throws IOException { [EOL] Path path = new Path(localDir.toUri().getPath(), [EOL] new Path(name.getMethodName(), "subdirectory")); [EOL] sftpFs.mkdirs(path); [EOL] assertTrue(localFs.exists(path)); [EOL] assertTrue(localFs.getFileStatus(path).isDirectory()); [EOL] assertThat(((SFTPFileSystem) sftpFs).getConnectionPool().getLiveConnCount(), [EOL] is(1)); [EOL] } [EOL] private static final String TEST_SFTP_DIR = "testsftp"; [EOL] private static final String TEST_ROOT_DIR = [EOL] GenericTestUtils.getTestDir().getAbsolutePath(); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final String connection = "sftp://user:password@localhost"; [EOL] private static Path localDir = null; [EOL] private static FileSystem localFs = null; [EOL] private FileSystem sftpFs = null; [EOL] private static SshServer sshd = null; [EOL] private static Configuration conf = null; [EOL] private static int port; [EOL]
@Test [EOL] public void testHadoopArchiveLogs() throws Exception { [EOL] String[] args = getArgs(); [EOL] final HadoopArchiveLogsRunner halr = new HadoopArchiveLogsRunner(conf); [EOL] assertEquals(0, ToolRunner.run(halr, args)); [EOL] [EOL] fs = FileSystem.get(conf); [EOL] FileStatus[] app1Files = fs.listStatus(app1Path); [EOL] Assert.assertEquals(1, app1Files.length); [EOL] FileStatus harFile = app1Files[0]; [EOL] Assert.assertEquals(app1.toString() + ".har", harFile.getPath().getName()); [EOL] Path harPath = new Path("har:///" + harFile.getPath().toUri().getRawPath()); [EOL] FileStatus[] harLogs = HarFs.get(harPath.toUri(), conf).listStatus(harPath); [EOL] Assert.assertEquals(FILE_COUNT, harLogs.length); [EOL] Arrays.sort(harLogs, new Comparator<FileStatus>() { [EOL] @Override [EOL] public int compare(FileStatus o1, FileStatus o2) { [EOL] return o1.getPath().getName().compareTo(o2.getPath().getName()); [EOL] } [EOL] }); [EOL] for (int i = 0; i < FILE_COUNT; i++) { [EOL] FileStatus harLog = harLogs[i]; [EOL] Assert.assertEquals("log" + (i + 1), harLog.getPath().getName()); [EOL] Assert.assertEquals(FILE_SIZES[i] * FILE_SIZE_INCREMENT, harLog.getLen()); [EOL] Assert.assertEquals( [EOL] new FsPermission(FsAction.READ_WRITE, FsAction.READ, FsAction.NONE), [EOL] harLog.getPermission()); [EOL] Assert.assertEquals(System.getProperty("user.name"), [EOL] harLog.getOwner()); [EOL] } [EOL] Assert.assertEquals(0, fs.listStatus(workingDir).length); [EOL] } [EOL] private static final int FILE_SIZE_INCREMENT = 4096; [EOL] private static final int[] FILE_SIZES = {3, 4, 2}; [EOL] private static final int FILE_COUNT = FILE_SIZES.length; [EOL] private static final byte[] DUMMY_DATA = new byte[FILE_SIZE_INCREMENT]; [EOL] private Configuration conf; [EOL] private MiniDFSCluster dfsCluster; [EOL] private MiniYARNCluster yarnCluster; [EOL] private FileSystem fs; [EOL] private ApplicationId app1; [EOL] private Path app1Path; [EOL] private Path workingDir; [EOL] private Path remoteRootLogDir; [EOL] private String suffix; [EOL] @Rule [EOL] public Timeout globalTimeout = new Timeout(50000); [EOL]
@Test [EOL] public void testJar() throws IOException { [EOL] File file = new File(TEST_DIR, "classpath.jar"); [EOL] Classpath.main(new String[] { "--jar", file.getAbsolutePath() }); [EOL] assertTrue(stdout.toByteArray().length == 0); [EOL] assertTrue(stderr.toByteArray().length == 0); [EOL] assertTrue(file.exists()); [EOL] assertJar(file); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestClasspath [EOL] .class); [EOL] private static final File TEST_DIR = GenericTestUtils.getTestDir( [EOL] "TestClasspath"); [EOL] private static final Charset UTF8 = Charset.forName("UTF-8"); [EOL] private PrintStream oldStdout, oldStderr; [EOL] private ByteArrayOutputStream stdout, stderr; [EOL] private PrintStream printStdout, printStderr; [EOL]
@Test [EOL] public void testParentOf() throws Throwable { [EOL] assertEquals("/", parentOf("/a")); [EOL] assertEquals("/", parentOf("/a/")); [EOL] assertEquals("/a", parentOf("/a/b")); [EOL] assertEquals("/a/b", parentOf("/a/b/c")); [EOL] } [EOL] public static final String EURO = "\u20AC"; [EOL]
@Test(timeout = 4000) [EOL]   public void testcapitalizeFully()  throws Throwable  { [EOL]       char[] charArray0 = new char[6]; [EOL]       String string0 = WordUtils.capitalizeFully((String) null, charArray0); [EOL]       assertNull(string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testnext()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getCSVInstance(); [EOL]       strTokenizer0.reset(); [EOL]       assertEquals(0, strTokenizer0.nextIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       CharSet charSet0 = CharSet.ASCII_ALPHA_LOWER; [EOL]       String string0 = charSet0.toString(); [EOL]       assertNotNull(string0); [EOL]   } [EOL] } [EOL]
@Test(timeout = 60000) [EOL] public void testMkdir() throws Exception {//FixME [EOL] HdfsFileStatus status = nn.getRpcServer().getFileInfo(testdir); [EOL] long dirId = status.getFileId(); [EOL] int namenodeId = Nfs3Utils.getNamenodeId(config); [EOL] XDR xdr_req = new XDR(); [EOL] FileHandle handle = new FileHandle(dirId, namenodeId); [EOL] MKDIR3Request req = new MKDIR3Request(handle, "fubar1", new SetAttr3()); [EOL] req.serialize(xdr_req); [EOL] [EOL] // Attempt to mkdir by an unprivileged user should fail. [EOL] MKDIR3Response response1 = nfsd.mkdir(xdr_req.asReadOnlyWrap(), [EOL] securityHandlerUnpriviledged, [EOL] new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3ERR_ACCES, [EOL] response1.getStatus()); [EOL] [EOL] XDR xdr_req2 = new XDR(); [EOL] MKDIR3Request req2 = new MKDIR3Request(handle, "fubar2", new SetAttr3()); [EOL] req2.serialize(xdr_req2); [EOL] [EOL] // Attempt to mkdir by a privileged user should pass. [EOL] MKDIR3Response response2 = nfsd.mkdir(xdr_req2.asReadOnlyWrap(), [EOL] securityHandler, new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3_OK, [EOL] response2.getStatus()); [EOL] } [EOL] static DistributedFileSystem hdfs; [EOL] static MiniDFSCluster cluster = null; [EOL] static NfsConfiguration config = new NfsConfiguration(); [EOL] static HdfsAdmin dfsAdmin; [EOL] static NameNode nn; [EOL] static Nfs3 nfs; [EOL] static RpcProgramNfs3 nfsd; [EOL] static SecurityHandler securityHandler; [EOL] static SecurityHandler securityHandlerUnpriviledged; [EOL] static String testdir = "/tmp"; [EOL] private static final String TEST_KEY = "test_key"; [EOL] private static FileSystemTestHelper fsHelper; [EOL] private static File testRootDir; [EOL] private static final EnumSet<CreateEncryptionZoneFlag> NO_TRASH = [EOL] EnumSet.of(CreateEncryptionZoneFlag.NO_TRASH); [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       Object[] objectArray0 = new Object[1]; [EOL]       Object[] objectArray1 = new Object[3]; [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       compareToBuilder0.append(objectArray0, objectArray1, comparator0); [EOL]       int int0 = compareToBuilder0.toComparison(); [EOL]       assertEquals((-1), (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testCharMatcher()  throws Throwable  { [EOL]       char[] charArray0 = new char[10]; [EOL]       StrMatcher.CharMatcher strMatcher_CharMatcher0 = new StrMatcher.CharMatcher('\u0000'); [EOL]       int int0 = strMatcher_CharMatcher0.isMatch(charArray0, 1, 1, 1); [EOL]       assertEquals(1, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testintToHexDigit()  throws Throwable  { [EOL]       char char0 = Conversion.intToHexDigit(11); [EOL]       assertEquals('b', char0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testand()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[17]; [EOL]       boolean boolean0 = BooleanUtils.and(booleanArray0); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testWriteStringsFileContext() throws IOException { [EOL] URI uri = tmp.toURI(); [EOL] Configuration conf = new Configuration(); [EOL] FileContext fc = FileContext.getFileContext(uri, conf); [EOL] Path testPath = new Path(new Path(uri), "writestrings.out"); [EOL] [EOL] Collection<String> write = Arrays.asList("over", "the", "lazy", "dog"); [EOL] [EOL] FileUtil.write(fc, testPath, write, StandardCharsets.UTF_8); [EOL] [EOL] List<String> read = [EOL] FileUtils.readLines(new File(testPath.toUri()), StandardCharsets.UTF_8); [EOL] [EOL] assertEquals(write, read); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test [EOL] public void testAllocResponseId() throws Exception { [EOL] ApplicationMasterProtocol scheduler = new MockScheduler(); [EOL] Configuration conf = new Configuration(); [EOL] LocalContainerAllocator lca = [EOL] new StubbedLocalContainerAllocator(scheduler); [EOL] lca.init(conf); [EOL] lca.start(); [EOL] [EOL] // do two heartbeats to verify the response ID is being tracked [EOL] lca.heartbeat(); [EOL] lca.heartbeat(); [EOL] lca.close(); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveAll()  throws Throwable  { [EOL]       char[] charArray0 = new char[1]; [EOL]       int[] intArray0 = new int[1]; [EOL]       char[] charArray1 = ArrayUtils.removeAll(charArray0, intArray0); [EOL]       assertEquals(0, charArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("v"); [EOL]       assertEquals(1, strBuilder0.size()); [EOL]        [EOL]       int int0 = 169; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator("v", 169); [EOL]       assertEquals(2, strBuilder0.size()); [EOL]       assertEquals(2, strBuilder1.size()); [EOL]        [EOL]       char[] charArray0 = new char[8]; [EOL]       charArray0[0] = 'O'; [EOL]       char char0 = '+'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.getChars(554, (-1433), charArray0, 554); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1433 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testRefreshNodes() throws Exception { [EOL] String[] args = { "-refreshNodes" }; [EOL] assertEquals(0, rmAdminCLI.run(args)); [EOL] verify(admin).refreshNodes(any(RefreshNodesRequest.class)); [EOL] } [EOL] private ResourceManagerAdministrationProtocol admin; [EOL] private HAServiceProtocol haadmin; [EOL] private RMAdminCLI rmAdminCLI; [EOL] private RMAdminCLI rmAdminCLIWithHAEnabled; [EOL] private CommonNodeLabelsManager dummyNodeLabelsManager; [EOL] private boolean remoteAdminServiceAccessed = false; [EOL] private static final String HOST_A = "1.2.3.1"; [EOL] private static final String HOST_B = "1.2.3.2"; [EOL] private static File dest; [EOL]
@Test [EOL] public void testOptionsAppendToConfDoesntOverwriteBandwidth() { [EOL] Configuration conf = new Configuration(); [EOL] Assert.assertEquals( [EOL] conf.getRaw(DistCpOptionSwitch.BANDWIDTH.getConfigLabel()), null); [EOL] DistCpOptions options = OptionsParser.parse(new String[] { [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] options.appendToConf(conf); [EOL] assertThat(conf.getFloat(DistCpOptionSwitch.BANDWIDTH.getConfigLabel(), -1)) [EOL] .isCloseTo(-1.0f,within(DELTA)); [EOL] [EOL] conf = new Configuration(); [EOL] Assert.assertEquals( [EOL] conf.getRaw(DistCpOptionSwitch.BANDWIDTH.getConfigLabel()), null); [EOL] options = OptionsParser.parse(new String[] { [EOL] "-update", [EOL] "-delete", [EOL] "-pu", [EOL] "-bandwidth", [EOL] "77", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] options.appendToConf(conf); [EOL] Assert.assertEquals( [EOL] conf.getFloat(DistCpOptionSwitch.BANDWIDTH.getConfigLabel(), -1), 77.0, [EOL] DELTA); [EOL] [EOL] conf = new Configuration(); [EOL] conf.set(DistCpOptionSwitch.BANDWIDTH.getConfigLabel(), "88"); [EOL] Assert.assertEquals( [EOL] conf.getRaw(DistCpOptionSwitch.BANDWIDTH.getConfigLabel()), "88"); [EOL] options = OptionsParser.parse(new String[] { [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] options.appendToConf(conf); [EOL] Assert.assertEquals( [EOL] conf.getFloat(DistCpOptionSwitch.BANDWIDTH.getConfigLabel(), -1), 88.0, [EOL] DELTA); [EOL] [EOL] conf = new Configuration(); [EOL] conf.set(DistCpOptionSwitch.BANDWIDTH.getConfigLabel(), "88.0"); [EOL] Assert.assertEquals( [EOL] conf.getRaw(DistCpOptionSwitch.BANDWIDTH.getConfigLabel()), "88.0"); [EOL] options = OptionsParser.parse(new String[] { [EOL] "-bandwidth", [EOL] "99", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] options.appendToConf(conf); [EOL] Assert.assertEquals( [EOL] conf.getFloat(DistCpOptionSwitch.BANDWIDTH.getConfigLabel(), -1), 99.0, [EOL] DELTA); [EOL] } [EOL] private static final float DELTA = 0.001f; [EOL]
@Test [EOL] public void testCompareToDateGT() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare testCompareToDateGT"); [EOL] TModelInstanceDetails lhs = new TModelInstanceDetails(); [EOL] lhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] lhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] lhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] lhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("2006-05-30T09:30:10-06:00"); [EOL] TModelInstanceDetails rhs = new TModelInstanceDetails(); [EOL] [EOL] rhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] rhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] rhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("2004-05-30T09:30:10-06:00"); [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", false, true, false); [EOL] [EOL] int result = instance.compare(lhs, rhs); [EOL] Assert.assertTrue("result " + lhs.getTModelInstanceInfo().get(0).getInstanceDetails().getInstanceParms() + " compare to " + [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().getInstanceParms() + " " + [EOL] result, result > 0); [EOL] [EOL] } [EOL]
@Test [EOL] public void testSettingKeyNull() throws Exception { [EOL] Configuration config = new Configuration(); [EOL] try { [EOL] config.set(null, "test"); [EOL] fail("Should throw an IllegalArgumentException exception "); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof IllegalArgumentException); [EOL] assertEquals(e.getMessage(), "Property name must not be null"); [EOL] } [EOL] } [EOL] @Rule [EOL] public ExpectedException thrown= ExpectedException.none(); [EOL] private static final double DOUBLE_DELTA = 0.000000001f; [EOL] private Configuration conf; [EOL] final static String CONFIG = new File("./test-config-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG2 = new File("./test-config2-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG_CORE = new File("./core-site.xml") [EOL] .getAbsolutePath(); [EOL] final static String CONFIG_FOR_ENUM = new File("./test-config-enum-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG_FOR_URI = new File( [EOL] "./test-config-uri-TestConfiguration.xml").toURI().toString(); [EOL] private static final String CONFIG_MULTI_BYTE = new File( [EOL] "./test-config-multi-byte-TestConfiguration.xml").getAbsolutePath(); [EOL] private static final String CONFIG_MULTI_BYTE_SAVED = new File( [EOL] "./test-config-multi-byte-saved-TestConfiguration.xml").getAbsolutePath(); [EOL] final static Random RAN = new Random(); [EOL] final static String XMLHEADER = [EOL] IBM_JAVA?"<?xml version=\"1.0\" encoding=\"UTF-8\"?><configuration>": [EOL] "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><configuration>"; [EOL] public static final String ESCAPED = "&apos;&#39;&#0039;&#x27;"; [EOL] private static final String SENSITIVE_CONFIG_KEYS = [EOL] CommonConfigurationKeysPublic.HADOOP_SECURITY_SENSITIVE_CONFIG_KEYS; [EOL] private BufferedWriter out; [EOL] ArrayList<Prop> props = new ArrayList<Prop>(); [EOL]
@Test(timeout = 4000) [EOL]   public void testtoByte()  throws Throwable  { [EOL]       MutableByte mutableByte0 = new MutableByte((byte) (-2)); [EOL]       MutableByte mutableByte1 = new MutableByte(); [EOL]       boolean boolean0 = mutableByte0.equals(mutableByte1); [EOL]       assertEquals((byte) (-2), (byte)mutableByte0.toByte()); [EOL]   } [EOL]  [EOL]
@Test (timeout = 10000) [EOL] public void testAddIfService() { [EOL] CompositeService testService = new CompositeService("TestService") { [EOL] Service service; [EOL] @Override [EOL] public void serviceInit(Configuration conf) { [EOL] Integer notAService = new Integer(0); [EOL] assertFalse("Added an integer as a service", [EOL] addIfService(notAService)); [EOL] [EOL] service = new AbstractService("Service") {}; [EOL] assertTrue("Unable to add a service", addIfService(service)); [EOL] } [EOL] }; [EOL] [EOL] testService.init(new Configuration()); [EOL] assertEquals("Incorrect number of services", [EOL] 1, testService.getServices().size()); [EOL] } [EOL] private static final int NUM_OF_SERVICES = 5; [EOL] private static final int FAILED_SERVICE_SEQ_NUMBER = 2; [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCompositeService.class); [EOL] private static final boolean STOP_ONLY_STARTED_SERVICES = [EOL] CompositeServiceImpl.isPolicyToStopOnlyStartedServices(); [EOL]
@Test [EOL] public void testInvalidRulesConfigFile() throws Exception { [EOL] FSConfigConverterTestCommons.configureYarnSiteXmlWithFsAllocFileDefined(); [EOL] FSConfigConverterTestCommons.configureFairSchedulerXml(); [EOL] FSConfigConverterTestCommons.configureInvalidConversionRulesFile(); [EOL] [EOL] FSConfigToCSConfigArgumentHandler argumentHandler = [EOL] createArgumentHandler(); [EOL] [EOL] String[] args = getArgumentsAsArrayWithDefaults(); [EOL] argumentHandler.parseAndConvert(args); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFSConfigToCSConfigArgumentHandler.class); [EOL] @Rule [EOL] public ExpectedException expectedException = ExpectedException.none(); [EOL] @Mock [EOL] private FSConfigToCSConfigConverter mockConverter; [EOL] @Mock [EOL] private ConvertedConfigValidator mockValidator; [EOL] private DryRunResultHolder dryRunResultHolder; [EOL] private ConversionOptions conversionOptions; [EOL] private FSConfigConverterTestCommons fsTestCommons; [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((-890)); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append("$Ps-)|ysy>r47^"); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       Object[] objectArray0 = new Object[6]; [EOL]       objectArray0[0] = (Object) strBuilder1; [EOL]       objectArray0[1] = (Object) "$Ps-)|ysy>r47^"; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder0; [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer1 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.clone(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       objectArray0[4] = (Object) strBuilder_StrBuilderTokenizer1; [EOL]       objectArray0[5] = (Object) "$Ps-)|ysy>r47^"; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendWithSeparators(objectArray0, "$Ps-)|ysy>r47^"); [EOL]       assertEquals(604, strBuilder0.capacity()); [EOL]       assertEquals(604, strBuilder1.capacity()); [EOL]       assertEquals(604, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(4, (float) 4); [EOL]       assertEquals(604, strBuilder0.capacity()); [EOL]       assertEquals(604, strBuilder1.capacity()); [EOL]       assertEquals(604, strBuilder2.capacity()); [EOL]       assertEquals(604, strBuilder3.capacity()); [EOL]        [EOL]       String string0 = strBuilder1.midString((-3719), 97); [EOL]       assertEquals(604, strBuilder0.capacity()); [EOL]       assertEquals(604, strBuilder1.capacity()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testprevious()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getCSVInstance(); [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       StrMatcher strMatcher0 = StrMatcher.commaMatcher(); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setQuoteMatcher(strMatcher0); [EOL]       assertEquals((-1), strTokenizer1.previousIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testprevious()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer("set() is unsupported"); [EOL]       Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer()); [EOL]       strTokenizer0.forEachRemaining(consumer0); [EOL]       StrMatcher.TrimMatcher strMatcher_TrimMatcher0 = new StrMatcher.TrimMatcher(); [EOL]       strTokenizer0.setTrimmerMatcher(strMatcher_TrimMatcher0); [EOL]       assertEquals(2, strTokenizer0.previousIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetArrayStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]       byte[] byteArray0 = new byte[0]; [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.appendDetail(stringBuffer0, "", byteArray0); [EOL]       assertEquals("{", standardToStringStyle0.getArrayStart()); [EOL]   } [EOL]  [EOL]
@SuppressWarnings("static-access") [EOL] @Test [EOL] public void testPartitionerShouldNotBeCalledWhenOneReducerIsPresent() [EOL] throws Exception { [EOL] MapFileOutputFormat outputFormat = new MapFileOutputFormat(); [EOL] Reader reader = Mockito.mock(Reader.class); [EOL] Reader[] readers = new Reader[]{reader}; [EOL] outputFormat.getEntry(readers, new MyPartitioner(), new Text(), new Text()); [EOL] assertTrue(!MyPartitioner.isGetPartitionCalled()); [EOL] } [EOL]
@Test [EOL] public void testInjectToken() throws Exception { [EOL] HttpURLConnection conn = Mockito.mock(HttpURLConnection.class); [EOL] AuthenticatedURL.Token token = new AuthenticatedURL.Token(); [EOL] token.set("foo"); [EOL] AuthenticatedURL.injectToken(conn, token); [EOL] Mockito.verify(conn).addRequestProperty(Mockito.eq("Cookie"), Mockito.anyString()); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(256); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.noneMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceAll(strMatcher0, ""); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln("HDK1o:4z@EGXArn*_"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder3 = new StrBuilder(); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append(strBuilder3, (-2074), (-2074)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testRetryUpToMaximumTimeWithFixedSleep() throws Exception { [EOL] RetryPolicy policy = mock(RetryUpToMaximumTimeWithFixedSleep.class); [EOL] long maxTime = 80L; [EOL] RetryPolicy realPolicy = retryUpToMaximumTimeWithFixedSleep(maxTime, 10, [EOL] TimeUnit.NANOSECONDS); [EOL] setupMockPolicy(policy, realPolicy); [EOL] [EOL] UnreliableInterface unreliable = (UnreliableInterface) [EOL] RetryProxy.create(UnreliableInterface.class, unreliableImpl, policy); [EOL] unreliable.alwaysSucceeds(); [EOL] unreliable.failsOnceThenSucceeds(); [EOL] try { [EOL] unreliable.failsTenTimesThenSucceeds(); [EOL] fail("Should fail"); [EOL] } catch (UnreliableException e) { [EOL] // expected [EOL] verify(policy, times((int)(maxTime/10) + 2)).shouldRetry(any(Exception.class), [EOL] anyInt(), anyInt(), anyBoolean()); [EOL] assertEquals(RetryDecision.FAIL, caughtRetryAction.action); [EOL] assertEquals(RetryUpToMaximumTimeWithFixedSleep.constructReasonString( [EOL] maxTime, TimeUnit.NANOSECONDS), caughtRetryAction.reason); [EOL] } catch (Exception e) { [EOL] fail("Other exception other than UnreliableException should also get " + [EOL] "failed."); [EOL] } [EOL] } [EOL] private UnreliableImplementation unreliableImpl; [EOL] private RetryAction caughtRetryAction = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testsetIgnoreEmptyTokens()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer("set() is unsupported"); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setDelimiterChar('i'); [EOL]       Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer()); [EOL]       strTokenizer1.forEachRemaining(consumer0); [EOL]       strTokenizer0.previousToken(); [EOL]       strTokenizer1.setIgnoreEmptyTokens(true); [EOL]       assertEquals(1, strTokenizer1.nextIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetFragmentInSeconds()  throws Throwable  { [EOL]       MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(); [EOL]       long long0 = DateUtils.getFragmentInSeconds((Calendar) mockGregorianCalendar0, 5); [EOL]       assertEquals(73281L, long0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       ToStringBuilder toStringBuilder0 = new ToStringBuilder("IPz$I2G^e"); [EOL]       ToStringBuilder toStringBuilder1 = toStringBuilder0.append("IPz$I2G^e", (short[]) null, false); [EOL]       assertSame(toStringBuilder1, toStringBuilder0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testescapeXml()  throws Throwable  { [EOL]       String string0 = StringEscapeUtils.escapeXml(""); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 10000) [EOL] public void testCheckAllVolumes() throws Exception { [EOL] LOG.info("Executing {}", testName.getMethodName()); [EOL] [EOL] final List<FsVolumeSpi> volumes = makeVolumes( [EOL] NUM_VOLUMES, expectedVolumeHealth); [EOL] final FsDatasetSpi<FsVolumeSpi> dataset = makeDataset(volumes); [EOL] final DatasetVolumeChecker checker = [EOL] new DatasetVolumeChecker(new HdfsConfiguration(), new FakeTimer()); [EOL] checker.setDelegateChecker(new DummyChecker()); [EOL] [EOL] Set<FsVolumeSpi> failedVolumes = checker.checkAllVolumes(dataset); [EOL] LOG.info("Got back {} failed volumes", failedVolumes.size()); [EOL] [EOL] if (expectedVolumeHealth == null || expectedVolumeHealth == FAILED) { [EOL] assertThat(failedVolumes.size(), is(NUM_VOLUMES)); [EOL] } else { [EOL] assertTrue(failedVolumes.isEmpty()); [EOL] } [EOL] [EOL] // Ensure each volume's check() method was called exactly once. [EOL] for (FsVolumeSpi volume : volumes) { [EOL] verify(volume, times(1)).check(any()); [EOL] } [EOL] } [EOL] public static final Logger LOG = [EOL] LoggerFactory.getLogger(TestDatasetVolumeChecker.class); [EOL] @Rule [EOL] public TestName testName = new TestName(); [EOL] private final VolumeCheckResult expectedVolumeHealth; [EOL] private static final int NUM_VOLUMES = 2; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEquals()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       byte[] byteArray0 = new byte[2]; [EOL]       byteArray0[0] = (byte)0; [EOL]       byteArray0[1] = (byte) (-105); [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(byteArray0, (byte[]) null); [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(0, 4134); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append((short) (byte) (-105), (short) (-1)); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append((byte)0, (byte)0); [EOL]       float[] floatArray0 = new float[3]; [EOL]       floatArray0[0] = (float) (short) (-1); [EOL]       floatArray0[1] = (float) 0; [EOL]       floatArray0[2] = 0.0F; [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append(floatArray0, floatArray0); [EOL]       assertFalse(equalsBuilder0.isEquals()); [EOL]        [EOL]       short[] shortArray0 = new short[1]; [EOL]       equalsBuilder4.reset(); [EOL]       shortArray0[0] = (short) (byte)0; [EOL]       equalsBuilder0.append(shortArray0, shortArray0); [EOL]       equalsBuilder5.append((Object) "", (Object) ""); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("Invalid startIndex: "); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) strTokenizer0, "Invalid startIndex: "); [EOL]       assertEquals(27, strBuilder0.length()); [EOL]       assertEquals(27, strBuilder1.length()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '\\'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(charArray0); [EOL]       assertEquals(29, strBuilder0.length()); [EOL]       assertEquals(29, strBuilder1.length()); [EOL]       assertEquals(29, strBuilder2.length()); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertEquals(81, strBuilder0.length()); [EOL]       assertEquals(81, strBuilder1.length()); [EOL]       assertEquals(81, strBuilder2.length()); [EOL]       assertEquals(81, strBuilder3.length()); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.setLength(2822); [EOL]       assertEquals(2822, strBuilder0.length()); [EOL]       assertEquals(2822, strBuilder4.length()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) '\\'; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       StrBuilder strBuilder5 = strBuilder4.appendAll(objectArray0); [EOL]       assertEquals(2954, strBuilder0.length()); [EOL]       assertEquals(2954, strBuilder4.length()); [EOL]       assertEquals(2954, strBuilder5.length()); [EOL]       assertEquals(4, objectArray0.length); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(strBuilder1, 0, 2822); [EOL]       assertEquals(5777, strBuilder0.length()); [EOL]       assertEquals(5777, strBuilder1.length()); [EOL]       assertEquals(5777, strBuilder6.length()); [EOL]        [EOL]       int int0 = strBuilder6.lastIndexOf("Invalid startIndex: "); [EOL]       assertEquals(5777, strBuilder0.length()); [EOL]       assertEquals(5777, strBuilder1.length()); [EOL]       assertEquals(5777, strBuilder6.length()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.append(false); [EOL]       assertEquals(5782, strBuilder7.length()); [EOL]       assertEquals(5782, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.appendln(1490.882886748184); [EOL]       assertEquals(5800, strBuilder0.length()); [EOL]       assertEquals(5800, strBuilder8.length()); [EOL]       assertEquals(5800, strBuilder1.length()); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder6.append(strBuilder3, 0, 2822); [EOL]       assertEquals(8622, strBuilder0.length()); [EOL]       assertEquals(8622, strBuilder9.length()); [EOL]       assertEquals(8622, strBuilder1.length()); [EOL]       assertEquals(8622, strBuilder2.length()); [EOL]       assertEquals(8622, strBuilder3.length()); [EOL]       assertEquals(8622, strBuilder6.length()); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append(charArray0, 0, 116); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // Invalid length: 116 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testset()  throws Throwable  { [EOL]       Calendar calendar0 = MockCalendar.getInstance(); [EOL]       Calendar calendar1 = DateUtils.round(calendar0, 9); [EOL]       Calendar calendar2 = DateUtils.truncate(calendar1, 9); [EOL]       assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392422400000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=15,DAY_OF_YEAR=46,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]", calendar2.toString()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       int int0 = 0; [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer("':EFAEb.O7[9#R/\"[V"); [EOL]        [EOL]       StringBuffer stringBuffer1 = stringBuffer0.delete(0, 0); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(stringBuffer0); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]       assertEquals(20, strBuilder1.size()); [EOL]        [EOL]       int int1 = strBuilder0.indexOf("x,OEdUuh6_<", 0); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]        [EOL]       Locale.Category locale_Category0 = Locale.Category.DISPLAY; [EOL]       Locale.Category locale_Category1 = Locale.Category.FORMAT; [EOL]       EnumSet<Locale.Category> enumSet0 = EnumSet.of(locale_Category0, locale_Category0, locale_Category0, locale_Category1); [EOL]       assertEquals(2, enumSet0.size()); [EOL]        [EOL]       Iterator<Locale.Category> iterator0 = enumSet0.iterator(); [EOL]       assertEquals(2, enumSet0.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.appendWithSeparators(iterator0, "x,OEdUuh6_<"); [EOL]       assertEquals(119, strBuilder0.size()); [EOL]       assertEquals(119, strBuilder1.size()); [EOL]       assertEquals(2, enumSet0.size()); [EOL]       assertEquals(119, strBuilder2.size()); [EOL]        [EOL]       String string0 = ""; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.insert((-1), ""); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(""); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.appendNewLine(); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.append((Object) strBuilder1); [EOL]       assertEquals(102, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(102, strBuilder3.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = new StrBuilder((String) null); [EOL]       assertEquals(32, strBuilder4.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder4.new StrBuilderTokenizer(); [EOL]       assertEquals(32, strBuilder4.capacity()); [EOL]        [EOL]       StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getDelimiterMatcher(); [EOL]       assertEquals(32, strBuilder4.capacity()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.deleteFirst(strMatcher0); [EOL]       assertEquals(102, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(102, strBuilder3.capacity()); [EOL]       assertEquals(32, strBuilder4.capacity()); [EOL]       assertEquals(102, strBuilder5.capacity()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetStart()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.isNot('%'); [EOL]       boolean boolean0 = charRange0.contains('n'); [EOL]       assertEquals('%', charRange0.getStart()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testVerifyParentDir() throws Exception { [EOL] hdfs.mkdirs(new Path("/dir1/dir2")); [EOL] hdfs.createNewFile(new Path("/dir1/file")); [EOL] hdfs.createNewFile(new Path("/dir1/dir2/file")); [EOL] [EOL] INodesInPath iip = fsdir.resolvePath(null, "/", DirOp.READ); [EOL] fsdir.verifyParentDir(iip); [EOL] [EOL] iip = fsdir.resolvePath(null, "/dir1", DirOp.READ); [EOL] fsdir.verifyParentDir(iip); [EOL] [EOL] iip = fsdir.resolvePath(null, "/dir1/file", DirOp.READ); [EOL] fsdir.verifyParentDir(iip); [EOL] [EOL] iip = fsdir.resolvePath(null, "/dir-nonexist/file", DirOp.READ); [EOL] try { [EOL] fsdir.verifyParentDir(iip); [EOL] fail("expected FNF"); [EOL] } catch (FileNotFoundException fnf) { [EOL] // expected. [EOL] } [EOL] [EOL] iip = fsdir.resolvePath(null, "/dir1/dir2", DirOp.READ); [EOL] fsdir.verifyParentDir(iip); [EOL] [EOL] iip = fsdir.resolvePath(null, "/dir1/dir2/file", DirOp.READ); [EOL] fsdir.verifyParentDir(iip); [EOL] [EOL] iip = fsdir.resolvePath(null, "/dir1/dir-nonexist/file", DirOp.READ); [EOL] try { [EOL] fsdir.verifyParentDir(iip); [EOL] fail("expected FNF"); [EOL] } catch (FileNotFoundException fnf) { [EOL] // expected. [EOL] } [EOL] [EOL] try { [EOL] iip = fsdir.resolvePath(null, "/dir1/file/fail", DirOp.READ); [EOL] fail("expected ACE"); [EOL] } catch (AccessControlException ace) { [EOL] assertTrue(ace.getMessage().contains("is not a directory")); [EOL] } [EOL] try { [EOL] iip = fsdir.resolvePath(null, "/dir1/file/fail", DirOp.WRITE); [EOL] fail("expected ACE"); [EOL] } catch (AccessControlException ace) { [EOL] assertTrue(ace.getMessage().contains("is not a directory")); [EOL] } [EOL] try { [EOL] iip = fsdir.resolvePath(null, "/dir1/file/fail", DirOp.CREATE); [EOL] fail("expected PNDE"); [EOL] } catch (ParentNotDirectoryException pnde) { [EOL] assertTrue(pnde.getMessage().contains("is not a directory")); [EOL] } [EOL] } [EOL] public static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFSDirectory.class); [EOL] private static final long seed = 0; [EOL] private static final short REPLICATION = 3; [EOL] private final Path dir = new Path("/" + getClass().getSimpleName()); [EOL] private final Path sub1 = new Path(dir, "sub1"); [EOL] private final Path file1 = new Path(sub1, "file1"); [EOL] private final Path file2 = new Path(sub1, "file2"); [EOL] private final Path sub11 = new Path(sub1, "sub11"); [EOL] private final Path file3 = new Path(sub11, "file3"); [EOL] private final Path file5 = new Path(sub1, "z_file5"); [EOL] private final Path sub2 = new Path(dir, "sub2"); [EOL] private final Path file6 = new Path(sub2, "file6"); [EOL] private Configuration conf; [EOL] private MiniDFSCluster cluster; [EOL] private FSNamesystem fsn; [EOL] private FSDirectory fsdir; [EOL] private DistributedFileSystem hdfs; [EOL] private static final int numGeneratedXAttrs = 256; [EOL] private static final ImmutableList<XAttr> generatedXAttrs = [EOL] ImmutableList.copyOf(generateXAttrs(numGeneratedXAttrs)); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.stripStart("XF", "5i;(d$6_s%^;sG2`"); [EOL]        [EOL]       String string1 = StringUtils.defaultString("5i;(d$6_s%^;sG2`");(d$6_s%^;sG2`", string1); [EOL]        [EOL]       long[] longArray0 = new long[7]; [EOL]       longArray0[0] = 1790L; [EOL]       longArray0[1] = 0L; [EOL]       longArray0[2] = 0L; [EOL]       longArray0[3] = 996L; [EOL]       longArray0[4] = (-3436L); [EOL]       longArray0[5] = (-955L); [EOL]       longArray0[6] = (-1154L); [EOL]       String string2 = StringUtils.join(longArray0, 'y', Integer.MAX_VALUE, Integer.MAX_VALUE); [EOL]       assertEquals(7, longArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testfloatValue()  throws Throwable  { [EOL]       MutableLong mutableLong0 = new MutableLong(); [EOL]       mutableLong0.setValue(525L); [EOL]       float float0 = mutableLong0.floatValue(); [EOL]       assertEquals(525.0F, float0, 0.01F); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testDeleteReservationNoID() { [EOL] ReservationDeleteRequest request = new ReservationDeleteRequestPBImpl(); [EOL] Plan plan = null; [EOL] try { [EOL] plan = rrValidator.validateReservationDeleteRequest(rSystem, request); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertNull(plan); [EOL] String message = e.getMessage(); [EOL] Assert [EOL] .assertTrue(message [EOL] .startsWith("Missing reservation id. Please try again by specifying a reservation id.")); [EOL] LOG.info(message); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestReservationInputValidator.class); [EOL] private static final String PLAN_NAME = "test-reservation"; [EOL] private Clock clock; [EOL] private Map<String, Plan> plans = new HashMap<String, Plan>(1); [EOL] private ReservationSystem rSystem; [EOL] private Plan plan; [EOL] private ReservationInputValidator rrValidator; [EOL]
@Test [EOL] public void testAllocateMultipleDevices() [EOL] throws ResourceHandlerException, IOException { [EOL] setupTestDirectoryWithScript(); [EOL] plugin = new NECVEPlugin(envProvider, defaultSearchDirs, udevUtil); [EOL] Set<Device> available = new HashSet<>(); [EOL] Device device0 = getTestDevice(0); [EOL] Device device1 = getTestDevice(1); [EOL] available.add(device0); [EOL] available.add(device1); [EOL] [EOL] Set<Device> allocated = plugin.allocateDevices(available, 2, env); [EOL] [EOL] assertEquals("No. of devices", 2, allocated.size()); [EOL] assertTrue("Device missing", allocated.contains(device0)); [EOL] assertTrue("Device missing", allocated.contains(device1)); [EOL] } [EOL] private static final String DEFAULT_SCRIPT_NAME = "nec-ve-get.py"; [EOL] private static final String[] EMPTY_SEARCH_DIRS = new String[] {}; [EOL] private static final Comparator<Device> DEVICE_COMPARATOR = [EOL] Comparator.comparingInt(Device::getId); [EOL] private Function<String, String> envProvider; [EOL] private Map<String, String> env; [EOL] private String[] defaultSearchDirs; [EOL] private Function<String[], CommandExecutor> [EOL] commandExecutorProvider; [EOL] private String testFolder; [EOL] @Mock [EOL] private CommandExecutor mockCommandExecutor; [EOL] @Mock [EOL] private UdevUtil udevUtil; [EOL] private String defaultScriptOutput; [EOL] private NECVEPlugin plugin; [EOL]
@Test [EOL] public void testErrorMessageForInvalidNameservice() throws Exception { [EOL] Configuration conf = new HdfsConfiguration(); [EOL] conf.set(DFSConfigKeys.DFS_NAMESERVICES, "ns1, ns2"); [EOL] String expectedErrorMessage = "Incorrect configuration: namenode address " [EOL] + DFS_NAMENODE_SERVICE_RPC_ADDRESS_KEY + ".[ns1, ns2]" [EOL] + " or " [EOL] + DFS_NAMENODE_RPC_ADDRESS_KEY + ".[ns1, ns2]" [EOL] + " is not configured."; [EOL] LambdaTestUtils.intercept(IOException.class, expectedErrorMessage, [EOL] ()->DFSUtil.getNNServiceRpcAddressesForCluster(conf)); [EOL] } [EOL] static final String NS1_NN_ADDR = "ns1-nn.example.com:8020"; [EOL] static final String NS1_NN1_ADDR = "ns1-nn1.example.com:8020"; [EOL] static final String NS1_NN2_ADDR = "ns1-nn2.example.com:8020"; [EOL] static final String NS1_NN1_HTTPS_ADDR = "ns1-nn1.example.com:50740"; [EOL] static final String NS1_NN1_HTTP_ADDR = "ns1-nn1.example.com:50070"; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetContentStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SHORT_PREFIX_STYLE.setSummaryObjectEndText("Windows 9"); [EOL]       assertEquals("[", standardToStringStyle0.getContentStart()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAsciiAlpha()  throws Throwable  { [EOL]       boolean boolean0 = CharUtils.isAsciiAlpha('A'); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder(""); [EOL]        [EOL]       StringBuilder stringBuilder1 = stringBuilder0.insert(0, false); [EOL]        [EOL]       StringBuilder stringBuilder2 = stringBuilder1.deleteCharAt(0); [EOL]        [EOL]       char[] charArray0 = new char[4]; [EOL]       charArray0[0] = ':'; [EOL]       charArray0[1] = '.'; [EOL]       charArray0[2] = 'f'; [EOL]       charArray0[3] = '#'; [EOL]       StringBuilder stringBuilder3 = stringBuilder2.insert(0, charArray0); [EOL]        [EOL]       StringBuilder stringBuilder4 = stringBuilder3.appendCodePoint(0); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln(stringBuilder4, 0, 326); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 300000) [EOL] public void testWithFederateClusterWithinSameNode() throws [EOL] Exception { [EOL] final Configuration conf = new HdfsConfiguration(); [EOL] initConf(conf); [EOL] [EOL] final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf) [EOL] .numDataNodes(4).storageTypes( new StorageType[] {StorageType.DISK, [EOL] StorageType.ARCHIVE}).nnTopology(MiniDFSNNTopology [EOL] .simpleFederatedTopology(2)).build(); [EOL] DFSTestUtil.setFederatedConfiguration(cluster, conf); [EOL] [EOL] try { [EOL] cluster.waitActive(); [EOL] [EOL] final String file = "/test/file"; [EOL] Path dir = new Path ("/test"); [EOL] [EOL] final DistributedFileSystem dfs1 = cluster.getFileSystem(0); [EOL] final DistributedFileSystem dfs2 = cluster.getFileSystem(1); [EOL] [EOL] URI nn1 = dfs1.getUri(); [EOL] URI nn2 = dfs2.getUri(); [EOL] [EOL] setupStoragePoliciesAndPaths(dfs1, dfs2, dir, file); [EOL] [EOL] [EOL] // move to ARCHIVE [EOL] dfs1.setStoragePolicy(dir, "COLD"); [EOL] int rc = ToolRunner.run(conf, new Mover.Cli(), [EOL] new String[] {"-p", nn1 + dir.toString()}); [EOL] Assert.assertEquals("Movement to ARCHIVE should be successful", 0, rc); [EOL] [EOL] [EOL] //move to DISK [EOL] dfs2.setStoragePolicy(dir, "HOT"); [EOL] rc = ToolRunner.run(conf, new Mover.Cli(), [EOL] new String[] {"-p", nn2 + dir.toString()}); [EOL] Assert.assertEquals("Movement to DISK should be successful", 0, rc); [EOL] [EOL] [EOL] // Wait till namenode notified about the block location details [EOL] waitForLocatedBlockWithArchiveStorageType(dfs1, file, 3); [EOL] waitForLocatedBlockWithDiskStorageType(dfs2, file, 3); [EOL] [EOL] } finally { [EOL] cluster.shutdown(); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestMover.class); [EOL] private static final int DEFAULT_BLOCK_SIZE = 100; [EOL] private File keytabFile; [EOL] private String principal; [EOL] private final ErasureCodingPolicy ecPolicy = [EOL] StripedFileTestUtil.getDefaultECPolicy(); [EOL] private final int dataBlocks = ecPolicy.getNumDataUnits(); [EOL] private final int parityBlocks = ecPolicy.getNumParityUnits(); [EOL] private final int cellSize = ecPolicy.getCellSize(); [EOL] private final int stripesPerBlock = 4; [EOL] private final int defaultBlockSize = cellSize * stripesPerBlock; [EOL]
@Test(expected=NullPointerException.class) [EOL] public void testGetTimelineServiceHBaseConfNullArgument() throws Exception { [EOL] HBaseTimelineStorageUtils.getTimelineServiceHBaseConf(null); [EOL] } [EOL] private String hbaseConfigPath = "target/hbase-site.xml"; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getSizeEndText(); [EOL]       assertEquals("<null>", standardToStringStyle0.getNullText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClientRetriesWithRuntimeException() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.setInt( [EOL] CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, 3); [EOL] KMSClientProvider p1 = mock(KMSClientProvider.class); [EOL] when(p1.createKey(Mockito.anyString(), Mockito.any(Options.class))) [EOL] .thenThrow(new RuntimeException("p1")); [EOL] KMSClientProvider p2 = mock(KMSClientProvider.class); [EOL] when(p2.createKey(Mockito.anyString(), Mockito.any(Options.class))) [EOL] .thenThrow(new IOException("p2")); [EOL] [EOL] when(p1.getKMSUrl()).thenReturn("p1"); [EOL] when(p2.getKMSUrl()).thenReturn("p2"); [EOL] [EOL] LoadBalancingKMSClientProvider kp = new LoadBalancingKMSClientProvider( [EOL] new KMSClientProvider[] {p1, p2}, 0, conf); [EOL] try { [EOL] kp.createKey("test3", new Options(conf)); [EOL] fail("Should fail since provider p1 threw RuntimeException"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof RuntimeException); [EOL] } [EOL] verify(p1, Mockito.times(1)).createKey(Mockito.eq("test3"), [EOL] Mockito.any(Options.class)); [EOL] verify(p2, Mockito.never()).createKey(Mockito.eq("test3"), [EOL] Mockito.any(Options.class)); [EOL] } [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(30 * 1000); [EOL]
@Test(timeout = 5000) [EOL] public void testGetNodeLabelsInfo() throws IOException { [EOL] mgr.addToCluserNodeLabels(Arrays.asList(NodeLabel.newInstance("p1", false), [EOL] NodeLabel.newInstance("p2", true), NodeLabel.newInstance("p3", false))); [EOL] mgr.addLabelsToNode(ImmutableMap.of(toNodeId("n1"), toSet("p2"))); [EOL] mgr.addLabelsToNode(ImmutableMap.of(toNodeId("n2"), toSet("p3"))); [EOL] [EOL] assertLabelInfoMapEquals(mgr.getNodeLabelsInfo(), ImmutableMap.of( [EOL] toNodeId("n1"), toSet(NodeLabel.newInstance("p2", true)), [EOL] toNodeId("n2"), toSet(NodeLabel.newInstance("p3", false)))); [EOL] } [EOL] DummyCommonNodeLabelsManager mgr = null; [EOL]
@Test [EOL] public void testCompareFsDirectories() throws Exception { [EOL] setupCompareFs(); [EOL] assertEquals(FileUtil.compareFs(fs1,fs1),true); [EOL] assertEquals(FileUtil.compareFs(fs1,fs2),false); [EOL] assertEquals(FileUtil.compareFs(fs1,fs5),false); [EOL] assertEquals(FileUtil.compareFs(fs3,fs4),true); [EOL] assertEquals(FileUtil.compareFs(fs1,fs6),false); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 10000) [EOL] public void testAddStoppedChildInStart() throws Throwable { [EOL] CompositeService parent = new CompositeService("parent"); [EOL] BreakableService child = new BreakableService(); [EOL] child.init(new Configuration()); [EOL] child.start(); [EOL] child.stop(); [EOL] parent.init(new Configuration()); [EOL] parent.start(); [EOL] AddSiblingService.addChildToService(parent, child); [EOL] parent.stop(); [EOL] } [EOL] private static final int NUM_OF_SERVICES = 5; [EOL] private static final int FAILED_SERVICE_SEQ_NUMBER = 2; [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCompositeService.class); [EOL] private static final boolean STOP_ONLY_STARTED_SERVICES = [EOL] CompositeServiceImpl.isPolicyToStopOnlyStartedServices(); [EOL]
@Test [EOL] public void testBadFormat() throws Exception { [EOL] StringWriter sw = new StringWriter(); [EOL] try { [EOL] ConfServlet.writeResponse(getTestConf(), sw, "not a format"); [EOL] fail("writeResponse with bad format didn't throw!"); [EOL] } catch (ConfServlet.BadFormatException bfe) { [EOL] // expected [EOL] } [EOL] assertEquals("", sw.toString()); [EOL] } [EOL] private static final String TEST_KEY = "testconfservlet.key"; [EOL] private static final String TEST_VAL = "testval"; [EOL] private static final Map<String, String> TEST_PROPERTIES = [EOL] new HashMap<String, String>(); [EOL] private static final Map<String, String> TEST_FORMATS = [EOL] new HashMap<String, String>(); [EOL]
@Test [EOL] public void testRefreshJobRetentionSettings() throws Exception { [EOL] String[] args = new String[1]; [EOL] args[0] = "-refreshJobRetentionSettings"; [EOL] hsAdminClient.run(args); [EOL] verify(jobHistoryService).refreshJobRetentionSettings(); [EOL] } [EOL] private boolean securityEnabled = true; [EOL] private HSAdminServer hsAdminServer = null; [EOL] private HSAdmin hsAdminClient = null; [EOL] JobConf conf = null; [EOL] private static long groupRefreshTimeoutSec = 1; [EOL] JobHistory jobHistoryService = null; [EOL] AggregatedLogDeletionService alds = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testaddContextValue()  throws Throwable  { [EOL]       DefaultExceptionContext defaultExceptionContext0 = new DefaultExceptionContext(); [EOL]       DefaultExceptionContext defaultExceptionContext1 = defaultExceptionContext0.addContextValue("Ex{ptio Conext:\"", "Ex{ptio Conext:\""); [EOL]       DefaultExceptionContext defaultExceptionContext2 = defaultExceptionContext0.setContextValue("Ex{ptio Conext:\"", defaultExceptionContext1); [EOL]       assertSame(defaultExceptionContext2, defaultExceptionContext1); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNodeRegistrationWithCentralLabelConfig() throws Exception { [EOL] writeToHostsFile("host2"); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, [EOL] hostFile.getAbsolutePath()); [EOL] conf.set(YarnConfiguration.NODELABEL_CONFIGURATION_TYPE, [EOL] YarnConfiguration.DEFAULT_NODELABEL_CONFIGURATION_TYPE); [EOL] [EOL] final RMNodeLabelsManager nodeLabelsMgr = new NullRMNodeLabelsManager(); [EOL] [EOL] rm = new MockRM(conf) { [EOL] @Override [EOL] protected RMNodeLabelsManager createNodeLabelManager() { [EOL] return nodeLabelsMgr; [EOL] } [EOL] }; [EOL] rm.start(); [EOL] try { [EOL] nodeLabelsMgr.addToCluserNodeLabelsWithDefaultExclusivity(toSet("A", "B", "C")); [EOL] } catch (IOException e) { [EOL] Assert.fail("Caught Exception while initializing"); [EOL] e.printStackTrace(); [EOL] } [EOL] ResourceTrackerService resourceTrackerService = [EOL] rm.getResourceTrackerService(); [EOL] RegisterNodeManagerRequest req = [EOL] Records.newRecord(RegisterNodeManagerRequest.class); [EOL] NodeId nodeId = NodeId.newInstance("host2", 1234); [EOL] Resource capability = BuilderUtils.newResource(1024, 1); [EOL] req.setResource(capability); [EOL] req.setNodeId(nodeId); [EOL] req.setHttpPort(1234); [EOL] req.setNMVersion(YarnVersionInfo.getVersion()); [EOL] req.setNodeLabels(toNodeLabelSet("A")); [EOL] RegisterNodeManagerResponse response = [EOL] resourceTrackerService.registerNodeManager(req); [EOL] // registered to RM with central label config [EOL] Assert.assertEquals(NodeAction.NORMAL, response.getNodeAction()); [EOL] Assert.assertNull(nodeLabelsMgr.getNodeLabels().get(nodeId)); [EOL] Assert [EOL] .assertFalse( [EOL] "Node Labels should not accepted by RM If its configured with " + [EOL] "Central configuration", [EOL] response.getAreNodeLabelsAcceptedByRM()); [EOL] if (rm != null) { [EOL] rm.stop(); [EOL] } [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testisAscii()  throws Throwable  { [EOL]       boolean boolean0 = CharUtils.isAsciiPrintable('\uD7C0'); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSourceListing() { [EOL] DistCpOptions options = OptionsParser.parse(new String[] { [EOL] "-f", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.assertEquals(options.getSourceFileListing(), [EOL] new Path("hdfs://localhost:8020/source/first")); [EOL] } [EOL] private static final float DELTA = 0.001f; [EOL]
@Test [EOL] public void testExecuteDockerKillSIGQUIT() throws Exception { [EOL] DockerKillCommand dockerKillCommand = [EOL] new DockerKillCommand(MOCK_CONTAINER_ID) [EOL] .setSignal(ContainerExecutor.Signal.QUIT.name()); [EOL] DockerCommandExecutor.executeDockerCommand(dockerKillCommand, [EOL] MOCK_CONTAINER_ID, env, mockExecutor, false, nmContext); [EOL] List<PrivilegedOperation> ops = MockPrivilegedOperationCaptor [EOL] .capturePrivilegedOperations(mockExecutor, 1, true); [EOL] List<String> dockerCommands = getValidatedDockerCommands(ops); [EOL] assertEquals(1, ops.size()); [EOL] assertEquals(PrivilegedOperation.OperationType.RUN_DOCKER_CMD.name(), [EOL] ops.get(0).getOperationType().name()); [EOL] assertEquals(4, dockerCommands.size()); [EOL] assertEquals("[docker-command-execution]", dockerCommands.get(0)); [EOL] assertEquals(" docker-command=kill", dockerCommands.get(1)); [EOL] assertEquals(" name=" + MOCK_CONTAINER_ID, dockerCommands.get(2)); [EOL] assertEquals(" signal=" + ContainerExecutor.Signal.QUIT.name(), [EOL] dockerCommands.get(3)); [EOL] } [EOL] private static final String MOCK_CONTAINER_ID = [EOL] "container_e11_1861047502093_13763105_01_000001"; [EOL] private static final String MOCK_LOCAL_IMAGE_NAME = "local_image_name"; [EOL] private static final String MOCK_IMAGE_NAME = "image_name"; [EOL] private static final String MOCK_CGROUP_HIERARCHY = "hadoop-yarn"; [EOL] private PrivilegedOperationExecutor mockExecutor; [EOL] private CGroupsHandler mockCGroupsHandler; [EOL] private Configuration configuration; [EOL] private ContainerRuntimeContext.Builder builder; [EOL] private DockerLinuxContainerRuntime runtime; [EOL] private Container container; [EOL] private ContainerId cId; [EOL] private ContainerLaunchContext context; [EOL] private HashMap<String, String> env; [EOL] private Context nmContext; [EOL] private ApplicationAttemptId appAttemptId; [EOL]
@Test [EOL] public void testMountTableFileWithInvalidFormat() throws Exception { [EOL] Path path = new Path(new URI( [EOL] targetTestRoot.toString() + "/testMountTableFileWithInvalidFormat/")); [EOL] fsTarget.mkdirs(path); [EOL] File invalidMountFileName = [EOL] new File(new URI(path.toString() + "/table.InvalidVersion.xml")); [EOL] invalidMountFileName.createNewFile(); [EOL] // Adding mount links to make sure it will not read it. [EOL] ViewFsTestSetup.addMountLinksToFile(TABLE_NAME, [EOL] new String[] {SRC_ONE, SRC_TWO }, new String[] {TARGET_ONE, [EOL] TARGET_TWO }, [EOL] new Path(invalidMountFileName.toURI()), conf); [EOL] // Pass mount table directory [EOL] loader.load(path.toString(), conf); [EOL] Assert.assertEquals(null, conf.get(MOUNT_LINK_KEY_SRC_TWO)); [EOL] Assert.assertEquals(null, conf.get(MOUNT_LINK_KEY_SRC_ONE)); [EOL] invalidMountFileName.delete(); [EOL] } [EOL] private static final String DOT = "."; [EOL] private static final String TARGET_TWO = "/tar2"; [EOL] private static final String TARGET_ONE = "/tar1"; [EOL] private static final String SRC_TWO = "/src2"; [EOL] private static final String SRC_ONE = "/src1"; [EOL] private static final String TABLE_NAME = "test"; [EOL] private MountTableConfigLoader loader = new HCFSMountTableConfigLoader(); [EOL] private static FileSystem fsTarget; [EOL] private static Configuration conf; [EOL] private static Path targetTestRoot; [EOL] private static FileSystemTestHelper fileSystemTestHelper = [EOL] new FileSystemTestHelper(); [EOL] private static File oldVersionMountTableFile; [EOL] private static File newVersionMountTableFile; [EOL] private static final String MOUNT_LINK_KEY_SRC_ONE = [EOL] new StringBuilder(Constants.CONFIG_VIEWFS_PREFIX).append(DOT) [EOL] .append(TABLE_NAME).append(DOT).append(Constants.CONFIG_VIEWFS_LINK) [EOL] .append(DOT).append(SRC_ONE).toString(); [EOL] private static final String MOUNT_LINK_KEY_SRC_TWO = [EOL] new StringBuilder(Constants.CONFIG_VIEWFS_PREFIX).append(DOT) [EOL] .append(TABLE_NAME).append(DOT).append(Constants.CONFIG_VIEWFS_LINK) [EOL] .append(DOT).append(SRC_TWO).toString(); [EOL]
@Test [EOL] public void testNonExistentApp() throws Exception { [EOL] YarnClient client = createCheckerWithMockedClient(); [EOL] ApplicationId id = ApplicationId.newInstance(1, 1); [EOL] [EOL] // test for null [EOL] doReturn(null).when(client).getApplicationReport(id); [EOL] assertFalse(checker.isApplicationActive(id)); [EOL] [EOL] // test for ApplicationNotFoundException [EOL] doThrow(new ApplicationNotFoundException("Throw!")).when(client) [EOL] .getApplicationReport(id); [EOL] assertFalse(checker.isApplicationActive(id)); [EOL] } [EOL] private RemoteAppChecker checker; [EOL]
@Test [EOL] public void testInheritedQueueAcls() throws IOException { [EOL] UserGroupInformation user = UserGroupInformation.getCurrentUser(); [EOL] [EOL] LeafQueue a = stubLeafQueue((LeafQueue)queues.get(A)); [EOL] LeafQueue b = stubLeafQueue((LeafQueue)queues.get(B)); [EOL] ParentQueue c = (ParentQueue)queues.get(C); [EOL] LeafQueue c1 = stubLeafQueue((LeafQueue)queues.get(C1)); [EOL] [EOL] assertFalse(root.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user)); [EOL] assertTrue(a.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user)); [EOL] assertTrue(b.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user)); [EOL] assertFalse(c.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user)); [EOL] assertFalse(c1.hasAccess(QueueACL.SUBMIT_APPLICATIONS, user)); [EOL] [EOL] assertTrue(hasQueueACL( [EOL] a.getQueueUserAclInfo(user), QueueACL.SUBMIT_APPLICATIONS)); [EOL] assertTrue(hasQueueACL( [EOL] b.getQueueUserAclInfo(user), QueueACL.SUBMIT_APPLICATIONS)); [EOL] assertFalse(hasQueueACL( [EOL] c.getQueueUserAclInfo(user), QueueACL.SUBMIT_APPLICATIONS)); [EOL] assertFalse(hasQueueACL( [EOL] c1.getQueueUserAclInfo(user), QueueACL.SUBMIT_APPLICATIONS)); [EOL] [EOL] } [EOL] private final RecordFactory recordFactory = [EOL] RecordFactoryProvider.getRecordFactory(null); [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLeafQueue.class); [EOL] RMContext rmContext; [EOL] RMContext spyRMContext; [EOL] ResourceRequest amResourceRequest; [EOL] CapacityScheduler cs; [EOL] CapacitySchedulerConfiguration csConf; [EOL] CapacitySchedulerContext csContext; [EOL] CSQueue root; [EOL] private CSQueueStore queues; [EOL] final static int GB = 1024; [EOL] final static String DEFAULT_RACK = "/default"; [EOL] private final static String LABEL = "test"; [EOL] private final ResourceCalculator resourceCalculator = [EOL] new DefaultResourceCalculator(); [EOL] private final ResourceCalculator dominantResourceCalculator = [EOL] new DominantResourceCalculator(); [EOL] private static final String A = "a"; [EOL] private static final String B = "b"; [EOL] private static final String C = "c"; [EOL] private static final String C1 = "c1"; [EOL] private static final String D = "d"; [EOL] private static final String E = "e"; [EOL]
@Test [EOL] public void testNullArgs() throws IOException { [EOL] GenericOptionsParser parser = new GenericOptionsParser(conf, null); [EOL] parser.getRemainingArgs(); [EOL] } [EOL] File testDir; [EOL] Configuration conf; [EOL] FileSystem localFs; [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(true); [EOL]       assertEquals(5, strBuilder0.size()); [EOL]       assertEquals(5, strBuilder1.size()); [EOL]        [EOL]       char[] charArray0 = new char[4]; [EOL]       charArray0[0] = '^'; [EOL]       charArray0[1] = '?'; [EOL]       charArray0[2] = 'U'; [EOL]       charArray0[3] = '4'; [EOL]       StrBuilder strBuilder2 = strBuilder1.insert(2, charArray0); [EOL]       assertEquals(9, strBuilder0.size()); [EOL]       assertEquals(9, strBuilder1.size()); [EOL]       assertEquals(9, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln((-3134.9556F)); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]       assertEquals(20, strBuilder3.size()); [EOL]        [EOL]       String string0 = null; [EOL]       StrBuilder strBuilder4 = strBuilder3.insert(0, (String) null); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]       assertEquals(20, strBuilder3.size()); [EOL]       assertEquals(20, strBuilder4.size()); [EOL]        [EOL]       Writer writer0 = strBuilder4.asWriter(); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]       assertEquals(20, strBuilder3.size()); [EOL]       assertEquals(20, strBuilder4.size()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]       assertEquals(20, strBuilder5.size()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher(':'); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf("vSi.a.bur[", 3954); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]        [EOL]       char[] charArray1 = new char[0]; [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.charSetMatcher(charArray1); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder5.trim(); [EOL]       assertEquals(19, strBuilder0.size()); [EOL]       assertEquals(19, strBuilder6.size()); [EOL]       assertEquals(19, strBuilder5.size()); [EOL]        [EOL]       int int1 = 6; [EOL]       StrBuilder strBuilder7 = strBuilder5.append(6); [EOL]       assertEquals(20, strBuilder0.size()); [EOL]       assertEquals(20, strBuilder7.size()); [EOL]       assertEquals(20, strBuilder5.size()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strMatcher0.isMatch(charArray1, 3954); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testinitializeUnchecked()  throws Throwable  { [EOL]       Integer integer0 = new Integer(0); [EOL]       ConcurrentUtils.ConstantFuture<Integer> concurrentUtils_ConstantFuture0 = new ConcurrentUtils.ConstantFuture<Integer>(integer0); [EOL]       TimeUnit timeUnit0 = TimeUnit.DAYS; [EOL]       concurrentUtils_ConstantFuture0.get((long) 0, timeUnit0); [EOL]       ConcurrentHashMap<Error, String> concurrentHashMap0 = new ConcurrentHashMap<Error, String>(0); [EOL]       MockError mockError0 = new MockError(":IC?TWffvYqDnT"); [EOL]       ConcurrentUtils.putIfAbsent((ConcurrentMap<Error, String>) concurrentHashMap0, (Error) mockError0, "Kh*+5b4@&oFsn"); [EOL]       ConcurrentUtils.initializeUnchecked((ConcurrentInitializer<Error>) null); [EOL]       ConcurrentUtils.initialize((ConcurrentInitializer<Error>) null); [EOL]       ConcurrentUtils.ConstantFuture<Object> concurrentUtils_ConstantFuture1 = new ConcurrentUtils.ConstantFuture<Object>((Object) null); [EOL]       concurrentUtils_ConstantFuture1.get(); [EOL]       ConcurrentSkipListMap<RuntimeException, Delayed> concurrentSkipListMap0 = new ConcurrentSkipListMap<RuntimeException, Delayed>(); [EOL]       ExecutionException executionException0 = new ExecutionException("Naming pattern must not be null!", (Throwable) null); [EOL]       ConcurrentUtils.extractCauseUnchecked(executionException0); [EOL]       Delayed delayed0 = ConcurrentUtils.createIfAbsentUnchecked((ConcurrentMap<RuntimeException, Delayed>) concurrentSkipListMap0, (RuntimeException) null, (ConcurrentInitializer<Delayed>) null); [EOL]       assertNull(delayed0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testConcatBlocks() { [EOL] INodeFile origFile = createINodeFiles(1, "origfile")[0]; [EOL] assertEquals("Number of blocks didn't match", origFile.numBlocks(), 1L); [EOL] [EOL] INodeFile[] appendFiles = createINodeFiles(4, "appendfile"); [EOL] BlockManager bm = Mockito.mock(BlockManager.class); [EOL] origFile.concatBlocks(appendFiles, bm); [EOL] assertEquals("Number of blocks didn't match", origFile.numBlocks(), 5L); [EOL] } [EOL] public static final Logger LOG = LoggerFactory.getLogger(TestINodeFile.class); [EOL] static final short BLOCKBITS = 48; [EOL] static final long BLKSIZE_MAXVALUE = ~(0xffffL << BLOCKBITS); [EOL] private static final PermissionStatus perm = new PermissionStatus( [EOL] "userName", null, FsPermission.getDefault()); [EOL] private short replication; [EOL] private long preferredBlockSize = 1024; [EOL]
@Test(timeout = 4000) [EOL]   public void testtranslate()  throws Throwable  { [EOL]       UnicodeEscaper unicodeEscaper0 = UnicodeEscaper.between(88, 0); [EOL]       StringWriter stringWriter0 = new StringWriter(0); [EOL]       char[] charArray0 = new char[9]; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       int int0 = unicodeEscaper0.translate((CharSequence) charBuffer0, 0, (Writer) stringWriter0); [EOL]       assertEquals(0, int0); [EOL]   } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitToBinary()  throws Throwable  { [EOL]       boolean[] booleanArray0 = Conversion.hexDigitToBinary('c'); [EOL]       char char0 = Conversion.binaryBeMsb0ToHexDigit(booleanArray0, 0); [EOL]       assertEquals('3', char0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetExternalExecutor()  throws Throwable  { [EOL]       Callable<String> callable0 = (Callable<String>) mock(Callable.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn((Object) null).when(callable0).call(); [EOL]       CallableBackgroundInitializer<String> callableBackgroundInitializer0 = new CallableBackgroundInitializer<String>(callable0); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.get(); [EOL]       callableBackgroundInitializer0.getTaskCount(); [EOL]       callableBackgroundInitializer0.getActiveExecutor(); [EOL]       ExecutorService executorService0 = callableBackgroundInitializer0.getActiveExecutor(); [EOL]       Callable<Object> callable1 = (Callable<Object>) mock(Callable.class, new ViolatedAssumptionAnswer()); [EOL]       CallableBackgroundInitializer<Object> callableBackgroundInitializer1 = new CallableBackgroundInitializer<Object>(callable1, executorService0); [EOL]       callableBackgroundInitializer1.isStarted(); [EOL]       Callable<Callable<Delayed>> callable2 = (Callable<Callable<Delayed>>) mock(Callable.class, new ViolatedAssumptionAnswer()); [EOL]       CallableBackgroundInitializer<Callable<Delayed>> callableBackgroundInitializer2 = new CallableBackgroundInitializer<Callable<Delayed>>(callable2); [EOL]       ExecutorService executorService1 = callableBackgroundInitializer2.getExternalExecutor(); [EOL]       assertNull(executorService1); [EOL]   } [EOL]  [EOL]
@Test(timeout = 60000) [EOL] public void testReadlink() throws Exception { [EOL] // Create a symlink first. [EOL] HdfsFileStatus status = nn.getRpcServer().getFileInfo(testdir); [EOL] long dirId = status.getFileId(); [EOL] int namenodeId = Nfs3Utils.getNamenodeId(config); [EOL] XDR xdr_req = new XDR(); [EOL] FileHandle handle = new FileHandle(dirId, namenodeId); [EOL] SYMLINK3Request req = new SYMLINK3Request(handle, "fubar", new SetAttr3(), [EOL] "bar"); [EOL] req.serialize(xdr_req); [EOL] [EOL] SYMLINK3Response response = nfsd.symlink(xdr_req.asReadOnlyWrap(), [EOL] securityHandler, new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3_OK, [EOL] response.getStatus()); [EOL] [EOL] // Now perform readlink operations. [EOL] FileHandle handle2 = response.getObjFileHandle(); [EOL] XDR xdr_req2 = new XDR(); [EOL] READLINK3Request req2 = new READLINK3Request(handle2); [EOL] req2.serialize(xdr_req2); [EOL] [EOL] // Attempt by an unpriviledged user should fail. [EOL] READLINK3Response response1 = nfsd.readlink(xdr_req2.asReadOnlyWrap(), [EOL] securityHandlerUnpriviledged, [EOL] new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3ERR_ACCES, [EOL] response1.getStatus()); [EOL] [EOL] // Attempt by a priviledged user should pass. [EOL] READLINK3Response response2 = nfsd.readlink(xdr_req2.asReadOnlyWrap(), [EOL] securityHandler, new InetSocketAddress("localhost", 1234)); [EOL] assertEquals("Incorrect return code:", Nfs3Status.NFS3_OK, [EOL] response2.getStatus()); [EOL] } [EOL] static DistributedFileSystem hdfs; [EOL] static MiniDFSCluster cluster = null; [EOL] static NfsConfiguration config = new NfsConfiguration(); [EOL] static HdfsAdmin dfsAdmin; [EOL] static NameNode nn; [EOL] static Nfs3 nfs; [EOL] static RpcProgramNfs3 nfsd; [EOL] static SecurityHandler securityHandler; [EOL] static SecurityHandler securityHandlerUnpriviledged; [EOL] static String testdir = "/tmp"; [EOL] private static final String TEST_KEY = "test_key"; [EOL] private static FileSystemTestHelper fsHelper; [EOL] private static File testRootDir; [EOL] private static final EnumSet<CreateEncryptionZoneFlag> NO_TRASH = [EOL] EnumSet.of(CreateEncryptionZoneFlag.NO_TRASH); [EOL]
@Test [EOL] public void testTargetAsEnvironment() { [EOL] if (!Shell.WINDOWS) { [EOL] fencer.tryFence(TEST_TARGET, "echo $target_host $target_port"); [EOL] Mockito.verify(ShellCommandFencer.LOG).info( [EOL] Mockito.endsWith("echo $ta...rget_port: dummyhost 1234")); [EOL] } else { [EOL] fencer.tryFence(TEST_TARGET, "echo %target_host% %target_port%"); [EOL] Mockito.verify(ShellCommandFencer.LOG).info( [EOL] Mockito.endsWith("echo %ta...get_port%: dummyhost 1234")); [EOL] } [EOL] } [EOL] private ShellCommandFencer fencer = createFencer(); [EOL] private static final HAServiceTarget TEST_TARGET = [EOL] new DummyHAService(HAServiceState.ACTIVE, [EOL] new InetSocketAddress("dummyhost", 1234)); [EOL] private static final Logger LOG = ShellCommandFencer.LOG; [EOL]
@Test(timeout = 4000) [EOL]   public void testintValue()  throws Throwable  { [EOL]       MutableInt mutableInt0 = new MutableInt((-1)); [EOL]       int int0 = mutableInt0.intValue(); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFilesystemCounter() { [EOL] GroupFactory groupFactory = new GroupFactoryForTest(); [EOL] Group fsGroup = groupFactory.newFileSystemGroup(); [EOL] [EOL] org.apache.hadoop.mapreduce.Counter count1 = [EOL] fsGroup.findCounter("ANY_BYTES_READ"); [EOL] Assert.assertNotNull(count1); [EOL] [EOL] // Verify no exception get thrown when finding an unknown counter [EOL] org.apache.hadoop.mapreduce.Counter count2 = [EOL] fsGroup.findCounter("Unknown"); [EOL] Assert.assertNull(count2); [EOL] } [EOL] private static final long MAX_VALUE = 10; [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestCounters.class); [EOL] static final Enum<?> FRAMEWORK_COUNTER = TaskCounter.CPU_MILLISECONDS; [EOL] static final long FRAMEWORK_COUNTER_VALUE = 8; [EOL] static final String FS_SCHEME = "HDFS"; [EOL] static final FileSystemCounter FS_COUNTER = FileSystemCounter.BYTES_READ; [EOL] static final long FS_COUNTER_VALUE = 10; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = "SzpQ!4 ;U"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("SzpQ!4 ;U"); [EOL]        [EOL]       char char0 = '`'; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) "SzpQ!4 ;U", 97, '`'); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("ekji"); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(97, (long) 2817); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.replaceFirst("SzpQ!4 ;U", "ekji"); [EOL]        [EOL]       String string1 = strBuilder0.getNullText(); [EOL]        [EOL]       String string2 = strBuilder1.leftString((-2254)); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]        [EOL]       boolean boolean0 = strBuilder3.contains('`'); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder2.replaceAll("ekji", "ekji"); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(2817, (-1.0F)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2817 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void readFromJar() throws WSDLException, URISyntaxException, Exception { [EOL] [EOL] ReadWSDL readWSDL = new ReadWSDL(); [EOL] Definition definition = readWSDL.readWSDL("uddi_v3_service.wsdl"); [EOL] Assert.assertNotNull(definition); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisArrayContentDetail()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SIMPLE_STYLE.setArraySeparator((String) null); [EOL]       assertTrue(standardToStringStyle0.isArrayContentDetail()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 600000) [EOL] public void testContainerAutoUpdateContainer() throws Exception { [EOL] rm.stop(); [EOL] createAndStartRMWithAutoUpdateContainer(); [EOL] MockNM nm1 = new MockNM("h1:1234", 4096, rm.getResourceTrackerService()); [EOL] nm1.registerNode(); [EOL] nm1.nodeHeartbeat(oppContainersStatus, true); [EOL] [EOL] OpportunisticContainerAllocatorAMService amservice = [EOL] (OpportunisticContainerAllocatorAMService) rm [EOL] .getApplicationMasterService(); [EOL] MockRMAppSubmissionData data = [EOL] MockRMAppSubmissionData.Builder.createWithMemory(1 * GB, rm) [EOL] .withAppName("app") [EOL] .withUser("user") [EOL] .withAcls(null) [EOL] .withQueue("default") [EOL] .withUnmanagedAM(false) [EOL] .build(); [EOL] RMApp app1 = MockRMAppSubmitter.submit(rm, data); [EOL] MockAM am1 = MockRM.launchAndRegisterAM(app1, rm, nm1); [EOL] ResourceScheduler scheduler = rm.getResourceScheduler(); [EOL] RMNode rmNode1 = rm.getRMContext().getRMNodes().get(nm1.getNodeId()); [EOL] [EOL] nm1.nodeHeartbeat(oppContainersStatus, true); [EOL] [EOL] GenericTestUtils.waitFor(() -> [EOL] amservice.getLeastLoadedNodes().size() == 1, 10, 10 * 100); [EOL] [EOL] AllocateResponse allocateResponse = am1.allocate(Arrays.asList( [EOL] ResourceRequest.newInstance(Priority.newInstance(1), "*", [EOL] Resources.createResource(1 * GB), 2, true, null, [EOL] ExecutionTypeRequest [EOL] .newInstance(ExecutionType.OPPORTUNISTIC, true))), null); [EOL] List<Container> allocatedContainers = [EOL] allocateResponse.getAllocatedContainers(); [EOL] allocatedContainers.addAll( [EOL] am1.allocate(null, null).getAllocatedContainers()); [EOL] Assert.assertEquals(2, allocatedContainers.size()); [EOL] Container container = allocatedContainers.get(0); [EOL] // Start Container in NM [EOL] nm1.nodeHeartbeat(Arrays.asList(ContainerStatus [EOL] .newInstance(container.getId(), ExecutionType.OPPORTUNISTIC, [EOL] ContainerState.RUNNING, "", 0)), true); [EOL] rm.drainEvents(); [EOL] [EOL] // Verify that container is actually running wrt the RM.. [EOL] RMContainer rmContainer = ((CapacityScheduler) scheduler) [EOL] .getApplicationAttempt(container.getId().getApplicationAttemptId()) [EOL] .getRMContainer(container.getId()); [EOL] Assert.assertEquals(RMContainerState.RUNNING, rmContainer.getState()); [EOL] [EOL] // Send Promotion req... this should result in update error [EOL] // Since the container doesn't exist anymore.. [EOL] allocateResponse = am1.sendContainerUpdateRequest(Arrays.asList( [EOL] UpdateContainerRequest.newInstance(0, container.getId(), [EOL] ContainerUpdateType.PROMOTE_EXECUTION_TYPE, null, [EOL] ExecutionType.GUARANTEED))); [EOL] [EOL] nm1.nodeHeartbeat(Arrays.asList(ContainerStatus [EOL] .newInstance(container.getId(), ExecutionType.OPPORTUNISTIC, [EOL] ContainerState.RUNNING, "", 0)), true); [EOL] rm.drainEvents(); [EOL] // Get the update response on next allocate [EOL] allocateResponse = am1.allocate(new ArrayList<>(), new ArrayList<>()); [EOL] // Check the update response from YARNRM [EOL] Assert.assertEquals(1, allocateResponse.getUpdatedContainers().size()); [EOL] UpdatedContainer uc = allocateResponse.getUpdatedContainers().get(0); [EOL] Assert.assertEquals(container.getId(), uc.getContainer().getId()); [EOL] Assert.assertEquals(ExecutionType.GUARANTEED, [EOL] uc.getContainer().getExecutionType()); [EOL] // Check that the container is updated in NM through NM heartbeat response [EOL] NodeHeartbeatResponse response = nm1.nodeHeartbeat(true); [EOL] Assert.assertEquals(1, response.getContainersToUpdate().size()); [EOL] Container containersFromNM = response.getContainersToUpdate().get(0); [EOL] Assert.assertEquals(container.getId(), containersFromNM.getId()); [EOL] Assert.assertEquals(ExecutionType.GUARANTEED, [EOL] containersFromNM.getExecutionType()); [EOL] [EOL] //Increase resources [EOL] allocateResponse = am1.sendContainerUpdateRequest(Arrays.asList( [EOL] UpdateContainerRequest.newInstance(1, container.getId(), [EOL] ContainerUpdateType.INCREASE_RESOURCE, [EOL] Resources.createResource(2 * GB, 1), null))); [EOL] response = nm1.nodeHeartbeat(Arrays.asList(ContainerStatus [EOL] .newInstance(container.getId(), ExecutionType.GUARANTEED, [EOL] ContainerState.RUNNING, "", 0)), true); [EOL] [EOL] rm.drainEvents(); [EOL] if (allocateResponse.getUpdatedContainers().size() == 0) { [EOL] allocateResponse = am1.allocate(new ArrayList<>(), new ArrayList<>()); [EOL] } [EOL] Assert.assertEquals(1, allocateResponse.getUpdatedContainers().size()); [EOL] uc = allocateResponse.getUpdatedContainers().get(0); [EOL] Assert.assertEquals(container.getId(), uc.getContainer().getId()); [EOL] Assert.assertEquals(Resource.newInstance(2 * GB, 1), [EOL] uc.getContainer().getResource()); [EOL] rm.drainEvents(); [EOL] [EOL] // Check that the container resources are increased in [EOL] // NM through NM heartbeat response [EOL] if (response.getContainersToUpdate().size() == 0) { [EOL] response = nm1.nodeHeartbeat(true); [EOL] } [EOL] Assert.assertEquals(1, response.getContainersToUpdate().size()); [EOL] Assert.assertEquals(Resource.newInstance(2 * GB, 1), [EOL] response.getContainersToUpdate().get(0).getResource()); [EOL] [EOL] //Decrease resources [EOL] allocateResponse = am1.sendContainerUpdateRequest(Arrays.asList( [EOL] UpdateContainerRequest.newInstance(2, container.getId(), [EOL] ContainerUpdateType.DECREASE_RESOURCE, [EOL] Resources.createResource(1 * GB, 1), null))); [EOL] Assert.assertEquals(1, allocateResponse.getUpdatedContainers().size()); [EOL] rm.drainEvents(); [EOL] [EOL] // Check that the container resources are decreased [EOL] // in NM through NM heartbeat response [EOL] response = nm1.nodeHeartbeat(true); [EOL] Assert.assertEquals(1, response.getContainersToUpdate().size()); [EOL] Assert.assertEquals(Resource.newInstance(1 * GB, 1), [EOL] response.getContainersToUpdate().get(0).getResource()); [EOL] [EOL] nm1.nodeHeartbeat(oppContainersStatus, true); [EOL] // DEMOTE the container [EOL] allocateResponse = am1.sendContainerUpdateRequest(Arrays.asList( [EOL] UpdateContainerRequest.newInstance(3, container.getId(), [EOL] ContainerUpdateType.DEMOTE_EXECUTION_TYPE, null, [EOL] ExecutionType.OPPORTUNISTIC))); [EOL] [EOL] response = nm1.nodeHeartbeat(Arrays.asList(ContainerStatus [EOL] .newInstance(container.getId(), ExecutionType.GUARANTEED, [EOL] ContainerState.RUNNING, "", 0)), true); [EOL] rm.drainEvents(); [EOL] if (allocateResponse.getUpdatedContainers().size() == 0) { [EOL] // Get the update response on next allocate [EOL] allocateResponse = am1.allocate(new ArrayList<>(), new ArrayList<>()); [EOL] } [EOL] // Check the update response from YARNRM [EOL] Assert.assertEquals(1, allocateResponse.getUpdatedContainers().size()); [EOL] uc = allocateResponse.getUpdatedContainers().get(0); [EOL] Assert.assertEquals(ExecutionType.OPPORTUNISTIC, [EOL] uc.getContainer().getExecutionType()); [EOL] // Check that the container is updated in NM through NM heartbeat response [EOL] if (response.getContainersToUpdate().size() == 0) { [EOL] response = nm1.nodeHeartbeat(oppContainersStatus, true); [EOL] } [EOL] Assert.assertEquals(1, response.getContainersToUpdate().size()); [EOL] Assert.assertEquals(ExecutionType.OPPORTUNISTIC, [EOL] response.getContainersToUpdate().get(0).getExecutionType()); [EOL] } [EOL] private static final int GB = 1024; [EOL] private MockRM rm; [EOL] private DrainDispatcher dispatcher; [EOL] private OpportunisticContainersStatus oppContainersStatus = [EOL] getOpportunisticStatus(); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       int int0 = 7; [EOL]       StrBuilder strBuilder0 = new StrBuilder(7); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.trim(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder1.length()); [EOL]        [EOL]       int int1 = 0; [EOL]       int int2 = 32; [EOL]       StrBuilder strBuilder2 = strBuilder0.insert(0, 32); [EOL]       assertEquals(2, strBuilder0.length()); [EOL]       assertEquals(2, strBuilder2.length()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append('r'); [EOL]       assertEquals(3, strBuilder0.length()); [EOL]       assertEquals(3, strBuilder1.length()); [EOL]       assertEquals(3, strBuilder3.length()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.replaceAll("java.vm.specification.version", "java.vm.specification.version"); [EOL]       assertEquals(3, strBuilder0.length()); [EOL]       assertEquals(3, strBuilder1.length()); [EOL]       assertEquals(3, strBuilder4.length()); [EOL]        [EOL]       Integer integer0 = new Integer(0); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder1.insert(0, (Object) integer0); [EOL]       assertEquals(31, strBuilder0.length()); [EOL]       assertEquals(31, strBuilder1.length()); [EOL]       assertEquals(31, strBuilder5.length()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.clear(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder6.length()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.quoteMatcher(); [EOL]        [EOL]       String string0 = ""; [EOL]       StrBuilder strBuilder7 = strBuilder5.appendln(false); [EOL]       assertEquals(6, strBuilder0.length()); [EOL]       assertEquals(6, strBuilder1.length()); [EOL]       assertEquals(6, strBuilder5.length()); [EOL]       assertEquals(6, strBuilder7.length()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder6.replaceAll(strMatcher0, ""); [EOL]       assertEquals(6, strBuilder0.length()); [EOL]       assertEquals(6, strBuilder6.length()); [EOL]       assertEquals(6, strBuilder8.length()); [EOL]        [EOL]       char char0 = 'W'; [EOL]       int int3 = strBuilder0.lastIndexOf('W', 7); [EOL]       assertEquals(6, strBuilder0.length()); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder5.new StrBuilderWriter(); [EOL]       assertEquals(6, strBuilder0.length()); [EOL]       assertEquals(6, strBuilder1.length()); [EOL]       assertEquals(6, strBuilder5.length()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder_StrBuilderWriter0.write("J~TQzXP^tZ:~", 7, 519); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNewKey() throws Exception{ [EOL] System.out.println("newKey"); [EOL] TripleDESCrytor instance = new TripleDESCrytor(); [EOL] String result = instance.newKey(); [EOL] assertNotNull(result); [EOL] } [EOL]
@Test [EOL] public void testPrimaryFilterString() { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("timeline") [EOL] .path("type_1").queryParam("primaryFilter", "user:username") [EOL] .accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] verifyEntities(response.getEntity(TimelineEntities.class)); [EOL] } [EOL] private static TimelineStore store; [EOL] private static TimelineACLsManager timelineACLsManager; [EOL] private static AdminACLsManager adminACLsManager; [EOL] private static long beforeTime; [EOL]
@Test [EOL] public void testFactory() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] final String userUri = UserProvider.SCHEME_NAME + ":///"; [EOL] final Path jksPath = new Path(tmpDir.toString(), "test.jks"); [EOL] final String jksUri = JavaKeyStoreProvider.SCHEME_NAME + [EOL] "://file" + jksPath.toUri(); [EOL] conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, [EOL] userUri + "," + jksUri); [EOL] List<CredentialProvider> providers = [EOL] CredentialProviderFactory.getProviders(conf); [EOL] assertEquals(2, providers.size()); [EOL] assertEquals(UserProvider.class, providers.get(0).getClass()); [EOL] assertEquals(JavaKeyStoreProvider.class, providers.get(1).getClass()); [EOL] assertEquals(userUri, providers.get(0).toString()); [EOL] assertEquals(jksUri, providers.get(1).toString()); [EOL] } [EOL] public static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCredentialProviderFactory.class); [EOL] @Rule [EOL] public final TestName test = new TestName(); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL] private static char[] chars = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', [EOL] 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', [EOL] 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', [EOL] 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', [EOL] '2', '3', '4', '5', '6', '7', '8', '9',}; [EOL] private static final File tmpDir = GenericTestUtils.getTestDir("creds"); [EOL]
@Test [EOL] public void testEnums() throws Exception { [EOL] for (YarnApplicationState applicationState : YarnApplicationState.values()) { [EOL] TypeConverter.fromYarn(applicationState, FinalApplicationStatus.FAILED); [EOL] } [EOL] // ad hoc test of NEW_SAVING, which is newly added [EOL] Assert.assertEquals(State.PREP, TypeConverter.fromYarn( [EOL] YarnApplicationState.NEW_SAVING, FinalApplicationStatus.FAILED)); [EOL] [EOL] for (TaskType taskType : TaskType.values()) { [EOL] TypeConverter.fromYarn(taskType); [EOL] } [EOL] [EOL] for (JobState jobState : JobState.values()) { [EOL] TypeConverter.fromYarn(jobState); [EOL] } [EOL] [EOL] for (QueueState queueState : QueueState.values()) { [EOL] TypeConverter.fromYarn(queueState); [EOL] } [EOL] [EOL] for (TaskState taskState : TaskState.values()) { [EOL] TypeConverter.fromYarn(taskState); [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitToBinary()  throws Throwable  { [EOL]       boolean[] booleanArray0 = Conversion.hexDigitToBinary('f'); [EOL]       assertEquals(4, booleanArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAsciiAlphanumeric()  throws Throwable  { [EOL]       boolean boolean0 = CharUtils.isAsciiAlphanumeric('A'); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("hZ3CNnc|]e"); [EOL]       assertEquals(10, strBuilder0.length()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(10, strBuilder0.length()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(); [EOL]       assertEquals(10, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-963), 104, '/'); [EOL]       assertEquals(114, strBuilder0.length()); [EOL]       assertEquals(114, strBuilder1.length()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.tabMatcher(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.deleteAll(strMatcher0); [EOL]       assertEquals(114, strBuilder0.length()); [EOL]       assertEquals(114, strBuilder1.length()); [EOL]       assertEquals(114, strBuilder2.length()); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = '/'; [EOL]       charArray0[1] = '/'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       assertEquals(2, charBuffer0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       Buffer buffer0 = charBuffer0.flip(); [EOL]       assertEquals(0, charBuffer0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertEquals(114, strBuilder0.length()); [EOL]       assertEquals(0, charBuffer0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       strBuilder_StrBuilderReader0.close(); [EOL]       assertEquals(114, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append((long) 104); [EOL]       assertEquals(117, strBuilder0.length()); [EOL]       assertEquals(117, strBuilder1.length()); [EOL]       assertEquals(117, strBuilder3.length()); [EOL]        [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       TreeSet<Object> treeSet0 = new TreeSet<Object>(comparator0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.appendWithSeparators((Iterable<?>) treeSet0, "hZ3CNnc|]e"); [EOL]       assertEquals(117, strBuilder4.length()); [EOL]       assertEquals(117, strBuilder0.length()); [EOL]       assertEquals(117, strBuilder1.length()); [EOL]       assertEquals(117, strBuilder3.length()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.ensureCapacity(104); [EOL]       assertEquals(117, strBuilder0.length()); [EOL]       assertEquals(117, strBuilder5.length()); [EOL]       assertEquals(117, strBuilder1.length()); [EOL]       assertEquals(117, strBuilder3.length()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]       assertEquals(117, strBuilder0.length()); [EOL]        [EOL]       List<String> list0 = strBuilder_StrBuilderTokenizer0.tokenize(charArray0, (-963), (-3316)); [EOL]       assertEquals(117, strBuilder0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder1.replaceFirst(strMatcher0, "Windows NT"); [EOL]       assertEquals(117, strBuilder0.length()); [EOL]       assertEquals(117, strBuilder1.length()); [EOL]       assertEquals(117, strBuilder6.length()); [EOL]        [EOL]       char[] charArray1 = new char[2]; [EOL]        [EOL]       charArray1[0] = '/'; [EOL]       charArray1[1] = '/'; [EOL]       StrBuilder strBuilder7 = strBuilder0.appendln(charArray1); [EOL]       assertEquals(120, strBuilder0.length()); [EOL]       assertEquals(120, strBuilder7.length()); [EOL]       assertEquals(2, charArray1.length); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln("hZ3CNnc|]e", 121, 97); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.trimToNull(".ti')kKzb5J(cbBlh"); [EOL]        [EOL]       boolean boolean0 = StringUtils.isBlank(".ti')kKzb5J(cbBlh"); [EOL]        [EOL]       int int0 = StringUtils.indexOf((CharSequence) ".ti')kKzb5J(cbBlh", 10); [EOL]        [EOL]       String string1 = StringUtils.center(".ti')kKzb5J(cbBlh", 0, '3'); [EOL]       assertTrue(string1.equals((Object)string0)); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[2]; [EOL]       charSequenceArray0[0] = (CharSequence) ".ti')kKzb5J(cbBlh"; [EOL]       charSequenceArray0[1] = (CharSequence) ".ti')kKzb5J(cbBlh"; [EOL]       int int1 = StringUtils.indexOfDifference(charSequenceArray0); [EOL]        [EOL]       String string2 = StringUtils.overlay("org.apache.commons.lang3.StringUtils", "s", 13, 13); [EOL]       assertFalse(string2.equals((Object)string1)); [EOL]       assertFalse(string2.equals((Object)string0)); [EOL]        [EOL]       String string3 = StringUtils.right("", 0); [EOL]       assertFalse(string3.equals((Object)string0)); [EOL]       assertFalse(string3.equals((Object)string2)); [EOL]       assertFalse(string3.equals((Object)string1)); [EOL]        [EOL]       String string4 = StringUtils.repeat(".ti')kKzb5J(cbBlh", 13); [EOL]       assertFalse(string4.equals((Object)string2)); [EOL]       assertFalse(string4.equals((Object)string1)); [EOL]       assertFalse(string4.equals((Object)string0)); [EOL]       assertFalse(string4.equals((Object)string3)); [EOL]        [EOL]       String string5 = StringUtils.chop("org.apache.cosmmons.lang3.StringUtils"); [EOL]       assertFalse(string5.equals((Object)string3)); [EOL]       assertFalse(string5.equals((Object)string1)); [EOL]       assertFalse(string5.equals((Object)string2)); [EOL]       assertFalse(string5.equals((Object)string0)); [EOL]       assertFalse(string5.equals((Object)string4)); [EOL]        [EOL]       int int2 = StringUtils.lastIndexOfAny("org.apache.commons.lang3.StringUtils", charSequenceArray0); [EOL]        [EOL]       String string6 = StringUtils.lowerCase("s"); [EOL]       assertFalse(string6.equals((Object)string2)); [EOL]       assertFalse(string6.equals((Object)string4)); [EOL]       assertFalse(string6.equals((Object)string1)); [EOL]       assertFalse(string6.equals((Object)string5)); [EOL]       assertFalse(string6.equals((Object)string0)); [EOL]       assertFalse(string6.equals((Object)string3)); [EOL]        [EOL]       String string7 = StringUtils.overlay("org.apache.cosmmons.lang3.StringUtil", "{}", 13, 0); [EOL]       assertFalse(string7.equals((Object)string0)); [EOL]       assertFalse(string7.equals((Object)string4)); [EOL]       assertFalse(string7.equals((Object)string2)); [EOL]       assertFalse(string7.equals((Object)string5)); [EOL]       assertFalse(string7.equals((Object)string1)); [EOL]       assertFalse(string7.equals((Object)string3)); [EOL]       assertFalse(string7.equals((Object)string6)); [EOL]        [EOL]       String[] stringArray0 = new String[9]; [EOL]       stringArray0[0] = ".ti')kKzb5J(cbBlh"; [EOL]       stringArray0[1] = "s"; [EOL]       stringArray0[2] = "org.apache.cosmmons.lang3.StringUtils"; [EOL]       stringArray0[3] = "s"; [EOL]       stringArray0[4] = "s"; [EOL]       stringArray0[5] = "{}"; [EOL]       stringArray0[6] = "{}"; [EOL]       stringArray0[7] = ""; [EOL]       stringArray0[8] = ".ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh"; [EOL]       String string8 = StringUtils.getCommonPrefix(stringArray0); [EOL]       assertFalse(string8.equals((Object)string7)); [EOL]       assertTrue(string8.equals((Object)string3)); [EOL]       assertFalse(string8.equals((Object)string2)); [EOL]       assertFalse(string8.equals((Object)string5)); [EOL]       assertFalse(string8.equals((Object)string6)); [EOL]       assertFalse(string8.equals((Object)string0)); [EOL]       assertFalse(string8.equals((Object)string1)); [EOL]       assertFalse(string8.equals((Object)string4)); [EOL]        [EOL]       String[] stringArray1 = StringUtils.substringsBetween("Threshold must not be negative", ".ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh.ti')kKzb5J(cbBlh", ""); [EOL]        [EOL]       String[] stringArray2 = StringUtils.substringsBetween("org.apache.commons.lang3.exception.CloneFa", "s", ".ti')kKzb5J(cbBlh"); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSSLInitFailure() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(SSLFactory.SSL_HOSTNAME_VERIFIER_KEY, "foo"); [EOL] GenericTestUtils.LogCapturer logs = [EOL] GenericTestUtils.LogCapturer.captureLogs( [EOL] LoggerFactory.getLogger(URLConnectionFactory.class)); [EOL] URLConnectionFactory.newDefaultURLConnectionFactory(conf); [EOL] Assert.assertTrue("Expected log for ssl init failure not found!", [EOL] logs.getOutput().contains( [EOL] "Cannot load customized ssl related configuration")); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testgetPackageCanonicalName()  throws Throwable  { [EOL]       String string0 = ClassUtils.getPackageCanonicalName("["); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.isEmpty(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       String string0 = strBuilder0.midString(34, (-1)); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator(">R<{"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[7]; [EOL]       charArray0[0] = 'K'; [EOL]       charArray0[2] = 'L'; [EOL]       charArray0[3] = 'x'; [EOL]       charArray0[4] = '`'; [EOL]       charArray0[5] = '^'; [EOL]       charArray0[6] = 'V'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.getChars(3889, 0, charArray0, (-1)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testExecuteDockerKillSIGKILL() throws Exception { [EOL] DockerKillCommand dockerKillCommand = [EOL] new DockerKillCommand(MOCK_CONTAINER_ID) [EOL] .setSignal(ContainerExecutor.Signal.KILL.name()); [EOL] DockerCommandExecutor.executeDockerCommand(dockerKillCommand, [EOL] MOCK_CONTAINER_ID, env, mockExecutor, false, nmContext); [EOL] List<PrivilegedOperation> ops = MockPrivilegedOperationCaptor [EOL] .capturePrivilegedOperations(mockExecutor, 1, true); [EOL] List<String> dockerCommands = getValidatedDockerCommands(ops); [EOL] assertEquals(1, ops.size()); [EOL] assertEquals(PrivilegedOperation.OperationType.RUN_DOCKER_CMD.name(), [EOL] ops.get(0).getOperationType().name()); [EOL] assertEquals(4, dockerCommands.size()); [EOL] assertEquals("[docker-command-execution]", dockerCommands.get(0)); [EOL] assertEquals(" docker-command=kill", dockerCommands.get(1)); [EOL] assertEquals(" name=" + MOCK_CONTAINER_ID, dockerCommands.get(2)); [EOL] assertEquals(" signal=" + ContainerExecutor.Signal.KILL.name(), [EOL] dockerCommands.get(3)); [EOL] } [EOL] private static final String MOCK_CONTAINER_ID = [EOL] "container_e11_1861047502093_13763105_01_000001"; [EOL] private static final String MOCK_LOCAL_IMAGE_NAME = "local_image_name"; [EOL] private static final String MOCK_IMAGE_NAME = "image_name"; [EOL] private static final String MOCK_CGROUP_HIERARCHY = "hadoop-yarn"; [EOL] private PrivilegedOperationExecutor mockExecutor; [EOL] private CGroupsHandler mockCGroupsHandler; [EOL] private Configuration configuration; [EOL] private ContainerRuntimeContext.Builder builder; [EOL] private DockerLinuxContainerRuntime runtime; [EOL] private Container container; [EOL] private ContainerId cId; [EOL] private ContainerLaunchContext context; [EOL] private HashMap<String, String> env; [EOL] private Context nmContext; [EOL] private ApplicationAttemptId appAttemptId; [EOL]
@Test(timeout = 4000) [EOL]   public void testatLeast()  throws Throwable  { [EOL]       JavaVersion javaVersion0 = JavaVersion.JAVA_1_3; [EOL]       boolean boolean0 = javaVersion0.atLeast(javaVersion0); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String string0 = StringUtils.left("F*ih6'Wv@Hv&-.Ni:q", (-2178)); [EOL]        [EOL]       boolean boolean0 = StringUtils.startsWith("", "F*ih6'Wv@Hv&-.Ni:q"); [EOL]        [EOL]       boolean boolean1 = StringUtils.isWhitespace((CharSequence) null); [EOL]        [EOL]       boolean boolean2 = StringUtils.containsWhitespace(""); [EOL]        [EOL]       String[] stringArray0 = StringUtils.split((String) null, ""); [EOL]        [EOL]       String string1 = StringUtils.stripStart("", (String) null); [EOL]       assertTrue(string1.equals((Object)string0)); [EOL]        [EOL]       int int0 = StringUtils.countMatches((CharSequence) null, ""); [EOL]        [EOL]       String string2 = StringUtils.stripToNull(""); [EOL]        [EOL]       String string3 = StringUtils.defaultString("", (String) null); [EOL]       assertTrue(string3.equals((Object)string1)); [EOL]       assertTrue(string3.equals((Object)string0)); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testZeroGuarOverCap() { [EOL] int[][] qData = new int[][] { [EOL] // / A B C D E F [EOL] { 200, 100, 0, 100, 0, 100, 100 }, // abs [EOL] { 200, 200, 200, 200, 200, 200, 200 }, // maxCap [EOL] { 170, 170, 60, 20, 90, 0, 0 }, // used [EOL] { 85, 50, 30, 10, 10, 20, 20 }, // pending [EOL] { 0, 0, 0, 0, 0, 0, 0 }, // reserved [EOL] { 4, 3, 1, 1, 1, 1, 1 }, // apps [EOL] { -1, -1, 1, 1, 1, -1, 1 }, // req granularity [EOL] { 2, 3, 0, 0, 0, 1, 0 }, // subqueues [EOL] }; [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData); [EOL] policy.editSchedule(); [EOL] // No preemption should happen because zero guaranteed queues should be [EOL] // treated as always satisfied, they should not preempt from each other. [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appA))); [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appB))); [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appC))); [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appD))); [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test [EOL] public void testConfModificationFederationOnly() { [EOL] final HdfsConfiguration conf = new HdfsConfiguration(); [EOL] String nsId = "ns1"; [EOL] [EOL] conf.set(DFS_NAMESERVICES, nsId); [EOL] conf.set(DFS_NAMESERVICE_ID, nsId); [EOL] [EOL] // Set the nameservice specific keys with nameserviceId in the config key [EOL] for (String key : NameNode.NAMENODE_SPECIFIC_KEYS) { [EOL] // Note: value is same as the key [EOL] conf.set(DFSUtil.addKeySuffixes(key, nsId), key); [EOL] } [EOL] [EOL] // Initialize generic keys from specific keys [EOL] NameNode.initializeGenericKeys(conf, nsId, null); [EOL] [EOL] // Retrieve the keys without nameserviceId and Ensure generic keys are set [EOL] // to the correct value [EOL] for (String key : NameNode.NAMENODE_SPECIFIC_KEYS) { [EOL] assertEquals(key, conf.get(key)); [EOL] } [EOL] } [EOL] static final String NS1_NN_ADDR = "ns1-nn.example.com:8020"; [EOL] static final String NS1_NN1_ADDR = "ns1-nn1.example.com:8020"; [EOL] static final String NS1_NN2_ADDR = "ns1-nn2.example.com:8020"; [EOL] static final String NS1_NN1_HTTPS_ADDR = "ns1-nn1.example.com:50740"; [EOL] static final String NS1_NN1_HTTP_ADDR = "ns1-nn1.example.com:50070"; [EOL]
@Test [EOL] public void testMultipleHotsWithDifferentCounts() { [EOL] BlockStoragePolicySuite bsps = BlockStoragePolicySuite.createDefaultSuite(); [EOL] StoragePolicySummary sts = new StoragePolicySummary(bsps.getAllPolicies()); [EOL] BlockStoragePolicy hot = bsps.getPolicy("HOT"); [EOL] sts.add(new StorageType[]{StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK, [EOL] StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK, [EOL] StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK, [EOL] StorageType.DISK,StorageType.DISK,StorageType.DISK},hot); [EOL] Map<String, Long> actualOutput = convertToStringMap(sts); [EOL] Assert.assertEquals(4,actualOutput.size()); [EOL] Map<String, Long> expectedOutput = new HashMap<>(); [EOL] expectedOutput.put("HOT|DISK:1(HOT)", 1l); [EOL] expectedOutput.put("HOT|DISK:2(HOT)", 2l); [EOL] expectedOutput.put("HOT|DISK:3(HOT)", 2l); [EOL] expectedOutput.put("HOT|DISK:4(HOT)", 1l); [EOL] Assert.assertEquals(expectedOutput,actualOutput); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       int int0 = 0; [EOL]       String string0 = StringUtils.center("org.apache.commons.lang3.StringUtils", 0, "org.apache.commons.lang3.StringUtils"); [EOL]        [EOL]       String string1 = StringUtils.stripToEmpty("org.apache.commons.lang3.StringUtils"); [EOL]        [EOL]       char char0 = 'R'; [EOL]       String string2 = StringUtils.center("JL_O}", 0, 'R'); [EOL]        [EOL]       String string3 = StringUtils.center((String) null, 0, "org.apache.commons.lang3.StringUtils"); [EOL]        [EOL]       char char1 = '}'; [EOL]       String string4 = StringUtils.rightPad((String) null, 2185, '}'); [EOL]        [EOL]       int int1 = StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null, 2185); [EOL]        [EOL]       Stack<Object> stack0 = new Stack<Object>(); [EOL]       assertTrue(stack0.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         stack0.listIterator((-1)); [EOL]         fail("Expecting exception: IndexOutOfBoundsException"); [EOL]        [EOL]       } catch(IndexOutOfBoundsException e) { [EOL]          // [EOL]          // Index: -1 [EOL]          // [EOL]          verifyException("java.util.Vector", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testformat()  throws Throwable  { [EOL]       String string0 = DateFormatUtils.formatUTC(0L, "."); [EOL]       assertEquals(".", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]        [EOL]       CompareToBuilder compareToBuilder1 = compareToBuilder0.append('a', '7'); [EOL]       compareToBuilder1.append(true, true); [EOL]       assertEquals(1, compareToBuilder0.toComparison()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testof()  throws Throwable  { [EOL]       Integer integer0 = new Integer(2382); [EOL]       MutableTriple<Integer, Integer, String> mutableTriple0 = new MutableTriple<Integer, Integer, String>(integer0, integer0, ""); [EOL]       Integer integer1 = new Integer(41); [EOL]       ImmutableTriple<Integer, Integer, String> immutableTriple0 = ImmutableTriple.of(integer1, integer1, ""); [EOL]       int int0 = mutableTriple0.compareTo((Triple<Integer, Integer, String>) immutableTriple0); [EOL]       assertEquals(1, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testhexToInt()  throws Throwable  { [EOL]       int int0 = Conversion.hexToInt("", 0, 0, 0, 0); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test(expected=AclException.class) [EOL] public void testReplaceAclDefaultEntriesInputTooLarge() throws AclException { [EOL] List<AclEntry> existing = new ImmutableList.Builder<AclEntry>() [EOL] .add(aclEntry(DEFAULT, USER, ALL)) [EOL] .add(aclEntry(DEFAULT, GROUP, READ)) [EOL] .add(aclEntry(DEFAULT, OTHER, NONE)) [EOL] .build(); [EOL] replaceAclEntries(existing, ACL_SPEC_DEFAULT_TOO_LARGE); [EOL] } [EOL] private static final List<AclEntry> ACL_SPEC_TOO_LARGE; [EOL] private static final List<AclEntry> ACL_SPEC_DEFAULT_TOO_LARGE; [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseFieldNames()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getFieldNameValueSeparator(); [EOL]       assertTrue(standardToStringStyle0.isUseFieldNames()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       char char0 = 'Q'; [EOL]       Integer integer0 = new Integer((-3878)); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) integer0, (-3878), 'H'); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       charArray0[0] = 'Q'; [EOL]       int int0 = 5; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert((-3878), charArray0, (-3878), 5); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -3878 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.setSummaryObjectEndText(""); [EOL]       String string0 = standardToStringStyle0.getSummaryObjectEndText(); [EOL]       assertEquals("", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testBasicLogging() { [EOL] assertTrue(helper.record().shouldLog()); [EOL] [EOL] for (int i = 0; i < 5; i++) { [EOL] timer.advance(LOG_PERIOD / 10); [EOL] assertFalse(helper.record().shouldLog()); [EOL] } [EOL] timer.advance(LOG_PERIOD); [EOL] assertTrue(helper.record().shouldLog()); [EOL] } [EOL] private static final int LOG_PERIOD = 100; [EOL] private LogThrottlingHelper helper; [EOL] private FakeTimer timer; [EOL]
@Test [EOL] public void testMissingTarget() { [EOL] try { [EOL] OptionsParser.parse(new String[] { [EOL] "-f", "hdfs://localhost:8020/source"}); [EOL] Assert.fail("Missing target allowed"); [EOL] } catch (IllegalArgumentException ignore) {} [EOL] } [EOL] private static final float DELTA = 0.001f; [EOL]
@Test(timeout = 4000) [EOL]   public void testset()  throws Throwable  { [EOL]       StrMatcher strMatcher0 = StrMatcher.quoteMatcher(); [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer("nFgu8hR=<", strMatcher0); [EOL]       strTokenizer0.next(); [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       assertEquals(1, strTokenizer0.nextIndex()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testIsEmpty() { [EOL] FoldedTreeSet<String> instance = new FoldedTreeSet<>(); [EOL] boolean expResult = true; [EOL] boolean result = instance.isEmpty(); [EOL] assertEquals(expResult, result); [EOL] instance.add("apa"); [EOL] instance.remove("apa"); [EOL] assertEquals(expResult, result); [EOL] } [EOL] private static Random srand; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator(' ', (-2561)); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testResolveCompsDependency() { [EOL] Service service = createExampleApplication(); [EOL] List<String> dependencies = new ArrayList<String>(); [EOL] dependencies.add("compb"); [EOL] Component compa = createComponent("compa"); [EOL] compa.setDependencies(dependencies); [EOL] Component compb = createComponent("compb"); [EOL] service.addComponent(compa); [EOL] service.addComponent(compb); [EOL] List<String> order = ServiceApiUtil.resolveCompsDependency(service); [EOL] List<String> expected = new ArrayList<String>(); [EOL] expected.add("compb"); [EOL] expected.add("compa"); [EOL] for (int i = 0; i < expected.size(); i++) { [EOL] Assert.assertEquals("Components are not equal.", expected.get(i), [EOL] order.get(i)); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestServiceApiUtil.class); [EOL] private static final String EXCEPTION_PREFIX = "Should have thrown " + [EOL] "exception: "; [EOL] private static final String NO_EXCEPTION_PREFIX = "Should not have thrown " + [EOL] "exception: "; [EOL] private static final String LEN_64_STR = [EOL] "abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01"; [EOL] private static final YarnConfiguration CONF_DEFAULT_DNS = new [EOL] YarnConfiguration(); [EOL] private static final YarnConfiguration CONF_DNS_ENABLED = new [EOL] YarnConfiguration(); [EOL]
@Test(timeout = 4000) [EOL]   public void testready()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       char[] charArray0 = new char[18]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertFalse(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertFalse(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertFalse(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder strBuilder2 = new StrBuilder(); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]        [EOL]       String string0 = strBuilder4.leftString((-1)); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(false); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", (-1)); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testClusterMetricsSlash() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = r.path("ws").path("v1").path("cluster") [EOL] .path("metrics/").accept(MediaType.APPLICATION_JSON) [EOL] .get(ClientResponse.class); [EOL] [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] verifyClusterMetricsJSON(json); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRMWebServices.class); [EOL] private static MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-963), (-1), '/'); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder1.length()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.tabMatcher(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.deleteAll(strMatcher0); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder1.length()); [EOL]       assertEquals(0, strBuilder2.length()); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[1] = '/'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       assertEquals(2, charBuffer0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(2, charBuffer0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charSetMatcher("q=e;yKvV#~sM4D<2"); [EOL]        [EOL]       strBuilder_StrBuilderReader0.close(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append((long) (-1)); [EOL]       assertEquals(2, strBuilder0.length()); [EOL]       assertEquals(2, strBuilder1.length()); [EOL]       assertEquals(2, strBuilder3.length()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.ensureCapacity((-1)); [EOL]       assertEquals(2, strBuilder0.length()); [EOL]       assertEquals(2, strBuilder1.length()); [EOL]       assertEquals(2, strBuilder3.length()); [EOL]       assertEquals(2, strBuilder4.length()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]       assertEquals(2, strBuilder0.length()); [EOL]        [EOL]       List<String> list0 = strBuilder_StrBuilderTokenizer0.tokenize(charArray0, (-963), (-3316));yKvV#~sM4D<2")); [EOL]       assertEquals(2, strBuilder0.length()); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder1.replaceFirst(strMatcher0, "Windows NT"); [EOL]       assertEquals(2, strBuilder5.length()); [EOL]       assertEquals(2, strBuilder0.length()); [EOL]       assertEquals(2, strBuilder1.length()); [EOL]        [EOL]       char[] charArray1 = new char[2]; [EOL]        [EOL]       charArray1[0] = '/'; [EOL]       charArray1[1] = '/'; [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(charArray1); [EOL]       assertEquals(5, strBuilder0.length()); [EOL]       assertEquals(5, strBuilder6.length()); [EOL]       assertEquals(2, charArray1.length); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln("hZ3CNnc|]e", 101, 97); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testReencryptEncryptedKeys() throws Exception { [EOL] List<EncryptedKeyVersion> ekvs = new ArrayList<>(4); [EOL] // Generate 2 new EEKs @v0 and add to the list [EOL] ekvs.add(kpExt.generateEncryptedKey(encryptionKey.getName())); [EOL] ekvs.add(kpExt.generateEncryptedKey(encryptionKey.getName())); [EOL] [EOL] // Roll the EK [EOL] kpExt.rollNewVersion(ekvs.get(0).getEncryptionKeyName()); [EOL] // Generate 1 new EEK @v1 add to the list. [EOL] ekvs.add(kpExt.generateEncryptedKey(encryptionKey.getName())); [EOL] [EOL] // Roll the EK again [EOL] kpExt.rollNewVersion(ekvs.get(0).getEncryptionKeyName()); [EOL] // Generate 1 new EEK @v2 add to the list. [EOL] ekvs.add(kpExt.generateEncryptedKey(encryptionKey.getName())); [EOL] [EOL] // leave a deep copy of the original, for verification purpose. [EOL] List<EncryptedKeyVersion> ekvsOrig = new ArrayList<>(ekvs.size()); [EOL] for (EncryptedKeyVersion ekv : ekvs) { [EOL] ekvsOrig.add(new EncryptedKeyVersion(ekv.getEncryptionKeyName(), [EOL] ekv.getEncryptionKeyVersionName(), ekv.getEncryptedKeyIv(), [EOL] ekv.getEncryptedKeyVersion())); [EOL] } [EOL] [EOL] // Reencrypt ekvs [EOL] kpExt.reencryptEncryptedKeys(ekvs); [EOL] [EOL] // Verify each ekv [EOL] for (int i = 0; i < ekvs.size(); ++i) { [EOL] final EncryptedKeyVersion ekv = ekvs.get(i); [EOL] final EncryptedKeyVersion orig = ekvsOrig.get(i); [EOL] assertEquals("Version name should be EEK", [EOL] KeyProviderCryptoExtension.EEK, [EOL] ekv.getEncryptedKeyVersion().getVersionName()); [EOL] assertEquals("Encryption key name should be " + ENCRYPTION_KEY_NAME, [EOL] ENCRYPTION_KEY_NAME, ekv.getEncryptionKeyName()); [EOL] assertNotNull("Expected encrypted key material", [EOL] ekv.getEncryptedKeyVersion().getMaterial()); [EOL] assertEquals("Length of encryption key material and EEK material should " [EOL] + "be the same", encryptionKey.getMaterial().length, [EOL] ekv.getEncryptedKeyVersion().getMaterial().length); [EOL] assertFalse( [EOL] "Encrypted key material should not equal encryption key material", [EOL] Arrays.equals(ekv.getEncryptedKeyVersion().getMaterial(), [EOL] encryptionKey.getMaterial())); [EOL] [EOL] if (i < 3) { [EOL] assertFalse("Re-encrypted EEK should have different material", [EOL] Arrays.equals(ekv.getEncryptedKeyVersion().getMaterial(), [EOL] orig.getEncryptedKeyVersion().getMaterial())); [EOL] } else { [EOL] assertTrue("Re-encrypted EEK should have same material", [EOL] Arrays.equals(ekv.getEncryptedKeyVersion().getMaterial(), [EOL] orig.getEncryptedKeyVersion().getMaterial())); [EOL] } [EOL] [EOL] // Decrypt the new EEK into an EK and check it [EOL] final KeyVersion kv = kpExt.decryptEncryptedKey(ekv); [EOL] assertEquals(KeyProviderCryptoExtension.EK, kv.getVersionName()); [EOL] [EOL] // Decrypt it again and it should be the same [EOL] KeyVersion kv1 = kpExt.decryptEncryptedKey(ekv); [EOL] assertArrayEquals(kv.getMaterial(), kv1.getMaterial()); [EOL] [EOL] // Verify decrypting the new EEK and orig EEK gives the same material. [EOL] final KeyVersion origKv = kpExt.decryptEncryptedKey(orig); [EOL] assertTrue("Returned EEK and original EEK should both decrypt to the " [EOL] + "same kv.", Arrays.equals(origKv.getMaterial(), kv.getMaterial())); [EOL] } [EOL] } [EOL] private static final String CIPHER = "AES"; [EOL] private static final String ENCRYPTION_KEY_NAME = "fooKey"; [EOL] private static Configuration conf; [EOL] private static KeyProvider kp; [EOL] private static KeyProviderCryptoExtension kpExt; [EOL] private static KeyProvider.Options options; [EOL] private static KeyVersion encryptionKey; [EOL] @Rule [EOL] public Timeout testTimeout = new Timeout(180000); [EOL]
@Test [EOL] public void testPollReturnsNullWhenEmpty() { [EOL] assertNull(fcq.poll()); [EOL] } [EOL] private FairCallQueue<Schedulable> fcq; [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       Character[] characterArray0 = new Character[4]; [EOL]       char char0 = '\\'; [EOL]       char[] charArray0 = ArrayUtils.toPrimitive(characterArray0, char0); [EOL]       int int0 = ArrayUtils.lastIndexOf(charArray0, '\\', 0); [EOL]       assertEquals(0, int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMultipleHots() { [EOL] BlockStoragePolicySuite bsps = BlockStoragePolicySuite.createDefaultSuite(); [EOL] StoragePolicySummary sts = new StoragePolicySummary(bsps.getAllPolicies()); [EOL] BlockStoragePolicy hot = bsps.getPolicy("HOT"); [EOL] sts.add(new StorageType[]{StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK, [EOL] StorageType.DISK,StorageType.DISK},hot); [EOL] sts.add(new StorageType[]{StorageType.DISK, [EOL] StorageType.DISK,StorageType.DISK,StorageType.DISK},hot); [EOL] Map<String, Long> actualOutput = convertToStringMap(sts); [EOL] Assert.assertEquals(4,actualOutput.size()); [EOL] Map<String, Long> expectedOutput = new HashMap<>(); [EOL] expectedOutput.put("HOT|DISK:1(HOT)", 1l); [EOL] expectedOutput.put("HOT|DISK:2(HOT)", 1l); [EOL] expectedOutput.put("HOT|DISK:3(HOT)", 1l); [EOL] expectedOutput.put("HOT|DISK:4(HOT)", 1l); [EOL] Assert.assertEquals(expectedOutput,actualOutput); [EOL] } [EOL]
@Test [EOL] public void testNodeRegistrationWithLabels() throws Exception { [EOL] writeToHostsFile("host2"); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, [EOL] hostFile.getAbsolutePath()); [EOL] conf.set(YarnConfiguration.NODELABEL_CONFIGURATION_TYPE, [EOL] YarnConfiguration.DISTRIBUTED_NODELABEL_CONFIGURATION_TYPE); [EOL] [EOL] final RMNodeLabelsManager nodeLabelsMgr = new NullRMNodeLabelsManager(); [EOL] [EOL] rm = new MockRM(conf) { [EOL] @Override [EOL] protected RMNodeLabelsManager createNodeLabelManager() { [EOL] return nodeLabelsMgr; [EOL] } [EOL] }; [EOL] rm.start(); [EOL] [EOL] try { [EOL] nodeLabelsMgr.addToCluserNodeLabelsWithDefaultExclusivity(toSet("A", "B", "C")); [EOL] } catch (IOException e) { [EOL] Assert.fail("Caught Exception while initializing"); [EOL] e.printStackTrace(); [EOL] } [EOL] [EOL] ResourceTrackerService resourceTrackerService = [EOL] rm.getResourceTrackerService(); [EOL] RegisterNodeManagerRequest registerReq = [EOL] Records.newRecord(RegisterNodeManagerRequest.class); [EOL] NodeId nodeId = NodeId.newInstance("host2", 1234); [EOL] Resource capability = BuilderUtils.newResource(1024, 1); [EOL] registerReq.setResource(capability); [EOL] registerReq.setNodeId(nodeId); [EOL] registerReq.setHttpPort(1234); [EOL] registerReq.setNMVersion(YarnVersionInfo.getVersion()); [EOL] registerReq.setNodeLabels(toSet(NodeLabel.newInstance("A"))); [EOL] RegisterNodeManagerResponse response = [EOL] resourceTrackerService.registerNodeManager(registerReq); [EOL] [EOL] Assert.assertEquals("Action should be normal on valid Node Labels", [EOL] NodeAction.NORMAL, response.getNodeAction()); [EOL] assertCollectionEquals(nodeLabelsMgr.getNodeLabels().get(nodeId), [EOL] NodeLabelsUtils.convertToStringSet(registerReq.getNodeLabels())); [EOL] Assert.assertTrue("Valid Node Labels were not accepted by RM", [EOL] response.getAreNodeLabelsAcceptedByRM()); [EOL] rm.stop(); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((String) null); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.insert(0, (Object) null); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.appendWithSeparators((Iterable<?>) null, (String) null); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.charSetMatcher((String) null); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charMatcher('L'); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendWithSeparators((Iterable<?>) null, ""); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.stringMatcher("r8T0ER3M!z7l6zL5!"); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((double) 0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       String string0 = strBuilder4.build(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.deleteFirst((String) null); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder5.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder1.replaceFirst(strMatcher0, "os.arch"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder6.getNullText()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.isEmpty(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       boolean boolean1 = strBuilder2.equals(strBuilder4); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       String string1 = strBuilder1.getNullText(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.appendSeparator(", Length: "); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder7.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder0.insert(0, false); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder8.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[3]; [EOL]       charArray0[0] = 'L'; [EOL]       charArray0[1] = 'L'; [EOL]       charArray0[2] = 'L'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder5.append(charArray0, 1898, 1898); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // Invalid startIndex: 1898 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.stripToEmpty((String) null); [EOL]        [EOL]       int int0 = StringUtils.indexOf((CharSequence) null, (CharSequence) "", 114); [EOL]        [EOL]       int int1 = StringUtils.lastIndexOf((CharSequence) null, (-1)); [EOL]        [EOL]       int int2 = StringUtils.lastIndexOf((CharSequence) "", (CharSequence) null, 1124); [EOL]        [EOL]       String[] stringArray0 = StringUtils.split("\n", 'e'); [EOL]       assertEquals(1, stringArray0.length); [EOL]        [EOL]       String string1 = StringUtils.removeStart("", "}%"); [EOL]        [EOL]       String string2 = StringUtils.defaultIfBlank("", "3::s0DFSZzQA>V_CN"); [EOL]        [EOL]       String string3 = StringUtils.prependIfMissing("", (CharSequence) null, stringArray0); [EOL]       assertEquals(1, stringArray0.length); [EOL]        [EOL]       String string4 = StringUtils.rightPad(" is not in the range '0' - '9'", 1124, ""); [EOL]        [EOL]       boolean boolean0 = StringUtils.endsWithIgnoreCase("3::s0DFSZzQA>V_CN", string4); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitByWholeSeparator(string4, (String) null, (-1)); [EOL]       assertEquals(8, stringArray1.length); [EOL]        [EOL]       String string5 = StringUtils.right("", (-240)); [EOL]        [EOL]       String string6 = StringUtils.difference("", ""); [EOL]        [EOL]       boolean boolean1 = StringUtils.endsWithIgnoreCase(string4, ""); [EOL]        [EOL]       String string7 = StringUtils.reverse(" is not in the range '0' - '9'"); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = 'e'; [EOL]       charArray0[1] = 'e'; [EOL]       boolean boolean2 = StringUtils.containsOnly((CharSequence) "'9' - '0' egnar eht ni ton si ", charArray0); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       short[] shortArray0 = new short[8]; [EOL]       shortArray0[0] = (short) (-700); [EOL]       shortArray0[1] = (short)2431; [EOL]       shortArray0[2] = (short)336; [EOL]       shortArray0[0] = (short) (-1905); [EOL]       shortArray0[4] = (short)2; [EOL]       shortArray0[5] = (short)16; [EOL]       shortArray0[6] = (short)0; [EOL]       shortArray0[7] = (short) (-2743); [EOL]       String string8 = StringUtils.join(shortArray0, ')'); [EOL]       assertEquals(8, shortArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(6); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.ensureCapacity(6); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendNull(); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder2.size()); [EOL]        [EOL]       StrMatcher.TrimMatcher strMatcher_TrimMatcher0 = new StrMatcher.TrimMatcher(); [EOL]        [EOL]       int int0 = strBuilder2.indexOf((StrMatcher) strMatcher_TrimMatcher0); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder2.size()); [EOL]        [EOL]       ArrayDeque<Integer> arrayDeque0 = new ArrayDeque<Integer>((-1)); [EOL]       assertEquals(0, arrayDeque0.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendAll((Iterable<?>) arrayDeque0); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder2.size()); [EOL]       assertEquals(0, arrayDeque0.size()); [EOL]       assertEquals(0, strBuilder3.size()); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder("v@1?:{"); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         stringBuilder0.insert((-1), (CharSequence) strBuilder2, (-1), 6); [EOL]         fail("Expecting exception: IndexOutOfBoundsException"); [EOL]        [EOL]       } catch(IndexOutOfBoundsException e) { [EOL]          // [EOL]          // dstOffset -1 [EOL]          // [EOL]          verifyException("java.lang.AbstractStringBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPreemptSkippedAMContainers() { [EOL] int[][] qData = new int[][] { [EOL] // / A B [EOL] { 100, 10, 90 }, // abs [EOL] { 100, 100, 100 }, // maxcap [EOL] { 100, 100, 0 }, // used [EOL] { 70, 20, 90 }, // pending [EOL] { 0, 0, 0 }, // reserved [EOL] { 5, 4, 1 }, // apps [EOL] { -1, 5, 5 }, // req granularity [EOL] { 2, 0, 0 }, // subqueues [EOL] }; [EOL] setAMContainer = true; [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData); [EOL] policy.editSchedule(); [EOL] [EOL] // All 5 containers of appD will be preempted including AM container. [EOL] verify(mDisp, times(5)).handle(argThat(new IsPreemptionRequestFor(appD))); [EOL] [EOL] // All 5 containers of appC will be preempted including AM container. [EOL] verify(mDisp, times(5)).handle(argThat(new IsPreemptionRequestFor(appC))); [EOL] [EOL] // By skipping AM Container, all other 4 containers of appB will be [EOL] // preempted [EOL] verify(mDisp, times(4)).handle(argThat(new IsPreemptionRequestFor(appB))); [EOL] [EOL] // By skipping AM Container, all other 4 containers of appA will be [EOL] // preempted [EOL] verify(mDisp, times(4)).handle(argThat(new IsPreemptionRequestFor(appA))); [EOL] setAMContainer = false; [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test(timeout = 4000) [EOL]   public void testhandleCause()  throws Throwable  { [EOL]       ExecutionException executionException0 = new ExecutionException((Throwable) null); [EOL]       MockPrintStream mockPrintStream0 = new MockPrintStream("org.apache.commons.lang3.concurrent.BasicThreadFactory$Builder"); [EOL]       executionException0.printStackTrace((PrintStream) mockPrintStream0); [EOL]       ConcurrentUtils.handleCauseUnchecked(executionException0); [EOL]       assertNull(executionException0.getMessage()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(8); [EOL]        [EOL]       StringBuilder stringBuilder0 = new StringBuilder(strBuilder0); [EOL]       assertEquals("", stringBuilder0.toString()); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]       assertEquals("", stringBuffer0.toString()); [EOL]        [EOL]       StringBuilder stringBuilder1 = stringBuilder0.append(stringBuffer0); [EOL]       assertEquals("", stringBuilder0.toString()); [EOL]       assertEquals("", stringBuffer0.toString()); [EOL]       assertEquals("", stringBuilder1.toString()); [EOL]        [EOL]       StringBuilder stringBuilder2 = stringBuilder1.insert(0, 3482.0); [EOL]       assertEquals("3482.0", stringBuilder0.toString()); [EOL]       assertEquals("", stringBuffer0.toString()); [EOL]       assertEquals("3482.0", stringBuilder1.toString()); [EOL]       assertEquals("3482.0", stringBuilder2.toString()); [EOL]        [EOL]       StringBuilder stringBuilder3 = stringBuilder2.append(5L); [EOL]       assertEquals("3482.05", stringBuilder0.toString()); [EOL]       assertEquals("", stringBuffer0.toString()); [EOL]       assertEquals("3482.05", stringBuilder1.toString()); [EOL]       assertEquals("3482.05", stringBuilder2.toString()); [EOL]       assertEquals("3482.05", stringBuilder3.toString()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(stringBuilder3); [EOL]       assertEquals("3482.05", stringBuilder0.toString()); [EOL]       assertEquals("", stringBuffer0.toString()); [EOL]       assertEquals("3482.05", stringBuilder1.toString()); [EOL]       assertEquals("3482.05", stringBuilder2.toString()); [EOL]       assertEquals("3482.05", stringBuilder3.toString()); [EOL]        [EOL]       int int0 = strBuilder0.size(); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetStart()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.isNotIn('j', 'y'); [EOL]       boolean boolean0 = charRange0.contains('j'); [EOL]       assertEquals('j', charRange0.getStart()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testnullToEmpty()  throws Throwable  { [EOL]       Byte[] byteArray0 = new Byte[0]; [EOL]       Byte[] byteArray1 = ArrayUtils.nullToEmpty(byteArray0); [EOL]       assertNotSame(byteArray1, byteArray0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMultipleChannels() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(CONFNAME, "*,*,/allowed"); [EOL] HostRestrictingAuthorizationFilter filter = [EOL] HostRestrictingAuthorizationFilterHandler.initializeState(conf); [EOL] EmbeddedChannel channel1 = new CustomEmbeddedChannel("127.0.0.1", 1006, [EOL] new HostRestrictingAuthorizationFilterHandler(filter)); [EOL] EmbeddedChannel channel2 = new CustomEmbeddedChannel("127.0.0.2", 1006, [EOL] new HostRestrictingAuthorizationFilterHandler(filter)); [EOL] EmbeddedChannel channel3 = new CustomEmbeddedChannel("127.0.0.3", 1006, [EOL] new HostRestrictingAuthorizationFilterHandler(filter)); [EOL] FullHttpRequest allowedHttpRequest = [EOL] new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, [EOL] HttpMethod.GET, [EOL] WebHdfsFileSystem.PATH_PREFIX + "/allowed/file_one?op=OPEN"); [EOL] FullHttpRequest allowedHttpRequest2 = [EOL] new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, [EOL] HttpMethod.GET, [EOL] WebHdfsFileSystem.PATH_PREFIX + "/allowed/file_two?op=OPEN"); [EOL] FullHttpRequest allowedHttpRequest3 = [EOL] new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, [EOL] HttpMethod.GET, [EOL] WebHdfsFileSystem.PATH_PREFIX + "/allowed/file_three?op=OPEN"); [EOL] assertTrue("Should successfully accept request", [EOL] channel1.writeInbound(allowedHttpRequest)); [EOL] assertTrue("Should successfully accept request, second time", [EOL] channel2.writeInbound(allowedHttpRequest2)); [EOL] [EOL] // verify closing one channel does not affect remaining channels [EOL] channel1.close(); [EOL] assertTrue("Should successfully accept request, third time", [EOL] channel3.writeInbound(allowedHttpRequest3)); [EOL] } [EOL] final static String CONFNAME = [EOL] HostRestrictingAuthorizationFilter.HDFS_CONFIG_PREFIX + [EOL] HostRestrictingAuthorizationFilter.RESTRICTION_CONFIG; [EOL]
@Test [EOL] public void testAccessRemoteNodeLabelManager() throws Exception { [EOL] String[] args = [EOL] { "-addToClusterNodeLabels", "x,y" }; [EOL] assertEquals(0, rmAdminCLI.run(args)); [EOL] [EOL] // localNodeLabelsManager shouldn't accessed [EOL] assertTrue(dummyNodeLabelsManager.getClusterNodeLabelNames().isEmpty()); [EOL] [EOL] // remote node labels manager accessed [EOL] assertTrue(remoteAdminServiceAccessed); [EOL] } [EOL] private ResourceManagerAdministrationProtocol admin; [EOL] private HAServiceProtocol haadmin; [EOL] private RMAdminCLI rmAdminCLI; [EOL] private RMAdminCLI rmAdminCLIWithHAEnabled; [EOL] private CommonNodeLabelsManager dummyNodeLabelsManager; [EOL] private boolean remoteAdminServiceAccessed = false; [EOL] private static final String HOST_A = "1.2.3.1"; [EOL] private static final String HOST_B = "1.2.3.2"; [EOL] private static File dest; [EOL]
@Test [EOL] public void testClear() throws Exception { [EOL] // Test lengths on an empty text object [EOL] Text text = new Text(); [EOL] assertEquals( [EOL] "Actual string on an empty text object must be an empty string", [EOL] "", text.toString()); [EOL] assertEquals("Underlying byte array length must be zero", [EOL] 0, text.getBytes().length); [EOL] assertEquals("String's length must be zero", [EOL] 0, text.getLength()); [EOL] assertEquals("String's text length must be zero", [EOL] 0, text.getTextLength()); [EOL] [EOL] // Test if clear works as intended [EOL] text = new Text("abcd\u20acbdcd\u20ac"); [EOL] int len = text.getLength(); [EOL] text.clear(); [EOL] assertEquals("String must be empty after clear()", [EOL] "", text.toString()); [EOL] assertTrue( [EOL] "Length of the byte array must not decrease after clear()", [EOL] text.getBytes().length >= len); [EOL] assertEquals("Length of the string must be reset to 0 after clear()", [EOL] 0, text.getLength()); [EOL] assertEquals("Text length of the string must be reset to 0 after clear()", [EOL] 0, text.getTextLength()); [EOL] } [EOL] private static final int NUM_ITERATIONS = 100; [EOL] private static final Random RANDOM = new Random(1); [EOL] private static final int RAND_LEN = -1; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmptyTokenAsNull()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(""); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.reset((String) null); [EOL]       assertFalse(strTokenizer1.isEmptyTokenAsNull()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testOutputPathValidity() throws Exception { [EOL] final String inputPathStr = inputPath.toUri().getPath(); [EOL] final URI uri = fs.getUri(); [EOL] final String harName = "foo.har"; [EOL] System.setProperty(HadoopArchives.TEST_HADOOP_ARCHIVES_JAR_PATH, [EOL] HADOOP_ARCHIVES_JAR); [EOL] final HadoopArchives har = new HadoopArchives(conf); [EOL] [EOL] PrintStream stderr = System.err; [EOL] ByteArrayOutputStream byteStream = new ByteArrayOutputStream(); [EOL] PrintStream newErr = new PrintStream(byteStream); [EOL] System.setErr(newErr); [EOL] [EOL] // fail if the archive path already exists [EOL] createFile(archivePath, fs, harName); [EOL] final String[] args = { "-archiveName", harName, "-p", inputPathStr, "*", [EOL] archivePath.toString() }; [EOL] Assert.assertEquals(-1, ToolRunner.run(har, args)); [EOL] String output = byteStream.toString(); [EOL] final Path outputPath = new Path(archivePath, harName); [EOL] Assert.assertTrue(output.indexOf("Archive path: " + outputPath.toString() [EOL] + " already exists") != -1); [EOL] [EOL] byteStream.reset(); [EOL] [EOL] // fail if the destination directory is a file [EOL] createFile(archivePath, fs, "sub1"); [EOL] final Path archivePath2 = new Path(archivePath, "sub1"); [EOL] final String[] args2 = { "-archiveName", harName, "-p", inputPathStr, "*", [EOL] archivePath2.toString() }; [EOL] Assert.assertEquals(-1, ToolRunner.run(har, args2)); [EOL] output = byteStream.toString(); [EOL] Assert.assertTrue(output.indexOf("Destination " + archivePath2.toString() [EOL] + " should be a directory but is a file") != -1); [EOL] [EOL] System.setErr(stderr); [EOL] } [EOL] public static final String HADOOP_ARCHIVES_JAR = JarFinder [EOL] .getJar(HadoopArchives.class); [EOL] private static final String inputDir = "input"; [EOL] private Path inputPath; [EOL] private Path archivePath; [EOL] private final List<String> fileList = new ArrayList<String>(); [EOL] private MiniDFSCluster dfscluster; [EOL] private Configuration conf; [EOL] private FileSystem fs; [EOL]
@Test [EOL] public void testCreateHardLinkMult() throws IOException { [EOL] //hardlink a whole list of three files at once [EOL] String[] fileNames = src.list(); [EOL] createHardLinkMult(src, fileNames, tgt_mult); [EOL] [EOL] //validate by link count - each file has been linked once, [EOL] //so each count is "2" [EOL] assertEquals(2, getLinkCount(x1)); [EOL] assertEquals(2, getLinkCount(x2)); [EOL] assertEquals(2, getLinkCount(x3)); [EOL] assertEquals(2, getLinkCount(x1_mult)); [EOL] assertEquals(2, getLinkCount(x2_mult)); [EOL] assertEquals(2, getLinkCount(x3_mult)); [EOL] [EOL] //validate by contents [EOL] validateTgtMult(); [EOL] [EOL] //validate that change of content is reflected in the other linked files [EOL] appendToFile(x1_mult, str3); [EOL] assertTrue(fetchFileContents(x1_mult).equals(str1 + str3)); [EOL] assertTrue(fetchFileContents(x1).equals(str1 + str3)); [EOL] } [EOL] final static private File TEST_DIR = GenericTestUtils.getTestDir("test/hl"); [EOL] private static String DIR = "dir_"; [EOL] private static File src = new File(TEST_DIR, DIR + "src"); [EOL] private static File tgt_mult = new File(TEST_DIR, DIR + "tgt_mult"); [EOL] private static File tgt_one = new File(TEST_DIR, DIR + "tgt_one"); [EOL] private static File x1 = new File(src, "x1"); [EOL] private static File x2 = new File(src, "x2"); [EOL] private static File x3 = new File(src, "x3"); [EOL] private static File x1_one = new File(tgt_one, "x1"); [EOL] private static File y_one = new File(tgt_one, "y"); [EOL] private static File x3_one = new File(tgt_one, "x3"); [EOL] private static File x11_one = new File(tgt_one, "x11"); [EOL] private static File x1_mult = new File(tgt_mult, "x1"); [EOL] private static File x2_mult = new File(tgt_mult, "x2"); [EOL] private static File x3_mult = new File(tgt_mult, "x3"); [EOL] private static String str1 = "11111"; [EOL] private static String str2 = "22222"; [EOL] private static String str3 = "33333"; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       String string0 = "org.apache.commons.lang3.text.StrBuilder$StrBuilderReader"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("org.apache.commons.lang3.text.StrBuilder$StrBuilderReader"); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char char0 = '\"'; [EOL]       strBuilder0.size = (-914); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendSeparator('\"', 'p'); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGlobalAppConstraints() [EOL] throws InvalidAllocationTagsQueryException { [EOL] AllocationTagsManager tm = new AllocationTagsManager(rmContext); [EOL] PlacementConstraintManagerService pcm = [EOL] new MemoryPlacementConstraintManager(); [EOL] rmContext.setAllocationTagsManager(tm); [EOL] rmContext.setPlacementConstraintManager(pcm); [EOL] [EOL] long ts = System.currentTimeMillis(); [EOL] ApplicationId application1 = BuilderUtils.newApplicationId(ts, 100); [EOL] ApplicationId application2 = BuilderUtils.newApplicationId(ts, 101); [EOL] ApplicationId application3 = BuilderUtils.newApplicationId(ts, 102); [EOL] [EOL] // Register App1 with anti-affinity constraint map. [EOL] RMNode n0r1 = rmNodes.get(0); [EOL] RMNode n1r1 = rmNodes.get(1); [EOL] RMNode n2r2 = rmNodes.get(2); [EOL] RMNode n3r2 = rmNodes.get(3); [EOL] [EOL] /** [EOL] * Place container: [EOL] * n0: app1/A(1), app2/A(1) [EOL] * n1: app3/A(3) [EOL] * n2: app1/A(2) [EOL] * n3: "" [EOL] */ [EOL] tm.addContainer(n0r1.getNodeID(), [EOL] newContainerId(application1, 0), ImmutableSet.of("A")); [EOL] tm.addContainer(n0r1.getNodeID(), [EOL] newContainerId(application2, 1), ImmutableSet.of("A")); [EOL] tm.addContainer(n1r1.getNodeID(), [EOL] newContainerId(application3, 2), ImmutableSet.of("A")); [EOL] tm.addContainer(n1r1.getNodeID(), [EOL] newContainerId(application3, 3), ImmutableSet.of("A")); [EOL] tm.addContainer(n1r1.getNodeID(), [EOL] newContainerId(application3, 4), ImmutableSet.of("A")); [EOL] tm.addContainer(n2r2.getNodeID(), [EOL] newContainerId(application1, 5), ImmutableSet.of("A")); [EOL] tm.addContainer(n2r2.getNodeID(), [EOL] newContainerId(application1, 6), ImmutableSet.of("A")); [EOL] [EOL] SchedulerNode schedulerNode0 = newSchedulerNode(n0r1.getHostName(), [EOL] n0r1.getRackName(), n0r1.getNodeID()); [EOL] SchedulerNode schedulerNode1 = newSchedulerNode(n1r1.getHostName(), [EOL] n1r1.getRackName(), n1r1.getNodeID()); [EOL] SchedulerNode schedulerNode2 = newSchedulerNode(n2r2.getHostName(), [EOL] n2r2.getRackName(), n2r2.getNodeID()); [EOL] SchedulerNode schedulerNode3 = newSchedulerNode(n3r2.getHostName(), [EOL] n3r2.getRackName(), n3r2.getNodeID()); [EOL] [EOL] TargetApplicationsNamespace namespaceAll = [EOL] new TargetApplicationsNamespace.All(); [EOL] [EOL] //*************************** [EOL] // 1) all, anti-affinity [EOL] //*************************** [EOL] // Anti-affinity with "A" from any application including itself. [EOL] PlacementConstraint constraint1 = PlacementConstraints.targetNotIn( [EOL] NODE, allocationTagWithNamespace(namespaceAll.toString(), "A")) [EOL] .build(); [EOL] Map<Set<String>, PlacementConstraint> constraintMap = new HashMap<>(); [EOL] Set<String> srcTags1 = ImmutableSet.of("A"); [EOL] constraintMap.put(srcTags1, constraint1); [EOL] pcm.registerApplication(application1, constraintMap); [EOL] [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application1, createSchedulingRequest(srcTags1), [EOL] schedulerNode0, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application1, createSchedulingRequest(srcTags1), [EOL] schedulerNode1, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application1, createSchedulingRequest(srcTags1), [EOL] schedulerNode2, pcm, tm)); [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application1, createSchedulingRequest(srcTags1), [EOL] schedulerNode3, pcm, tm)); [EOL] [EOL] pcm.unregisterApplication(application1); [EOL] [EOL] //*************************** [EOL] // 2) all, max cardinality [EOL] //*************************** [EOL] PlacementConstraint constraint2 = PlacementConstraints [EOL] .maxCardinality(NODE, namespaceAll.toString(), 2, "A") [EOL] .build(); [EOL] constraintMap.clear(); [EOL] Set<String> srcTags2 = ImmutableSet.of("foo"); [EOL] constraintMap.put(srcTags2, constraint2); [EOL] pcm.registerApplication(application2, constraintMap); [EOL] [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application2, createSchedulingRequest(srcTags2), [EOL] schedulerNode0, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application2, createSchedulingRequest(srcTags2), [EOL] schedulerNode1, pcm, tm)); [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application2, createSchedulingRequest(srcTags2), [EOL] schedulerNode2, pcm, tm)); [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application2, createSchedulingRequest(srcTags2), [EOL] schedulerNode3, pcm, tm)); [EOL] [EOL] pcm.unregisterApplication(application2); [EOL] [EOL] //*************************** [EOL] // 3) all, min cardinality [EOL] //*************************** [EOL] PlacementConstraint constraint3 = PlacementConstraints [EOL] .minCardinality(NODE, namespaceAll.toString(), 3, "A") [EOL] .build(); [EOL] constraintMap.clear(); [EOL] Set<String> srcTags3 = ImmutableSet.of("foo"); [EOL] constraintMap.put(srcTags3, constraint3); [EOL] pcm.registerApplication(application3, constraintMap); [EOL] [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application3, createSchedulingRequest(srcTags3), [EOL] schedulerNode0, pcm, tm)); [EOL] Assert.assertTrue(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application3, createSchedulingRequest(srcTags3), [EOL] schedulerNode1, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application3, createSchedulingRequest(srcTags3), [EOL] schedulerNode2, pcm, tm)); [EOL] Assert.assertFalse(PlacementConstraintsUtil.canSatisfyConstraints( [EOL] application3, createSchedulingRequest(srcTags3), [EOL] schedulerNode3, pcm, tm)); [EOL] [EOL] pcm.unregisterApplication(application3); [EOL] } [EOL] private List<RMNode> rmNodes; [EOL] private RMContext rmContext; [EOL] private static final int GB = 1024; [EOL] private ApplicationId appId1; [EOL] private PlacementConstraint c1, c2, c3, c4, c5, c6, c7; [EOL] private Set<String> sourceTag1, sourceTag2; [EOL] private Map<Set<String>, PlacementConstraint> constraintMap1, [EOL] constraintMap2, constraintMap3, constraintMap4; [EOL] private AtomicLong requestID = new AtomicLong(0); [EOL]
@Test(expected = WebApplicationException.class) [EOL] public void testgetDetailJSONNULL() { [EOL] System.out.println("testgetDetailJSONNULL"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] UriContainer expResult = null; [EOL] Object output = instance.getDetailJSON(null, null, null, null); [EOL] Assert.assertNotNull(output); [EOL] //Assert.assertFalse(serviceListXML.getTModelKey().isEmpty()); [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test [EOL] public void testInit() throws Exception { [EOL] Assert.assertEquals(KerberosTestUtils.getKeytabFile(), handler.getKeytab()); [EOL] Set<KerberosPrincipal> principals = handler.getPrincipals(); [EOL] Principal expectedPrincipal = [EOL] new KerberosPrincipal(KerberosTestUtils.getServerPrincipal()); [EOL] Assert.assertTrue(principals.contains(expectedPrincipal)); [EOL] Assert.assertEquals(1, principals.size()); [EOL] } [EOL] @Rule [EOL] public Timeout globalTimeout = Timeout.millis(60000); [EOL] protected KerberosAuthenticationHandler handler; [EOL]
@Test(timeout = 4000) [EOL]   public void testinitialize()  throws Throwable  { [EOL]       ForkJoinPool forkJoinPool0 = ForkJoinPool.commonPool(); [EOL]       MultiBackgroundInitializer multiBackgroundInitializer0 = new MultiBackgroundInitializer(forkJoinPool0); [EOL]       MultiBackgroundInitializer.MultiBackgroundInitializerResults multiBackgroundInitializer_MultiBackgroundInitializerResults0 = multiBackgroundInitializer0.initialize(); [EOL]       Set<String> set0 = multiBackgroundInitializer_MultiBackgroundInitializerResults0.initializerNames(); [EOL]       assertTrue(set0.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalStateException.class) [EOL] public void testFinishRefreshWithoutLazyRefresh() throws IOException { [EOL] FileWriter efw = new FileWriter(excludesFile); [EOL] FileWriter ifw = new FileWriter(includesFile); [EOL] efw.close(); [EOL] ifw.close(); [EOL] [EOL] HostsFileReader hfp = new HostsFileReader(includesFile, excludesFile); [EOL] hfp.finishRefresh(); [EOL] } [EOL] final String HOSTS_TEST_DIR = GenericTestUtils.getTestDir().getAbsolutePath(); [EOL] File EXCLUDES_FILE = new File(HOSTS_TEST_DIR, "dfs.exclude"); [EOL] File INCLUDES_FILE = new File(HOSTS_TEST_DIR, "dfs.include"); [EOL] String excludesFile = HOSTS_TEST_DIR + "/dfs.exclude"; [EOL] String includesFile = HOSTS_TEST_DIR + "/dfs.include"; [EOL] private String excludesXmlFile = HOSTS_TEST_DIR + "/dfs.exclude.xml"; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char char0 = 'j'; [EOL]       Iterable<Object> iterable0 = null; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterable<?>) null, "b0}RRkoCl[.="); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       int int0 = strBuilder0.indexOf('j', 815); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char char1 = '8'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendSeparator('j', '8'); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       int int1 = 516; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.insert(516, false); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 516 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetMountsOfConsecutiveSlashes() throws IOException { [EOL] // Check listing the mount table records at or beneath a path [EOL] List<MountTable> records = mountTable.getMounts("///"); [EOL] assertEquals(10, records.size()); [EOL] compareRecords(records, new String[] {"/", "/tmp", "/user", "/usr/bin", [EOL] "user/a", "/user/a/demo/a", "/user/a/demo/b", "/user/b/file1.txt", [EOL] "readonly", "multi"}); [EOL] [EOL] records = mountTable.getMounts("/user///"); [EOL] assertEquals(5, records.size()); [EOL] compareRecords(records, new String[] {"/user", "/user/a/demo/a", [EOL] "/user/a/demo/b", "user/a", "/user/b/file1.txt"}); [EOL] [EOL] records = mountTable.getMounts("///user///a"); [EOL] assertEquals(3, records.size()); [EOL] compareRecords(records, [EOL] new String[] {"/user/a/demo/a", "/user/a/demo/b", "/user/a"}); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestMountTableResolver.class); [EOL] private static final int TEST_MAX_CACHE_SIZE = 10; [EOL] private MountTableResolver mountTable; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(79); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(0.0F); [EOL]       assertEquals(3, strBuilder0.length()); [EOL]       assertEquals(3, strBuilder1.length()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.append((double) 79); [EOL]       assertEquals(7, strBuilder0.length()); [EOL]       assertEquals(7, strBuilder2.length()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendln((-2267)); [EOL]       assertEquals(13, strBuilder0.length()); [EOL]       assertEquals(13, strBuilder3.length()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendln((Object) strBuilder3); [EOL]       assertEquals(65, strBuilder0.length()); [EOL]       assertEquals(65, strBuilder1.length()); [EOL]       assertEquals(65, strBuilder3.length()); [EOL]       assertEquals(65, strBuilder4.length()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder2.clear(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder2.length()); [EOL]       assertEquals(0, strBuilder5.length()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.deleteAll('#'); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder1.length()); [EOL]       assertEquals(0, strBuilder3.length()); [EOL]       assertEquals(0, strBuilder4.length()); [EOL]       assertEquals(0, strBuilder6.length()); [EOL]        [EOL]       StringBuilder stringBuilder0 = strBuilder1.toStringBuilder(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder1.length()); [EOL]        [EOL]       int int0 = 2; [EOL]       StrBuilder strBuilder7 = strBuilder0.append((CharSequence) strBuilder1); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder1.length()); [EOL]       assertEquals(0, strBuilder7.length()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder0.replaceAll("nCIF=^XRVL:\t%AH&", "end < start"); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]       assertEquals(0, strBuilder8.length()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder2.append((CharSequence) stringBuilder0, 2, (-211)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testConvertAllocationsToReservationInfoEmptyAllocations() { [EOL] long startTime = new Date().getTime(); [EOL] long step = 10000; [EOL] int[] alloc = {}; [EOL] ReservationId id = ReservationSystemTestUtil.getNewReservationId(); [EOL] ReservationAllocation allocation = createReservationAllocation( [EOL] startTime, startTime + 10 * step, step, alloc, id, [EOL] createResource(4000, 2)); [EOL] [EOL] List<ReservationAllocationState> infoList = ReservationSystemUtil [EOL] .convertAllocationsToReservationInfo( [EOL] Collections.singleton(allocation), false); [EOL] [EOL] Assert.assertEquals(infoList.size(), 1); [EOL] Assert.assertEquals(infoList.get(0).getReservationId().toString(), [EOL] id.toString()); [EOL] Assert.assertTrue(infoList.get(0).getResourceAllocationRequests() [EOL] .isEmpty()); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseClassName()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SHORT_PREFIX_STYLE.setSummaryObjectEndText("Windows 9"); [EOL]       assertTrue(standardToStringStyle0.isUseClassName()); [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalStateException.class) [EOL] public void testImmutablesCanOnlySetOnceFromArray() { [EOL] VariableContext variables = new VariableContext(); [EOL] [EOL] variables.setImmutables("%user", "%primary_group", "%secondary_group"); [EOL] variables.setImmutables("%user", "%primary_group", "%secondary_group"); [EOL] } [EOL]
@Test [EOL] public void testRequestInterceptorChainCreation() throws Exception { [EOL] RequestInterceptor root = [EOL] super.getAMRMProxyService().createRequestInterceptorChain(); [EOL] int index = 0; [EOL] while (root != null) { [EOL] switch (index) { [EOL] case 0: [EOL] case 1: [EOL] case 2: [EOL] Assert.assertEquals(PassThroughRequestInterceptor.class.getName(), [EOL] root.getClass().getName()); [EOL] break; [EOL] case 3: [EOL] Assert.assertEquals(MockRequestInterceptor.class.getName(), root [EOL] .getClass().getName()); [EOL] break; [EOL] } [EOL] [EOL] root = root.getNextInterceptor(); [EOL] index++; [EOL] } [EOL] [EOL] Assert.assertEquals( [EOL] "The number of interceptors in chain does not match", [EOL] Integer.toString(4), Integer.toString(index)); [EOL] [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestAMRMProxyService.class); [EOL] private static MockResourceManagerFacade mockRM; [EOL]
@Test [EOL] public void testNodeRegistrationFailure() throws Exception { [EOL] writeToHostsFile("host1"); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, hostFile [EOL] .getAbsolutePath()); [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] [EOL] ResourceTrackerService resourceTrackerService = rm.getResourceTrackerService(); [EOL] RegisterNodeManagerRequest req = Records.newRecord( [EOL] RegisterNodeManagerRequest.class); [EOL] NodeId nodeId = NodeId.newInstance("host2", 1234); [EOL] req.setNodeId(nodeId); [EOL] req.setHttpPort(1234); [EOL] // trying to register a invalid node. [EOL] RegisterNodeManagerResponse response = resourceTrackerService.registerNodeManager(req); [EOL] Assert.assertEquals(NodeAction.SHUTDOWN,response.getNodeAction()); [EOL] Assert [EOL] .assertEquals( [EOL] "Disallowed NodeManager from host2, Sending SHUTDOWN signal to the NodeManager.", [EOL] response.getDiagnosticsMessage()); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StringBuffer stringBuffer0 = strBuilder0.toStringBuffer(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       StringBuffer stringBuffer1 = stringBuffer0.reverse(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteAll((StrMatcher) strMatcher_NoMatcher0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       charArray0[0] = '3'; [EOL]       StrBuilder strBuilder2 = strBuilder0.append(3986.49F); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendWithSeparators((Object[]) null, "rXB\u0003WVlNWF<}"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       boolean boolean0 = strBuilder3.contains((StrMatcher) strMatcher_NoMatcher0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append(""); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       IntStream intStream0 = strBuilder2.codePoints(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder2.appendln(stringBuffer0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.append(5305); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.appendln('3'); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder7.isEmpty()); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf((StrMatcher) strMatcher_NoMatcher0, (-2104)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder7.appendln(""); [EOL]       assertFalse(strBuilder8.isEmpty()); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder7.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testBootstrap() throws Exception { [EOL] Configuration conf = new YarnConfiguration(); [EOL] List<PrivilegedOperation> ret = [EOL] cGroupsBlkioResourceHandlerImpl.bootstrap(conf); [EOL] verify(mockCGroupsHandler, times(1)).initializeCGroupController( [EOL] CGroupsHandler.CGroupController.BLKIO); [EOL] Assert.assertNull(ret); [EOL] } [EOL] private CGroupsHandler mockCGroupsHandler; [EOL] private CGroupsBlkioResourceHandlerImpl cGroupsBlkioResourceHandlerImpl; [EOL]
@Test [EOL] public void testUnhealthyNodeStatus() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, hostFile [EOL] .getAbsolutePath()); [EOL] [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] [EOL] MockNM nm1 = rm.registerNode("host1:1234", 5120); [EOL] Assert.assertEquals(0, ClusterMetrics.getMetrics().getUnhealthyNMs()); [EOL] // node healthy [EOL] nm1.nodeHeartbeat(true); [EOL] [EOL] // node unhealthy [EOL] nm1.nodeHeartbeat(false); [EOL] checkUnhealthyNMCount(rm, nm1, true, 1); [EOL] [EOL] // node healthy again [EOL] nm1.nodeHeartbeat(true); [EOL] checkUnhealthyNMCount(rm, nm1, false, 0); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testdoubleValue()  throws Throwable  { [EOL]       MutableShort mutableShort0 = new MutableShort((short)0); [EOL]       mutableShort0.increment(); [EOL]       short short0 = mutableShort0.shortValue(); [EOL]       assertEquals(1.0, mutableShort0.doubleValue(), 0.01); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("%.uP-XC6m9"); [EOL]       assertEquals(10, strBuilder0.size()); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer(strBuilder0); [EOL]       assertEquals(10, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(stringBuffer0); [EOL]       assertEquals(21, strBuilder0.size()); [EOL]       assertEquals(21, strBuilder1.size()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testConvertDeletionTaskToProto() throws Exception { [EOL] DeletionServiceDeleteTaskProto proto = [EOL] deletionTask.convertDeletionTaskToProto(); [EOL] assertEquals(ID, proto.getId()); [EOL] assertEquals(USER, proto.getUser()); [EOL] assertEquals(SUBDIR, new Path(proto.getSubdir())); [EOL] assertEquals(BASEDIR, new Path(proto.getBasedirs(0))); [EOL] assertEquals(1, proto.getBasedirsCount()); [EOL] } [EOL] private static final int ID = 0; [EOL] private static final String USER = "user"; [EOL] private static final Path SUBDIR = new Path("subdir"); [EOL] private static final Path BASEDIR = new Path("basedir"); [EOL] private List<Path> baseDirs = new ArrayList<>(); [EOL] private DeletionService deletionService; [EOL] private FileDeletionTask deletionTask; [EOL]
@Test [EOL] public void mergeAll() { [EOL] Credentials creds = new Credentials(); [EOL] creds.addToken(service[0], token[0]); [EOL] creds.addToken(service[1], token[1]); [EOL] creds.addSecretKey(secret[0], secret[0].getBytes()); [EOL] creds.addSecretKey(secret[1], secret[1].getBytes()); [EOL] [EOL] Credentials credsToAdd = new Credentials(); [EOL] // one duplicate with different value, one new [EOL] credsToAdd.addToken(service[0], token[3]); [EOL] credsToAdd.addToken(service[2], token[2]); [EOL] credsToAdd.addSecretKey(secret[0], secret[3].getBytes()); [EOL] credsToAdd.addSecretKey(secret[2], secret[2].getBytes()); [EOL] [EOL] creds.mergeAll(credsToAdd); [EOL] assertEquals(3, creds.numberOfTokens()); [EOL] assertEquals(3, creds.numberOfSecretKeys()); [EOL] // existing token & secret should not be overwritten [EOL] assertEquals(token[0], creds.getToken(service[0])); [EOL] assertEquals(secret[0], new Text(creds.getSecretKey(secret[0]))); [EOL] // non-duplicate token & secret should be present [EOL] assertEquals(token[1], creds.getToken(service[1])); [EOL] assertEquals(secret[1], new Text(creds.getSecretKey(secret[1]))); [EOL] // new token & secret should be added [EOL] assertEquals(token[2], creds.getToken(service[2])); [EOL] assertEquals(secret[2], new Text(creds.getSecretKey(secret[2]))); [EOL] } [EOL] private static final String DEFAULT_HMAC_ALGORITHM = "HmacSHA1"; [EOL] private static final File tmpDir = GenericTestUtils.getTestDir("mapred"); [EOL] static Text secret[] = { [EOL] new Text("secret1"), [EOL] new Text("secret2"), [EOL] new Text("secret3"), [EOL] new Text("secret4") [EOL] }; [EOL] static Text service[] = { [EOL] new Text("service1"), [EOL] new Text("service2"), [EOL] new Text("service3"), [EOL] new Text("service4") [EOL] }; [EOL] static Token<?> token[] = { [EOL] new Token<TokenIdentifier>(), [EOL] new Token<TokenIdentifier>(), [EOL] new Token<TokenIdentifier>(), [EOL] new Token<TokenIdentifier>() [EOL] }; [EOL]
@Test(timeout = 4000) [EOL]   public void testcompareTo()  throws Throwable  { [EOL]       Integer integer0 = new Integer(0); [EOL]       MutablePair<AbstractMap.SimpleImmutableEntry<String, String>, ImmutablePair<Integer, Integer>> mutablePair0 = new MutablePair<AbstractMap.SimpleImmutableEntry<String, String>, ImmutablePair<Integer, Integer>>(); [EOL]       AbstractMap.SimpleImmutableEntry<String, String> abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<String, String>("", ""); [EOL]       ImmutablePair<Integer, Integer> immutablePair0 = new ImmutablePair<Integer, Integer>(integer0, integer0); [EOL]       MutablePair<AbstractMap.SimpleImmutableEntry<String, String>, ImmutablePair<Integer, Integer>> mutablePair1 = MutablePair.of(abstractMap_SimpleImmutableEntry0, immutablePair0); [EOL]       int int0 = mutablePair0.compareTo((Pair<AbstractMap.SimpleImmutableEntry<String, String>, ImmutablePair<Integer, Integer>>) mutablePair1); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAuthLocalJceks() throws Exception { [EOL] File localJceksFile = File.createTempFile( [EOL] getClass().getSimpleName() +".testAuthLocalJceks-", ".localjceks"); [EOL] populateLocalJceksTestFile(localJceksFile.getAbsolutePath()); [EOL] try { [EOL] String localJceksUri = "localjceks://file/" + [EOL] localJceksFile.getAbsolutePath(); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, [EOL] localJceksUri); [EOL] List<ZKAuthInfo> zkAuths = SecurityUtil.getZKAuthInfos(conf, [EOL] CommonConfigurationKeys.ZK_AUTH); [EOL] assertEquals(1, zkAuths.size()); [EOL] ZKAuthInfo zkAuthInfo = zkAuths.get(0); [EOL] assertEquals("a_scheme", zkAuthInfo.getScheme()); [EOL] assertArrayEquals("a_password".getBytes(), zkAuthInfo.getAuth()); [EOL] } finally { [EOL] boolean deleted = localJceksFile.delete(); [EOL] assertTrue(deleted); [EOL] } [EOL] } [EOL] private static final String ZK_AUTH_VALUE = "a_scheme:a_password"; [EOL]
@Test(timeout = 4000) [EOL]   public void testcontains()  throws Throwable  { [EOL]       String string0 = "\\p{InCombiningDiacriticalMarks}+"; [EOL]       Locale locale0 = Locale.TAIWAN; [EOL]        [EOL]       String string1 = locale0.getDisplayName(); [EOL]        [EOL]       String string2 = StringUtils.lowerCase("p{InCombiningDiacriticalMarks}+", locale0); [EOL]        [EOL]       Stack<Object> stack0 = new Stack<Object>(); [EOL]       assertFalse(stack0.contains("p{InCombiningDiacriticalMarks}+")); [EOL]        [EOL]       boolean boolean0 = stack0.add((Object) "p{InCombiningDiacriticalMarks}+"); [EOL]       assertTrue(stack0.contains("p{InCombiningDiacriticalMarks}+")); [EOL]        [EOL]       Iterator<Object> iterator0 = stack0.iterator(); [EOL]       assertTrue(stack0.contains("p{InCombiningDiacriticalMarks}+")); [EOL]        [EOL]       char char0 = '>'; [EOL]       String string3 = StringUtils.join(iterator0, '>'); [EOL]       assertFalse(stack0.contains('>')); [EOL]       assertTrue(stack0.contains("p{InCombiningDiacriticalMarks}+")); [EOL]        [EOL]       int[] intArray0 = new int[8]; [EOL]       intArray0[0] = (int) '>'; [EOL]       intArray0[1] = 2777; [EOL]       intArray0[2] = (int) '>'; [EOL]       intArray0[3] = (-1572); [EOL]       intArray0[4] = (int) '>'; [EOL]       intArray0[5] = (int) '>'; [EOL]       intArray0[6] = (int) '>'; [EOL]       intArray0[7] = (int) '>'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         StringUtils.join(intArray0, '>', (-1572), 62); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // -1572 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.StringUtils", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 5000) [EOL] public void testManyRuns() { [EOL] [EOL] QueueMetrics qm = [EOL] QueueMetrics.forQueue(metricsSystem, "root", null, false, conf); [EOL] qm.setAvailableResourcesToQueue(RMNodeLabelsManager.NO_LABEL, [EOL] Resource.newInstance(1, 1)); [EOL] [EOL] int numIterations = 1000; [EOL] long start = System.currentTimeMillis(); [EOL] for (int i = 0; i < numIterations; i++) { [EOL] ic.editSchedule(); [EOL] } [EOL] long end = System.currentTimeMillis(); [EOL] [EOL] System.out.println("Runtime per iteration (avg of " + numIterations [EOL] + " iterations): " + (end - start) + " tot time"); [EOL] [EOL] } [EOL] public final static Logger LOG = [EOL] Logger.getLogger(TestMetricsInvariantChecker.class); [EOL] private MetricsSystem metricsSystem; [EOL] private MetricsInvariantChecker ic; [EOL] private Configuration conf; [EOL]
@Test [EOL] public void testCreateStartupShutdownMessage() { [EOL] //pass null args and method must still return a string beginning with [EOL] // "STARTUP_MSG" [EOL] String msg = StringUtils.createStartupShutdownMessage( [EOL] this.getClass().getName(), "test.host", null); [EOL] assertTrue(msg.startsWith("STARTUP_MSG:")); [EOL] } [EOL] final private static String NULL_STR = null; [EOL] final private static String EMPTY_STR = ""; [EOL] final private static String STR_WO_SPECIAL_CHARS = "AB"; [EOL] final private static String STR_WITH_COMMA = "A,B"; [EOL] final private static String ESCAPED_STR_WITH_COMMA = "A\\,B"; [EOL] final private static String STR_WITH_ESCAPE = "AB\\"; [EOL] final private static String ESCAPED_STR_WITH_ESCAPE = "AB\\\\"; [EOL] final private static String STR_WITH_BOTH2 = ",A\\,,B\\\\,"; [EOL] final private static String ESCAPED_STR_WITH_BOTH2 = [EOL] "\\,A\\\\\\,\\,B\\\\\\\\\\,"; [EOL] final private static FastDateFormat FAST_DATE_FORMAT = [EOL] FastDateFormat.getInstance("d-MMM-yyyy HH:mm:ss"); [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseFieldNames()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.MULTI_LINE_STYLE.setUseIdentityHashCode(false); [EOL]       assertTrue(standardToStringStyle0.isUseFieldNames()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testListStatusNestedRecursive() throws IOException { [EOL] Configuration conf = new Configuration(); [EOL] conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS, numThreads); [EOL] [EOL] List<Path> expectedPaths = configureTestNestedRecursive(conf, localFs); [EOL] Job job = Job.getInstance(conf); [EOL] FileInputFormat<?, ?> fif = new TextInputFormat(); [EOL] List<FileStatus> statuses = fif.listStatus(job); [EOL] [EOL] verifyFileStatuses(expectedPaths, statuses, localFs); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFileInputFormat.class); [EOL] private static String testTmpDir = System.getProperty("test.build.data", "/tmp"); [EOL] private static final Path TEST_ROOT_DIR = new Path(testTmpDir, "TestFIF"); [EOL] private static FileSystem localFs; [EOL] private int numThreads; [EOL]
@Test [EOL] public void testNodeGroups() throws Exception { [EOL] assertEquals(3, cluster.getNumOfRacks()); [EOL] assertTrue(cluster.isOnSameNodeGroup(dataNodes[0], dataNodes[1])); [EOL] assertFalse(cluster.isOnSameNodeGroup(dataNodes[1], dataNodes[2])); [EOL] assertFalse(cluster.isOnSameNodeGroup(dataNodes[2], dataNodes[3])); [EOL] assertTrue(cluster.isOnSameNodeGroup(dataNodes[3], dataNodes[4])); [EOL] assertFalse(cluster.isOnSameNodeGroup(dataNodes[4], dataNodes[5])); [EOL] assertFalse(cluster.isOnSameNodeGroup(dataNodes[5], dataNodes[6])); [EOL] assertFalse(cluster.isOnSameNodeGroup(dataNodes[6], dataNodes[7])); [EOL] } [EOL] private final static NetworkTopologyWithNodeGroup cluster = new [EOL] NetworkTopologyWithNodeGroup(); [EOL] private final static NodeBase dataNodes[] = new NodeBase[] { [EOL] new NodeBase("h1", "/d1/r1/s1"), [EOL] new NodeBase("h2", "/d1/r1/s1"), [EOL] new NodeBase("h3", "/d1/r1/s2"), [EOL] new NodeBase("h4", "/d1/r2/s3"), [EOL] new NodeBase("h5", "/d1/r2/s3"), [EOL] new NodeBase("h6", "/d1/r2/s4"), [EOL] new NodeBase("h7", "/d2/r3/s5"), [EOL] new NodeBase("h8", "/d2/r3/s6") [EOL] }; [EOL] private final static NodeBase computeNode = new NodeBase("/d1/r1/s1/h9"); [EOL] private final static NodeBase rackOnlyNode = new NodeBase("h10", "/r2"); [EOL]
@Test (timeout = 30000) [EOL] public void testCreateJarWithClassPath() throws Exception { [EOL] // create files expected to match a wildcard [EOL] List<File> wildcardMatches = Arrays.asList(new File(tmp, "wildcard1.jar"), [EOL] new File(tmp, "wildcard2.jar"), new File(tmp, "wildcard3.JAR"), [EOL] new File(tmp, "wildcard4.JAR")); [EOL] for (File wildcardMatch: wildcardMatches) { [EOL] Assert.assertTrue("failure creating file: " + wildcardMatch, [EOL] wildcardMatch.createNewFile()); [EOL] } [EOL] [EOL] // create non-jar files, which we expect to not be included in the classpath [EOL] Assert.assertTrue(new File(tmp, "text.txt").createNewFile()); [EOL] Assert.assertTrue(new File(tmp, "executable.exe").createNewFile()); [EOL] Assert.assertTrue(new File(tmp, "README").createNewFile()); [EOL] [EOL] // create classpath jar [EOL] String wildcardPath = tmp.getCanonicalPath() + File.separator + "*"; [EOL] String nonExistentSubdir = tmp.getCanonicalPath() + Path.SEPARATOR + "subdir" [EOL] + Path.SEPARATOR; [EOL] List<String> classPaths = Arrays.asList("", "cp1.jar", "cp2.jar", wildcardPath, [EOL] "cp3.jar", nonExistentSubdir); [EOL] String inputClassPath = StringUtils.join(File.pathSeparator, classPaths); [EOL] String[] jarCp = FileUtil.createJarWithClassPath(inputClassPath + File.pathSeparator + "unexpandedwildcard/*", [EOL] new Path(tmp.getCanonicalPath()), System.getenv()); [EOL] String classPathJar = jarCp[0]; [EOL] assertNotEquals("Unexpanded wildcard was not placed in extra classpath", jarCp[1].indexOf("unexpanded"), -1); [EOL] [EOL] // verify classpath by reading manifest from jar file [EOL] JarFile jarFile = null; [EOL] try { [EOL] jarFile = new JarFile(classPathJar); [EOL] Manifest jarManifest = jarFile.getManifest(); [EOL] Assert.assertNotNull(jarManifest); [EOL] Attributes mainAttributes = jarManifest.getMainAttributes(); [EOL] Assert.assertNotNull(mainAttributes); [EOL] Assert.assertTrue(mainAttributes.containsKey(Attributes.Name.CLASS_PATH)); [EOL] String classPathAttr = mainAttributes.getValue(Attributes.Name.CLASS_PATH); [EOL] Assert.assertNotNull(classPathAttr); [EOL] List<String> expectedClassPaths = new ArrayList<String>(); [EOL] for (String classPath: classPaths) { [EOL] if (classPath.length() == 0) { [EOL] continue; [EOL] } [EOL] if (wildcardPath.equals(classPath)) { [EOL] // add wildcard matches [EOL] for (File wildcardMatch: wildcardMatches) { [EOL] expectedClassPaths.add(wildcardMatch.toURI().toURL() [EOL] .toExternalForm()); [EOL] } [EOL] } else { [EOL] File fileCp = null; [EOL] if(!new Path(classPath).isAbsolute()) { [EOL] fileCp = new File(tmp, classPath); [EOL] } [EOL] else { [EOL] fileCp = new File(classPath); [EOL] } [EOL] if (nonExistentSubdir.equals(classPath)) { [EOL] // expect to maintain trailing path separator if present in input, even [EOL] // if directory doesn't exist yet [EOL] expectedClassPaths.add(fileCp.toURI().toURL() [EOL] .toExternalForm() + Path.SEPARATOR); [EOL] } else { [EOL] expectedClassPaths.add(fileCp.toURI().toURL() [EOL] .toExternalForm()); [EOL] } [EOL] } [EOL] } [EOL] List<String> actualClassPaths = Arrays.asList(classPathAttr.split(" ")); [EOL] Collections.sort(expectedClassPaths); [EOL] Collections.sort(actualClassPaths); [EOL] Assert.assertEquals(expectedClassPaths, actualClassPaths); [EOL] } finally { [EOL] if (jarFile != null) { [EOL] try { [EOL] jarFile.close(); [EOL] } catch (IOException e) { [EOL] LOG.warn("exception closing jarFile: " + classPathJar, e); [EOL] } [EOL] } [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 4000) [EOL]   public void testisDigits()  throws Throwable  { [EOL]       boolean boolean0 = NumberUtils.isDigits((String) null); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testread()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.ready()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("D:qv{0F`Yb3&H^f*N2", 1); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]        [EOL]       String string0 = strBuilder4.leftString(1); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(true); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", 1); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder6.trim(); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetEntityDefaultView() throws Exception { [EOL] Client client = createClient(); [EOL] try { [EOL] URI uri = URI.create("http://localhost:" + serverPort + "/ws/v2/" + [EOL] "timeline/clusters/cluster1/apps/app1/entities/app/id_1"); [EOL] ClientResponse resp = getResponse(client, uri); [EOL] TimelineEntity entity = resp.getEntity(TimelineEntity.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] resp.getType().toString()); [EOL] assertNotNull(entity); [EOL] assertEquals("id_1", entity.getId()); [EOL] assertEquals("app", entity.getType()); [EOL] assertEquals((Long)1425016502000L, entity.getCreatedTime()); [EOL] // Default view i.e. when no fields are specified, entity contains only [EOL] // entity id, entity type and created time. [EOL] assertEquals(0, entity.getConfigs().size()); [EOL] assertEquals(0, entity.getMetrics().size()); [EOL] } finally { [EOL] client.destroy(); [EOL] } [EOL] } [EOL] private static final String ROOT_DIR = new File("target", [EOL] TestTimelineReaderWebServices.class.getSimpleName()).getAbsolutePath(); [EOL] private int serverPort; [EOL] private TimelineReaderServer server; [EOL]
@Test [EOL] public void testIterator() { [EOL] ChunkedArrayList<Integer> l = new ChunkedArrayList<Integer>(); [EOL] for (int i = 0; i < 30000; i++) { [EOL] l.add(i); [EOL] } [EOL] [EOL] int i = 0; [EOL] for (int fromList : l) { [EOL] assertEquals(i, fromList); [EOL] i++; [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testsetMonths()  throws Throwable  { [EOL]       MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, (-947), (-947), 0); [EOL]       Date date0 = DateUtils.truncate((Object) mockGregorianCalendar0, 0); [EOL]       Date date1 = DateUtils.setMonths(date0, 1); [EOL]       assertEquals("Mon Jan 01 00:00:00 GMT 4", date1.toString()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       double[] doubleArray0 = new double[4]; [EOL]       int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-297.21217)); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testExists() throws IOException { [EOL] System.out.println("pre-create test path"); [EOL] fs.mkdirs(new Path("test/registryTestNode")); [EOL] [EOL] System.out.println("Check for existing node"); [EOL] boolean exists = registry.exists("test/registryTestNode"); [EOL] Assert.assertTrue(exists); [EOL] [EOL] System.out.println("Check for non-existing node"); [EOL] exists = registry.exists("test/nonExistentNode"); [EOL] Assert.assertFalse(exists); [EOL] } [EOL] private static FSRegistryOperationsService registry = [EOL] new FSRegistryOperationsService(); [EOL] private static FileSystem fs; [EOL]
@Test [EOL] public void testPrimaryAndDependentLoggers() { [EOL] helper = new LogThrottlingHelper(LOG_PERIOD, "foo", timer); [EOL] [EOL] assertTrue(helper.record("foo", 0).shouldLog()); [EOL] assertTrue(helper.record("bar", 0).shouldLog()); [EOL] assertFalse(helper.record("bar", 0).shouldLog()); [EOL] assertFalse(helper.record("foo", 0).shouldLog()); [EOL] [EOL] assertFalse(helper.record("foo", LOG_PERIOD / 2).shouldLog()); [EOL] assertFalse(helper.record("bar", LOG_PERIOD / 2).shouldLog()); [EOL] [EOL] // Both should log once the period has elapsed [EOL] assertTrue(helper.record("foo", LOG_PERIOD).shouldLog()); [EOL] assertTrue(helper.record("bar", LOG_PERIOD).shouldLog()); [EOL] [EOL] // "bar" should not log yet because "foo" hasn't been triggered [EOL] assertFalse(helper.record("bar", LOG_PERIOD * 2).shouldLog()); [EOL] assertTrue(helper.record("foo", LOG_PERIOD * 2).shouldLog()); [EOL] // The timing of "bar" shouldn't matter as it is dependent on "foo" [EOL] assertTrue(helper.record("bar", 0).shouldLog()); [EOL] } [EOL] private static final int LOG_PERIOD = 100; [EOL] private LogThrottlingHelper helper; [EOL] private FakeTimer timer; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       CharSequence charSequence0 = null; [EOL]       int int0 = StringUtils.indexOf((CharSequence) null, 0, 0); [EOL]        [EOL]       String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null, "&,1fs'G.F7", 0); [EOL]        [EOL]       char[] charArray0 = new char[6]; [EOL]       charArray0[0] = '!'; [EOL]       charArray0[1] = '8'; [EOL]       charArray0[2] = '9'; [EOL]       charArray0[3] = '('; [EOL]       charArray0[4] = ';'; [EOL]       charArray0[5] = 'B'; [EOL]       boolean boolean0 = StringUtils.containsAny((CharSequence) null, charArray0);', 'B'}, charArray0); [EOL]        [EOL]       String string0 = StringUtils.replaceEachRepeatedly((String) null, (String[]) null, (String[]) null); [EOL]        [EOL]       String string1 = StringUtils.stripToNull("&,1fs'G.F7"); [EOL]        [EOL]       int int1 = StringUtils.indexOf((CharSequence) null, (CharSequence) "&,1fs'G.F7"); [EOL]        [EOL]       String string2 = StringUtils.substring("", 0); [EOL]       assertFalse(string2.equals((Object)string1)); [EOL]        [EOL]       String string3 = StringUtils.repeat("&,1fs'G.F7", 2138); [EOL]       assertFalse(string3.equals((Object)string1)); [EOL]       assertFalse(string3.equals((Object)string2)); [EOL]        [EOL]       boolean boolean1 = StringUtils.startsWithIgnoreCase("&,1fs'G.F7", (CharSequence) null); [EOL]        [EOL]       String string4 = StringUtils.trim(""); [EOL]       assertFalse(string4.equals((Object)string1)); [EOL]       assertFalse(string4.equals((Object)string3)); [EOL]       assertTrue(string4.equals((Object)string2)); [EOL]        [EOL]       String string5 = ""; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         StringUtils.abbreviate("", 0); [EOL]         fail("Expecting exception: IllegalArgumentException"); [EOL]        [EOL]       } catch(IllegalArgumentException e) { [EOL]          // [EOL]          // Minimum abbreviation width is 4 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.StringUtils", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testToStringNoQuota() { [EOL] long length = 11111; [EOL] long fileCount = 22222; [EOL] long directoryCount = 33333; [EOL] [EOL] ContentSummary contentSummary = new ContentSummary.Builder().length(length). [EOL] fileCount(fileCount).directoryCount(directoryCount).build(); [EOL] String expected = " none inf none" [EOL] + " inf 33333 22222 11111 "; [EOL] assertEquals(expected, contentSummary.toString(true)); [EOL] } [EOL]
@Test [EOL] public void testgetTModelListJSON() { [EOL] System.out.println("testgetTModelListJSON"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] UriContainer expResult = null; [EOL] KeyBag serviceListXML = instance.getTModelListJSON(); [EOL] Assert.assertNotNull(serviceListXML); [EOL] Assert.assertFalse(serviceListXML.getTModelKey().isEmpty()); [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSimpleName()  throws Throwable  { [EOL]       String string0 = ClassUtils.getSimpleName((Object) null, (String) null); [EOL]       assertNull(string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       int int0 = 517; [EOL]       StrBuilder strBuilder0 = new StrBuilder(517); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       Object object0 = new Object(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append('S'); [EOL]       assertEquals(1, strBuilder0.size()); [EOL]       assertEquals(1, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln(object0); [EOL]       assertEquals(29, strBuilder0.size()); [EOL]       assertEquals(29, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append((long) 517); [EOL]       assertEquals(32, strBuilder0.size()); [EOL]       assertEquals(32, strBuilder2.size()); [EOL]       assertEquals(32, strBuilder3.size()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertEquals(84, strBuilder0.size()); [EOL]       assertEquals(84, strBuilder2.size()); [EOL]       assertEquals(84, strBuilder4.size()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.replaceFirst("G1", "G1"); [EOL]       assertEquals(84, strBuilder0.size()); [EOL]       assertEquals(84, strBuilder5.size()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder5.append((long) 517); [EOL]       assertEquals(87, strBuilder0.size()); [EOL]       assertEquals(87, strBuilder5.size()); [EOL]       assertEquals(87, strBuilder6.size()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.appendSeparator("v5a", 517); [EOL]       assertEquals(91, strBuilder0.size()); [EOL]       assertEquals(91, strBuilder7.size()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.charMatcher('S'); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder7.replaceFirst(strMatcher0, ""); [EOL]       assertEquals(90, strBuilder0.size()); [EOL]       assertEquals(90, strBuilder7.size()); [EOL]       assertEquals(90, strBuilder8.size()); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder1.appendln("v5a"); [EOL]       assertEquals(95, strBuilder0.size()); [EOL]       assertEquals(95, strBuilder1.size()); [EOL]       assertEquals(95, strBuilder9.size()); [EOL]        [EOL]       StrBuilder strBuilder10 = strBuilder1.appendFixedWidthPadRight(517, 517, 'o'); [EOL]       assertEquals(612, strBuilder0.size()); [EOL]       assertEquals(612, strBuilder1.size()); [EOL]       assertEquals(612, strBuilder10.size()); [EOL]        [EOL]       int int1 = 2001; [EOL]       boolean boolean0 = true; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder9.append((CharSequence) strBuilder1, 517, 1738); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // length must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout=60000) [EOL] public void testInterruption() throws Exception { [EOL] final DomainSocketWatcher watcher = newDomainSocketWatcher(10); [EOL] watcher.watcherThread.interrupt(); [EOL] Uninterruptibles.joinUninterruptibly(watcher.watcherThread); [EOL] watcher.close(); [EOL] } [EOL] static final Logger LOG = [EOL] LoggerFactory.getLogger(TestDomainSocketWatcher.class); [EOL] private Throwable trappedException = null; [EOL]
@Test(timeout = 4000) [EOL]   public void testcompare()  throws Throwable  { [EOL]       Range<String> range0 = Range.is("pKzJ'CmBAFa}&8mMy"); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(955, 955).when(comparator0).compare(any() , any()); [EOL]       Range<Object> range1 = Range.between((Object) "8BSsazZjZ<nSFi28~ ", (Object) range0, comparator0); [EOL]       boolean boolean0 = range1.isEndedBy("pKzJ'CmBAFa}&8mMy"); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCharAt() { [EOL] String line = "adsawseeeeegqewgasddga"; [EOL] Text text = new Text(line); [EOL] for (int i = 0; i < line.length(); i++) { [EOL] assertTrue("testCharAt error1 !!!", text.charAt(i) == line.charAt(i)); [EOL] } [EOL] assertEquals("testCharAt error2 !!!", -1, text.charAt(-1)); [EOL] assertEquals("testCharAt error3 !!!", -1, text.charAt(100)); [EOL] } [EOL] private static final int NUM_ITERATIONS = 100; [EOL] private static final Random RANDOM = new Random(1); [EOL] private static final int RAND_LEN = -1; [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseFieldNames()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.DEFAULT_STYLE.setSizeEndText("AEhzPmLst|m|:e7J{Z"); [EOL]       assertTrue(standardToStringStyle0.isUseFieldNames()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseClassName()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       Boolean boolean0 = Boolean.TRUE; [EOL]       standardToStringStyle0.isFullDetail(boolean0); [EOL]       assertTrue(standardToStringStyle0.isUseClassName()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmarkSupported()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("F"); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.deleteFirst('e'); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.insert(0, "F"); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.deleteAll('#'); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append(598L); [EOL]        [EOL]       String string0 = strBuilder0.toString(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder4.reverse(); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       char[] charArray0 = new char[8]; [EOL]       charArray0[0] = 'e'; [EOL]       charArray0[1] = 'e'; [EOL]       charArray0[2] = 'K'; [EOL]       charArray0[3] = 'e'; [EOL]       int int0 = strBuilder2.indexOf((StrMatcher) null); [EOL]        [EOL]       charArray0[4] = 'e'; [EOL]       charArray0[5] = 'e'; [EOL]       charArray0[6] = 'e'; [EOL]       charArray0[7] = 'e'; [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       int int2 = 1354; [EOL]       strBuilder_StrBuilderReader0.mark(1354); [EOL]       assertTrue(strBuilder_StrBuilderReader0.markSupported()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder3.new StrBuilderTokenizer(); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder_StrBuilderTokenizer0.previous(); [EOL]         fail("Expecting exception: NoSuchElementException"); [EOL]        [EOL]       } catch(NoSuchElementException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrTokenizer", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testValidClientIndex() throws Exception { [EOL] ConnectionPool pool = new ConnectionPool( [EOL] conf, TEST_NN_ADDRESS, TEST_USER1, 2, 2, 0.5f, ClientProtocol.class); [EOL] for(int i = -3; i <= 3; i++) { [EOL] pool.getClientIndex().set(i); [EOL] ConnectionContext conn = pool.getConnection(); [EOL] assertNotNull(conn); [EOL] assertTrue(conn.isUsable()); [EOL] } [EOL] } [EOL] private Configuration conf; [EOL] private ConnectionManager connManager; [EOL] private static final String[] TEST_GROUP = new String[]{"TEST_GROUP"}; [EOL] private static final UserGroupInformation TEST_USER1 = [EOL] UserGroupInformation.createUserForTesting("user1", TEST_GROUP); [EOL] private static final UserGroupInformation TEST_USER2 = [EOL] UserGroupInformation.createUserForTesting("user2", TEST_GROUP); [EOL] private static final UserGroupInformation TEST_USER3 = [EOL] UserGroupInformation.createUserForTesting("user3", TEST_GROUP); [EOL] private static final String TEST_NN_ADDRESS = "nn1:8080"; [EOL] private static final String UNRESOLVED_TEST_NN_ADDRESS = "unknownhost:8080"; [EOL] @Rule [EOL] public ExpectedException exceptionRule = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testisIgnoreEmptyTokens()  throws Throwable  { [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer("`<j[.Hj#z$ak.1\"Rd", strMatcher0); [EOL]       strTokenizer0.getQuoteMatcher(); [EOL]       assertTrue(strTokenizer0.isIgnoreEmptyTokens()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testIO() throws IOException { [EOL] TypedBytesWritable tbw = new TypedBytesWritable(); [EOL] tbw.setValue(12345); [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] DataOutput dout = new DataOutputStream(baos); [EOL] tbw.write(dout); [EOL] ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); [EOL] DataInput din = new DataInputStream(bais); [EOL] TypedBytesWritable readTbw = new TypedBytesWritable(); [EOL] readTbw.readFields(din); [EOL] assertEquals(tbw, readTbw); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getReducedFraction((-1), (-1)); [EOL]       Fraction fraction1 = Fraction.ONE_QUARTER; [EOL]       boolean boolean0 = fraction0.equals(fraction1); [EOL]       assertFalse(fraction1.equals((Object)fraction0)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoBooleanObject()  throws Throwable  { [EOL]       Boolean boolean0 = BooleanUtils.toBooleanObject(")l(BL"); [EOL]       assertNull(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetArraySeparator()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getContentStart(); [EOL]       assertEquals(",", standardToStringStyle0.getArraySeparator()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       char[] charArray0 = new char[4]; [EOL]       charArray0[0] = 'I'; [EOL]       charArray0[1] = 'e'; [EOL]       charArray0[2] = 'M'; [EOL]       charArray0[3] = 'I'; [EOL]       StrMatcher.CharSetMatcher strMatcher_CharSetMatcher0 = new StrMatcher.CharSetMatcher(charArray0); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceAll((StrMatcher) strMatcher_CharSetMatcher0, (String) null); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetArrayStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.setSizeStartText((String) null); [EOL]       assertEquals("{", standardToStringStyle0.getArrayStart()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSubmitApplicationWrongFormat() [EOL] throws YarnException, IOException, InterruptedException { [EOL] [EOL] ApplicationSubmissionContextInfo context = [EOL] new ApplicationSubmissionContextInfo(); [EOL] context.setApplicationId("Application_wrong_id"); [EOL] Response response = interceptor.submitApplication(context, null); [EOL] Assert.assertEquals(BAD_REQUEST, response.getStatus()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFederationInterceptorREST.class); [EOL] private final static int NUM_SUBCLUSTER = 4; [EOL] private static final int BAD_REQUEST = 400; [EOL] private static final int ACCEPTED = 202; [EOL] private static String user = "test-user"; [EOL] private TestableFederationInterceptorREST interceptor; [EOL] private MemoryFederationStateStore stateStore; [EOL] private FederationStateStoreTestUtil stateStoreUtil; [EOL] private List<SubClusterId> subClusters; [EOL]
@Test [EOL] public void testSubmitReservationNoDefinition() { [EOL] ReservationSubmissionRequest request = [EOL] new ReservationSubmissionRequestPBImpl(); [EOL] request.setQueue(PLAN_NAME); [EOL] Plan plan = null; [EOL] try { [EOL] plan = [EOL] rrValidator.validateReservationSubmissionRequest(rSystem, request, [EOL] ReservationSystemTestUtil.getNewReservationId()); [EOL] Assert.fail(); [EOL] } catch (YarnException e) { [EOL] Assert.assertNull(plan); [EOL] String message = e.getMessage(); [EOL] Assert.assertEquals("Missing reservation definition. Please try again by " [EOL] + "specifying a reservation definition.", message); [EOL] LOG.info(message); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestReservationInputValidator.class); [EOL] private static final String PLAN_NAME = "test-reservation"; [EOL] private Clock clock; [EOL] private Map<String, Plan> plans = new HashMap<String, Plan>(1); [EOL] private ReservationSystem rSystem; [EOL] private Plan plan; [EOL] private ReservationInputValidator rrValidator; [EOL]
@Test [EOL] public void testResendRequestsOnRMRestart() [EOL] throws YarnException, IOException { [EOL] ContainerId c1 = createContainerId(1); [EOL] ContainerId c2 = createContainerId(2); [EOL] ContainerId c3 = createContainerId(3); [EOL] [EOL] // Ask for two containers, one with location preference [EOL] this.asks.add(createResourceRequest(0, "node1", 2048, 1, 1, [EOL] ExecutionType.GUARANTEED, 1)); [EOL] this.asks.add(createResourceRequest(0, "rack", 2048, 1, 1, [EOL] ExecutionType.GUARANTEED, 1)); [EOL] this.asks.add(createResourceRequest(0, ResourceRequest.ANY, 2048, 1, 1, [EOL] ExecutionType.GUARANTEED, 2)); [EOL] [EOL] this.releases.add(c1); [EOL] this.blacklistAdditions.add("node1"); [EOL] this.blacklistRemoval.add("node0"); [EOL] [EOL] // 1. a fully loaded request [EOL] this.relayer.allocate(getAllocateRequest()); [EOL] assertAsksAndReleases(3, 1); [EOL] assertBlacklistAdditionsAndRemovals(1, 1); [EOL] clearAllocateRequestLists(); [EOL] [EOL] // 2. empty request [EOL] this.relayer.allocate(getAllocateRequest()); [EOL] assertAsksAndReleases(0, 0); [EOL] assertBlacklistAdditionsAndRemovals(0, 0); [EOL] clearAllocateRequestLists(); [EOL] [EOL] // Set RM restart and failover flag [EOL] this.mockAMS.setFailoverFlag(); [EOL] [EOL] // More requests [EOL] this.blacklistAdditions.add("node2"); [EOL] this.releases.add(c2); [EOL] this.relayer.allocate(getAllocateRequest()); [EOL] [EOL] // verify pending requests are fully re-sent [EOL] assertAsksAndReleases(3, 2); [EOL] assertBlacklistAdditionsAndRemovals(2, 0); [EOL] clearAllocateRequestLists(); [EOL] } [EOL] private Configuration conf; [EOL] private MockApplicationMasterService mockAMS; [EOL] private AMRMClientRelayer relayer; [EOL] private int responseId = 0; [EOL] private List<ResourceRequest> asks = new ArrayList<>(); [EOL] private List<ContainerId> releases = new ArrayList<>(); [EOL] private List<String> blacklistAdditions = new ArrayList<>(); [EOL] private List<String> blacklistRemoval = new ArrayList<>(); [EOL]
@Test(timeout = 60000) [EOL] public void testRemoveAll() { [EOL] TestElement[] elements = generateElements(1 << 16); [EOL] final LightWeightResizableGSet<TestKey, TestElement> set = [EOL] new LightWeightResizableGSet<TestKey, TestElement>(); [EOL] [EOL] assertThat(set.size()).isZero(); [EOL] [EOL] // put all elements [EOL] for (int i = 0; i < elements.length; i++) { [EOL] TestElement element = set.put(elements[i]); [EOL] assertThat(element).isNull(); [EOL] } [EOL] [EOL] // check the set size [EOL] assertThat(set.size()).isEqualTo(elements.length); [EOL] [EOL] // remove all through clear [EOL] { [EOL] set.clear(); [EOL] assertThat(set.size()).isZero(); [EOL] [EOL] // check all elements removed [EOL] for (int i = 0; i < elements.length; i++) { [EOL] assertThat(set.contains(elements[i])).isFalse(); [EOL] } [EOL] assertThat(set.iterator().hasNext()).isFalse(); [EOL] } [EOL] [EOL] // put all elements back [EOL] for (int i = 0; i < elements.length; i++) { [EOL] TestElement element = set.put(elements[i]); [EOL] assertThat(element).isNull(); [EOL] } [EOL] [EOL] // remove all through iterator [EOL] { [EOL] for (Iterator<TestElement> iter = set.iterator(); iter.hasNext(); ) { [EOL] TestElement element = iter.next(); [EOL] // element should be there before removing [EOL] assertThat(set.contains(element)).isTrue(); [EOL] iter.remove(); [EOL] // element should not be there now [EOL] assertThat(set.contains(element)).isFalse(); [EOL] } [EOL] [EOL] // the deleted elements should not be there [EOL] for (int i = 0; i < elements.length; i++) { [EOL] assertThat(set.contains(elements[i])).isFalse(); [EOL] } [EOL] [EOL] // iterator should not have next [EOL] assertThat(set.iterator().hasNext()).isFalse(); [EOL] [EOL] // check the set size [EOL] assertThat(set.size()).isZero(); [EOL] } [EOL] } [EOL] public static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLightWeightResizableGSet.class); [EOL] private Random random = new Random(); [EOL]
@Test [EOL] public void testDependencySorting() throws IOException { [EOL] Component a = ServiceTestUtils.createComponent("a"); [EOL] Component b = ServiceTestUtils.createComponent("b"); [EOL] Component c = ServiceTestUtils.createComponent("c"); [EOL] Component d = [EOL] ServiceTestUtils.createComponent("d").dependencies(Arrays.asList("c")); [EOL] Component e = ServiceTestUtils.createComponent("e") [EOL] .dependencies(Arrays.asList("b", "d")); [EOL] [EOL] verifyDependencySorting(Arrays.asList(a, b, c), a, b, c); [EOL] verifyDependencySorting(Arrays.asList(c, a, b), c, a, b); [EOL] verifyDependencySorting(Arrays.asList(a, b, c, d, e), a, b, c, d, e); [EOL] verifyDependencySorting(Arrays.asList(e, d, c, b, a), c, b, a, d, e); [EOL] [EOL] c.setDependencies(Arrays.asList("e")); [EOL] try { [EOL] verifyDependencySorting(Arrays.asList(a, b, c, d, e)); [EOL] Assert.fail(EXCEPTION_PREFIX + "components with dependency cycle"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals(String.format( [EOL] RestApiErrorMessages.ERROR_DEPENDENCY_CYCLE, Arrays.asList(c, d, [EOL] e)), ex.getMessage()); [EOL] } [EOL] [EOL] SliderFileSystem sfs = ServiceTestUtils.initMockFs(); [EOL] Service service = createValidApplication(null); [EOL] service.setComponents(Arrays.asList(c, d, e)); [EOL] try { [EOL] ServiceApiUtil.validateAndResolveService(service, sfs, [EOL] CONF_DEFAULT_DNS); [EOL] Assert.fail(EXCEPTION_PREFIX + "components with bad dependencies"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals(String.format( [EOL] RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, "b", "e"), ex [EOL] .getMessage()); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestServiceApiUtil.class); [EOL] private static final String EXCEPTION_PREFIX = "Should have thrown " + [EOL] "exception: "; [EOL] private static final String NO_EXCEPTION_PREFIX = "Should not have thrown " + [EOL] "exception: "; [EOL] private static final String LEN_64_STR = [EOL] "abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01"; [EOL] private static final YarnConfiguration CONF_DEFAULT_DNS = new [EOL] YarnConfiguration(); [EOL] private static final YarnConfiguration CONF_DNS_ENABLED = new [EOL] YarnConfiguration(); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.substringBefore("", "s/eB&ED@mIB"); [EOL]        [EOL]       String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens("", "s/eB&ED@mIB", 0); [EOL]       assertEquals(0, stringArray0.length); [EOL]        [EOL]       String string1 = StringUtils.rightPad("", 0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetStagingDirWhenShortFileOwnerNameAndShortUserName() [EOL] throws IOException, InterruptedException { [EOL] Cluster cluster = mock(Cluster.class); [EOL] Configuration conf = new Configuration(); [EOL] String stagingDirOwner = USER_1_SHORT_NAME; [EOL] Path stagingPath = mock(Path.class); [EOL] UserGroupInformation user = UserGroupInformation [EOL] .createUserForTesting(USER_1_SHORT_NAME, GROUP_NAMES); [EOL] assertEquals(USER_1_SHORT_NAME, user.getUserName()); [EOL] FileSystem fs = new FileSystemTestHelper.MockFileSystem(); [EOL] FileStatus fileStatus = new FileStatus(1, true, 1, 1, 100L, 100L, [EOL] FsPermission.getDefault(), stagingDirOwner, stagingDirOwner, [EOL] stagingPath); [EOL] when(stagingPath.getFileSystem(conf)).thenReturn(fs); [EOL] when(fs.getFileStatus(stagingPath)).thenReturn(fileStatus); [EOL] when(cluster.getStagingAreaDir()).thenReturn(stagingPath); [EOL] assertEquals(stagingPath, [EOL] JobSubmissionFiles.getStagingDir(cluster, conf, user)); [EOL] } [EOL] final private static String USER_1 = "user1@HADOOP.APACHE.ORG"; [EOL] final private static String USER_1_SHORT_NAME = "user1"; [EOL] final private static String GROUP1_NAME = "group1"; [EOL] final private static String GROUP2_NAME = "group2"; [EOL] final private static String GROUP3_NAME = "group3"; [EOL] final private static String[] GROUP_NAMES = new String[] {GROUP1_NAME, [EOL] GROUP2_NAME, GROUP3_NAME }; [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(3163); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(""); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendln((-3417.2957F)); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder2.capacity()); [EOL]        [EOL]       int int0 = strBuilder2.indexOf("3+r3jcbdAXt1x", 3163); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendSeparator('s'); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder3.capacity()); [EOL]        [EOL]       char[] charArray0 = new char[7]; [EOL]       charArray0[0] = 's'; [EOL]       charArray0[1] = 'H'; [EOL]       ArrayList<StrBuilder> arrayList0 = new ArrayList<StrBuilder>(); [EOL]        [EOL]       ArrayList<Object> arrayList1 = new ArrayList<Object>(arrayList0); [EOL]        [EOL]       ListIterator<Object> listIterator0 = arrayList1.listIterator(); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.appendAll((Iterator<?>) listIterator0); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder4.capacity()); [EOL]        [EOL]       charArray0[2] = 's'; [EOL]       charArray0[3] = 's'; [EOL]       charArray0[4] = 's'; [EOL]       charArray0[5] = 's'; [EOL]       charArray0[6] = 's'; [EOL]       StrBuilder strBuilder5 = strBuilder1.append(charArray0); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder5.capacity()); [EOL]       assertEquals(3163, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln("aHPcrO", 5, 0); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder6.capacity()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.appendFixedWidthPadRight((Object) strBuilder5, 0, 's'); [EOL]       assertEquals(3163, strBuilder0.capacity()); [EOL]       assertEquals(3163, strBuilder5.capacity()); [EOL]       assertEquals(3163, strBuilder1.capacity()); [EOL]       assertEquals(3163, strBuilder7.capacity()); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer(""); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder3.append(stringBuffer0, 3062, (-1)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetEscapeChar()  throws Throwable  { [EOL]       HashMap<String, String> hashMap0 = new HashMap<String, String>(); [EOL]       StrLookup.MapStrLookup<String> strLookup_MapStrLookup0 = new StrLookup.MapStrLookup<String>(hashMap0); [EOL]       StrSubstitutor strSubstitutor0 = new StrSubstitutor(strLookup_MapStrLookup0, "6", "6", '<'); [EOL]       StringBuffer stringBuffer0 = new StringBuffer("6"); [EOL]       boolean boolean0 = strSubstitutor0.replaceIn(stringBuffer0, 1, 0); [EOL]       assertEquals('<', strSubstitutor0.getEscapeChar()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testget()  throws Throwable  { [EOL]       Callable<String> callable0 = (Callable<String>) mock(Callable.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn("", "p!,").when(callable0).call(); [EOL]       CallableBackgroundInitializer<String> callableBackgroundInitializer0 = new CallableBackgroundInitializer<String>(callable0); [EOL]       callableBackgroundInitializer0.getTaskCount(); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.initialize(); [EOL]       callableBackgroundInitializer0.start(); [EOL]       callableBackgroundInitializer0.get(); [EOL]       assertTrue(callableBackgroundInitializer0.isStarted()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testForName() { [EOL] assertEquals("The forName() method did not parse the task ID string " [EOL] + "correctly", "task_1_0001_m_000000", [EOL] TaskID.forName("task_1_0001_m_000").toString()); [EOL] assertEquals("The forName() method did not parse the task ID string " [EOL] + "correctly", "task_23_0002_r_000001", [EOL] TaskID.forName("task_23_0002_r_0001").toString()); [EOL] assertEquals("The forName() method did not parse the task ID string " [EOL] + "correctly", "task_345_0003_s_000002", [EOL] TaskID.forName("task_345_0003_s_00002").toString()); [EOL] assertEquals("The forName() method did not parse the task ID string " [EOL] + "correctly", "task_6789_0004_c_000003", [EOL] TaskID.forName("task_6789_0004_c_000003").toString()); [EOL] assertEquals("The forName() method did not parse the task ID string " [EOL] + "correctly", "task_12345_0005_t_4000000", [EOL] TaskID.forName("task_12345_0005_t_4000000").toString()); [EOL] [EOL] try { [EOL] TaskID.forName("tisk_12345_0005_t_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "tisk_12345_0005_t_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("tisk_12345_0005_t_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "tisk_12345_0005_t_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_abc_0005_t_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_abc_0005_t_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_12345_xyz_t_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_12345_xyz_t_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_12345_0005_x_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_12345_0005_x_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_12345_0005_t_jkl"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_12345_0005_t_jkl"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_12345_0005_t"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_12345_0005_t"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_12345_0005_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_12345_0005_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("task_12345_t_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "task_12345_t_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] [EOL] try { [EOL] TaskID.forName("12345_0005_t_4000000"); [EOL] fail("The forName() method parsed an invalid job ID: " [EOL] + "12345_0005_t_4000000"); [EOL] } catch (IllegalArgumentException ex) { [EOL] // Expected [EOL] } [EOL] } [EOL]
@Test(timeout = 30000) [EOL] public void testNormalizeRequest() { [EOL] ResourceCalculator resourceCalculator = new DefaultResourceCalculator(); [EOL] [EOL] final int minMemory = 1024; [EOL] final int maxMemory = 8192; [EOL] Resource minResource = Resources.createResource(minMemory, 0); [EOL] Resource maxResource = Resources.createResource(maxMemory, 0); [EOL] [EOL] ResourceRequest ask = new ResourceRequestPBImpl(); [EOL] [EOL] // case negative memory [EOL] ask.setCapability(Resources.createResource(-1024)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(minMemory, ask.getCapability().getMemorySize()); [EOL] [EOL] // case zero memory [EOL] ask.setCapability(Resources.createResource(0)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(minMemory, ask.getCapability().getMemorySize()); [EOL] [EOL] // case memory is a multiple of minMemory [EOL] ask.setCapability(Resources.createResource(2 * minMemory)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(2 * minMemory, ask.getCapability().getMemorySize()); [EOL] [EOL] // case memory is not a multiple of minMemory [EOL] ask.setCapability(Resources.createResource(minMemory + 10)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(2 * minMemory, ask.getCapability().getMemorySize()); [EOL] [EOL] // case memory is equal to max allowed [EOL] ask.setCapability(Resources.createResource(maxMemory)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(maxMemory, ask.getCapability().getMemorySize()); [EOL] [EOL] // case memory is just less than max [EOL] ask.setCapability(Resources.createResource(maxMemory - 10)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(maxMemory, ask.getCapability().getMemorySize()); [EOL] [EOL] // max is not a multiple of min [EOL] maxResource = Resources.createResource(maxMemory - 10, 0); [EOL] ask.setCapability(Resources.createResource(maxMemory - 100)); [EOL] // multiple of minMemory > maxMemory, then reduce to maxMemory [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(maxResource.getMemorySize(), [EOL] ask.getCapability().getMemorySize()); [EOL] [EOL] // ask is more than max [EOL] maxResource = Resources.createResource(maxMemory, 0); [EOL] ask.setCapability(Resources.createResource(maxMemory + 100)); [EOL] SchedulerUtils.normalizeRequest(ask, resourceCalculator, minResource, [EOL] maxResource); [EOL] assertEquals(maxResource.getMemorySize(), [EOL] ask.getCapability().getMemorySize()); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestSchedulerUtils.class); [EOL] private static Resource configuredMaxAllocation; [EOL] private RMContext rmContext = getMockRMContext(); [EOL] private static YarnConfiguration conf = new YarnConfiguration(); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append((-4569442781688233984L), (-4569442781688233984L)); [EOL]       byte[] byteArray0 = new byte[5]; [EOL]       byteArray0[0] = (byte)125; [EOL]       byteArray0[1] = (byte)1; [EOL]       byteArray0[2] = (byte) (-38); [EOL]       byteArray0[3] = (byte)107; [EOL]       byteArray0[4] = (byte) (-72); [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(byteArray0, byteArray0); [EOL]       long[] longArray0 = new long[0]; [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append(longArray0, longArray0); [EOL]       assertTrue(equalsBuilder3.build()); [EOL]        [EOL]       int[] intArray0 = new int[8]; [EOL]       intArray0[0] = (int) (byte)107; [EOL]       intArray0[1] = (int) (byte) (-38); [EOL]       intArray0[2] = (int) (byte) (-72); [EOL]       intArray0[3] = (int) (byte)1; [EOL]       intArray0[4] = (int) (byte)107; [EOL]       intArray0[5] = (int) (byte) (-38); [EOL]       intArray0[6] = (int) (byte) (-38); [EOL]       intArray0[7] = (int) (byte)125; [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append(intArray0, (int[]) null); [EOL]       Object[] objectArray0 = new Object[1]; [EOL]       objectArray0[0] = (Object) 107; [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append(objectArray0, objectArray0); [EOL]       equalsBuilder5.append(objectArray0, objectArray0); [EOL]       assertFalse(equalsBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPerQueueDisablePreemptionBroadHierarchical() { [EOL] int[][] qData = new int[][] { [EOL] // / A D G [EOL] // B C E F H I [EOL] {1000, 350, 150, 200, 400, 200, 200, 250, 100, 150 }, // abs [EOL] {1000,1000,1000,1000,1000,1000,1000,1000,1000,1000 }, // maxCap [EOL] {1000, 400, 200, 200, 400, 250, 150, 200, 150, 50 }, // used [EOL] { 50, 0, 0, 0, 50, 0, 50, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, // reserved [EOL] // appA appB appC appD appE appF [EOL] { 6, 2, 1, 1, 2, 1, 1, 2, 1, 1 }, // apps [EOL] { -1, -1, 1, 1, -1, 1, 1, -1, 1, 1 }, // req granulrity [EOL] { 3, 2, 0, 0, 2, 0, 0, 2, 0, 0 }, // subqueues [EOL] }; [EOL] [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData); [EOL] policy.editSchedule(); [EOL] // queueF(appD) wants resources, Verify that resources come from queueE(appC) [EOL] // because it's a sibling and queueB(appA) because queueA is over capacity. [EOL] verify(mDisp, times(27)).handle(argThat(new IsPreemptionRequestFor(appA))); [EOL] verify(mDisp, times(23)).handle(argThat(new IsPreemptionRequestFor(appC))); [EOL] [EOL] // Need to call setup() again to reset mDisp [EOL] setup(); [EOL] // Turn off preemption for queueB(appA) [EOL] conf.setPreemptionDisabled("root.queueA.queueB", true); [EOL] ProportionalCapacityPreemptionPolicy policy2 = buildPolicy(qData); [EOL] policy2.editSchedule(); [EOL] // Now that queueB(appA) is not preemptable, verify that resources come [EOL] // from queueE(appC) [EOL] verify(mDisp, times(50)).handle(argThat(new IsPreemptionRequestFor(appC))); [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appA))); [EOL] [EOL] setup(); [EOL] // Turn off preemption for two of the 3 queues with over-capacity. [EOL] conf.setPreemptionDisabled("root.queueD.queueE", true); [EOL] conf.setPreemptionDisabled("root.queueA.queueB", true); [EOL] ProportionalCapacityPreemptionPolicy policy3 = buildPolicy(qData); [EOL] policy3.editSchedule(); [EOL] [EOL] // Verify that the request was starved out even though queueH(appE) is [EOL] // over capacity. This is because queueG (queueH's parent) is NOT [EOL] // overcapacity. [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appA))); // queueB [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appB))); // queueC [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appC))); // queueE [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appE))); // queueH [EOL] verify(mDisp, never()).handle(argThat(new IsPreemptionRequestFor(appF))); // queueI [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test(timeout = 4000) [EOL]   public void testnextIndex()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("kfk"); [EOL]       assertEquals(0, strTokenizer0.nextIndex()); [EOL]        [EOL]       Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer()); [EOL]       strTokenizer0.forEachRemaining(consumer0); [EOL]       int int0 = strTokenizer0.previousIndex(); [EOL]       assertEquals(1, strTokenizer0.nextIndex()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisNotTrue()  throws Throwable  { [EOL]       boolean boolean0 = BooleanUtils.isNotTrue((Boolean) null); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test (timeout = 5000) [EOL] public void testReplaceTokensWinEnvVars() { [EOL] Pattern pattern = StringUtils.WIN_ENV_VAR_PATTERN; [EOL] Map<String, String> replacements = new HashMap<String, String>(); [EOL] replacements.put("foo", "zoo"); [EOL] replacements.put("baz", "zaz"); [EOL] [EOL] assertEquals("zoo", StringUtils.replaceTokens("%foo%", pattern, [EOL] replacements)); [EOL] assertEquals("zaz", StringUtils.replaceTokens("%baz%", pattern, [EOL] replacements)); [EOL] assertEquals("", StringUtils.replaceTokens("%bar%", pattern, [EOL] replacements)); [EOL] assertEquals("", StringUtils.replaceTokens("", pattern, replacements)); [EOL] assertEquals("zoo__zaz", StringUtils.replaceTokens("%foo%_%bar%_%baz%", [EOL] pattern, replacements)); [EOL] assertEquals("begin zoo__zaz end", StringUtils.replaceTokens( [EOL] "begin %foo%_%bar%_%baz% end", pattern, replacements)); [EOL] } [EOL] final private static String NULL_STR = null; [EOL] final private static String EMPTY_STR = ""; [EOL] final private static String STR_WO_SPECIAL_CHARS = "AB"; [EOL] final private static String STR_WITH_COMMA = "A,B"; [EOL] final private static String ESCAPED_STR_WITH_COMMA = "A\\,B"; [EOL] final private static String STR_WITH_ESCAPE = "AB\\"; [EOL] final private static String ESCAPED_STR_WITH_ESCAPE = "AB\\\\"; [EOL] final private static String STR_WITH_BOTH2 = ",A\\,,B\\\\,"; [EOL] final private static String ESCAPED_STR_WITH_BOTH2 = [EOL] "\\,A\\\\\\,\\,B\\\\\\\\\\,"; [EOL] final private static FastDateFormat FAST_DATE_FORMAT = [EOL] FastDateFormat.getInstance("d-MMM-yyyy HH:mm:ss"); [EOL]
@Test [EOL] public void testEventFiltersParsing() throws Exception { [EOL] String expr = "abc,def"; [EOL] TimelineFilterList expectedList = new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "abc"), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "def") [EOL] ); [EOL] verifyFilterList(expr, [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr), expectedList); [EOL] [EOL] expr = "(abc,def)"; [EOL] verifyFilterList(expr, [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr), expectedList); [EOL] [EOL] expr = "(abc,def) OR (rst, uvx)"; [EOL] expectedList = new TimelineFilterList(Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "abc"), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "def") [EOL] ), [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "rst"), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "uvx") [EOL] ) [EOL] ); [EOL] verifyFilterList(expr, [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr), expectedList); [EOL] [EOL] expr = "!(abc,def,uvc) OR (rst, uvx)"; [EOL] expectedList = new TimelineFilterList(Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.NOT_EQUAL, "abc"), [EOL] new TimelineExistsFilter(TimelineCompareOp.NOT_EQUAL, "def"), [EOL] new TimelineExistsFilter(TimelineCompareOp.NOT_EQUAL, "uvc") [EOL] ), [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "rst"), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "uvx") [EOL] ) [EOL] ); [EOL] verifyFilterList(expr, [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr), expectedList); [EOL] [EOL] expr = "(((!(abc,def,uvc) OR (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu)))" + [EOL] " OR ((bcd,tyu) AND uvb))"; [EOL] expectedList = new TimelineFilterList(Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineFilterList(Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter( [EOL] TimelineCompareOp.NOT_EQUAL, "abc"), [EOL] new TimelineExistsFilter( [EOL] TimelineCompareOp.NOT_EQUAL, "def"), [EOL] new TimelineExistsFilter(TimelineCompareOp.NOT_EQUAL, "uvc") [EOL] ), [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "rst"), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "uvx") [EOL] ) [EOL] ), [EOL] new TimelineFilterList(Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter( [EOL] TimelineCompareOp.NOT_EQUAL, "abcdefg") [EOL] ), [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter( [EOL] TimelineCompareOp.NOT_EQUAL, "ghj"), [EOL] new TimelineExistsFilter( [EOL] TimelineCompareOp.NOT_EQUAL, "tyu") [EOL] ) [EOL] ) [EOL] ), [EOL] new TimelineFilterList( [EOL] new TimelineFilterList( [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "bcd"), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "tyu") [EOL] ), [EOL] new TimelineExistsFilter(TimelineCompareOp.EQUAL, "uvb") [EOL] ) [EOL] ); [EOL] verifyFilterList(expr, [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr), expectedList); [EOL] [EOL] expr = " ( ( ( ! ( abc , def , uvc) OR ( rst , uvx ) )" + [EOL] " AND ( ! ( abcdefg ) OR ! ( ghj, tyu) ) ) OR ( (" + [EOL] " bcd , tyu ) AND uvb ) )"; [EOL] verifyFilterList(expr, [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr), expectedList); [EOL] [EOL] expr = "(((!(abc,def,uvc) OR (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu)))" + [EOL] " OR ((bcd,tyu) AND uvb)"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Improper brackets. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "(((!(abc,def,uvc) (OR (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu)))" + [EOL] " OR ((bcd,tyu) AND uvb))"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected opening bracket. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "(((!(abc,def,uvc) OR) (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu)))" + [EOL] " OR ((bcd,tyu) AND uvb))"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected closing bracket. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "(((!(abc,def,uvc) PI (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu)))" + [EOL] " OR ((bcd,tyu) AND uvb))"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Invalid op. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "(((!(abc,def,uvc) !OR (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu)))" + [EOL] " OR ((bcd,tyu) AND uvb))"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected ! char. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "abc,def,uvc) OR (rst, uvx)"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected closing bracket. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "abc,def,uvc OR )rst, uvx)"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected closing bracket. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "abc,def,uvc OR ,rst, uvx)"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected delimiter. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "abc,def,uvc OR ! "; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unexpected not char. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "(abc,def,uvc)) OR (rst, uvx)"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("Unbalanced brackets. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] expr = "(((! ,(abc,def,uvc) OR (rst, uvx)) AND (!(abcdefg) OR !(ghj,tyu" + [EOL] "))) OR ((bcd,tyu) AND uvb))"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseEventFilters(expr); [EOL] fail("( should follow ! char. Exception should have been thrown"); [EOL] } catch (TimelineParseException e){} [EOL] [EOL] assertNull(TimelineReaderWebServicesUtils.parseEventFilters(null)); [EOL] assertNull(TimelineReaderWebServicesUtils.parseEventFilters(" ")); [EOL] } [EOL]
@Test [EOL] public void testNodeHeartbeatForAppCollectorsMap() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED, true); [EOL] // set version to 2 [EOL] conf.setFloat(YarnConfiguration.TIMELINE_SERVICE_VERSION, 2.0f); [EOL] // enable aux-service based timeline collectors [EOL] conf.set(YarnConfiguration.NM_AUX_SERVICES, "timeline_collector"); [EOL] conf.set(YarnConfiguration.NM_AUX_SERVICES + "." [EOL] + "timeline_collector" + ".class", [EOL] PerNodeTimelineCollectorsAuxService.class.getName()); [EOL] conf.setClass(YarnConfiguration.TIMELINE_SERVICE_WRITER_CLASS, [EOL] FileSystemTimelineWriterImpl.class, TimelineWriter.class); [EOL] [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] [EOL] MockNM nm1 = rm.registerNode("host1:1234", 5120); [EOL] MockNM nm2 = rm.registerNode("host2:1234", 2048); [EOL] [EOL] NodeHeartbeatResponse nodeHeartbeat1 = nm1.nodeHeartbeat(true); [EOL] NodeHeartbeatResponse nodeHeartbeat2 = nm2.nodeHeartbeat(true); [EOL] [EOL] RMNodeImpl node1 = [EOL] (RMNodeImpl) rm.getRMContext().getRMNodes().get(nm1.getNodeId()); [EOL] [EOL] RMNodeImpl node2 = [EOL] (RMNodeImpl) rm.getRMContext().getRMNodes().get(nm2.getNodeId()); [EOL] [EOL] RMAppImpl app1 = (RMAppImpl) MockRMAppSubmitter.submitWithMemory(1024, rm); [EOL] String collectorAddr1 = "1.2.3.4:5"; [EOL] app1.setCollectorData(AppCollectorData.newInstance( [EOL] app1.getApplicationId(), collectorAddr1)); [EOL] [EOL] String collectorAddr2 = "5.4.3.2:1"; [EOL] RMAppImpl app2 = (RMAppImpl) MockRMAppSubmitter.submitWithMemory(1024, rm); [EOL] app2.setCollectorData(AppCollectorData.newInstance( [EOL] app2.getApplicationId(), collectorAddr2)); [EOL] [EOL] String collectorAddr3 = "5.4.3.2:2"; [EOL] app2.setCollectorData(AppCollectorData.newInstance( [EOL] app2.getApplicationId(), collectorAddr3, 0, 1)); [EOL] [EOL] String collectorAddr4 = "5.4.3.2:3"; [EOL] app2.setCollectorData(AppCollectorData.newInstance( [EOL] app2.getApplicationId(), collectorAddr4, 1, 0)); [EOL] [EOL] // Create a running container for app1 running on nm1 [EOL] ContainerId runningContainerId1 = BuilderUtils.newContainerId( [EOL] BuilderUtils.newApplicationAttemptId( [EOL] app1.getApplicationId(), 0), 0); [EOL] [EOL] ContainerStatus status1 = ContainerStatus.newInstance(runningContainerId1, [EOL] ContainerState.RUNNING, "", 0); [EOL] List<ContainerStatus> statusList = new ArrayList<ContainerStatus>(); [EOL] statusList.add(status1); [EOL] NodeHealthStatus nodeHealth = NodeHealthStatus.newInstance(true, [EOL] "", System.currentTimeMillis()); [EOL] NodeStatus nodeStatus = NodeStatus.newInstance(nm1.getNodeId(), 0, [EOL] statusList, null, nodeHealth, null, null, null); [EOL] node1.handle(new RMNodeStatusEvent(nm1.getNodeId(), nodeStatus)); [EOL] [EOL] Assert.assertEquals(1, node1.getRunningApps().size()); [EOL] Assert.assertEquals(app1.getApplicationId(), node1.getRunningApps().get(0)); [EOL] [EOL] // Create a running container for app2 running on nm2 [EOL] ContainerId runningContainerId2 = BuilderUtils.newContainerId( [EOL] BuilderUtils.newApplicationAttemptId( [EOL] app2.getApplicationId(), 0), 0); [EOL] [EOL] ContainerStatus status2 = ContainerStatus.newInstance(runningContainerId2, [EOL] ContainerState.RUNNING, "", 0); [EOL] statusList = new ArrayList<ContainerStatus>(); [EOL] statusList.add(status2); [EOL] nodeStatus = NodeStatus.newInstance(nm1.getNodeId(), 0, [EOL] statusList, null, nodeHealth, null, null, null); [EOL] node2.handle(new RMNodeStatusEvent(nm2.getNodeId(), nodeStatus)); [EOL] Assert.assertEquals(1, node2.getRunningApps().size()); [EOL] Assert.assertEquals(app2.getApplicationId(), node2.getRunningApps().get(0)); [EOL] [EOL] nodeHeartbeat1 = nm1.nodeHeartbeat(true); [EOL] Map<ApplicationId, AppCollectorData> map1 [EOL] = nodeHeartbeat1.getAppCollectors(); [EOL] Assert.assertEquals(1, map1.size()); [EOL] Assert.assertEquals(collectorAddr1, [EOL] map1.get(app1.getApplicationId()).getCollectorAddr()); [EOL] [EOL] nodeHeartbeat2 = nm2.nodeHeartbeat(true); [EOL] Map<ApplicationId, AppCollectorData> map2 [EOL] = nodeHeartbeat2.getAppCollectors(); [EOL] Assert.assertEquals(1, map2.size()); [EOL] Assert.assertEquals(collectorAddr4, [EOL] map2.get(app2.getApplicationId()).getCollectorAddr()); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout=180000) [EOL] public void testShutdown() throws Exception { [EOL] final AtomicInteger bytesRead = new AtomicInteger(0); [EOL] final AtomicBoolean failed = new AtomicBoolean(false); [EOL] final DomainSocket[] socks = DomainSocket.socketpair(); [EOL] Runnable reader = new Runnable() { [EOL] @Override [EOL] public void run() { [EOL] while (true) { [EOL] try { [EOL] int ret = socks[1].getInputStream().read(); [EOL] if (ret == -1) return; [EOL] bytesRead.addAndGet(1); [EOL] } catch (IOException e) { [EOL] DomainSocket.LOG.error("reader error", e); [EOL] failed.set(true); [EOL] return; [EOL] } [EOL] } [EOL] } [EOL] }; [EOL] Thread readerThread = new Thread(reader); [EOL] readerThread.start(); [EOL] socks[0].getOutputStream().write(1); [EOL] socks[0].getOutputStream().write(2); [EOL] socks[0].getOutputStream().write(3); [EOL] Assert.assertTrue(readerThread.isAlive()); [EOL] socks[0].shutdown(); [EOL] readerThread.join(); [EOL] Assert.assertFalse(failed.get()); [EOL] Assert.assertEquals(3, bytesRead.get()); [EOL] IOUtils.cleanup(null, socks); [EOL] } [EOL] private static TemporarySocketDirectory sockDir; [EOL]
@Test [EOL] public void testAppsQuery() throws Exception { [EOL] WebResource r = resource(); [EOL] ClientResponse response = [EOL] r.path("ws").path("v1").path("applicationhistory").path("apps") [EOL] .queryParam("state", YarnApplicationState.FINISHED.toString()) [EOL] .queryParam("user.name", USERS[round]) [EOL] .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] assertEquals("incorrect number of elements", 1, json.length()); [EOL] JSONObject apps = json.getJSONObject("apps"); [EOL] assertEquals("incorrect number of elements", 1, apps.length()); [EOL] JSONArray array = apps.getJSONArray("app"); [EOL] assertEquals("incorrect number of elements", MAX_APPS, array.length()); [EOL] } [EOL] private static ApplicationHistoryClientService historyClientService; [EOL] private static AHSWebServices ahsWebservice; [EOL] private static final String[] USERS = new String[] { "foo" , "bar" }; [EOL] private static final int MAX_APPS = 6; [EOL] private static Configuration conf; [EOL] private static FileSystem fs; [EOL] private static final String remoteLogRootDir = "target/logs/"; [EOL] private static final String rootLogDir = "target/LocalLogs"; [EOL] private static final String NM_WEBADDRESS = "test-nm-web-address:9999"; [EOL] private static final String NM_ID = "test:1234"; [EOL] private int round; [EOL]
@Test [EOL] public void testCountPath() { [EOL] LeaseManager lm = new LeaseManager(makeMockFsNameSystem()); [EOL] [EOL] lm.addLease("holder1", 1); [EOL] assertThat(lm.countPath(), is(1L)); [EOL] [EOL] lm.addLease("holder2", 2); [EOL] assertThat(lm.countPath(), is(2L)); [EOL] lm.addLease("holder2", 2); // Duplicate addition [EOL] assertThat(lm.countPath(), is(2L)); [EOL] [EOL] assertThat(lm.countPath(), is(2L)); [EOL] [EOL] // Remove a couple of non-existing leases. countPath should not change. [EOL] lm.removeLease("holder2", stubInodeFile(3)); [EOL] lm.removeLease("InvalidLeaseHolder", stubInodeFile(1)); [EOL] assertThat(lm.countPath(), is(2L)); [EOL] [EOL] INodeFile file = stubInodeFile(1); [EOL] lm.reassignLease(lm.getLease(file), file, "holder2"); [EOL] assertThat(lm.countPath(), is(2L)); // Count unchanged on reassign [EOL] [EOL] lm.removeLease("holder2", stubInodeFile(2)); // Remove existing [EOL] assertThat(lm.countPath(), is(1L)); [EOL] } [EOL] @Rule [EOL] public Timeout timeout = new Timeout(300000); [EOL] public static long maxLockHoldToReleaseLeaseMs = 100; [EOL]
@Test(timeout = 4000) [EOL]   public void testbetween()  throws Throwable  { [EOL]       Object object0 = new Object(); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(0).when(comparator0).compare(any() , any()); [EOL]       Range<Object> range0 = Range.between(object0, object0, comparator0); [EOL]       boolean boolean0 = range0.equals((Object) null); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testCompareToLHSNull() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare testCompareToLHSNull"); [EOL] TModelInstanceDetails lhs = new TModelInstanceDetails(); [EOL] lhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] lhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] lhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] //lhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("xyz"); [EOL] TModelInstanceDetails rhs = new TModelInstanceDetails(); [EOL] [EOL] rhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] rhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] rhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("xyz"); [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", true, false, false); [EOL] int expResult = 0; [EOL] int result = instance.compare(lhs, rhs); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testidentityToString()  throws Throwable  { [EOL]       String string0 = ObjectUtils.identityToString((Object) ""); [EOL]       assertNotNull(string0); [EOL]   } [EOL]  [EOL]
@Test (timeout = 30000) [EOL] public void testFailFullyDeleteGrantPermissions() throws IOException { [EOL] setupDirsAndNonWritablePermissions(); [EOL] boolean ret = FileUtil.fullyDelete(new MyFile(del), true); [EOL] // this time the directories with revoked permissions *should* be deleted: [EOL] validateAndSetWritablePermissions(false, ret); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmptyTokenAsNull()  throws Throwable  { [EOL]       char[] charArray0 = new char[9]; [EOL]       charArray0[0] = 'u'; [EOL]       charArray0[6] = '0'; [EOL]       StrMatcher strMatcher0 = StrMatcher.trimMatcher(); [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(charArray0, strMatcher0, strMatcher0); [EOL]       strTokenizer0.next(); [EOL]       strTokenizer0.next(); [EOL]       assertFalse(strTokenizer0.isEmptyTokenAsNull()); [EOL]        [EOL]       strTokenizer0.setEmptyTokenAsNull(true); [EOL]       assertTrue(strTokenizer0.isEmptyTokenAsNull()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSelectCgroup() throws Exception { [EOL] File cpu = new File(tmpPath, "cpu"); [EOL] File cpuNoExist = new File(tmpPath, "cpuNoExist"); [EOL] File memory = new File(tmpPath, "memory"); [EOL] try { [EOL] CGroupsHandlerImpl handler = new CGroupsHandlerImpl( [EOL] createNoMountConfiguration(tmpPath), [EOL] privilegedOperationExecutorMock); [EOL] Map<String, Set<String>> cgroups = new LinkedHashMap<>(); [EOL] [EOL] Assert.assertTrue("temp dir should be created", cpu.mkdirs()); [EOL] Assert.assertTrue("temp dir should be created", memory.mkdirs()); [EOL] Assert.assertFalse("temp dir should not be created", cpuNoExist.exists()); [EOL] [EOL] cgroups.put( [EOL] memory.getAbsolutePath(), Collections.singleton("memory")); [EOL] cgroups.put( [EOL] cpuNoExist.getAbsolutePath(), Collections.singleton("cpu")); [EOL] cgroups.put(cpu.getAbsolutePath(), Collections.singleton("cpu")); [EOL] String selectedCPU = handler.findControllerInMtab("cpu", cgroups); [EOL] Assert.assertEquals("Wrong CPU mount point selected", [EOL] cpu.getAbsolutePath(), selectedCPU); [EOL] } finally { [EOL] FileUtils.deleteQuietly(cpu); [EOL] FileUtils.deleteQuietly(memory); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestCGroupsHandlerImpl.class); [EOL] private PrivilegedOperationExecutor privilegedOperationExecutorMock; [EOL] private String tmpPath; [EOL] private String hierarchy; [EOL] private CGroupsHandler.CGroupController controller; [EOL] private String controllerPath; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       Float[] floatArray0 = new Float[8]; [EOL]       Float float0 = new Float((-1444.746F)); [EOL]       floatArray0[0] = float0; [EOL]       float[] floatArray1 = ArrayUtils.toPrimitive(floatArray0, (-1484.0985F)); [EOL]       assertArrayEquals(new float[] {(-1444.746F), (-1484.0985F), (-1484.0985F), (-1484.0985F), (-1484.0985F), (-1484.0985F), (-1484.0985F), (-1484.0985F)}, floatArray1, 0.01F); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = new StrBuilder((String) null); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[8]; [EOL]       charArray0[0] = 'i'; [EOL]       charArray0[1] = '~'; [EOL]       charArray0[2] = 'i'; [EOL]       charArray0[3] = 'i'; [EOL]       charArray0[4] = 'i'; [EOL]       charArray0[5] = 'i'; [EOL]       charArray0[6] = 'i'; [EOL]       charArray0[7] = 'i'; [EOL]       StrMatcher.CharSetMatcher strMatcher_CharSetMatcher0 = new StrMatcher.CharSetMatcher(charArray0); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.deleteAll((StrMatcher) strMatcher_CharSetMatcher0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder0.appendFixedWidthPadRight((Object) strBuilder1, 0, 'i'); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendln((double) 0); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       int int0 = strBuilder4.lastIndexOf('l', 103); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder0.appendAll((Iterable<?>) null); [EOL]       assertNull(strBuilder5.getNullText()); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendSeparator((String) null); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder6.getNullText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcontains()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((-620)); [EOL]        [EOL]       String string0 = strBuilder0.getNewLineText(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln(1L); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.markSupported(); [EOL]        [EOL]       TreeSet<Object> treeSet0 = new TreeSet<Object>(); [EOL]       assertFalse(treeSet0.contains((-620))); [EOL]        [EOL]       Iterator<Object> iterator0 = treeSet0.descendingIterator(); [EOL]       assertFalse(treeSet0.contains((-620))); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendAll(iterator0); [EOL]       assertFalse(treeSet0.contains((-620))); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln(strBuilder0); [EOL]       assertFalse(treeSet0.contains((-620))); [EOL]        [EOL]       boolean boolean1 = strBuilder2.equals((Object) null); [EOL]       assertFalse(treeSet0.contains((-620))); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder2.deleteAll('J'); [EOL]       assertFalse(treeSet0.contains('J')); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder1.append(1L); [EOL]        [EOL]       StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter(); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       strBuilder_StrBuilderWriter0.write(charArray0); [EOL]        [EOL]       Writer writer0 = strBuilder_StrBuilderWriter0.append((CharSequence) strBuilder5); [EOL]        [EOL]       strBuilder_StrBuilderWriter0.write("?NYmW7afS>c]@v"); [EOL]        [EOL]       boolean boolean2 = strBuilder5.isEmpty(); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder4.deleteFirst('\\'); [EOL]       assertFalse(treeSet0.contains('J')); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder6.appendWithSeparators(iterator0, "u"); [EOL]       assertFalse(treeSet0.contains('J')); [EOL]        [EOL]       StringBuffer stringBuffer0 = new StringBuffer(strBuilder2); [EOL]       assertFalse(treeSet0.contains('J')); [EOL]        [EOL]       StringBuffer stringBuffer1 = stringBuffer0.append(1.0F); [EOL]       assertFalse(treeSet0.contains('J')); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.append(stringBuffer0); [EOL]       assertFalse(treeSet0.contains('J')); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder4.subSequence((-900), (-620)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -900 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testSuccessfulReadAhead() throws Exception { [EOL] // Mock failure for client.read() [EOL] AbfsClient client = getMockAbfsClient(); [EOL] [EOL] // Success operation mock [EOL] AbfsRestOperation op = getMockRestOp(); [EOL] [EOL] // Stub : [EOL] // Pass all readAheads and fail the post eviction request to [EOL] // prove ReadAhead buffer is used [EOL] // for post eviction check, fail all read aheads [EOL] doReturn(op) [EOL] .doReturn(op) [EOL] .doReturn(op) [EOL] .doThrow(new TimeoutException("Internal Server error for RAH-X")) [EOL] .doThrow(new TimeoutException("Internal Server error for RAH-Y")) [EOL] .doThrow(new TimeoutException("Internal Server error for RAH-Z")) [EOL] .when(client) [EOL] .read(any(String.class), any(Long.class), any(byte[].class), [EOL] any(Integer.class), any(Integer.class), any(String.class), [EOL] any(String.class)); [EOL] [EOL] AbfsInputStream inputStream = getAbfsInputStream(client, "testSuccessfulReadAhead.txt"); [EOL] [EOL] // First read request that triggers readAheads. [EOL] inputStream.read(new byte[ONE_KB]); [EOL] [EOL] // Only the 3 readAhead threads should have triggered client.read [EOL] verifyReadCallCount(client, 3); [EOL] [EOL] // Another read request whose requested data is already read ahead. [EOL] inputStream.read(ONE_KB, new byte[ONE_KB], 0, ONE_KB); [EOL] [EOL] // Once created, mock will remember all interactions. [EOL] // As the above read should not have triggered any server calls, total [EOL] // number of read calls made at this point will be same as last. [EOL] verifyReadCallCount(client, 3); [EOL] [EOL] // Stub will throw exception for client.read() for 4th and later calls [EOL] // if not using the read-ahead buffer exception will be thrown on read [EOL] checkEvictedStatus(inputStream, 0, true); [EOL] } [EOL] private static final int ONE_KB = 1 * 1024; [EOL] private static final int TWO_KB = 2 * 1024; [EOL] private static final int THREE_KB = 3 * 1024; [EOL] private static final int REDUCED_READ_BUFFER_AGE_THRESHOLD = 3000; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("D:qv{0F`Yb3&H^f*N2", 1); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       String string0 = strBuilder4.leftString(1); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(true); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder5.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", 1); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder6.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]       assertNull(strBuilder7.getNullText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[9]; [EOL]       ArrayList<Integer> arrayList0 = new ArrayList<Integer>(955); [EOL]        [EOL]       String string0 = StringUtils.join((Iterable<?>) arrayList0, '5'); [EOL]        [EOL]       charSequenceArray0[0] = (CharSequence) ""; [EOL]       String string1 = StringUtils.mid("", 955, 3); [EOL]        [EOL]       charSequenceArray0[1] = (CharSequence) ""; [EOL]       String string2 = StringUtils.upperCase(""); [EOL]        [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       String string3 = StringUtils.removeStartIgnoreCase("\r", ""); [EOL]        [EOL]       charSequenceArray0[3] = (CharSequence) "\r"; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charSequenceArray0[2]); [EOL]       assertEquals("", charBuffer0.toString()); [EOL]        [EOL]       charSequenceArray0[4] = (CharSequence) charBuffer0; [EOL]       CharSequence charSequence0 = StringUtils.defaultIfEmpty(charSequenceArray0[0], charSequenceArray0[0]); [EOL]        [EOL]       charSequenceArray0[5] = (CharSequence) ""; [EOL]       long[] longArray0 = new long[7]; [EOL]       longArray0[0] = (long) 3; [EOL]       longArray0[1] = 2587L; [EOL]       longArray0[2] = (long) 3; [EOL]       longArray0[3] = (long) 955; [EOL]       longArray0[4] = (long) 955; [EOL]       longArray0[5] = (long) 3; [EOL]       longArray0[6] = (-1L); [EOL]       String string4 = StringUtils.join(longArray0, '5', 8192, (-1515)); [EOL]        [EOL]       charSequenceArray0[6] = (CharSequence) ""; [EOL]       String string5 = StringUtils.chomp("\"N;ix%MK");ix%MK", string5); [EOL]        [EOL]       charSequenceArray0[7] = (CharSequence) "\"N;ix%MK"; [EOL]       float[] floatArray0 = new float[2]; [EOL]       floatArray0[0] = (float) 8192; [EOL]       floatArray0[1] = (float) 3L; [EOL]       String string6 = StringUtils.join(floatArray0, 'L', 32, 16); [EOL]        [EOL]       charSequenceArray0[8] = (CharSequence) ""; [EOL]       int int0 = StringUtils.indexOfDifference(charSequenceArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getSummaryObjectStartText(); [EOL]       assertEquals("<", string0); [EOL]   } [EOL]  [EOL]
@Test [EOL] 	public void testHelloWorld_BPEL4WSProcessTModel() throws WSDLException, JAXBException , Exception{ [EOL] [EOL] 		//Obtained from the .bpel file: [EOL] 		String targetNamespace = "http://www.jboss.org/bpel/examples"; [EOL] 		QName serviceName = new QName (targetNamespace, "HelloWorld"); [EOL] 		String bpelOverViewUrl = "http://localhost/registry/" + serviceName.getLocalPart() + ".bpel"; [EOL] 		 [EOL] 		// Reading the WSDL [EOL] 		Definition wsdlDefinition = rw.readWSDL("bpel/HelloWorld.wsdl"); [EOL] 		 [EOL] 	 @SuppressWarnings("unchecked") [EOL] 		Map<QName,PortType> portTypes= (Map<QName,PortType>) wsdlDefinition.getAllPortTypes(); [EOL] 	 TModel bpel4WSTModel = bpel2UDDI.createBPEL4WSProcessTModel(serviceName, targetNamespace, portTypes, bpelOverViewUrl); [EOL] 	 [EOL] 		System.out.println("***** BPEL4WS Process TModel: " + bpel4WSTModel.getName().getValue()); [EOL] if (serialize) [EOL] 		System.out.println(pTModel.print(bpel4WSTModel)); [EOL] 		 [EOL] 		Assert.assertNotNull(bpel4WSTModel); [EOL] 	} [EOL] static BPEL2UDDI bpel2UDDI; [EOL] PrintUDDI<TModel> pTModel = new PrintUDDI<TModel>(); [EOL] PrintUDDI<FindTModel> pFindTModel = new PrintUDDI<FindTModel>(); [EOL] PrintUDDI<BindingTemplate> pBinding = new PrintUDDI<BindingTemplate>(); [EOL] ReadWSDL rw = new ReadWSDL(); [EOL] static boolean serialize=false; [EOL]
@Test [EOL] public void testPropertyRedactionForJHS() throws Exception { [EOL] final Configuration conf = new Configuration(); [EOL] [EOL] String sensitivePropertyName = "aws.fake.credentials.name"; [EOL] String sensitivePropertyValue = "aws.fake.credentials.val"; [EOL] conf.set(sensitivePropertyName, sensitivePropertyValue); [EOL] conf.set(MRJobConfig.MR_JOB_REDACTED_PROPERTIES, [EOL] sensitivePropertyName); [EOL] conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, [EOL] dfsCluster.getURI().toString()); [EOL] final TestParams params = new TestParams(); [EOL] conf.set(MRJobConfig.MR_AM_STAGING_DIR, params.dfsWorkDir); [EOL] [EOL] final JHEvenHandlerForTest jheh = [EOL] new JHEvenHandlerForTest(params.mockAppContext, 0, false); [EOL] [EOL] try { [EOL] jheh.init(conf); [EOL] jheh.start(); [EOL] handleEvent(jheh, new JobHistoryEvent(params.jobId, [EOL] new AMStartedEvent(params.appAttemptId, 200, params.containerId, [EOL] "nmhost", 3000, 4000, -1))); [EOL] handleEvent(jheh, new JobHistoryEvent(params.jobId, [EOL] new JobUnsuccessfulCompletionEvent(TypeConverter.fromYarn( [EOL] params.jobId), 0, 0, 0, 0, 0, 0, 0, [EOL] JobStateInternal.FAILED.toString()))); [EOL] [EOL] // verify the value of the sensitive property in job.xml is restored. [EOL] assertThat(conf.get(sensitivePropertyName)) [EOL] .isEqualTo(sensitivePropertyValue) [EOL] .withFailMessage(sensitivePropertyName + " is modified."); [EOL] [EOL] // load the job_conf.xml in JHS directory and verify property redaction. [EOL] Path jhsJobConfFile = getJobConfInIntermediateDoneDir(conf, params.jobId); [EOL] Assert.assertTrue("The job_conf.xml file is not in the JHS directory", [EOL] FileContext.getFileContext(conf).util().exists(jhsJobConfFile)); [EOL] Configuration jhsJobConf = new Configuration(); [EOL] [EOL] try (InputStream input = FileSystem.get(conf).open(jhsJobConfFile)) { [EOL] jhsJobConf.addResource(input); [EOL] Assert.assertEquals( [EOL] sensitivePropertyName + " is not redacted in HDFS.", [EOL] MRJobConfUtil.REDACTION_REPLACEMENT_VAL, [EOL] jhsJobConf.get(sensitivePropertyName)); [EOL] } [EOL] } finally { [EOL] jheh.stop(); [EOL] purgeHdfsHistoryIntermediateDoneDirectory(conf); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestJobHistoryEventHandler.class); [EOL] private static MiniDFSCluster dfsCluster = null; [EOL] private static String coreSitePath; [EOL]
@Test [EOL] public void testPriorityUtilizationOrdering() { [EOL] PriorityUtilizationQueueOrderingPolicy policy = [EOL] new PriorityUtilizationQueueOrderingPolicy(true); [EOL] [EOL] // Case 1, one queue [EOL] policy.setQueues(mockCSQueues(new String[] { "a" }, new int[] { 1 }, [EOL] new float[] { 0.1f }, new float[] {0.2f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a" }); [EOL] [EOL] // Case 2, 2 queues, both under utilized, same priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 1 }, [EOL] new float[] { 0.2f, 0.1f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "b", "a" }); [EOL] [EOL] // Case 3, 2 queues, both over utilized, same priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 1 }, [EOL] new float[] { 1.1f, 1.2f },new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 4, 2 queues, one under and one over, same priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 1 }, [EOL] new float[] { 0.1f, 1.2f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 5, 2 queues, both over utilized, different priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 2 }, [EOL] new float[] { 1.1f, 1.2f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "b", "a" }); [EOL] [EOL] // Case 6, 2 queues, both under utilized, different priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 2 }, [EOL] new float[] { 0.1f, 0.2f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "b", "a" }); [EOL] [EOL] // Case 7, 2 queues, one under utilized and one over utilized, [EOL] // different priority (1) [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 2 }, [EOL] new float[] { 0.1f, 1.2f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 8, 2 queues, one under utilized and one over utilized, [EOL] // different priority (1) [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 2, 1 }, [EOL] new float[] { 0.1f, 1.2f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 9, 2 queues, one under utilized and one meet, different priority (1) [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 2 }, [EOL] new float[] { 0.1f, 1.0f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 10, 2 queues, one under utilized and one meet, different priority (2) [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 2, 1 }, [EOL] new float[] { 0.1f, 1.0f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 11, 2 queues, one under utilized and one meet, same priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 1 }, [EOL] new float[] { 0.1f, 1.0f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] // Case 12, 2 queues, both meet, different priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 2 }, [EOL] new float[] { 1.0f, 1.0f }, new float[] {0.2f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "b", "a" }); [EOL] [EOL] // Case 13, 5 queues, different priority [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b", "c", "d", "e" }, [EOL] new int[] { 1, 2, 0, 0, 3 }, [EOL] new float[] { 1.2f, 1.0f, 0.2f, 1.1f, 0.2f }, [EOL] new float[] { 0.2f, 0.1f, 0.1f, 0.3f, 0.3f }, "")); [EOL] verifyOrder(policy, "", new String[] { "e", "c", "b", "a", "d" }); [EOL] [EOL] // Case 14, 5 queues, different priority, [EOL] // partition default - abs capacity is 0; [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b", "c", "d", "e" }, [EOL] new int[] { 1, 2, 0, 0, 3 }, [EOL] new float[] { 1.2f, 1.0f, 0.2f, 1.1f, 0.2f }, [EOL] new float[] { 0.2f, 0.1f, 0.1f, 0.3f, 0.3f }, "x")); [EOL] verifyOrder(policy, "", new String[] { "e", "b", "a", "c", "d" }); [EOL] [EOL] // Case 15, 5 queues, different priority, partition x; [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b", "c", "d", "e" }, [EOL] new int[] { 1, 2, 0, 0, 3 }, [EOL] new float[] { 1.2f, 1.0f, 0.2f, 1.1f, 0.2f }, [EOL] new float[] { 0.2f, 0.1f, 0.1f, 0.3f, 0.3f }, "x")); [EOL] verifyOrder(policy, "x", new String[] { "e", "c", "b", "a", "d" }); [EOL] [EOL] // Case 16, 5 queues, different priority, partition x; and different [EOL] // accessibility [EOL] List<CSQueue> queues = mockCSQueues(new String[] { "a", "b", "c", "d", "e" }, [EOL] new int[] { 1, 2, 0, 0, 3 }, [EOL] new float[] { 1.2f, 1.0f, 0.2f, 1.1f, 0.2f }, [EOL] new float[] { 0.2f, 0.1f, 0.1f, 0.3f, 0.3f }, "x"); [EOL] // Only a/d has access to x [EOL] when(queues.get(0).getAccessibleNodeLabels()).thenReturn( [EOL] ImmutableSet.of("x")); [EOL] when(queues.get(3).getAccessibleNodeLabels()).thenReturn( [EOL] ImmutableSet.of("x")); [EOL] policy.setQueues(queues); [EOL] verifyOrder(policy, "x", new String[] { "a", "d", "e", "c", "b" }); [EOL] [EOL] // Case 17, 2 queues, one's abs capacity is 0 [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 1 }, [EOL] new float[] { 0.1f, 1.2f }, new float[] {0.0f, 0.3f}, "")); [EOL] verifyOrder(policy, "", new String[] { "b", "a" }); [EOL] [EOL] // Case 18, 2 queues, one's abs capacity is 0 [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b" }, new int[] { 1, 1 }, [EOL] new float[] { 0.1f, 1.2f }, new float[] {0.3f, 0.0f}, "")); [EOL] verifyOrder(policy, "", new String[] { "a", "b" }); [EOL] [EOL] //Case 19, 5 queues with 2 having abs capacity 0 are prioritized last [EOL] policy.setQueues(mockCSQueues(new String[] { "a", "b", "c", "d", "e" }, [EOL] new int[] { 1, 2, 0, 0, 3 }, [EOL] new float[] { 1.2f, 1.0f, 0.2f, 1.1f, 0.2f }, [EOL] new float[] { 0.0f, 0.0f, 0.1f, 0.3f, 0.3f }, "x")); [EOL] verifyOrder(policy, "x", new String[] { "e", "c", "d", "b", "a" }); [EOL] [EOL] } [EOL]
@Test [EOL] public void testMemoryPercentageNegativeValue() throws Exception { [EOL] expectNegativePercentageOldStyle(); [EOL] parseResourceConfigValue("-10% memory, 50% cpu"); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SIMPLE_STYLE.setUseShortClassName(true); [EOL]       assertEquals("<", standardToStringStyle0.getSummaryObjectStartText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFormatTimeSortable() { [EOL] long timeDiff = 523452311; [EOL] String timeDiffStr = "99hrs, 59mins, 59sec"; [EOL] [EOL] assertEquals("Incorrect time diff string returned", timeDiffStr, [EOL] StringUtils.formatTimeSortable(timeDiff)); [EOL] } [EOL] final private static String NULL_STR = null; [EOL] final private static String EMPTY_STR = ""; [EOL] final private static String STR_WO_SPECIAL_CHARS = "AB"; [EOL] final private static String STR_WITH_COMMA = "A,B"; [EOL] final private static String ESCAPED_STR_WITH_COMMA = "A\\,B"; [EOL] final private static String STR_WITH_ESCAPE = "AB\\"; [EOL] final private static String ESCAPED_STR_WITH_ESCAPE = "AB\\\\"; [EOL] final private static String STR_WITH_BOTH2 = ",A\\,,B\\\\,"; [EOL] final private static String ESCAPED_STR_WITH_BOTH2 = [EOL] "\\,A\\\\\\,\\,B\\\\\\\\\\,"; [EOL] final private static FastDateFormat FAST_DATE_FORMAT = [EOL] FastDateFormat.getInstance("d-MMM-yyyy HH:mm:ss"); [EOL]
@Test [EOL] public void getPrecedence() { [EOL] int precedence = 12345; [EOL] when(expr.getPrecedence()).thenReturn(precedence); [EOL] assertEquals(precedence, test.getPrecedence()); [EOL] verify(expr).getPrecedence(); [EOL] verifyNoMoreInteractions(expr); [EOL] } [EOL] private Expression expr; [EOL] private FilterExpression test; [EOL] @Rule [EOL] public Timeout globalTimeout = new Timeout(10000); [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtEnd()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getSizeEndText(); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtEnd()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPackageRequests() { [EOL] MockAMSimulator app = new MockAMSimulator(); [EOL] List<ContainerSimulator> containerSimulators = new ArrayList<>(); [EOL] Resource resource = Resources.createResource(1024); [EOL] int priority = 1; [EOL] ExecutionType execType = ExecutionType.GUARANTEED; [EOL] String type = "map"; [EOL] [EOL] ContainerSimulator s1 = new ContainerSimulator(resource, 100, [EOL] "/default-rack/h1", priority, type, execType); [EOL] ContainerSimulator s2 = new ContainerSimulator(resource, 100, [EOL] "/default-rack/h1", priority, type, execType); [EOL] ContainerSimulator s3 = new ContainerSimulator(resource, 100, [EOL] "/default-rack/h2", priority, type, execType); [EOL] [EOL] containerSimulators.add(s1); [EOL] containerSimulators.add(s2); [EOL] containerSimulators.add(s3); [EOL] [EOL] List<ResourceRequest> res = app.packageRequests(containerSimulators, [EOL] priority); [EOL] [EOL] // total 4 resource requests: any -> 1, rack -> 1, node -> 2 [EOL] // All resource requests for any would be packaged into 1. [EOL] // All resource requests for racks would be packaged into 1 as all of them [EOL] // are for same rack. [EOL] // All resource requests for nodes would be packaged into 2 as there are [EOL] // two different nodes. [EOL] Assert.assertEquals(4, res.size()); [EOL] int anyRequestCount = 0; [EOL] int rackRequestCount = 0; [EOL] int nodeRequestCount = 0; [EOL] [EOL] for (ResourceRequest request : res) { [EOL] String resourceName = request.getResourceName(); [EOL] if (resourceName.equals("*")) { [EOL] anyRequestCount++; [EOL] } else if (resourceName.equals("/default-rack")) { [EOL] rackRequestCount++; [EOL] } else { [EOL] nodeRequestCount++; [EOL] } [EOL] } [EOL] [EOL] Assert.assertEquals(1, anyRequestCount); [EOL] Assert.assertEquals(1, rackRequestCount); [EOL] Assert.assertEquals(2, nodeRequestCount); [EOL] [EOL] containerSimulators.clear(); [EOL] s1 = new ContainerSimulator(resource, 100, [EOL] "/default-rack/h1", priority, type, execType, 1, 0); [EOL] s2 = new ContainerSimulator(resource, 100, [EOL] "/default-rack/h1", priority, type, execType, 2, 0); [EOL] s3 = new ContainerSimulator(resource, 100, [EOL] "/default-rack/h2", priority, type, execType, 1, 0); [EOL] [EOL] containerSimulators.add(s1); [EOL] containerSimulators.add(s2); [EOL] containerSimulators.add(s3); [EOL] [EOL] res = app.packageRequests(containerSimulators, priority); [EOL] [EOL] // total 7 resource requests: any -> 2, rack -> 2, node -> 3 [EOL] // All resource requests for any would be packaged into 2 as there are [EOL] // two different allocation id. [EOL] // All resource requests for racks would be packaged into 2 as all of them [EOL] // are for same rack but for two different allocation id. [EOL] // All resource requests for nodes would be packaged into 3 as either node [EOL] // or allocation id is different for each request. [EOL] Assert.assertEquals(7, res.size()); [EOL] [EOL] anyRequestCount = 0; [EOL] rackRequestCount = 0; [EOL] nodeRequestCount = 0; [EOL] [EOL] for (ResourceRequest request : res) { [EOL] String resourceName = request.getResourceName(); [EOL] long allocationId = request.getAllocationRequestId(); [EOL] // allocation id should be either 1 or 2 [EOL] Assert.assertTrue(allocationId == 1 || allocationId == 2); [EOL] if (resourceName.equals("*")) { [EOL] anyRequestCount++; [EOL] } else if (resourceName.equals("/default-rack")) { [EOL] rackRequestCount++; [EOL] } else { [EOL] nodeRequestCount++; [EOL] } [EOL] } [EOL] [EOL] Assert.assertEquals(2, anyRequestCount); [EOL] Assert.assertEquals(2, rackRequestCount); [EOL] Assert.assertEquals(3, nodeRequestCount); [EOL] } [EOL] private ResourceManager rm; [EOL] private YarnConfiguration conf; [EOL] private Path metricOutputDir; [EOL] private Class<?> slsScheduler; [EOL] private Class<?> scheduler; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetArrayStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer(); [EOL]       standardToStringStyle0.appendCyclicObject(stringBuffer0, (String) null, stringBuffer0); [EOL]       assertEquals("{", standardToStringStyle0.getArrayStart()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseShortClassName()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer("lg?3caGG41[$\"tg!|"); [EOL]       standardToStringStyle0.DEFAULT_STYLE.appendDetail(stringBuffer0, (String) null, true); [EOL]       assertFalse(standardToStringStyle0.isUseShortClassName()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((String) null); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator((String) null, (String) null); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]       assertEquals(0, strBuilder1.size()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(0.0); [EOL]       assertEquals(4, strBuilder0.size()); [EOL]       assertEquals(4, strBuilder1.size()); [EOL]       assertEquals(4, strBuilder2.size()); [EOL]        [EOL]       int int0 = 556; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.substring(821, 556); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testof()  throws Throwable  { [EOL]       MutableTriple<String, Integer, String> mutableTriple0 = new MutableTriple<String, Integer, String>(); [EOL]       mutableTriple0.setLeft("wo?ME"); [EOL]       MutableTriple<Object, Object, Object> mutableTriple1 = new MutableTriple<Object, Object, Object>(); [EOL]       Integer integer0 = new Integer((-3184)); [EOL]       ImmutableTriple<Integer, Object, String> immutableTriple0 = ImmutableTriple.of(integer0, (Object) null, "wo?ME"); [EOL]       ImmutableTriple<Object, ImmutableTriple<Integer, Object, String>, Triple<Object, Object, Object>> immutableTriple1 = new ImmutableTriple<Object, ImmutableTriple<Integer, Object, String>, Triple<Object, Object, Object>>("wo?ME", immutableTriple0, mutableTriple1); [EOL]       boolean boolean0 = immutableTriple1.equals(mutableTriple0); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseFieldNames()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.setUseFieldNames(false); [EOL]       boolean boolean0 = standardToStringStyle0.isUseFieldNames(); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("0rn@[CM"); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) strTokenizer0, "0rn@[CM"); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '\\'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(charArray0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertEquals(160, strBuilder0.capacity()); [EOL]       assertEquals(160, strBuilder1.capacity()); [EOL]       assertEquals(160, strBuilder2.capacity()); [EOL]       assertEquals(160, strBuilder3.capacity()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.setLength(2822); [EOL]       assertEquals(5644, strBuilder0.capacity()); [EOL]       assertEquals(5644, strBuilder4.capacity()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder4; [EOL]       objectArray0[1] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) '\\'; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       StrBuilder strBuilder5 = strBuilder4.appendAll(objectArray0); [EOL]       assertEquals(5644, strBuilder0.capacity()); [EOL]       assertEquals(5644, strBuilder4.capacity()); [EOL]       assertEquals(5644, strBuilder5.capacity()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(strBuilder1, 0, 2822); [EOL]       assertEquals(11654, strBuilder0.capacity()); [EOL]       assertEquals(11654, strBuilder1.capacity()); [EOL]       assertEquals(11654, strBuilder6.capacity()); [EOL]        [EOL]       int int0 = strBuilder6.lastIndexOf("0rn@[CM"); [EOL]       assertEquals(11654, strBuilder0.capacity()); [EOL]       assertEquals(11654, strBuilder1.capacity()); [EOL]       assertEquals(11654, strBuilder6.capacity()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.append(false); [EOL]       assertEquals(11654, strBuilder7.capacity()); [EOL]       assertEquals(11654, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.appendln(1490.882886748184); [EOL]       assertEquals(11654, strBuilder0.capacity()); [EOL]       assertEquals(11654, strBuilder8.capacity()); [EOL]       assertEquals(11654, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder6.append(strBuilder3, 0, 2822); [EOL]       assertEquals(11654, strBuilder0.capacity()); [EOL]       assertEquals(11654, strBuilder9.capacity()); [EOL]       assertEquals(11654, strBuilder1.capacity()); [EOL]       assertEquals(11654, strBuilder2.capacity()); [EOL]       assertEquals(11654, strBuilder3.capacity()); [EOL]       assertEquals(11654, strBuilder6.capacity()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder5.new StrBuilderReader(); [EOL]       assertEquals(11654, strBuilder0.capacity()); [EOL]       assertEquals(11654, strBuilder4.capacity()); [EOL]       assertEquals(11654, strBuilder5.capacity()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder_StrBuilderReader0.read(charArray0, (-2133), (-915)); [EOL]         fail("Expecting exception: IndexOutOfBoundsException"); [EOL]        [EOL]       } catch(IndexOutOfBoundsException e) { [EOL]          // [EOL]          // no message in exception (getMessage() returned null) [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder$StrBuilderReader", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testRetryUpToMaximumCountWithProportionalSleep() throws UnreliableException { [EOL] UnreliableInterface unreliable = (UnreliableInterface) [EOL] RetryProxy.create(UnreliableInterface.class, unreliableImpl, [EOL] retryUpToMaximumCountWithProportionalSleep(8, 1, TimeUnit.NANOSECONDS)); [EOL] unreliable.alwaysSucceeds(); [EOL] unreliable.failsOnceThenSucceeds(); [EOL] try { [EOL] unreliable.failsTenTimesThenSucceeds(); [EOL] fail("Should fail"); [EOL] } catch (UnreliableException e) { [EOL] // expected [EOL] } [EOL] } [EOL] private UnreliableImplementation unreliableImpl; [EOL] private RetryAction caughtRetryAction = null; [EOL]
@Test [EOL] public void testSiteLocalityThresholdConversion() { [EOL] yarnConfig.set(FairSchedulerConfiguration.LOCALITY_THRESHOLD_NODE, [EOL] "123.123"); [EOL] yarnConfig.set(FairSchedulerConfiguration.LOCALITY_THRESHOLD_RACK, [EOL] "321.321"); [EOL] [EOL] converter.convertSiteProperties(yarnConfig, yarnConvertedConfig, false, [EOL] false); [EOL] [EOL] assertEquals("Locality threshold node", "123.123", [EOL] yarnConvertedConfig.get( [EOL] CapacitySchedulerConfiguration.NODE_LOCALITY_DELAY)); [EOL] assertEquals("Locality threshold rack", "321.321", [EOL] yarnConvertedConfig.get( [EOL] CapacitySchedulerConfiguration.RACK_LOCALITY_ADDITIONAL_DELAY)); [EOL] } [EOL] private Configuration yarnConfig; [EOL] private FSYarnSiteConverter converter; [EOL] private Configuration yarnConvertedConfig; [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getArrayEnd(); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtStart()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFilterFileSystem() throws Exception { [EOL] int errors = 0; [EOL] for (Method m : FileSystem.class.getDeclaredMethods()) { [EOL] if (Modifier.isStatic(m.getModifiers()) || [EOL] Modifier.isPrivate(m.getModifiers()) || [EOL] Modifier.isFinal(m.getModifiers())) { [EOL] continue; [EOL] } [EOL] try { [EOL] MustNotImplement.class.getMethod(m.getName(), m.getParameterTypes()); [EOL] try { [EOL] FilterFileSystem.class.getDeclaredMethod(m.getName(), [EOL] m.getParameterTypes()); [EOL] LOG.error("FilterFileSystem MUST NOT implement " + m); [EOL] errors++; [EOL] } catch (NoSuchMethodException ex) { [EOL] // Expected [EOL] } [EOL] } catch (NoSuchMethodException exc) { [EOL] try{ [EOL] FilterFileSystem.class.getDeclaredMethod(m.getName(), m.getParameterTypes()); [EOL] } catch(NoSuchMethodException exc2){ [EOL] LOG.error("FilterFileSystem MUST implement " + m); [EOL] errors++; [EOL] } [EOL] } [EOL] } [EOL] assertTrue((errors + " methods were not overridden correctly - see" + [EOL] " log"), errors <= 0); [EOL] } [EOL] private static final Log LOG = FileSystem.LOG; [EOL] private static final Configuration conf = new Configuration(); [EOL]
@Test [EOL] public void testOnlyCPU() throws Exception { [EOL] String value = "1024vcores"; [EOL] expectUnparsableResource(value); [EOL] parseResourceConfigValue(value); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((-890)); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append("$Ps-)|ysy>r47^"); [EOL]       assertEquals(14, strBuilder0.size()); [EOL]       assertEquals(14, strBuilder1.size()); [EOL]        [EOL]       Object[] objectArray0 = new Object[6]; [EOL]       objectArray0[0] = (Object) strBuilder1; [EOL]       objectArray0[1] = (Object) "$Ps-)|ysy>r47^"; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder0; [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer(); [EOL]       assertEquals(14, strBuilder0.size()); [EOL]       assertEquals(14, strBuilder1.size()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer1 = (StrBuilder.StrBuilderTokenizer)strBuilder_StrBuilderTokenizer0.clone(); [EOL]       assertEquals(14, strBuilder0.size()); [EOL]       assertEquals(14, strBuilder1.size()); [EOL]        [EOL]       objectArray0[4] = (Object) strBuilder_StrBuilderTokenizer1; [EOL]       objectArray0[5] = (Object) "$Ps-)|ysy>r47^"; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendWithSeparators(objectArray0, "$Ps-)|ysy>r47^"); [EOL]       assertEquals(427, strBuilder0.size()); [EOL]       assertEquals(427, strBuilder1.size()); [EOL]       assertEquals(427, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(4, (float) 4); [EOL]       assertEquals(430, strBuilder0.size()); [EOL]       assertEquals(430, strBuilder1.size()); [EOL]       assertEquals(430, strBuilder2.size()); [EOL]       assertEquals(430, strBuilder3.size()); [EOL]        [EOL]       String string0 = strBuilder1.midString((-3719), 97); [EOL]       assertEquals(430, strBuilder0.size()); [EOL]       assertEquals(430, strBuilder1.size()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCustomResourceRequestedUnitIsGreaterThanAvailableUnit() [EOL] throws InvalidResourceRequestException { [EOL] Resource requestedResource = [EOL] ResourceTypesTestHelper.newResource(1, 1, [EOL] ImmutableMap.of("custom-resource-1", "1M")); [EOL] [EOL] Resource availableResource = ResourceTypesTestHelper.newResource(1, 1, [EOL] ImmutableMap.<String, String>builder().put("custom-resource-1", [EOL] "120k") [EOL] .build()); [EOL] [EOL] exception.expect(InvalidResourceRequestException.class); [EOL] exception.expectMessage(InvalidResourceRequestExceptionMessageGenerator [EOL] .create().withRequestedResourceType("custom-resource-1") [EOL] .withRequestedResource(requestedResource) [EOL] .withAvailableAllocation(availableResource) [EOL] .withMaxAllocation(configuredMaxAllocation) [EOL] .withInvalidResourceType(GREATER_THEN_MAX_ALLOCATION) [EOL] .build()); [EOL] SchedulerUtils.checkResourceRequestAgainstAvailableResource( [EOL] requestedResource, availableResource); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestSchedulerUtils.class); [EOL] private static Resource configuredMaxAllocation; [EOL] private RMContext rmContext = getMockRMContext(); [EOL] private static YarnConfiguration conf = new YarnConfiguration(); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test [EOL] public void processOptionsHeaderWithQuotas() { [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] options.add("-q"); [EOL] options.add("-v"); [EOL] options.add("dummy"); [EOL] [EOL] PrintStream out = mock(PrintStream.class); [EOL] [EOL] Count count = new Count(); [EOL] count.out = out; [EOL] [EOL] count.processOptions(options); [EOL] [EOL] String withQuotasHeader = [EOL] // <----12----> <-----15------> <-----15------> <-----15------> [EOL] " QUOTA REM_QUOTA SPACE_QUOTA REM_SPACE_QUOTA " + [EOL] // <----12----> <----12----> <-------18-------> [EOL] " DIR_COUNT FILE_COUNT CONTENT_SIZE PATHNAME"; [EOL] verify(out).println(withQuotasHeader); [EOL] verifyNoMoreInteractions(out); [EOL] } [EOL] private static final String WITH_QUOTAS = "Content summary with quotas"; [EOL] private static final String NO_QUOTAS = "Content summary without quotas"; [EOL] private static final String HUMAN = "human: "; [EOL] private static final String BYTES = "bytes: "; [EOL] private static final String QUOTAS_AND_USAGE = "quotas and usage"; [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static FileStatus fileStat; [EOL]
@Test [EOL] public void testSetClientConfigDir() { [EOL] dockerRunCommand.setClientConfigDir(CLIENT_CONFIG_PATH); [EOL] assertEquals(CLIENT_CONFIG_PATH, StringUtils.join(",", [EOL] dockerRunCommand.getDockerCommandWithArguments().get("docker-config"))); [EOL] } [EOL] private DockerRunCommand dockerRunCommand; [EOL] private static final String CONTAINER_NAME = "foo"; [EOL] private static final String USER_ID = "user_id"; [EOL] private static final String IMAGE_NAME = "image_name"; [EOL] private static final String CLIENT_CONFIG_PATH = "/path/to/client.json"; [EOL]
@Test(timeout = 4000) [EOL]   public void testset()  throws Throwable  { [EOL]       char[] charArray0 = new char[9]; [EOL]       charArray0[0] = 'u'; [EOL]       charArray0[2] = 'B'; [EOL]       StrMatcher strMatcher0 = StrMatcher.trimMatcher(); [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(charArray0, strMatcher0, strMatcher0); [EOL]       strTokenizer0.next(); [EOL]       strTokenizer0.next(); [EOL]       StrTokenizer strTokenizer1 = strTokenizer0.setDelimiterChar('H'); [EOL]       assertSame(strTokenizer0, strTokenizer1); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testFallbackResultUnset() { [EOL] rule.setFallbackResult(null); [EOL] List<MappingRule> rules = ruleCreator.getMappingRules(description); [EOL] MappingRule mpr = rules.get(0); [EOL] assertEquals("Fallback result", MappingRuleResultType.SKIP, [EOL] mpr.getFallback().getResult()); [EOL] } [EOL] private static final String MATCH_ALL = "*"; [EOL] private static final String DEFAULT_QUEUE = "root.default"; [EOL] private static final String SECONDARY_GROUP = "users"; [EOL] private static final String PRIMARY_GROUP = "superuser"; [EOL] private static final String APPLICATION_NAME = "MapReduce"; [EOL] private static final String SPECIFIED_QUEUE = "root.users.hadoop"; [EOL] private static final String USER_NAME = "testuser"; [EOL] private MappingRuleCreator ruleCreator; [EOL] private VariableContext variableContext; [EOL] private MappingRulesDescription description; [EOL] private Rule rule; [EOL] @org.junit.Rule [EOL] public ExpectedException expected = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testhashCode()  throws Throwable  { [EOL]       HashCodeBuilder hashCodeBuilder0 = new HashCodeBuilder(Integer.MAX_VALUE, Integer.MAX_VALUE); [EOL]       HashCodeBuilder hashCodeBuilder1 = hashCodeBuilder0.append((short) (-1)); [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       objectArray0[0] = (Object) hashCodeBuilder1; [EOL]       objectArray0[1] = (Object) hashCodeBuilder0; [EOL]       objectArray0[2] = (Object) hashCodeBuilder0; [EOL]       Object object0 = new Object(); [EOL]       objectArray0[3] = object0; [EOL]       objectArray0[4] = (Object) hashCodeBuilder0; [EOL]       objectArray0[5] = (Object) hashCodeBuilder0; [EOL]       objectArray0[6] = (Object) hashCodeBuilder1; [EOL]       hashCodeBuilder1.append(objectArray0); [EOL]       assertEquals(0, (int)hashCodeBuilder0.build()); [EOL]       assertEquals(0, hashCodeBuilder0.toHashCode()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testExecutorPath() { [EOL] String containerExePath = PrivilegedOperationExecutor [EOL] .getContainerExecutorExecutablePath(nullConf); [EOL] [EOL] //In case HADOOP_YARN_HOME isn't set, CWD is used. If conf is null or [EOL] //NM_LINUX_CONTAINER_EXECUTOR_PATH is not set, then a defaultPath is [EOL] //constructed. [EOL] String yarnHomeEnvVar = System.getenv("HADOOP_YARN_HOME"); [EOL] String yarnHome = yarnHomeEnvVar != null ? yarnHomeEnvVar [EOL] : new File("").getAbsolutePath(); [EOL] String expectedPath = yarnHome + "/bin/container-executor"; [EOL] [EOL] Assert.assertEquals(expectedPath, containerExePath); [EOL] [EOL] containerExePath = PrivilegedOperationExecutor [EOL] .getContainerExecutorExecutablePath(emptyConf); [EOL] Assert.assertEquals(expectedPath, containerExePath); [EOL] [EOL] //if NM_LINUX_CONTAINER_EXECUTOR_PATH is set, this must be returned [EOL] expectedPath = customExecutorPath; [EOL] containerExePath = PrivilegedOperationExecutor [EOL] .getContainerExecutorExecutablePath(confWithExecutorPath); [EOL] Assert.assertEquals(expectedPath, containerExePath); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestPrivilegedOperationExecutor.class); [EOL] private String localDataDir; [EOL] private String customExecutorPath; [EOL] private Configuration nullConf = null; [EOL] private Configuration emptyConf; [EOL] private Configuration confWithExecutorPath; [EOL] private String cGroupTasksNone; [EOL] private String cGroupTasksInvalid; [EOL] private String cGroupTasks1; [EOL] private String cGroupTasks2; [EOL] private String cGroupTasks3; [EOL] private PrivilegedOperation opDisallowed; [EOL] private PrivilegedOperation opTasksNone; [EOL] private PrivilegedOperation opTasksInvalid; [EOL] private PrivilegedOperation opTasks1; [EOL] private PrivilegedOperation opTasks2; [EOL] private PrivilegedOperation opTasks3; [EOL]
@Test(timeout = 4000) [EOL]   public void testisSameInstant()  throws Throwable  { [EOL]       MockDate mockDate0 = new MockDate(362L); [EOL]       boolean boolean0 = DateUtils.isSameInstant((Date) mockDate0, (Date) mockDate0); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testUpdateYarnSysFS() throws Exception { [EOL] String user = System.getProperty("user.name"); [EOL] String appId="app-1"; [EOL] String spec=""; [EOL] Context ctx = mock(Context.class); [EOL] LinuxContainerExecutor lce = mock(LinuxContainerExecutor.class); [EOL] lce.updateYarnSysFS(ctx, user, appId, spec); [EOL] verify(lce, times(1)).updateYarnSysFS(ctx, user, appId, spec); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLinuxContainerExecutor.class); [EOL] private static File workSpace; [EOL] private LinuxContainerExecutor exec = null; [EOL] private String appSubmitter = null; [EOL] private LocalDirsHandlerService dirsHandler; [EOL] private Configuration conf; [EOL] private FileContext files; [EOL] private int id = 0; [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       assertTrue(equalsBuilder0.build()); [EOL]        [EOL]       boolean[] booleanArray0 = new boolean[6]; [EOL]       booleanArray0[0] = true; [EOL]       booleanArray0[1] = true; [EOL]       booleanArray0[2] = true; [EOL]       booleanArray0[3] = true; [EOL]       booleanArray0[4] = false; [EOL]       booleanArray0[5] = false; [EOL]       boolean[] booleanArray1 = new boolean[2]; [EOL]       booleanArray1[0] = false; [EOL]       booleanArray1[1] = true; [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(booleanArray0, booleanArray1); [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.appendSuper(true); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append(false, true); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append(1865, 1865); [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append((double) 1865, (double) 1865); [EOL]       EqualsBuilder equalsBuilder6 = equalsBuilder5.append((long) 1865, (long) 1865); [EOL]   } [EOL]  [EOL]
@Test(timeout = 60000) [EOL] public void testRequestWithInvalidKerberosAuthorization() throws Exception { [EOL] String token = new Base64(0).encodeToString(new byte[]{0, 1, 2}); [EOL] [EOL] HttpServletRequest request = Mockito.mock(HttpServletRequest.class); [EOL] HttpServletResponse response = Mockito.mock(HttpServletResponse.class); [EOL] [EOL] Mockito.when(request.getHeader(AUTHORIZATION_HEADER)).thenReturn( [EOL] NEGOTIATE + token); [EOL] [EOL] try { [EOL] handler.authenticate(request, response); [EOL] Assert.fail(); [EOL] } catch (AuthenticationException ex) { [EOL] // Expected [EOL] } catch (Exception ex) { [EOL] Assert.fail("Wrong exception :"+ex); [EOL] } [EOL] } [EOL] private KerberosSecurityTestcase krbTest = new KerberosSecurityTestcase(); [EOL] private MultiSchemeAuthenticationHandler handler; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNumerator()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.ONE; [EOL]       Fraction fraction1 = Fraction.getFraction((-1391.467789443829)); [EOL]       Fraction fraction2 = fraction0.subtract(fraction1); [EOL]       assertEquals((-3304736), fraction1.getNumerator()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMergesubtractTestNonNegative() throws PlanningException { [EOL] [EOL] // starting with default array example [EOL] TreeMap<Long, Resource> a = new TreeMap<>(); [EOL] TreeMap<Long, Resource> b = new TreeMap<>(); [EOL] [EOL] setupArrays(a, b); [EOL] [EOL] RLESparseResourceAllocation rleA = [EOL] new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] RLESparseResourceAllocation rleB = [EOL] new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] try { [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.subtractTestNonNegative, 0, 60); [EOL] fail(); [EOL] } catch (PlanningException pe) { [EOL] // Expected! [EOL] } [EOL] [EOL] // NOTE a is empty!! so the subtraction is implicitly considered negative [EOL] // and the test should fail [EOL] [EOL] a = new TreeMap<>(); [EOL] b = new TreeMap<>(); [EOL] b.put(11L, Resource.newInstance(5, 6)); [EOL] [EOL] rleA = new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] rleB = new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] try { [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.subtractTestNonNegative, 0, 60); [EOL] fail(); [EOL] } catch (PlanningException pe) { [EOL] // Expected! [EOL] } [EOL] [EOL] // Testing that the subtractTestNonNegative detects problems even if only [EOL] // one [EOL] // of the resource dimensions is "<0" [EOL] a.put(10L, Resource.newInstance(10, 5)); [EOL] b.put(11L, Resource.newInstance(5, 6)); [EOL] [EOL] rleA = new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] rleB = new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] try { [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.subtractTestNonNegative, 0, 60); [EOL] fail(); [EOL] } catch (PlanningException pe) { [EOL] // Expected! [EOL] } [EOL] [EOL] // try with reverse setting [EOL] a.put(10L, Resource.newInstance(5, 10)); [EOL] b.put(11L, Resource.newInstance(6, 5)); [EOL] [EOL] rleA = new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] rleB = new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] try { [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.subtractTestNonNegative, 0, 60); [EOL] fail(); [EOL] } catch (PlanningException pe) { [EOL] // Expected! [EOL] } [EOL] [EOL] // trying a case that should work [EOL] a.put(10L, Resource.newInstance(10, 6)); [EOL] b.put(11L, Resource.newInstance(5, 6)); [EOL] [EOL] rleA = new RLESparseResourceAllocation(a, new DefaultResourceCalculator()); [EOL] rleB = new RLESparseResourceAllocation(b, new DefaultResourceCalculator()); [EOL] [EOL] RLESparseResourceAllocation out = [EOL] RLESparseResourceAllocation.merge(new DefaultResourceCalculator(), [EOL] Resource.newInstance(100 * 128 * 1024, 100 * 32), rleA, rleB, [EOL] RLEOperator.subtractTestNonNegative, 0, 60); [EOL] [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestRLESparseResourceAllocation.class); [EOL]
@Test [EOL] @TestDir [EOL] @TestJetty [EOL] @TestHdfs [EOL] public void testNoRedirectWithData() throws Exception { [EOL] createHttpFSServer(false, false); [EOL] [EOL] final String path = "/file"; [EOL] final String username = HadoopUsersConfTestHelper.getHadoopUsers()[0]; [EOL] // file creation which should not redirect [EOL] URL url = new URL(TestJettyHelper.getJettyURL(), [EOL] MessageFormat.format( [EOL] "/webhdfs/v1{0}?user.name={1}&op=CREATE&data=true&noredirect=true", [EOL] path, username)); [EOL] HttpURLConnection conn = (HttpURLConnection) url.openConnection(); [EOL] conn.setRequestMethod(HttpMethod.PUT); [EOL] conn.setRequestProperty("Content-Type", MediaType.APPLICATION_OCTET_STREAM); [EOL] conn.setDoOutput(true); [EOL] conn.connect(); [EOL] Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode()); [EOL] JSONObject json = (JSONObject) new JSONParser() [EOL] .parse(new InputStreamReader(conn.getInputStream())); [EOL] [EOL] // get the location to write [EOL] String location = (String) json.get("Location"); [EOL] Assert.assertTrue(location.contains(DataParam.NAME)); [EOL] Assert.assertTrue(location.contains("CREATE")); [EOL] url = new URL(location); [EOL] conn = (HttpURLConnection) url.openConnection(); [EOL] conn.setRequestMethod(HttpMethod.PUT); [EOL] conn.setRequestProperty("Content-Type", MediaType.APPLICATION_OCTET_STREAM); [EOL] conn.setDoOutput(true); [EOL] conn.connect(); [EOL] final String writeStr = "write some content"; [EOL] OutputStream os = conn.getOutputStream(); [EOL] os.write(writeStr.getBytes()); [EOL] os.close(); [EOL] // Verify that file got created [EOL] Assert.assertEquals(HttpURLConnection.HTTP_CREATED, conn.getResponseCode()); [EOL] json = (JSONObject) new JSONParser() [EOL] .parse(new InputStreamReader(conn.getInputStream())); [EOL] location = (String) json.get("Location"); [EOL] Assert.assertEquals(TestJettyHelper.getJettyURL() + "/webhdfs/v1" + path, [EOL] location); [EOL] } [EOL]
@Test (timeout = 30000) [EOL] public void testCwdContents() throws Exception { [EOL] String dirString = Path.CUR_DIR; [EOL] PathData item = new PathData(dirString, conf); [EOL] PathData[] items = item.getDirectoryContents(); [EOL] assertEquals( [EOL] sortedString("d1", "d2"), [EOL] sortedString(items) [EOL] ); [EOL] } [EOL] private static final String TEST_ROOT_DIR = [EOL] GenericTestUtils.getTestDir("testPD").getAbsolutePath(); [EOL] protected Configuration conf; [EOL] protected FileSystem fs; [EOL] protected Path testDir; [EOL]
@Test(timeout = 4000) [EOL] public void testSendMapCount() throws Exception { [EOL] final List<ShuffleHandler.ReduceMapFileCount> listenerList = [EOL] new ArrayList<ShuffleHandler.ReduceMapFileCount>(); [EOL] [EOL] final ChannelHandlerContext mockCtx = [EOL] mock(ChannelHandlerContext.class); [EOL] final MessageEvent mockEvt = mock(MessageEvent.class); [EOL] final Channel mockCh = mock(AbstractChannel.class); [EOL] final ChannelPipeline mockPipeline = mock(ChannelPipeline.class); [EOL] [EOL] // Mock HttpRequest and ChannelFuture [EOL] final HttpRequest mockHttpRequest = createMockHttpRequest(); [EOL] final ChannelFuture mockFuture = createMockChannelFuture(mockCh, [EOL] listenerList); [EOL] final ShuffleHandler.TimeoutHandler timerHandler = [EOL] new ShuffleHandler.TimeoutHandler(); [EOL] [EOL] // Mock Netty Channel Context and Channel behavior [EOL] Mockito.doReturn(mockCh).when(mockCtx).getChannel(); [EOL] when(mockCh.getPipeline()).thenReturn(mockPipeline); [EOL] when(mockPipeline.get( [EOL] Mockito.any(String.class))).thenReturn(timerHandler); [EOL] when(mockCtx.getChannel()).thenReturn(mockCh); [EOL] Mockito.doReturn(mockFuture).when(mockCh).write(Mockito.any(Object.class)); [EOL] when(mockCh.write(Object.class)).thenReturn(mockFuture); [EOL] [EOL] //Mock MessageEvent behavior [EOL] Mockito.doReturn(mockCh).when(mockEvt).getChannel(); [EOL] when(mockEvt.getChannel()).thenReturn(mockCh); [EOL] Mockito.doReturn(mockHttpRequest).when(mockEvt).getMessage(); [EOL] [EOL] final ShuffleHandler sh = new MockShuffleHandler(); [EOL] Configuration conf = new Configuration(); [EOL] sh.init(conf); [EOL] sh.start(); [EOL] int maxOpenFiles =conf.getInt(ShuffleHandler.SHUFFLE_MAX_SESSION_OPEN_FILES, [EOL] ShuffleHandler.DEFAULT_SHUFFLE_MAX_SESSION_OPEN_FILES); [EOL] sh.getShuffle(conf).messageReceived(mockCtx, mockEvt); [EOL] assertTrue("Number of Open files should not exceed the configured " + [EOL] "value!-Not Expected", [EOL] listenerList.size() <= maxOpenFiles); [EOL] while(!listenerList.isEmpty()) { [EOL] listenerList.remove(0).operationComplete(mockFuture); [EOL] assertTrue("Number of Open files should not exceed the configured " + [EOL] "value!-Not Expected", [EOL] listenerList.size() <= maxOpenFiles); [EOL] } [EOL] sh.close(); [EOL] } [EOL] static final long MiB = 1024 * 1024; [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestShuffleHandler.class); [EOL] private static final File ABS_LOG_DIR = GenericTestUtils.getTestDir( [EOL] TestShuffleHandler.class.getSimpleName() + "LocDir"); [EOL]
@Test(timeout = 30000) [EOL] public void testDeleteSnapshot() throws Exception { [EOL] Path snapRootPath = new Path("/snapPath"); [EOL] Path chRootedSnapRootPath = new Path( [EOL] Path.getPathWithoutSchemeAndAuthority(chrootedTo), "snapPath"); [EOL] AbstractFileSystem baseFs = Mockito.spy(fc.getDefaultFileSystem()); [EOL] ChRootedFs chRootedFs = new ChRootedFs(baseFs, chrootedTo); [EOL] Mockito.doNothing().when(baseFs) [EOL] .deleteSnapshot(chRootedSnapRootPath, "snap1"); [EOL] chRootedFs.deleteSnapshot(snapRootPath, "snap1"); [EOL] Mockito.verify(baseFs).deleteSnapshot(chRootedSnapRootPath, "snap1"); [EOL] } [EOL] FileContextTestHelper fileContextTestHelper = new FileContextTestHelper(); [EOL] FileContext fc; [EOL] FileContext fcTarget; [EOL] Path chrootedTo; [EOL]
@Test [EOL] public void testGracefulDecommissionDefaultTimeoutResolution() [EOL] throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, excludeHostXmlFile [EOL] .getAbsolutePath()); [EOL] [EOL] writeToHostsXmlFile(excludeHostXmlFile, Pair.of("", null)); [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] [EOL] int nodeMemory = 1024; [EOL] MockNM nm1 = rm.registerNode("host1:1234", nodeMemory); [EOL] MockNM nm2 = rm.registerNode("host2:5678", nodeMemory); [EOL] MockNM nm3 = rm.registerNode("host3:9101", nodeMemory); [EOL] [EOL] NodeHeartbeatResponse nodeHeartbeat1 = nm1.nodeHeartbeat(true); [EOL] NodeHeartbeatResponse nodeHeartbeat2 = nm2.nodeHeartbeat(true); [EOL] NodeHeartbeatResponse nodeHeartbeat3 = nm3.nodeHeartbeat(true); [EOL] [EOL] Assert.assertTrue( [EOL] NodeAction.NORMAL.equals(nodeHeartbeat1.getNodeAction())); [EOL] Assert.assertTrue( [EOL] NodeAction.NORMAL.equals(nodeHeartbeat2.getNodeAction())); [EOL] Assert.assertTrue( [EOL] NodeAction.NORMAL.equals(nodeHeartbeat3.getNodeAction())); [EOL] [EOL] rm.waitForState(nm1.getNodeId(), NodeState.RUNNING); [EOL] rm.waitForState(nm2.getNodeId(), NodeState.RUNNING); [EOL] rm.waitForState(nm3.getNodeId(), NodeState.RUNNING); [EOL] [EOL] // Graceful decommission both host1 and host2, with [EOL] // non default timeout for host1 [EOL] final Integer nm1DecommissionTimeout = 20; [EOL] writeToHostsXmlFile( [EOL] excludeHostXmlFile, [EOL] Pair.of(nm1.getNodeId().getHost(), nm1DecommissionTimeout), [EOL] Pair.of(nm2.getNodeId().getHost(), null)); [EOL] rm.getNodesListManager().refreshNodes(conf, true); [EOL] rm.waitForState(nm1.getNodeId(), NodeState.DECOMMISSIONING); [EOL] rm.waitForState(nm2.getNodeId(), NodeState.DECOMMISSIONING); [EOL] Assert.assertEquals( [EOL] nm1DecommissionTimeout, rm.getDecommissioningTimeout(nm1.getNodeId())); [EOL] Integer defaultDecTimeout = [EOL] conf.getInt(YarnConfiguration.RM_NODE_GRACEFUL_DECOMMISSION_TIMEOUT, [EOL] YarnConfiguration.DEFAULT_RM_NODE_GRACEFUL_DECOMMISSION_TIMEOUT); [EOL] Assert.assertEquals( [EOL] defaultDecTimeout, rm.getDecommissioningTimeout(nm2.getNodeId())); [EOL] [EOL] // Graceful decommission host3 with a new default timeout [EOL] final Integer newDefaultDecTimeout = defaultDecTimeout + 10; [EOL] writeToHostsXmlFile( [EOL] excludeHostXmlFile, Pair.of(nm3.getNodeId().getHost(), null)); [EOL] conf.setInt(YarnConfiguration.RM_NODE_GRACEFUL_DECOMMISSION_TIMEOUT, [EOL] newDefaultDecTimeout); [EOL] rm.getNodesListManager().refreshNodes(conf, true); [EOL] rm.waitForState(nm3.getNodeId(), NodeState.DECOMMISSIONING); [EOL] Assert.assertEquals( [EOL] newDefaultDecTimeout, rm.getDecommissioningTimeout(nm3.getNodeId())); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.mid("", 64, 64); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[9]; [EOL]       charSequenceArray0[0] = (CharSequence) ""; [EOL]       charSequenceArray0[1] = (CharSequence) ""; [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       charSequenceArray0[3] = (CharSequence) ""; [EOL]       charSequenceArray0[4] = (CharSequence) ""; [EOL]       charSequenceArray0[5] = (CharSequence) ""; [EOL]       charSequenceArray0[6] = (CharSequence) ""; [EOL]       charSequenceArray0[7] = (CharSequence) ""; [EOL]       String string1 = StringUtils.substringAfter("r", ""); [EOL]        [EOL]       charSequenceArray0[8] = (CharSequence) "r"; [EOL]       boolean boolean0 = StringUtils.endsWithAny("", charSequenceArray0); [EOL]       assertEquals(9, charSequenceArray0.length); [EOL]        [EOL]       boolean boolean1 = StringUtils.equals(charSequenceArray0[1], (CharSequence) ""); [EOL]       assertEquals(9, charSequenceArray0.length); [EOL]        [EOL]       int[] intArray0 = new int[8]; [EOL]       intArray0[0] = 64; [EOL]       intArray0[1] = 64; [EOL]       intArray0[2] = 64; [EOL]       intArray0[3] = 64; [EOL]       intArray0[4] = 64; [EOL]       intArray0[5] = 64; [EOL]       intArray0[6] = 64; [EOL]       intArray0[7] = 1076; [EOL]       String string2 = StringUtils.join(intArray0, 'q', 0, (-385)); [EOL]       assertEquals(8, intArray0.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNoFilter() throws Exception { [EOL] GetCompInstancesRequestProto req = GetCompInstancesRequestProto.newBuilder() [EOL] .build(); [EOL] List<ComponentContainers> compContainers = FilterUtils.filterInstances( [EOL] new MockRunningServiceContext(rule, [EOL] TestServiceManager.createBaseDef("service")), req); [EOL] Assert.assertEquals("num comps", 2, compContainers.size()); [EOL] compContainers.forEach(item -> { [EOL] Assert.assertEquals("num containers", 2, item.getContainers().size()); [EOL] }); [EOL] } [EOL] @Rule [EOL] public ServiceTestUtils.ServiceFSWatcher rule = [EOL] new ServiceTestUtils.ServiceFSWatcher(); [EOL]
@Test [EOL] public void testEncrypt() throws Exception { [EOL] System.out.println("encrypt"); [EOL] String str = "test"; [EOL] DefaultCryptor instance = new DefaultCryptor(); [EOL] String expResult = "test"; [EOL] String result =instance.decrypt(instance.encrypt(str)); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]        [EOL]       float[] floatArray0 = new float[7]; [EOL]       floatArray0[0] = 3863.3088F; [EOL]       floatArray0[1] = 0.0F; [EOL]       floatArray0[2] = 0.0F; [EOL]       floatArray0[3] = (-1268.2902F); [EOL]       floatArray0[4] = (-3025.2256F); [EOL]       floatArray0[5] = 0.0F; [EOL]       floatArray0[6] = 885.884F; [EOL]       float[] floatArray1 = new float[7]; [EOL]       floatArray1[0] = 885.884F; [EOL]       floatArray1[1] = 3863.3088F; [EOL]       floatArray1[2] = 0.0F; [EOL]       floatArray1[3] = 0.0F; [EOL]       floatArray1[4] = (-3025.2256F); [EOL]       floatArray1[5] = (-3025.2256F); [EOL]       floatArray1[6] = 3863.3088F; [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(floatArray0, floatArray1); [EOL]       char[] charArray0 = new char[0]; [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append(charArray0, charArray0); [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append(false, false); [EOL]       short[] shortArray0 = new short[8]; [EOL]       shortArray0[0] = (short) (-4493); [EOL]       shortArray0[1] = (short)1200; [EOL]       shortArray0[2] = (short)430; [EOL]       shortArray0[3] = (short)543; [EOL]       shortArray0[4] = (short)4401; [EOL]       shortArray0[5] = (short)3602; [EOL]       shortArray0[6] = (short) (-1); [EOL]       shortArray0[7] = (short)0; [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append(shortArray0, shortArray0); [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append((float) (short)543, 3024.4634F); [EOL]       long[] longArray0 = new long[2]; [EOL]       longArray0[0] = (long) (short)4401; [EOL]       longArray0[1] = (long) (short) (-1); [EOL]       equalsBuilder5.append(longArray0, longArray0); [EOL]       assertFalse(equalsBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testTypeUnset() { [EOL] rule.setType(null); [EOL] [EOL] expected.expect(IllegalArgumentException.class); [EOL] expected.expectMessage("Rule type is undefined"); [EOL] [EOL] ruleCreator.getMappingRules(description); [EOL] } [EOL] private static final String MATCH_ALL = "*"; [EOL] private static final String DEFAULT_QUEUE = "root.default"; [EOL] private static final String SECONDARY_GROUP = "users"; [EOL] private static final String PRIMARY_GROUP = "superuser"; [EOL] private static final String APPLICATION_NAME = "MapReduce"; [EOL] private static final String SPECIFIED_QUEUE = "root.users.hadoop"; [EOL] private static final String USER_NAME = "testuser"; [EOL] private MappingRuleCreator ruleCreator; [EOL] private VariableContext variableContext; [EOL] private MappingRulesDescription description; [EOL] private Rule rule; [EOL] @org.junit.Rule [EOL] public ExpectedException expected = ExpectedException.none(); [EOL]
@Test [EOL] public void testHashCode() { [EOL] TaskType[] types = TaskType.values(); [EOL] [EOL] for (int i = 0; i < types.length; i++) { [EOL] JobID jobId = new JobID("1234" + i, i); [EOL] TaskID taskId1 = new TaskID(jobId, types[i], i); [EOL] TaskID taskId2 = new TaskID(jobId, types[i], i); [EOL] [EOL] assertTrue("The hashcode() method gave unequal hash codes for two equal " [EOL] + "task IDs", taskId1.hashCode() == taskId2.hashCode()); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testUpdateSocketAddress() throws IOException { [EOL] InetSocketAddress addr = NetUtils.createSocketAddrForHost("host", 1); [EOL] InetSocketAddress connectAddr = conf.updateConnectAddr("myAddress", addr); [EOL] assertEquals(connectAddr.getHostName(), addr.getHostName()); [EOL] [EOL] addr = new InetSocketAddress(1); [EOL] connectAddr = conf.updateConnectAddr("myAddress", addr); [EOL] assertEquals(connectAddr.getHostName(), [EOL] InetAddress.getLocalHost().getHostName()); [EOL] } [EOL] @Rule [EOL] public ExpectedException thrown= ExpectedException.none(); [EOL] private static final double DOUBLE_DELTA = 0.000000001f; [EOL] private Configuration conf; [EOL] final static String CONFIG = new File("./test-config-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG2 = new File("./test-config2-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG_CORE = new File("./core-site.xml") [EOL] .getAbsolutePath(); [EOL] final static String CONFIG_FOR_ENUM = new File("./test-config-enum-TestConfiguration.xml").getAbsolutePath(); [EOL] final static String CONFIG_FOR_URI = new File( [EOL] "./test-config-uri-TestConfiguration.xml").toURI().toString(); [EOL] private static final String CONFIG_MULTI_BYTE = new File( [EOL] "./test-config-multi-byte-TestConfiguration.xml").getAbsolutePath(); [EOL] private static final String CONFIG_MULTI_BYTE_SAVED = new File( [EOL] "./test-config-multi-byte-saved-TestConfiguration.xml").getAbsolutePath(); [EOL] final static Random RAN = new Random(); [EOL] final static String XMLHEADER = [EOL] IBM_JAVA?"<?xml version=\"1.0\" encoding=\"UTF-8\"?><configuration>": [EOL] "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><configuration>"; [EOL] public static final String ESCAPED = "&apos;&#39;&#0039;&#x27;"; [EOL] private static final String SENSITIVE_CONFIG_KEYS = [EOL] CommonConfigurationKeysPublic.HADOOP_SECURITY_SENSITIVE_CONFIG_KEYS; [EOL] private BufferedWriter out; [EOL] ArrayList<Prop> props = new ArrayList<Prop>(); [EOL]
@Test(timeout=120000) [EOL] public void testRandomDouble() throws Exception { [EOL] OsSecureRandom random = getOsSecureRandom(); [EOL] [EOL] double rand1 = random.nextDouble(); [EOL] double rand2 = random.nextDouble(); [EOL] while (rand1 == rand2) { [EOL] rand2 = random.nextDouble(); [EOL] } [EOL] random.close(); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testfloatValue()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.ONE; [EOL]       Fraction fraction1 = fraction0.negate(); [EOL]       assertEquals((-1.0F), fraction1.floatValue(), 0.01F); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPositiveStartandFinishTimes() { [EOL] long elapsed = Times.elapsed(5, 10, true); [EOL] Assert.assertEquals("Elapsed time is not 5", 5, elapsed); [EOL] elapsed = Times.elapsed(5, 10, false); [EOL] Assert.assertEquals("Elapsed time is not 5", 5, elapsed); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       byte[] byteArray0 = ArrayUtils.toPrimitive((Byte[]) null, (byte)2); [EOL]       assertNull(byteArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsize()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((String) null); [EOL]       assertEquals(0, strBuilder0.size()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(false); [EOL]       assertEquals(5, strBuilder0.size()); [EOL]       assertEquals(5, strBuilder1.size()); [EOL]        [EOL]       int int0 = 32; [EOL]       int int1 = 8; [EOL]       char[] charArray0 = new char[4]; [EOL]       StrBuilder strBuilder2 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder2.size()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.appendln('}'); [EOL]       assertEquals(7, strBuilder0.size()); [EOL]       assertEquals(7, strBuilder1.size()); [EOL]       assertEquals(7, strBuilder3.size()); [EOL]        [EOL]       int int2 = 0; [EOL]       String string0 = strBuilder3.substring(0); [EOL]       assertEquals(7, strBuilder0.size()); [EOL]       assertEquals(7, strBuilder1.size()); [EOL]       assertEquals(7, strBuilder3.size()); [EOL]        [EOL]       int int3 = strBuilder2.indexOf((StrMatcher) null, 8); [EOL]       assertEquals(0, strBuilder2.size()); [EOL]        [EOL]       charArray0[0] = '\"'; [EOL]       charArray0[1] = 'b'; [EOL]       char char0 = 'S'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.validateIndex(8); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 8 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMultiplication() { [EOL] for(int i = 0; i < 100; i++) { [EOL] final long a = nextPositiveLong(); [EOL] final long b = nextPositiveLong(); [EOL] verifyMultiplication(a, b); [EOL] } [EOL] final long max = Long.MAX_VALUE & MASK; [EOL] verifyMultiplication(max, max); [EOL] } [EOL] static final Random RAN = new Random(); [EOL] static final long MASK = (1L << (LongLong.SIZE >> 1)) - 1; [EOL]
@Test(expected = WebApplicationException.class) [EOL] public void testGeEndpointsByServiceJSON_NULL() { [EOL] System.out.println("geEndpointsByServiceJSON_NULL"); [EOL] String id = UUID.randomUUID().toString(); [EOL] [EOL] UriContainer expResult = null; [EOL] UriContainer result = instance.geEndpointsByServiceJSON(id); [EOL] [EOL] } [EOL] private final static String ENDPOINT_ADDRESS = "http://localhost:8080/rest"; [EOL] private final static String JUDDI_BIZ ="uddi:juddi.apache.org:node1"; [EOL] private final static String JUDDI_SVC = "uddi:juddi.apache.org:services-inquiry"; [EOL] private final static String JUDDI_BT = "uddi:juddi.apache.org:servicebindings-inquiry-ws"; [EOL] private final static String JUDDI_TMODEL = "uddi:uddi.org:transport:smtp"; [EOL] private final static String WADL_ADDRESS = ENDPOINT_ADDRESS + "?_wadl"; [EOL] private static Server server; [EOL] UDDIInquiryJAXRS instance = null; [EOL]
@Test (timeout=50000) [EOL] public void testMaxUnflushedCompletionEvents() throws Exception { [EOL] TestParams t = new TestParams(); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(MRJobConfig.MR_AM_STAGING_DIR, t.workDir); [EOL] conf.setLong(MRJobConfig.MR_AM_HISTORY_COMPLETE_EVENT_FLUSH_TIMEOUT_MS, [EOL] 60 * 1000l); [EOL] conf.setInt(MRJobConfig.MR_AM_HISTORY_JOB_COMPLETE_UNFLUSHED_MULTIPLIER, 10); [EOL] conf.setInt(MRJobConfig.MR_AM_HISTORY_MAX_UNFLUSHED_COMPLETE_EVENTS, 10); [EOL] conf.setInt( [EOL] MRJobConfig.MR_AM_HISTORY_USE_BATCHED_FLUSH_QUEUE_SIZE_THRESHOLD, 5); [EOL] [EOL] JHEvenHandlerForTest realJheh = [EOL] new JHEvenHandlerForTest(t.mockAppContext, 0); [EOL] JHEvenHandlerForTest jheh = spy(realJheh); [EOL] jheh.init(conf); [EOL] [EOL] EventWriter mockWriter = null; [EOL] try { [EOL] jheh.start(); [EOL] handleEvent(jheh, new JobHistoryEvent(t.jobId, new AMStartedEvent( [EOL] t.appAttemptId, 200, t.containerId, "nmhost", 3000, 4000, -1))); [EOL] mockWriter = jheh.getEventWriter(); [EOL] verify(mockWriter).write(any(HistoryEvent.class)); [EOL] [EOL] for (int i = 0 ; i < 100 ; i++) { [EOL] queueEvent(jheh, new JobHistoryEvent(t.jobId, new TaskFinishedEvent( [EOL] t.taskID, t.taskAttemptID, 0, TaskType.MAP, "", null, 0))); [EOL] } [EOL] [EOL] handleNextNEvents(jheh, 9); [EOL] verify(mockWriter, times(0)).flush(); [EOL] [EOL] handleNextNEvents(jheh, 1); [EOL] verify(mockWriter).flush(); [EOL] [EOL] handleNextNEvents(jheh, 50); [EOL] verify(mockWriter, times(6)).flush(); [EOL] [EOL] } finally { [EOL] jheh.stop(); [EOL] verify(mockWriter).close(); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestJobHistoryEventHandler.class); [EOL] private static MiniDFSCluster dfsCluster = null; [EOL] private static String coreSitePath; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("v"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       int int0 = 169; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendSeparator("v", 169); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[8]; [EOL]       charArray0[0] = 'O'; [EOL]       char char0 = '+'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.getChars(554, (-1433), charArray0, 554); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1433 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       Locale.Category locale_Category0 = Locale.Category.FORMAT; [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.insert(0, (Object) locale_Category0); [EOL]       assertEquals(72, strBuilder0.capacity()); [EOL]       assertEquals(72, strBuilder1.capacity()); [EOL]        [EOL]       char char0 = '\"'; [EOL]       StrBuilder strBuilder2 = strBuilder0.appendPadding(0, '\"'); [EOL]       assertEquals(72, strBuilder0.capacity()); [EOL]       assertEquals(72, strBuilder2.capacity()); [EOL]        [EOL]       char[] charArray0 = new char[6]; [EOL]       charArray0[0] = '\"'; [EOL]       charArray0[1] = '\"'; [EOL]       charArray0[2] = '\"'; [EOL]       charArray0[3] = '\"'; [EOL]       charArray0[4] = '\"'; [EOL]       charArray0[5] = '\"'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.append(charArray0, (-2049), 0); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // Invalid startIndex: 0 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer(0); [EOL]       Boolean boolean0 = Boolean.TRUE; [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.append(stringBuffer0, "org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle", (char[]) null, boolean0); [EOL]       assertEquals("<null>", standardToStringStyle0.getNullText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNoRetryOnSaslError() throws Exception { [EOL] RetryPolicy policy = mock(RetryPolicy.class); [EOL] RetryPolicy realPolicy = RetryPolicies.failoverOnNetworkException(5); [EOL] setupMockPolicy(policy, realPolicy); [EOL] [EOL] UnreliableInterface unreliable = (UnreliableInterface) RetryProxy.create( [EOL] UnreliableInterface.class, unreliableImpl, policy); [EOL] [EOL] try { [EOL] unreliable.failsWithSASLExceptionTenTimes(); [EOL] fail("Should fail"); [EOL] } catch (SaslException e) { [EOL] // expected [EOL] verify(policy, times(1)).shouldRetry(any(Exception.class), anyInt(), [EOL] anyInt(), anyBoolean()); [EOL] assertEquals(RetryDecision.FAIL, caughtRetryAction.action); [EOL] } [EOL] } [EOL] private UnreliableImplementation unreliableImpl; [EOL] private RetryAction caughtRetryAction = null; [EOL]
@Test [EOL] public void testSetCopyBufferSize() { [EOL] final DistCpOptions.Builder builder = new DistCpOptions.Builder( [EOL] Collections.singletonList(new Path("hdfs://localhost:8020/source")), [EOL] new Path("hdfs://localhost:8020/target/")); [EOL] [EOL] Assert.assertEquals(DistCpConstants.COPY_BUFFER_SIZE_DEFAULT, [EOL] builder.build().getCopyBufferSize()); [EOL] [EOL] builder.withCopyBufferSize(4194304); [EOL] Assert.assertEquals(4194304, [EOL] builder.build().getCopyBufferSize()); [EOL] [EOL] builder.withCopyBufferSize(-1); [EOL] Assert.assertEquals(DistCpConstants.COPY_BUFFER_SIZE_DEFAULT, [EOL] builder.build().getCopyBufferSize()); [EOL] } [EOL] private static final float DELTA = 0.001f; [EOL]
@Test(timeout = 10000) [EOL] @SuppressWarnings("unchecked") [EOL] public void testLocalResourceCache() { [EOL] String user = "testuser"; [EOL] DrainDispatcher dispatcher = null; [EOL] try { [EOL] Configuration conf = new Configuration(); [EOL] dispatcher = createDispatcher(conf); [EOL] [EOL] EventHandler<LocalizerEvent> localizerEventHandler = [EOL] mock(EventHandler.class); [EOL] EventHandler<ContainerEvent> containerEventHandler = [EOL] mock(EventHandler.class); [EOL] [EOL] // Registering event handlers. [EOL] dispatcher.register(LocalizerEventType.class, localizerEventHandler); [EOL] dispatcher.register(ContainerEventType.class, containerEventHandler); [EOL] [EOL] ConcurrentMap<LocalResourceRequest, LocalizedResource> localrsrc = [EOL] new ConcurrentHashMap<LocalResourceRequest, LocalizedResource>(); [EOL] LocalResourcesTracker tracker = [EOL] new LocalResourcesTrackerImpl(user, null, dispatcher, localrsrc, [EOL] true, conf, new NMNullStateStoreService(), null); [EOL] [EOL] LocalResourceRequest lr = [EOL] createLocalResourceRequest(user, 1, 1, LocalResourceVisibility.PUBLIC); [EOL] [EOL] // Creating 2 containers for same application which will be requesting [EOL] // same local resource. [EOL] // Container 1 requesting local resource. [EOL] ContainerId cId1 = BuilderUtils.newContainerId(1, 1, 1, 1); [EOL] LocalizerContext lc1 = new LocalizerContext(user, cId1, null); [EOL] ResourceEvent reqEvent1 = [EOL] new ResourceRequestEvent(lr, LocalResourceVisibility.PRIVATE, lc1); [EOL] [EOL] // No resource request is initially present in local cache [EOL] Assert.assertEquals(0, localrsrc.size()); [EOL] [EOL] // Container-1 requesting local resource. [EOL] tracker.handle(reqEvent1); [EOL] dispatcher.await(); [EOL] [EOL] // New localized Resource should have been added to local resource map [EOL] // and the requesting container will be added to its waiting queue. [EOL] Assert.assertEquals(1, localrsrc.size()); [EOL] Assert.assertTrue(localrsrc.containsKey(lr)); [EOL] Assert.assertEquals(1, localrsrc.get(lr).getRefCount()); [EOL] Assert.assertTrue(localrsrc.get(lr).ref.contains(cId1)); [EOL] Assert.assertEquals(ResourceState.DOWNLOADING, localrsrc.get(lr) [EOL] .getState()); [EOL] [EOL] // Container 2 requesting the resource [EOL] ContainerId cId2 = BuilderUtils.newContainerId(1, 1, 1, 2); [EOL] LocalizerContext lc2 = new LocalizerContext(user, cId2, null); [EOL] ResourceEvent reqEvent2 = [EOL] new ResourceRequestEvent(lr, LocalResourceVisibility.PRIVATE, lc2); [EOL] tracker.handle(reqEvent2); [EOL] dispatcher.await(); [EOL] [EOL] // Container 2 should have been added to the waiting queue of the local [EOL] // resource [EOL] Assert.assertEquals(2, localrsrc.get(lr).getRefCount()); [EOL] Assert.assertTrue(localrsrc.get(lr).ref.contains(cId2)); [EOL] [EOL] // Failing resource localization [EOL] ResourceEvent resourceFailedEvent = new ResourceFailedLocalizationEvent( [EOL] lr,(new Exception("test").getMessage())); [EOL] [EOL] // Backing up the resource to track its state change as it will be [EOL] // removed after the failed event. [EOL] LocalizedResource localizedResource = localrsrc.get(lr); [EOL] [EOL] tracker.handle(resourceFailedEvent); [EOL] dispatcher.await(); [EOL] [EOL] // After receiving failed resource event; all waiting containers will be [EOL] // notified with Container Resource Failed Event. [EOL] Assert.assertEquals(0, localrsrc.size()); [EOL] verify(containerEventHandler, timeout(1000).times(2)).handle( [EOL] isA(ContainerResourceFailedEvent.class)); [EOL] Assert.assertEquals(ResourceState.FAILED, localizedResource.getState()); [EOL] [EOL] // Container 1 trying to release the resource (This resource is already [EOL] // deleted from the cache. This call should return silently without [EOL] // exception. [EOL] ResourceReleaseEvent relEvent1 = new ResourceReleaseEvent(lr, cId1); [EOL] tracker.handle(relEvent1); [EOL] dispatcher.await(); [EOL] [EOL] // Container-3 now requests for the same resource. This request call [EOL] // is coming prior to Container-2's release call. [EOL] ContainerId cId3 = BuilderUtils.newContainerId(1, 1, 1, 3); [EOL] LocalizerContext lc3 = new LocalizerContext(user, cId3, null); [EOL] ResourceEvent reqEvent3 = [EOL] new ResourceRequestEvent(lr, LocalResourceVisibility.PRIVATE, lc3); [EOL] tracker.handle(reqEvent3); [EOL] dispatcher.await(); [EOL] [EOL] // Local resource cache now should have the requested resource and the [EOL] // number of waiting containers should be 1. [EOL] Assert.assertEquals(1, localrsrc.size()); [EOL] Assert.assertTrue(localrsrc.containsKey(lr)); [EOL] Assert.assertEquals(1, localrsrc.get(lr).getRefCount()); [EOL] Assert.assertTrue(localrsrc.get(lr).ref.contains(cId3)); [EOL] [EOL] // Container-2 Releases the resource [EOL] ResourceReleaseEvent relEvent2 = new ResourceReleaseEvent(lr, cId2); [EOL] tracker.handle(relEvent2); [EOL] dispatcher.await(); [EOL] [EOL] // Making sure that there is no change in the cache after the release. [EOL] Assert.assertEquals(1, localrsrc.size()); [EOL] Assert.assertTrue(localrsrc.containsKey(lr)); [EOL] Assert.assertEquals(1, localrsrc.get(lr).getRefCount()); [EOL] Assert.assertTrue(localrsrc.get(lr).ref.contains(cId3)); [EOL] [EOL] // Sending ResourceLocalizedEvent to tracker. In turn resource should [EOL] // send Container Resource Localized Event to waiting containers. [EOL] Path localizedPath = new Path("/tmp/file1"); [EOL] ResourceLocalizedEvent localizedEvent = [EOL] new ResourceLocalizedEvent(lr, localizedPath, 123L); [EOL] tracker.handle(localizedEvent); [EOL] dispatcher.await(); [EOL] [EOL] // Verifying ContainerResourceLocalizedEvent . [EOL] verify(containerEventHandler, timeout(1000).times(1)).handle( [EOL] isA(ContainerResourceLocalizedEvent.class)); [EOL] Assert.assertEquals(ResourceState.LOCALIZED, localrsrc.get(lr) [EOL] .getState()); [EOL] Assert.assertEquals(1, localrsrc.get(lr).getRefCount()); [EOL] [EOL] // Container-3 releasing the resource. [EOL] ResourceReleaseEvent relEvent3 = new ResourceReleaseEvent(lr, cId3); [EOL] tracker.handle(relEvent3); [EOL] dispatcher.await(); [EOL] [EOL] Assert.assertEquals(0, localrsrc.get(lr).getRefCount()); [EOL] [EOL] } finally { [EOL] if (dispatcher != null) { [EOL] dispatcher.stop(); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void testLocalJobRunnerRetryCount() throws InterruptedException { [EOL] int retryAttempts = 3; [EOL] JobStatus jobStatus = createTestJobStatus( [EOL] "job_20130313155005308_0001", JobStatus.SUCCEEDED); [EOL] JobConf jobConf = createTestJobConf( [EOL] new Configuration(), retryAttempts, baseUrl + "fail"); [EOL] JobEndNotifier.localRunnerNotification(jobConf, jobStatus); [EOL] [EOL] // Validate params [EOL] assertEquals(retryAttempts + 1, FailServlet.calledTimes); [EOL] } [EOL] HttpServer2 server; [EOL] URL baseUrl; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln("rn$e:"); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       Vector<String> vector0 = new Vector<String>(); [EOL]       assertTrue(vector0.isEmpty()); [EOL]        [EOL]       LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>(vector0); [EOL]       assertTrue(vector0.isEmpty()); [EOL]       assertTrue(linkedHashSet0.isEmpty()); [EOL]        [EOL]       TreeSet<Object> treeSet0 = new TreeSet<Object>(linkedHashSet0); [EOL]       assertTrue(vector0.isEmpty()); [EOL]       assertTrue(linkedHashSet0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendAll((Iterable<?>) treeSet0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertTrue(vector0.isEmpty()); [EOL]       assertTrue(linkedHashSet0.isEmpty()); [EOL]       assertFalse(strBuilder2.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.appendSeparator("rn$e:", 1); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StringBuffer stringBuffer0 = strBuilder0.toStringBuffer(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]        [EOL]       Integer[] integerArray0 = new Integer[5]; [EOL]       Integer integer0 = new Integer(1); [EOL]        [EOL]       integerArray0[0] = integer0; [EOL]       Integer integer1 = new Integer(862); [EOL]        [EOL]       integerArray0[1] = integer1; [EOL]       int int0 = 0; [EOL]       Integer integer2 = new Integer(0); [EOL]        [EOL]       integerArray0[2] = integer2; [EOL]       Integer integer3 = new Integer(862); [EOL]        [EOL]       integerArray0[3] = integer3; [EOL]       Integer integer4 = new Integer(int0); [EOL]        [EOL]       integerArray0[4] = integer4; [EOL]       StrBuilder strBuilder4 = strBuilder3.appendAll(integerArray0); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testPreemptionWithVCoreResource() { [EOL] int[][] qData = new int[][]{ [EOL] // / A B [EOL] {100, 100, 100}, // maxcap [EOL] {5, 1, 1}, // apps [EOL] {2, 0, 0}, // subqueues [EOL] }; [EOL] [EOL] // Resources can be set like memory:vcores [EOL] String[][] resData = new String[][]{ [EOL] // / A B [EOL] {"100:100", "50:50", "50:50"}, // abs [EOL] {"10:100", "10:100", "0"}, // used [EOL] {"70:20", "70:20", "10:100"}, // pending [EOL] {"0", "0", "0"}, // reserved [EOL] {"-1", "1:10", "1:10"}, // req granularity [EOL] }; [EOL] [EOL] // Passing last param as TRUE to use DominantResourceCalculator [EOL] ProportionalCapacityPreemptionPolicy policy = buildPolicy(qData, resData, [EOL] true); [EOL] policy.editSchedule(); [EOL] [EOL] // 4 containers will be preempted here [EOL] verify(mDisp, times(4)).handle(argThat(new IsPreemptionRequestFor(appA))); [EOL] } [EOL] static final long TS = 3141592653L; [EOL] int appAlloc = 0; [EOL] boolean setAMContainer = false; [EOL] boolean setLabeledContainer = false; [EOL] float setAMResourcePercent = 0.0f; [EOL] Random rand = null; [EOL] Clock mClock = null; [EOL] CapacitySchedulerConfiguration conf = null; [EOL] CapacityScheduler mCS = null; [EOL] RMContext rmContext = null; [EOL] RMNodeLabelsManager lm = null; [EOL] EventHandler<Event> mDisp = null; [EOL] ResourceCalculator rc = new DefaultResourceCalculator(); [EOL] Resource clusterResources = null; [EOL] final ApplicationAttemptId appA = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 0), 0); [EOL] final ApplicationAttemptId appB = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 1), 0); [EOL] final ApplicationAttemptId appC = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 2), 0); [EOL] final ApplicationAttemptId appD = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 3), 0); [EOL] final ApplicationAttemptId appE = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ApplicationAttemptId appF = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(TS, 4), 0); [EOL] final ArgumentCaptor<ContainerPreemptEvent> evtCaptor = [EOL] ArgumentCaptor.forClass(ContainerPreemptEvent.class); [EOL] @Rule public TestName name = new TestName(); [EOL] private static final int[][] Q_DATA_FOR_IGNORE = new int[][]{ [EOL] // / A B C [EOL] { 100, 40, 40, 20 }, // abs [EOL] { 100, 100, 100, 100 }, // maxCap [EOL] { 100, 0, 60, 40 }, // used [EOL] { 0, 0, 0, 0 }, // pending [EOL] { 0, 0, 0, 0 }, // reserved [EOL] { 3, 1, 1, 1 }, // apps [EOL] { -1, 1, 1, 1 }, // req granularity [EOL] { 3, 0, 0, 0 }, // subqueues [EOL] }; [EOL]
@Test [EOL] public void testForceKillApplication() [EOL] throws YarnException, IOException, InterruptedException { [EOL] LOG.info("Test FederationClientInterceptor: Force Kill Application"); [EOL] [EOL] ApplicationId appId = [EOL] ApplicationId.newInstance(System.currentTimeMillis(), 1); [EOL] SubmitApplicationRequest request = mockSubmitApplicationRequest(appId); [EOL] [EOL] // Submit the application we are going to kill later [EOL] SubmitApplicationResponse response = interceptor.submitApplication(request); [EOL] [EOL] Assert.assertNotNull(response); [EOL] Assert.assertNotNull(stateStoreUtil.queryApplicationHomeSC(appId)); [EOL] [EOL] KillApplicationRequest requestKill = [EOL] KillApplicationRequest.newInstance(appId); [EOL] KillApplicationResponse responseKill = [EOL] interceptor.forceKillApplication(requestKill); [EOL] Assert.assertNotNull(responseKill); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestFederationClientInterceptor.class); [EOL] private TestableFederationClientInterceptor interceptor; [EOL] private MemoryFederationStateStore stateStore; [EOL] private FederationStateStoreTestUtil stateStoreUtil; [EOL] private List<SubClusterId> subClusters; [EOL] private String user = "test-user"; [EOL] private final static int NUM_SUBCLUSTER = 4; [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       double[] doubleArray0 = new double[4]; [EOL]       double[] doubleArray1 = new double[7]; [EOL]       compareToBuilder0.append(doubleArray0, doubleArray1); [EOL]       Object[] objectArray0 = new Object[2]; [EOL]       compareToBuilder0.append(objectArray0, objectArray0); [EOL]       assertEquals((-1), (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNewLineText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.setNullText("Invalid startIndex: "); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder1.getNewLineText()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.replaceFirst("Invalid startIndex: ", "t~;\"vYIT!5d}%CW)%"); [EOL]       assertNull(strBuilder0.getNewLineText()); [EOL]       assertNull(strBuilder2.getNewLineText()); [EOL]        [EOL]       int int0 = 537; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.replace(537, 166, ""); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // end < start [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testInterceptSource() { [EOL] String srcRegex = "word1"; [EOL] String replaceString = "word2"; [EOL] RegexMountPointResolvedDstPathReplaceInterceptor interceptor = [EOL] new RegexMountPointResolvedDstPathReplaceInterceptor(srcRegex, [EOL] replaceString); [EOL] String sourcePath = "/a/b/l3/dd"; [EOL] Assert.assertEquals(sourcePath, interceptor.interceptSource(sourcePath)); [EOL] } [EOL]
@Test [EOL] public void testGetUgiDuringStartup() throws Exception { [EOL] conf.set(DFSConfigKeys.FS_DEFAULT_NAME_KEY, "hdfs://localhost:4321/"); [EOL] ServletContext context = mock(ServletContext.class); [EOL] String realUser = "TheDoctor"; [EOL] String user = "TheNurse"; [EOL] conf.set(DFSConfigKeys.HADOOP_SECURITY_AUTHENTICATION, "kerberos"); [EOL] UserGroupInformation.setConfiguration(conf); [EOL] HttpServletRequest request; [EOL] [EOL] Text ownerText = new Text(user); [EOL] DelegationTokenIdentifier dtId = new DelegationTokenIdentifier( [EOL] ownerText, ownerText, new Text(realUser)); [EOL] Token<DelegationTokenIdentifier> token = [EOL] new Token<DelegationTokenIdentifier>(dtId, [EOL] new DummySecretManager(0, 0, 0, 0)); [EOL] String tokenString = token.encodeToUrlString(); [EOL] [EOL] // token with auth-ed user [EOL] request = getMockRequest(realUser, null, null); [EOL] when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn( [EOL] tokenString); [EOL] [EOL] NameNode mockNN = mock(NameNode.class); [EOL] Mockito.doCallRealMethod().when(mockNN) [EOL] .verifyToken(Mockito.any(), Mockito.any()); [EOL] when(context.getAttribute("name.node")).thenReturn(mockNN); [EOL] [EOL] LambdaTestUtils.intercept(RetriableException.class, [EOL] "Namenode is in startup mode", [EOL] () -> JspHelper.getUGI(context, request, conf)); [EOL] } [EOL] private final Configuration conf = new HdfsConfiguration(); [EOL] private static String clientAddr = "1.1.1.1"; [EOL] private static String chainedClientAddr = clientAddr+", 2.2.2.2"; [EOL] private static String proxyAddr = "3.3.3.3"; [EOL]
@Test [EOL] public void testCustomResourceRequestedUnitIsSmallerThanAvailableUnit2() { [EOL] Resource requestedResource = [EOL] ResourceTypesTestHelper.newResource(1, 1, [EOL] ImmutableMap.of("custom-resource-1", "11")); [EOL] [EOL] Resource availableResource = [EOL] ResourceTypesTestHelper.newResource(1, 1, [EOL] ImmutableMap.of("custom-resource-1", "1G")); [EOL] [EOL] try { [EOL] SchedulerUtils.checkResourceRequestAgainstAvailableResource( [EOL] requestedResource, availableResource); [EOL] } catch (InvalidResourceRequestException e) { [EOL] fail(String.format( [EOL] "Resource request should be accepted. Requested: %s, available: %s", [EOL] requestedResource, availableResource)); [EOL] } [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestSchedulerUtils.class); [EOL] private static Resource configuredMaxAllocation; [EOL] private RMContext rmContext = getMockRMContext(); [EOL] private static YarnConfiguration conf = new YarnConfiguration(); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test [EOL] public void testDefaultProbe() { [EOL] // component instance has a good hostname, so probe will eventually succeed [EOL] // whether or not DNS checking is enabled [EOL] ComponentInstance componentInstance = [EOL] createMockComponentInstance("example.com"); [EOL] checkPingResults(probe, componentInstance, false); [EOL] [EOL] // component instance has a bad hostname, so probe will fail when DNS [EOL] // checking is enabled [EOL] componentInstance = createMockComponentInstance("bad.dns.test"); [EOL] checkPingResults(probe, componentInstance, probe.isDnsCheckEnabled()); [EOL] } [EOL] private final DefaultProbe probe; [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("FiHbfxLjq4Y/Lm\""); [EOL]        [EOL]       int int0 = 988; [EOL]       String string0 = strBuilder0.midString(2, 988); [EOL]        [EOL]       StringWriter stringWriter0 = new StringWriter(1855); [EOL]       assertEquals("", stringWriter0.toString()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.delete(2, 88); [EOL]        [EOL]       StringBuffer stringBuffer0 = stringWriter0.getBuffer(); [EOL]       assertEquals("", stringWriter0.toString()); [EOL]       assertEquals("", stringBuffer0.toString()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.clear(); [EOL]        [EOL]       char char0 = '\''; [EOL]       StringWriter stringWriter1 = stringWriter0.append('\''); [EOL]       assertEquals("'", stringWriter0.toString()); [EOL]       assertEquals("'", stringWriter1.toString()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln(stringBuffer0, 109, (-1319)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testmarkSupported()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder((String) null); [EOL]        [EOL]       Object[] objectArray0 = new Object[7]; [EOL]       Object object0 = new Object(); [EOL]        [EOL]       objectArray0[0] = object0; [EOL]       objectArray0[1] = (Object) strBuilder0; [EOL]       objectArray0[2] = (Object) null; [EOL]       objectArray0[3] = (Object) null; [EOL]       objectArray0[4] = (Object) strBuilder0; [EOL]       objectArray0[5] = (Object) strBuilder0; [EOL]       objectArray0[6] = (Object) null; [EOL]       StrMatcher strMatcher0 = StrMatcher.splitMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "length must be valid"); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendWithSeparators(objectArray0, (String) null); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append((CharSequence) strBuilder0, 31, 31); [EOL]        [EOL]       Reader reader0 = strBuilder0.asReader(); [EOL]       assertTrue(reader0.markSupported()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append(1L); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMultipleLocalizers() throws Exception { [EOL] FakeContainerLocalizerWrapper testA = new FakeContainerLocalizerWrapper(); [EOL] FakeContainerLocalizerWrapper testB = new FakeContainerLocalizerWrapper(); [EOL] [EOL] FakeContainerLocalizer localizerA = testA.init(); [EOL] FakeContainerLocalizer localizerB = testB.init(); [EOL] [EOL] // run localization [EOL] Thread threadA = new Thread() { [EOL] @Override [EOL] public void run() { [EOL] try { [EOL] localizerA.runLocalization(nmAddr); [EOL] } catch (Exception e) { [EOL] LOG.warn(e.toString()); [EOL] } [EOL] } [EOL] }; [EOL] Thread threadB = new Thread() { [EOL] @Override [EOL] public void run() { [EOL] try { [EOL] localizerB.runLocalization(nmAddr); [EOL] } catch (Exception e) { [EOL] LOG.warn(e.toString()); [EOL] } [EOL] } [EOL] }; [EOL] ShellCommandExecutor shexcA = null; [EOL] ShellCommandExecutor shexcB = null; [EOL] try { [EOL] threadA.start(); [EOL] threadB.start(); [EOL] [EOL] GenericTestUtils.waitFor(new Supplier<Boolean>() { [EOL] @Override [EOL] public Boolean get() { [EOL] FakeContainerLocalizer.FakeLongDownload downloader = [EOL] localizerA.getDownloader(); [EOL] return downloader != null && downloader.getShexc() != null && [EOL] downloader.getShexc().getProcess() != null; [EOL] } [EOL] }, 10, 30000); [EOL] [EOL] GenericTestUtils.waitFor(new Supplier<Boolean>() { [EOL] @Override [EOL] public Boolean get() { [EOL] FakeContainerLocalizer.FakeLongDownload downloader = [EOL] localizerB.getDownloader(); [EOL] return downloader != null && downloader.getShexc() != null && [EOL] downloader.getShexc().getProcess() != null; [EOL] } [EOL] }, 10, 30000); [EOL] [EOL] shexcA = localizerA.getDownloader().getShexc(); [EOL] shexcB = localizerB.getDownloader().getShexc(); [EOL] [EOL] assertTrue("Localizer A process not running, but should be", [EOL] shexcA.getProcess().isAlive()); [EOL] assertTrue("Localizer B process not running, but should be", [EOL] shexcB.getProcess().isAlive()); [EOL] [EOL] // Stop heartbeat from giving anymore resources to download [EOL] testA.heartbeatResponse++; [EOL] testB.heartbeatResponse++; [EOL] [EOL] // Send DIE to localizerA. This should kill its subprocesses [EOL] testA.heartbeatResponse++; [EOL] [EOL] threadA.join(); [EOL] shexcA.getProcess().waitFor(10000, TimeUnit.MILLISECONDS); [EOL] [EOL] assertFalse("Localizer A process is still running, but shouldn't be", [EOL] shexcA.getProcess().isAlive()); [EOL] assertTrue("Localizer B process not running, but should be", [EOL] shexcB.getProcess().isAlive()); [EOL] [EOL] } finally { [EOL] // Make sure everything gets cleaned up [EOL] // Process A should already be dead [EOL] shexcA.getProcess().destroy(); [EOL] shexcB.getProcess().destroy(); [EOL] shexcA.getProcess().waitFor(10000, TimeUnit.MILLISECONDS); [EOL] shexcB.getProcess().waitFor(10000, TimeUnit.MILLISECONDS); [EOL] [EOL] threadA.join(); [EOL] // Send DIE to localizer B [EOL] testB.heartbeatResponse++; [EOL] threadB.join(); [EOL] } [EOL] } [EOL] static final Logger LOG = [EOL] LoggerFactory.getLogger(TestContainerLocalizer.class); [EOL] static final Path basedir = [EOL] new Path("target", TestContainerLocalizer.class.getName()); [EOL] static final FsPermission CACHE_DIR_PERM = new FsPermission((short)0710); [EOL] static final FsPermission USERCACHE_DIR_PERM = new FsPermission((short) 0755); [EOL] static final String appUser = "yak"; [EOL] static final String appId = "app_RM_0"; [EOL] static final String containerId = "container_0"; [EOL] static final InetSocketAddress nmAddr = [EOL] new InetSocketAddress("foobar", 8040); [EOL]
@Test(timeout = 4000) [EOL]   public void testisPackageAccess()  throws Throwable  { [EOL]       boolean boolean0 = MemberUtils.isPackageAccess(0); [EOL]       assertTrue(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testApplicationNotFound() throws IOException, YarnException { [EOL] ApplicationId appId = null; [EOL] appId = ApplicationId.newInstance(0, MAX_APPS + 1); [EOL] GetApplicationReportRequest request = [EOL] GetApplicationReportRequest.newInstance(appId); [EOL] try { [EOL] @SuppressWarnings("unused") [EOL] GetApplicationReportResponse response = [EOL] clientService.getApplicationReport(request); [EOL] Assert.fail("Exception should have been thrown before we reach here."); [EOL] } catch (ApplicationNotFoundException e) { [EOL] //This exception is expected. [EOL] Assert.assertTrue(e.getMessage().contains( [EOL] "doesn't exist in the timeline store")); [EOL] } catch (Exception e) { [EOL] Assert.fail("Undesired exception caught"); [EOL] } [EOL] } [EOL] private static ApplicationHistoryClientService clientService; [EOL] private static TimelineDataManager dataManager; [EOL] private final static int MAX_APPS = 2; [EOL]
@Test(timeout = 4000) [EOL]   public void testisUseClassName()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer("$W8BC)fVnoVM,sZ]"); [EOL]       standardToStringStyle0.NO_FIELD_NAMES_STYLE.appendNullText(stringBuffer0, "hJd3~IkyQU3Lzn0Z^Hs"); [EOL]       assertTrue(standardToStringStyle0.isUseClassName()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetEnd()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.isNot('%'); [EOL]       boolean boolean0 = charRange0.isNegated(); [EOL]       assertEquals('%', charRange0.getEnd()); [EOL]   } [EOL]  [EOL]
@Test(timeout=30000) [EOL] public void testFailedLocationsAboveThreshold() throws Exception { [EOL] final List<StorageLocation> locations = [EOL] makeMockLocations(HEALTHY, FAILED, FAILED); // 1 healthy, 2 failed. [EOL] final Configuration conf = new HdfsConfiguration(); [EOL] conf.setInt(DFS_DATANODE_FAILED_VOLUMES_TOLERATED_KEY, 1); [EOL] [EOL] thrown.expect(IOException.class); [EOL] thrown.expectMessage("Too many failed volumes - current valid volumes: 1," [EOL] + " volumes configured: 3, volumes failed: 2, volume failures" [EOL] + " tolerated: 1"); [EOL] StorageLocationChecker checker = [EOL] new StorageLocationChecker(conf, new FakeTimer()); [EOL] checker.check(conf, locations); [EOL] } [EOL] public static final Logger LOG = LoggerFactory.getLogger( [EOL] TestStorageLocationChecker.class); [EOL] @Rule [EOL] public ExpectedException thrown = ExpectedException.none(); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeEndText()  throws Throwable  { [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.MULTI_LINE_STYLE; [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       StringBuffer stringBuffer0 = new StringBuffer((CharSequence) "{"); [EOL]       toStringStyle0.appendEnd(stringBuffer0, standardToStringStyle0); [EOL]       assertEquals(">", standardToStringStyle0.getSizeEndText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]        [EOL]       char[] charArray0 = new char[18]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]       assertEquals("n:qv{0F`Yb3&H^f*N2", charBuffer0.toString()); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertEquals("n:qv{0F`Yb3&H^f*N2", charBuffer0.toString()); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder strBuilder2 = new StrBuilder(); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]       assertEquals("", charBuffer1.toString()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]        [EOL]       String string0 = strBuilder4.leftString((-1)); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(false); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", (-1)); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]       assertEquals("en_CA", locale0.toString()); [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]       assertEquals("en_CA", locale0.toString()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]       assertEquals("en_CA", locale0.toString()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitToBinary()  throws Throwable  { [EOL]       boolean[] booleanArray0 = Conversion.hexDigitToBinary('F'); [EOL]       assertTrue(Arrays.equals(new boolean[] {true, true, true, true}, booleanArray0)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetTypeArguments()  throws Throwable  { [EOL]       Class<Object> class0 = Object.class; [EOL]       Class<?> class1 = TypeUtils.getRawType(class0, class0); [EOL]       Class<String> class2 = String.class; [EOL]       Map<TypeVariable<?>, Type> map0 = TypeUtils.getTypeArguments((Type) class1, (Class<?>) class2); [EOL]       assertNull(map0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCidrLongRW() { [EOL] NfsExports matcher = new NfsExports(CacheSize, ExpirationPeriod, [EOL] "192.168.0.0/255.255.252.0 rw"); [EOL] Assert.assertEquals(AccessPrivilege.READ_WRITE, [EOL] matcher.getAccessPrivilege(address1, hostname1)); [EOL] Assert.assertEquals(AccessPrivilege.NONE, [EOL] matcher.getAccessPrivilege(address2, hostname1)); [EOL] } [EOL] private final String address1 = "192.168.0.12"; [EOL] private final String address2 = "10.0.0.12"; [EOL] private final String hostname1 = "a.b.com"; [EOL] private final String hostname2 = "a.b.org"; [EOL] private static final long ExpirationPeriod = [EOL] Nfs3Constant.NFS_EXPORTS_CACHE_EXPIRYTIME_MILLIS_DEFAULT * 1000 * 1000; [EOL] private static final int CacheSize = Nfs3Constant.NFS_EXPORTS_CACHE_SIZE_DEFAULT; [EOL] private static final long NanosPerMillis = 1000000; [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       double[] doubleArray0 = new double[2]; [EOL]       doubleArray0[0] = 0.0; [EOL]       doubleArray0[1] = 0.0; [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(doubleArray0, doubleArray0); [EOL]       Object object0 = new Object(); [EOL]       EqualsBuilder equalsBuilder2 = equalsBuilder1.append((Object) equalsBuilder0, object0); [EOL]       float[] floatArray0 = new float[0]; [EOL]       EqualsBuilder equalsBuilder3 = equalsBuilder2.append(floatArray0, floatArray0); [EOL]       EqualsBuilder equalsBuilder4 = equalsBuilder3.append((byte) (-1), (byte) (-81)); [EOL]       EqualsBuilder equalsBuilder5 = equalsBuilder4.append(floatArray0, floatArray0); [EOL]       assertSame(equalsBuilder5, equalsBuilder0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testsubarray()  throws Throwable  { [EOL]       boolean[] booleanArray0 = new boolean[1]; [EOL]       boolean[] booleanArray1 = ArrayUtils.subarray(booleanArray0, 5, (-1)); [EOL]       assertNotSame(booleanArray0, booleanArray1); [EOL]   } [EOL]  [EOL]
@Test (timeout = 5000) [EOL] public void testRunCommandNoPriority() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] String[] command = containerExecutor.getRunCommand("echo", "group1", "user", null, conf); [EOL] assertTrue("first command should be the run command for the platform", [EOL] command[0].equals(Shell.WINUTILS) || command[0].equals("bash")); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestContainerExecutor.class); [EOL] private ContainerExecutor containerExecutor = new DefaultContainerExecutor(); [EOL]
@Test [EOL] public void testGetSplits() throws Exception { [EOL] final DistCpContext context = new DistCpContext(getOptions()); [EOL] Configuration configuration = new Configuration(); [EOL] configuration.set("mapred.map.tasks", [EOL] String.valueOf(context.getMaxMaps())); [EOL] CopyListing.getCopyListing(configuration, CREDENTIALS, context) [EOL] .buildListing(new Path(cluster.getFileSystem().getUri().toString() [EOL] +"/tmp/testDynInputFormat/fileList.seq"), context); [EOL] [EOL] JobContext jobContext = new JobContextImpl(configuration, new JobID()); [EOL] DynamicInputFormat<Text, CopyListingFileStatus> inputFormat = [EOL] new DynamicInputFormat<Text, CopyListingFileStatus>(); [EOL] List<InputSplit> splits = inputFormat.getSplits(jobContext); [EOL] [EOL] int nFiles = 0; [EOL] int taskId = 0; [EOL] [EOL] for (InputSplit split : splits) { [EOL] StubContext stubContext = new StubContext(jobContext.getConfiguration(), [EOL] null, taskId); [EOL] final TaskAttemptContext taskAttemptContext [EOL] = stubContext.getContext(); [EOL] [EOL] RecordReader<Text, CopyListingFileStatus> recordReader = [EOL] inputFormat.createRecordReader(split, taskAttemptContext); [EOL] stubContext.setReader(recordReader); [EOL] recordReader.initialize(splits.get(0), taskAttemptContext); [EOL] float previousProgressValue = 0f; [EOL] while (recordReader.nextKeyValue()) { [EOL] CopyListingFileStatus fileStatus = recordReader.getCurrentValue(); [EOL] String source = fileStatus.getPath().toString(); [EOL] System.out.println(source); [EOL] Assert.assertTrue(expectedFilePaths.contains(source)); [EOL] final float progress = recordReader.getProgress(); [EOL] Assert.assertTrue(progress >= previousProgressValue); [EOL] Assert.assertTrue(progress >= 0.0f); [EOL] Assert.assertTrue(progress <= 1.0f); [EOL] previousProgressValue = progress; [EOL] ++nFiles; [EOL] } [EOL] Assert.assertTrue(recordReader.getProgress() == 1.0f); [EOL] [EOL] ++taskId; [EOL] } [EOL] [EOL] Assert.assertEquals(expectedFilePaths.size(), nFiles); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestDynamicInputFormat.class); [EOL] private static MiniDFSCluster cluster; [EOL] private static final int N_FILES = 1000; [EOL] private static final int NUM_SPLITS = 7; [EOL] private static final Credentials CREDENTIALS = new Credentials(); [EOL] private static List<String> expectedFilePaths = new ArrayList<String>(N_FILES); [EOL]
@Test [EOL] public void processPathDirOrderMtimeReverse() throws IOException { [EOL] TestFile testfile01 = new TestFile("testDirectory", "testFile01"); [EOL] TestFile testfile02 = new TestFile("testDirectory", "testFile02"); [EOL] TestFile testfile03 = new TestFile("testDirectory", "testFile03"); [EOL] TestFile testfile04 = new TestFile("testDirectory", "testFile04"); [EOL] TestFile testfile05 = new TestFile("testDirectory", "testFile05"); [EOL] TestFile testfile06 = new TestFile("testDirectory", "testFile06"); [EOL] [EOL] // set file mtime in different order to file names [EOL] testfile01.setMtime(NOW.getTime() + 10); [EOL] testfile02.setMtime(NOW.getTime() + 30); [EOL] testfile03.setMtime(NOW.getTime() + 20); [EOL] testfile04.setMtime(NOW.getTime() + 60); [EOL] testfile05.setMtime(NOW.getTime() + 50); [EOL] testfile06.setMtime(NOW.getTime() + 40); [EOL] [EOL] TestFile testDir = new TestFile("", "testDirectory"); [EOL] testDir.setIsDir(true); [EOL] testDir.addContents(testfile01, testfile02, testfile03, testfile04, [EOL] testfile05, testfile06); [EOL] [EOL] LinkedList<PathData> pathData = new LinkedList<PathData>(); [EOL] pathData.add(testDir.getPathData()); [EOL] [EOL] PrintStream out = mock(PrintStream.class); [EOL] [EOL] Ls ls = new Ls(); [EOL] ls.out = out; [EOL] [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] options.add("-t"); [EOL] options.add("-r"); [EOL] ls.processOptions(options); [EOL] String lineFormat = TestFile.computeLineFormat(pathData); [EOL] [EOL] ls.processArguments(pathData); [EOL] InOrder inOrder = inOrder(out); [EOL] inOrder.verify(out).println("Found 6 items"); [EOL] inOrder.verify(out).println(testfile01.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile03.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile02.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile06.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile05.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile04.formatLineMtime(lineFormat)); [EOL] verifyNoMoreInteractions(out); [EOL] } [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static final Date NOW = new Date(); [EOL]
@Test(timeout = 4000) [EOL]   public void testisAppendStatics()  throws Throwable  { [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.SIMPLE_STYLE; [EOL]       StringBuffer stringBuffer0 = new StringBuffer(""); [EOL]       Class<Object> class0 = Object.class; [EOL]       ReflectionToStringBuilder reflectionToStringBuilder0 = new ReflectionToStringBuilder((Object) null, toStringStyle0, stringBuffer0, (Class<? super Object>) class0, true, true); [EOL]       reflectionToStringBuilder0.setUpToClass(class0); [EOL]       assertTrue(reflectionToStringBuilder0.isAppendStatics()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       Float float0 = new Float(167.82865430967); [EOL]       MutableInt mutableInt0 = new MutableInt(float0); [EOL]       boolean boolean0 = ObjectUtils.equals((Object) mutableInt0, (Object) null); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testCopyBytesWithCountShouldNotCloseStreamsWhenCloseIsFalse() [EOL] throws Exception { [EOL] InputStream inputStream = Mockito.mock(InputStream.class); [EOL] OutputStream outputStream = Mockito.mock(OutputStream.class); [EOL] Mockito.doReturn(-1).when(inputStream).read(new byte[4096], 0, 1); [EOL] IOUtils.copyBytes(inputStream, outputStream, (long) 1, false); [EOL] Mockito.verify(inputStream, Mockito.atMost(0)).close(); [EOL] Mockito.verify(outputStream, Mockito.atMost(0)).close(); [EOL] } [EOL] private static final String TEST_FILE_NAME = "test_file"; [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestIOUtils.class); [EOL]
@Test [EOL] public void testRead() { [EOL] File tmpFile; [EOL] File outFile; [EOL] try { [EOL] tmpFile = createFile(1024); [EOL] outFile = createFile(); [EOL] [EOL] tmpFile.deleteOnExit(); [EOL] outFile.deleteOnExit(); [EOL] [EOL] long maxBandwidth = copyAndAssert(tmpFile, outFile, 0, 1, -1, CB.BUFFER); [EOL] [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 20, 0, CB.BUFFER); [EOL] /* [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 10, 0, CB.BUFFER); [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 50, 0, CB.BUFFER); [EOL] */ [EOL] [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 20, 0, CB.BUFF_OFFSET); [EOL] /* [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 10, 0, CB.BUFF_OFFSET); [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 50, 0, CB.BUFF_OFFSET); [EOL] */ [EOL] [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 20, 0, CB.ONE_C); [EOL] /* [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 10, 0, CB.ONE_C); [EOL] copyAndAssert(tmpFile, outFile, maxBandwidth, 50, 0, CB.ONE_C); [EOL] */ [EOL] } catch (IOException e) { [EOL] LOG.error("Exception encountered ", e); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestThrottledInputStream.class); [EOL] private static final int BUFF_SIZE = 1024; [EOL]
@Test [EOL] public void testCalculateChunkedSumsByteArrayFail() throws ChecksumException { [EOL] allocateArrayByteBuffers(); [EOL] fillDataAndInvalidChecksums(); [EOL] NativeCrc32.calculateChunkedSumsByteArray(bytesPerChecksum, checksumType.id, [EOL] checksums.array(), checksums.position(), data.array(), data.position(), [EOL] data.remaining()); [EOL] } [EOL] private static final long BASE_POSITION = 0; [EOL] private static final int IO_BYTES_PER_CHECKSUM_DEFAULT = 512; [EOL] private static final String IO_BYTES_PER_CHECKSUM_KEY = [EOL] "io.bytes.per.checksum"; [EOL] private static final int NUM_CHUNKS = 3; [EOL] private final DataChecksum.Type checksumType; [EOL] private int bytesPerChecksum; [EOL] private String fileName; [EOL] private ByteBuffer data, checksums; [EOL] private DataChecksum checksum; [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL]
@Test [EOL] public void testStatus() { [EOL] String appName = "nonexistent-app"; [EOL] try { [EOL] String result = asc.getStatusString(appName); [EOL] assertEquals("Status reponse don't match", [EOL] " Service " + appName + " not found", result); [EOL] } catch (IOException | YarnException e) { [EOL] fail(); [EOL] } [EOL] } [EOL] private static ApiServiceClient asc; [EOL] private static ApiServiceClient badAsc; [EOL] private static Server server; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSizeEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]        [EOL]       standardToStringStyle0.setArrayEnd((String) null); [EOL]       assertEquals(">", standardToStringStyle0.getSizeEndText()); [EOL]   } [EOL]  [EOL]
@Test (timeout = 30000) [EOL] public void testPathToUriConversion() throws URISyntaxException, IOException { [EOL] // Path differs from URI in that it ignores the query part.. [EOL] assertEquals("? mark char in to URI", [EOL] new URI(null, null, "/foo?bar", null, null), [EOL] new Path("/foo?bar").toUri()); [EOL] assertEquals("escape slashes chars in to URI", [EOL] new URI(null, null, "/foo\"bar", null, null), [EOL] new Path("/foo\"bar").toUri()); [EOL] assertEquals("spaces in chars to URI", [EOL] new URI(null, null, "/foo bar", null, null), [EOL] new Path("/foo bar").toUri()); [EOL] // therefore "foo?bar" is a valid Path, so a URI created from a Path [EOL] // has path "foo?bar" where in a straight URI the path part is just "foo" [EOL] assertEquals("/foo?bar", [EOL] new Path("http://localhost/foo?bar").toUri().getPath()); [EOL] assertEquals("/foo", new URI("http://localhost/foo?bar").getPath()); [EOL] [EOL] // The path part handling in Path is equivalent to URI [EOL] assertEquals(new URI("/foo;bar").getPath(), new Path("/foo;bar").toUri().getPath()); [EOL] assertEquals(new URI("/foo;bar"), new Path("/foo;bar").toUri()); [EOL] assertEquals(new URI("/foo+bar"), new Path("/foo+bar").toUri()); [EOL] assertEquals(new URI("/foo-bar"), new Path("/foo-bar").toUri()); [EOL] assertEquals(new URI("/foo=bar"), new Path("/foo=bar").toUri()); [EOL] assertEquals(new URI("/foo,bar"), new Path("/foo,bar").toUri()); [EOL] } [EOL]
@Test [EOL] public void testMainMethodMapFile() { [EOL] String inFile = "mainMethodMapFile.mapfile"; [EOL] String path = new Path(TEST_DIR, inFile).toString(); [EOL] String[] args = { path, path }; [EOL] MapFile.Writer writer = null; [EOL] try { [EOL] writer = createWriter(inFile, IntWritable.class, Text.class); [EOL] writer.append(new IntWritable(1), new Text("test_text1")); [EOL] writer.append(new IntWritable(2), new Text("test_text2")); [EOL] writer.close(); [EOL] MapFile.main(args); [EOL] } catch (Exception ex) { [EOL] fail("testMainMethodMapFile error !!!"); [EOL] } finally { [EOL] IOUtils.cleanupWithLogger(null, writer); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestMapFile.class); [EOL] private static final Path TEST_DIR = new Path(GenericTestUtils.getTempPath( [EOL] TestMapFile.class.getSimpleName())); [EOL] private static Configuration conf = new Configuration(); [EOL] private static final Progressable defaultProgressable = new Progressable() { [EOL] @Override [EOL] public void progress() { [EOL] } [EOL] }; [EOL] private static final CompressionCodec defaultCodec = new CompressionCodec() { [EOL] @Override [EOL] public CompressionOutputStream createOutputStream(OutputStream out) [EOL] throws IOException { [EOL] return mock(CompressionOutputStream.class); [EOL] } [EOL] [EOL] @Override [EOL] public CompressionOutputStream createOutputStream(OutputStream out, [EOL] Compressor compressor) throws IOException { [EOL] return mock(CompressionOutputStream.class); [EOL] } [EOL] [EOL] @Override [EOL] public Class<? extends Compressor> getCompressorType() { [EOL] return null; [EOL] } [EOL] [EOL] @Override [EOL] public Compressor createCompressor() { [EOL] return null; [EOL] } [EOL] [EOL] @Override [EOL] public CompressionInputStream createInputStream(InputStream in) [EOL] throws IOException { [EOL] return null; [EOL] } [EOL] [EOL] @Override [EOL] public CompressionInputStream createInputStream(InputStream in, [EOL] Decompressor decompressor) throws IOException { [EOL] return null; [EOL] } [EOL] [EOL] @Override [EOL] public Class<? extends Decompressor> getDecompressorType() { [EOL] return null; [EOL] } [EOL] [EOL] @Override [EOL] public Decompressor createDecompressor() { [EOL] return null; [EOL] } [EOL] [EOL] @Override [EOL] public String getDefaultExtension() { [EOL] return null; [EOL] } [EOL] }; [EOL]
@Test [EOL] public void testCompareToDurationEQ() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare testCompareToDurationEQ"); [EOL] TModelInstanceDetails lhs = new TModelInstanceDetails(); [EOL] lhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] lhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] lhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] lhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("P5Y"); [EOL] TModelInstanceDetails rhs = new TModelInstanceDetails(); [EOL] [EOL] rhs.getTModelInstanceInfo().add(new TModelInstanceInfo()); [EOL] rhs.getTModelInstanceInfo().get(0).setTModelKey("hi"); [EOL] rhs.getTModelInstanceInfo().get(0).setInstanceDetails(new InstanceDetails()); [EOL] rhs.getTModelInstanceInfo().get(0).getInstanceDetails().setInstanceParms("P5Y"); [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", false, false, true); [EOL] int result = instance.compare(lhs, rhs); [EOL] Assert.assertTrue("result " + lhs.getTModelInstanceInfo().get(0).getInstanceDetails().getInstanceParms() + " compare to " + [EOL] lhs.getTModelInstanceInfo().get(0).getInstanceDetails().getInstanceParms() + " " + [EOL] result, result == 0); [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       Integer integer0 = new Integer((-1083)); [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.SIMPLE_STYLE; [EOL]       ToStringBuilder toStringBuilder0 = new ToStringBuilder(integer0, toStringStyle0); [EOL]       long[] longArray0 = new long[8]; [EOL]       ToStringBuilder toStringBuilder1 = toStringBuilder0.append(longArray0); [EOL]       assertSame(toStringBuilder1, toStringBuilder0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       String string0 = "K6f"; [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       int int0 = 0; [EOL]       StrBuilder strBuilder1 = strBuilder0.delete(0, 0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       String string1 = "]*qbQ%"; [EOL]       StrBuilder strBuilder2 = strBuilder1.setNewLineText("]*qbQ%"); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln(strBuilder0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]        [EOL]       LinkedList<Integer> linkedList0 = new LinkedList<Integer>(); [EOL]        [EOL]       Iterator<Integer> iterator0 = linkedList0.iterator(); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder1.appendAll(iterator0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder4.appendSeparator("]*qbQ%", (-1079)); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder4.getNullText()); [EOL]       assertNull(strBuilder5.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendln('\''); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder6.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder6.append(0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]       assertNull(strBuilder2.getNullText()); [EOL]       assertNull(strBuilder3.getNullText()); [EOL]       assertNull(strBuilder6.getNullText()); [EOL]       assertNull(strBuilder7.getNullText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append(strBuilder0, (-286), 0); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveElement()  throws Throwable  { [EOL]       long[] longArray0 = new long[2]; [EOL]       long[] longArray1 = ArrayUtils.removeElements(longArray0, longArray0); [EOL]       assertEquals(0, longArray1.length); [EOL]   } [EOL]  [EOL]
@Test(expected = FederationPolicyInitializationException.class) [EOL] public void nullType() throws Exception { [EOL] FederationPolicyInitializationContextValidator.validate(context, null); [EOL] } [EOL] private SubClusterPolicyConfiguration goodConfig; [EOL] private SubClusterResolver goodSR; [EOL] private FederationStateStoreFacade goodFacade; [EOL] private SubClusterId goodHome; [EOL] private FederationPolicyInitializationContext context; [EOL]
@Test [EOL] public void testGetRelativePath() { [EOL] Path root = new Path("/tmp/abc"); [EOL] Path child = new Path("/tmp/abc/xyz/file"); [EOL] assertThat(DistCpUtils.getRelativePath(root, child)).isEqualTo("/xyz/file"); [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestDistCpUtils.class); [EOL] private static final Configuration config = new Configuration(); [EOL] private static MiniDFSCluster cluster; [EOL] private static final FsPermission fullPerm = new FsPermission((short) 777); [EOL] private static final FsPermission almostFullPerm = new FsPermission((short) 666); [EOL] private static final FsPermission noPerm = new FsPermission((short) 0); [EOL] private static Random rand = new Random(); [EOL]
@Test (timeout = 30000) [EOL] public void testListAPI() throws IOException { [EOL] //Test existing files case [EOL] String[] files = FileUtil.list(partitioned); [EOL] Assert.assertEquals("Unexpected number of pre-existing files", 2, files.length); [EOL] [EOL] //Test existing directory with no files case [EOL] File newDir = new File(tmp.getPath(),"test"); [EOL] newDir.mkdir(); [EOL] Assert.assertTrue("Failed to create test dir", newDir.exists()); [EOL] files = FileUtil.list(newDir); [EOL] Assert.assertEquals("New directory unexpectedly contains files", 0, files.length); [EOL] newDir.delete(); [EOL] Assert.assertFalse("Failed to delete test dir", newDir.exists()); [EOL] [EOL] //Test non-existing directory case, this throws [EOL] //IOException [EOL] try { [EOL] files = FileUtil.list(newDir); [EOL] Assert.fail("IOException expected on list() for non-existent dir " [EOL] + newDir.toString()); [EOL] } catch(IOException ioe) { [EOL] //Expected an IOException [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test [EOL] public void testWithEmptyList() { [EOL] try { [EOL] List<String> list = new ArrayList<String>(); [EOL] String[] arr = GenericsUtil.toArray(list); [EOL] fail("Empty array should throw exception"); [EOL] System.out.println(arr); //use arr so that compiler will not complain [EOL] [EOL] }catch (IndexOutOfBoundsException ex) { [EOL] //test case is successful [EOL] } [EOL] } [EOL]
@Test [EOL] public void processPathDirectory() throws IOException { [EOL] TestFile testfile01 = new TestFile("testDirectory", "testFile01"); [EOL] TestFile testfile02 = new TestFile("testDirectory", "testFile02"); [EOL] TestFile testfile03 = new TestFile("testDirectory", "testFile03"); [EOL] TestFile testfile04 = new TestFile("testDirectory", "testFile04"); [EOL] TestFile testfile05 = new TestFile("testDirectory", "testFile05"); [EOL] TestFile testfile06 = new TestFile("testDirectory", "testFile06"); [EOL] [EOL] TestFile testDir = new TestFile("", "testDirectory"); [EOL] testDir.setIsDir(true); [EOL] testDir.addContents(testfile01, testfile02, testfile03, testfile04, [EOL] testfile05, testfile06); [EOL] [EOL] LinkedList<PathData> pathData = new LinkedList<PathData>(); [EOL] pathData.add(testDir.getPathData()); [EOL] [EOL] PrintStream out = mock(PrintStream.class); [EOL] [EOL] Ls ls = new Ls(); [EOL] ls.out = out; [EOL] [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] ls.processOptions(options); [EOL] String lineFormat = TestFile.computeLineFormat(pathData); [EOL] [EOL] ls.processArguments(pathData); [EOL] InOrder inOrder = inOrder(out); [EOL] inOrder.verify(out).println("Found 6 items"); [EOL] inOrder.verify(out).println(testfile01.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile02.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile03.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile04.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile05.formatLineMtime(lineFormat)); [EOL] inOrder.verify(out).println(testfile06.formatLineMtime(lineFormat)); [EOL] verifyNoMoreInteractions(out); [EOL] } [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static final Date NOW = new Date(); [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectEndText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getFieldSeparator(); [EOL]       assertEquals(">", standardToStringStyle0.getSummaryObjectEndText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testProcessEvictableResource() throws Exception { [EOL] FileSystem fs = mock(FileSystem.class); [EOL] CleanerMetrics metrics = mock(CleanerMetrics.class); [EOL] SCMStore store = mock(SCMStore.class); [EOL] [EOL] CleanerTask task = [EOL] createSpiedTask(fs, store, metrics, new ReentrantLock()); [EOL] [EOL] // mock an evictable resource [EOL] when(store.isResourceEvictable(isA(String.class), isA(FileStatus.class))) [EOL] .thenReturn(true); [EOL] FileStatus status = mock(FileStatus.class); [EOL] when(status.getPath()).thenReturn(new Path(ROOT + "/a/b/c/abc")); [EOL] when(store.removeResource(isA(String.class))).thenReturn(true); [EOL] // rename succeeds [EOL] when(fs.rename(isA(Path.class), isA(Path.class))).thenReturn(true); [EOL] // delete returns true [EOL] when(fs.delete(isA(Path.class), anyBoolean())).thenReturn(true); [EOL] [EOL] // process the resource [EOL] task.processSingleResource(status); [EOL] [EOL] // the directory should be renamed [EOL] verify(fs).rename(eq(status.getPath()), isA(Path.class)); [EOL] // metrics should record a deleted file [EOL] verify(metrics).reportAFileDelete(); [EOL] verify(metrics, never()).reportAFileProcess(); [EOL] } [EOL] private static final String ROOT = [EOL] YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT; [EOL] private static final long SLEEP_TIME = [EOL] YarnConfiguration.DEFAULT_SCM_CLEANER_RESOURCE_SLEEP_MS; [EOL] private static final int NESTED_LEVEL = [EOL] YarnConfiguration.DEFAULT_SHARED_CACHE_NESTED_LEVEL; [EOL]
@Test [EOL] public void testClear() { [EOL] FoldedTreeSet<String> instance = new FoldedTreeSet<>(); [EOL] instance.clear(); [EOL] assertEquals(true, instance.isEmpty()); [EOL] instance.add("apa"); [EOL] assertEquals(false, instance.isEmpty()); [EOL] instance.clear(); [EOL] assertEquals(true, instance.isEmpty()); [EOL] } [EOL] private static Random srand; [EOL]
@Test(timeout = 4000) [EOL]   public void testintToShortArray()  throws Throwable  { [EOL]       short[] shortArray0 = new short[7]; [EOL]       short[] shortArray1 = Conversion.intToShortArray(0, 0, shortArray0, (short) (-3102), 0); [EOL]       assertSame(shortArray1, shortArray0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testUnsuitable() throws Exception { [EOL] try { [EOL] final Configuration conf = new Configuration(); [EOL] // all files 13k or less [EOL] conf.setLong(FilePool.GRIDMIX_MIN_FILE, 14 * 1024); [EOL] final FilePool pool = new FilePool(conf, base); [EOL] pool.refresh(); [EOL] } catch (IOException e) { [EOL] return; [EOL] } [EOL] fail(); [EOL] } [EOL] static final Logger LOG = LoggerFactory.getLogger(TestFileQueue.class); [EOL] static final int NFILES = 26; [EOL] static final Path base = getBaseDir(); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[8]; [EOL]       String string0 = StringUtils.strip("xlj[0BAT3@1"); [EOL]        [EOL]       charSequenceArray0[0] = (CharSequence) "xlj[0BAT3@1"; [EOL]       String string1 = StringUtils.removeStart("xlj[0BAT3@1", "&r"); [EOL]        [EOL]       charSequenceArray0[1] = (CharSequence) "xlj[0BAT3@1"; [EOL]       String string2 = StringUtils.leftPad("xlj[0BAT3@1", 8192, "}^M"); [EOL]        [EOL]       charSequenceArray0[2] = (CharSequence) string2; [EOL]       String string3 = StringUtils.replaceChars("xlj[0BAT3@1", (String) null, "xlj[0BAT3@1"); [EOL]        [EOL]       charSequenceArray0[3] = (CharSequence) "xlj[0BAT3@1"; [EOL]       String string4 = StringUtils.stripToNull("Minimum abbreviation width is 4"); [EOL]        [EOL]       charSequenceArray0[4] = (CharSequence) "Minimum abbreviation width is 4"; [EOL]       String string5 = StringUtils.EMPTY; [EOL]        [EOL]       charSequenceArray0[5] = (CharSequence) ""; [EOL]       String string6 = StringUtils.difference("", (String) null); [EOL]        [EOL]       charSequenceArray0[6] = (CharSequence) ""; [EOL]       String string7 = StringUtils.substringBefore("", "Index: "); [EOL]        [EOL]       charSequenceArray0[7] = (CharSequence) ""; [EOL]       int int0 = StringUtils.indexOfDifference(charSequenceArray0); [EOL]       assertEquals(8, charSequenceArray0.length); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testStatisticsStrWithNullOpCodeCount() throws IOException { [EOL] String editFilename = nnHelper.generateEdits(); [EOL] String outFilename = editFilename + ".stats"; [EOL] FileOutputStream fout = new FileOutputStream(outFilename); [EOL] StatisticsEditsVisitor visitor = new StatisticsEditsVisitor(fout); [EOL] OfflineEditsViewer oev = new OfflineEditsViewer(); [EOL] [EOL] String statisticsStr = null; [EOL] if (oev.go(editFilename, outFilename, "stats", new Flags(), visitor) == 0) { [EOL] statisticsStr = visitor.getStatisticsString(); [EOL] } [EOL] Assert.assertNotNull(statisticsStr); [EOL] [EOL] String str; [EOL] Long count; [EOL] Map<FSEditLogOpCodes, Long> opCodeCount = visitor.getStatistics(); [EOL] for (FSEditLogOpCodes opCode : FSEditLogOpCodes.values()) { [EOL] count = opCodeCount.get(opCode); [EOL] // Verify the str when the opCode's count is null [EOL] if (count == null) { [EOL] str = [EOL] String.format(" %-30.30s (%3d): %d%n", opCode.toString(), [EOL] opCode.getOpCode(), Long.valueOf(0L)); [EOL] assertTrue(statisticsStr.contains(str)); [EOL] } [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestOfflineEditsViewer.class); [EOL] private static final String buildDir = PathUtils [EOL] .getTestDirName(TestOfflineEditsViewer.class); [EOL] private static final OfflineEditsViewerHelper nnHelper = new OfflineEditsViewerHelper(); [EOL] private static final ImmutableSet<FSEditLogOpCodes> skippedOps = skippedOps(); [EOL] @Rule [EOL] public final TemporaryFolder folder = new TemporaryFolder(); [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       boolean[] booleanArray0 = new boolean[6]; [EOL]       boolean[] booleanArray1 = new boolean[9]; [EOL]       compareToBuilder0.append(booleanArray0, booleanArray1); [EOL]       compareToBuilder0.append('P', 'j'); [EOL]       assertEquals((-1), (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisEquals()  throws Throwable  { [EOL]       EqualsBuilder equalsBuilder0 = new EqualsBuilder(); [EOL]       short[] shortArray0 = new short[1]; [EOL]       EqualsBuilder equalsBuilder1 = equalsBuilder0.append(shortArray0, shortArray0); [EOL]        [EOL]       char[] charArray0 = new char[8]; [EOL]       charArray0[0] = '6'; [EOL]       charArray0[1] = 'l'; [EOL]       charArray0[2] = '4'; [EOL]       charArray0[3] = 'm'; [EOL]       charArray0[5] = '/'; [EOL]       charArray0[6] = '_'; [EOL]       charArray0[7] = 'F'; [EOL]       byte[] byteArray0 = new byte[4]; [EOL]       byteArray0[0] = (byte) (-1); [EOL]       byteArray0[1] = (byte) (-23); [EOL]       byteArray0[2] = (byte) (-23); [EOL]       byteArray0[3] = (byte)0; [EOL]       byte[] byteArray1 = new byte[4]; [EOL]       byteArray1[0] = (byte) (-1); [EOL]       byteArray1[1] = (byte) (-23); [EOL]       byteArray1[2] = (byte) (-23); [EOL]       byteArray1[3] = (byte) (-23); [EOL]       equalsBuilder1.append(byteArray0, byteArray1); [EOL]       assertFalse(equalsBuilder1.isEquals()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNumerator()  throws Throwable  { [EOL]       Fraction fraction0 = Fraction.getFraction(2374, 0, 2374); [EOL]       Fraction fraction1 = Fraction.getReducedFraction(0, 2374); [EOL]       Fraction fraction2 = fraction0.ONE_HALF.multiplyBy(fraction1); [EOL]       assertEquals(5635876, fraction0.getNumerator()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetEntitiesAclEnabled() throws Exception { [EOL] AdminACLsManager oldAdminACLsManager = [EOL] aclsManager.setAdminACLsManager(adminACLsManager); [EOL] try { [EOL] TimelineEntities entities = dataManaer.getEntities( [EOL] "ACL_ENTITY_TYPE_1", null, null, null, null, null, null, 1l, null, [EOL] UserGroupInformation.createUserForTesting("owner_1", new String[] {"group1"})); [EOL] Assert.assertEquals(1, entities.getEntities().size()); [EOL] Assert.assertEquals("ACL_ENTITY_ID_11", [EOL] entities.getEntities().get(0).getEntityId()); [EOL] } finally { [EOL] aclsManager.setAdminACLsManager(oldAdminACLsManager); [EOL] } [EOL] } [EOL] private FileContext fsContext; [EOL] private File fsPath; [EOL] private TimelineDataManager dataManaer; [EOL] private static TimelineACLsManager aclsManager; [EOL] private static AdminACLsManager adminACLsManager; [EOL]
@Test [EOL] public void testDecommissionWithExcludeHosts() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] conf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, hostFile [EOL] .getAbsolutePath()); [EOL] [EOL] writeToHostsFile(""); [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] [EOL] MockNM nm1 = rm.registerNode("host1:1234", 5120); [EOL] MockNM nm2 = rm.registerNode("host2:5678", 10240); [EOL] MockNM nm3 = rm.registerNode("localhost:4433", 1024); [EOL] [EOL] [EOL] int metricCount = ClusterMetrics.getMetrics().getNumDecommisionedNMs(); [EOL] NodeHeartbeatResponse nodeHeartbeat = nm1.nodeHeartbeat(true); [EOL] Assert.assertTrue(NodeAction.NORMAL.equals(nodeHeartbeat.getNodeAction())); [EOL] nodeHeartbeat = nm2.nodeHeartbeat(true); [EOL] Assert.assertTrue(NodeAction.NORMAL.equals(nodeHeartbeat.getNodeAction())); [EOL] rm.drainEvents(); [EOL] [EOL] // To test that IPs also work [EOL] String ip = NetUtils.normalizeHostName("localhost"); [EOL] writeToHostsFile("host2", ip); [EOL] [EOL] rm.getNodesListManager().refreshNodes(conf); [EOL] [EOL] checkDecommissionedNMCount(rm, metricCount + 2); [EOL] [EOL] nodeHeartbeat = nm1.nodeHeartbeat(true); [EOL] Assert.assertTrue(NodeAction.NORMAL.equals(nodeHeartbeat.getNodeAction())); [EOL] nodeHeartbeat = nm2.nodeHeartbeat(true); [EOL] Assert.assertTrue("The decommisioned metrics are not updated", [EOL] NodeAction.SHUTDOWN.equals(nodeHeartbeat.getNodeAction())); [EOL] [EOL] nodeHeartbeat = nm3.nodeHeartbeat(true); [EOL] Assert.assertTrue("The decommisioned metrics are not updated", [EOL] NodeAction.SHUTDOWN.equals(nodeHeartbeat.getNodeAction())); [EOL] rm.drainEvents(); [EOL] [EOL] writeToHostsFile(""); [EOL] rm.getNodesListManager().refreshNodes(conf); [EOL] [EOL] nm3 = rm.registerNode("localhost:4433", 1024); [EOL] nodeHeartbeat = nm3.nodeHeartbeat(true); [EOL] rm.drainEvents(); [EOL] Assert.assertTrue(NodeAction.NORMAL.equals(nodeHeartbeat.getNodeAction())); [EOL] // decommissined node is 1 since 1 node is rejoined after updating exclude [EOL] // file [EOL] checkDecommissionedNMCount(rm, metricCount + 1); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test(timeout = 4000) [EOL]   public void testisTrue()  throws Throwable  { [EOL]       Boolean boolean0 = Boolean.TRUE; [EOL]       MutableBoolean mutableBoolean0 = new MutableBoolean(boolean0); [EOL]       boolean boolean1 = mutableBoolean0.isTrue(); [EOL]       assertTrue(boolean1); [EOL]   } [EOL]  [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL] public void processPathDirDisplayECPolicyWhenUnsupported() [EOL] throws IOException { [EOL] TestFile testFile = new TestFile("testDirectory", "testFile"); [EOL] TestFile testDir = new TestFile("", "testDirectory"); [EOL] testDir.setIsDir(true); [EOL] testDir.addContents(testFile); [EOL] LinkedList<PathData> pathData = new LinkedList<PathData>(); [EOL] pathData.add(testDir.getPathData()); [EOL] Ls ls = new Ls(); [EOL] LinkedList<String> options = new LinkedList<String>(); [EOL] options.add("-e"); [EOL] ls.processOptions(options); [EOL] ls.processArguments(pathData); [EOL] } [EOL] private static Configuration conf; [EOL] private static FileSystem mockFs; [EOL] private static final Date NOW = new Date(); [EOL]
@Test [EOL] public void testNoHostsForUsers() throws Exception { [EOL] Configuration conf = new Configuration(false); [EOL] conf.set("y." + REAL_USER_NAME + ".users", [EOL] StringUtils.join(",", Arrays.asList(AUTHORIZED_PROXY_USER_NAME))); [EOL] ProxyUsers.refreshSuperUserGroupsConfiguration(conf, "y"); [EOL] [EOL] UserGroupInformation realUserUgi = UserGroupInformation [EOL] .createRemoteUser(REAL_USER_NAME); [EOL] UserGroupInformation proxyUserUgi = UserGroupInformation.createProxyUserForTesting( [EOL] AUTHORIZED_PROXY_USER_NAME, realUserUgi, GROUP_NAMES); [EOL] [EOL] // IP doesn't matter [EOL] assertNotAuthorized(proxyUserUgi, "1.2.3.4"); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestProxyUsers.class); [EOL] private static final String REAL_USER_NAME = "proxier"; [EOL] private static final String PROXY_USER_NAME = "proxied_user"; [EOL] private static final String AUTHORIZED_PROXY_USER_NAME = "authorized_proxied_user"; [EOL] private static final String[] GROUP_NAMES = [EOL] new String[] { "foo_group" }; [EOL] private static final String[] NETGROUP_NAMES = [EOL] new String[] { "@foo_group" }; [EOL] private static final String[] OTHER_GROUP_NAMES = [EOL] new String[] { "bar_group" }; [EOL] private static final String[] SUDO_GROUP_NAMES = [EOL] new String[] { "sudo_proxied_user" }; [EOL] private static final String PROXY_IP = "1.2.3.4"; [EOL] private static final String PROXY_IP_RANGE = "10.222.0.0/16,10.113.221.221"; [EOL]
@Test(timeout = 4000) [EOL]   public void testmid()  throws Throwable  { [EOL]       String string0 = null; [EOL]       String string1 = StringUtils.mid((String) null, 0, 1805); [EOL]       assertNull(string1); [EOL]        [EOL]       int[] intArray0 = new int[7]; [EOL]       intArray0[0] = 1805; [EOL]       intArray0[1] = 0; [EOL]       intArray0[2] = 0; [EOL]       intArray0[3] = 1805; [EOL]       intArray0[4] = 1805; [EOL]       intArray0[5] = 1805; [EOL]       intArray0[6] = 1805; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         StringUtils.join(intArray0, '.', (-502), 0); [EOL]         fail("Expecting exception: ArrayIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(ArrayIndexOutOfBoundsException e) { [EOL]          // [EOL]          // -502 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.StringUtils", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void getApplicationAttemptEntity() throws Exception { [EOL] ApplicationAttemptId attemptId = [EOL] ApplicationAttemptId.fromString("appattempt_1234_0001_000001"); [EOL] TimelineEntity entity = client.getApplicationAttemptEntity(attemptId, [EOL] null, null); [EOL] Assert.assertEquals("mockAppAttempt1", entity.getId()); [EOL] } [EOL] private TimelineReaderClient client; [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       int int0 = strBuilder_StrBuilderReader0.read(charArray0); [EOL]        [EOL]       charArray0[0] = 'n'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]        [EOL]       boolean boolean0 = strBuilder_StrBuilderReader0.ready(); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher(); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.replaceFirst(strMatcher0, "D:qv{0F`Yb3&H^f*N2"); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("D:qv{0F`Yb3&H^f*N2", 1); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder0; [EOL]       objectArray0[1] = (Object) charBuffer0; [EOL]       objectArray0[2] = (Object) strBuilder0; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       CharBuffer charBuffer1 = CharBuffer.allocate(0); [EOL]       assertTrue(charBuffer1.equals((Object)charBuffer0)); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.append("D:qv{0F`Yb3&H^f*N2", objectArray0); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.append((Object) ""); [EOL]        [EOL]       String string0 = strBuilder4.leftString(1); [EOL]        [EOL]       int int2 = strBuilder3.size(); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder3.appendln(true); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder3.appendSeparator("~G;2|T ", 1); [EOL]        [EOL]       Locale locale0 = Locale.CANADA; [EOL]        [EOL]       Set<String> set0 = locale0.getUnicodeLocaleKeys(); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder4.appendAll((Iterable<?>) set0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetAppAttempts() throws Exception { [EOL] Client client = createClient(); [EOL] try { [EOL] URI uri = URI.create("http://localhost:" + serverPort + "/ws/v2/" [EOL] + "timeline/clusters/cluster1/apps/app1/" [EOL] + "entities/YARN_APPLICATION_ATTEMPT"); [EOL] ClientResponse resp = getResponse(client, uri); [EOL] Set<TimelineEntity> entities = [EOL] resp.getEntity(new GenericType<Set<TimelineEntity>>() { [EOL] }); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] resp.getType().toString()); [EOL] assertNotNull(entities); [EOL] int totalEntities = entities.size(); [EOL] assertEquals(2, totalEntities); [EOL] assertTrue( [EOL] "Entity with app-attempt-2 should have been present in response.", [EOL] entities.contains( [EOL] newEntity(TimelineEntityType.YARN_APPLICATION_ATTEMPT.toString(), [EOL] "app-attempt-1"))); [EOL] assertTrue( [EOL] "Entity with app-attempt-2 should have been present in response.", [EOL] entities.contains( [EOL] newEntity(TimelineEntityType.YARN_APPLICATION_ATTEMPT.toString(), [EOL] "app-attempt-2"))); [EOL] [EOL] uri = URI.create("http://localhost:" + serverPort + "/ws/v2/" [EOL] + "timeline/clusters/cluster1/apps/app1/appattempts"); [EOL] resp = getResponse(client, uri); [EOL] entities = resp.getEntity(new GenericType<Set<TimelineEntity>>() { [EOL] }); [EOL] assertEquals(MediaType.APPLICATION_JSON_TYPE, resp.getType()); [EOL] assertNotNull(entities); [EOL] int retrievedEntity = entities.size(); [EOL] assertEquals(2, retrievedEntity); [EOL] assertTrue( [EOL] "Entity with app-attempt-2 should have been present in response.", [EOL] entities.contains( [EOL] newEntity(TimelineEntityType.YARN_APPLICATION_ATTEMPT.toString(), [EOL] "app-attempt-1"))); [EOL] assertTrue( [EOL] "Entity with app-attempt-2 should have been present in response.", [EOL] entities.contains( [EOL] newEntity(TimelineEntityType.YARN_APPLICATION_ATTEMPT.toString(), [EOL] "app-attempt-2"))); [EOL] [EOL] assertEquals(totalEntities, retrievedEntity); [EOL] [EOL] } finally { [EOL] client.destroy(); [EOL] } [EOL] } [EOL] private static final String ROOT_DIR = new File("target", [EOL] TestTimelineReaderWebServices.class.getSimpleName()).getAbsolutePath(); [EOL] private int serverPort; [EOL] private TimelineReaderServer server; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.noneMatcher(); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = '$'; [EOL]       charArray0[1] = 'B'; [EOL]       StrMatcher strMatcher1 = StrMatcher.charSetMatcher(charArray0); [EOL]        [EOL]       StrMatcher strMatcher2 = StrMatcher.stringMatcher("Invalid startIndex: "); [EOL]        [EOL]       int int0 = strBuilder0.lastIndexOf(strMatcher0); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       boolean boolean0 = strBuilder0.startsWith(""); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.append(true); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]       assertNull(strBuilder1.getNullText()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.deleteCharAt((-1)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test (timeout=60000) [EOL] public void testFileDeletionTaskDependency() throws Exception { [EOL] FakeDefaultContainerExecutor exec = new FakeDefaultContainerExecutor(); [EOL] Configuration conf = new Configuration(); [EOL] exec.setConf(conf); [EOL] DeletionService del = new DeletionService(exec); [EOL] del.init(conf); [EOL] del.start(); [EOL] [EOL] try { [EOL] Random r = new Random(); [EOL] long seed = r.nextLong(); [EOL] r.setSeed(seed); [EOL] System.out.println("SEED: " + seed); [EOL] List<Path> dirs = buildDirs(r, base, 2); [EOL] createDirs(new Path("."), dirs); [EOL] [EOL] // first we will try to delete sub directories which are present. This [EOL] // should then trigger parent directory to be deleted. [EOL] List<Path> subDirs = buildDirs(r, dirs.get(0), 2); [EOL] [EOL] FileDeletionTask dependentDeletionTask = [EOL] new FileDeletionTask(del, null, dirs.get(0), new ArrayList<Path>()); [EOL] List<FileDeletionTask> deletionTasks = new ArrayList<FileDeletionTask>(); [EOL] for (Path subDir : subDirs) { [EOL] List<Path> subDirList = new ArrayList<>(); [EOL] subDirList.add(subDir); [EOL] FileDeletionTask deletionTask = [EOL] new FileDeletionTask(del, null, dirs.get(0), subDirList); [EOL] deletionTask.addDeletionTaskDependency(dependentDeletionTask); [EOL] deletionTasks.add(deletionTask); [EOL] } [EOL] for (FileDeletionTask task : deletionTasks) { [EOL] del.delete(task); [EOL] } [EOL] [EOL] int msecToWait = 20 * 1000; [EOL] while (msecToWait > 0 && (lfs.util().exists(dirs.get(0)))) { [EOL] Thread.sleep(100); [EOL] msecToWait -= 100; [EOL] } [EOL] assertFalse(lfs.util().exists(dirs.get(0))); [EOL] [EOL] [EOL] // Now we will try to delete sub directories; one of the deletion task we [EOL] // will mark as failure and then parent directory should not be deleted. [EOL] subDirs = buildDirs(r, dirs.get(1), 2); [EOL] subDirs.add(new Path(dirs.get(1), "absentFile")); [EOL] [EOL] dependentDeletionTask = new FileDeletionTask(del, null, dirs.get(1), [EOL] new ArrayList<Path>()); [EOL] deletionTasks = new ArrayList<FileDeletionTask>(); [EOL] for (Path subDir : subDirs) { [EOL] List<Path> subDirList = new ArrayList<>(); [EOL] subDirList.add(subDir); [EOL] FileDeletionTask deletionTask = new FileDeletionTask(del, null, null, [EOL] subDirList); [EOL] deletionTask.addDeletionTaskDependency(dependentDeletionTask); [EOL] deletionTasks.add(deletionTask); [EOL] } [EOL] // marking one of the tasks as a failure. [EOL] deletionTasks.get(2).setSuccess(false); [EOL] for (FileDeletionTask task : deletionTasks) { [EOL] del.delete(task); [EOL] } [EOL] [EOL] msecToWait = 20 * 1000; [EOL] while (msecToWait > 0 [EOL] && (lfs.util().exists(subDirs.get(0)) || lfs.util().exists( [EOL] subDirs.get(1)))) { [EOL] Thread.sleep(100); [EOL] msecToWait -= 100; [EOL] } [EOL] assertTrue(lfs.util().exists(dirs.get(1))); [EOL] } finally { [EOL] del.stop(); [EOL] } [EOL] } [EOL] private static final FileContext lfs = getLfs(); [EOL] private static final Path base = [EOL] lfs.makeQualified(new Path("target", TestDeletionService.class.getName())); [EOL]
@Test(timeout = 4000) [EOL]   public void testregister()  throws Throwable  { [EOL]       HashCodeBuilder hashCodeBuilder0 = new HashCodeBuilder(); [EOL]       HashCodeBuilder hashCodeBuilder1 = hashCodeBuilder0.append('['); [EOL]       short[] shortArray0 = new short[7]; [EOL]       shortArray0[0] = (short)37; [EOL]       shortArray0[1] = (short) (-1872); [EOL]       shortArray0[2] = (short)2; [EOL]       HashCodeBuilder.reflectionHashCode((Object) hashCodeBuilder1, true); [EOL]       shortArray0[3] = (short)2; [EOL]       shortArray0[4] = (short) (-132); [EOL]       HashCodeBuilder.getRegistry(); [EOL]       shortArray0[5] = (short) (-1654); [EOL]       shortArray0[6] = (short)778; [EOL]       hashCodeBuilder1.append(shortArray0); [EOL]       HashCodeBuilder hashCodeBuilder2 = hashCodeBuilder1.append((int[]) null); [EOL]       IDKey iDKey0 = new IDKey(hashCodeBuilder2); [EOL]       HashCodeBuilder.register(iDKey0); [EOL]       Integer integer0 = hashCodeBuilder2.build(); [EOL]       assertEquals((-847924507), (int)integer0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testunescapeHtml3()  throws Throwable  { [EOL]       String string0 = StringEscapeUtils.unescapeHtml3("_uKyBnE~p"); [EOL]       assertEquals("_uKyBnE~p", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlastIndexOf()  throws Throwable  { [EOL]       int[] intArray0 = new int[7]; [EOL]       intArray0[3] = (-426); [EOL]       int int0 = ArrayUtils.lastIndexOf(intArray0, (-426), 102); [EOL]       assertEquals(3, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testappend()  throws Throwable  { [EOL]       Integer integer0 = new Integer((-1083)); [EOL]       ToStringStyle toStringStyle0 = ToStringStyle.SIMPLE_STYLE; [EOL]       ToStringBuilder toStringBuilder0 = new ToStringBuilder(integer0, toStringStyle0); [EOL]       byte[] byteArray0 = new byte[0]; [EOL]       ToStringBuilder toStringBuilder1 = toStringBuilder0.append(byteArray0); [EOL]       assertSame(toStringBuilder1, toStringBuilder0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testremoveElement()  throws Throwable  { [EOL]       byte[] byteArray0 = new byte[9]; [EOL]       byte[] byteArray1 = ArrayUtils.removeElement(byteArray0, (byte)15); [EOL]       assertEquals(9, byteArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtoComparison()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       Object object0 = new Object(); [EOL]       Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(0).when(comparator0).compare(any() , any()); [EOL]       CompareToBuilder compareToBuilder1 = compareToBuilder0.append((Object) "!Z;sl 2pEf u", object0, (Comparator<?>) comparator0); [EOL]       assertEquals(0, compareToBuilder1.toComparison()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetResource() throws IOException { [EOL] URL testJar = makeTestJar().toURI().toURL(); [EOL] [EOL] ClassLoader currentClassLoader = getClass().getClassLoader(); [EOL] ClassLoader appClassloader = new ApplicationClassLoader( [EOL] new URL[] { testJar }, currentClassLoader, null); [EOL] [EOL] assertNull("Resource should be null for current classloader", [EOL] currentClassLoader.getResourceAsStream("resource.txt")); [EOL] [EOL] InputStream in = appClassloader.getResourceAsStream("resource.txt"); [EOL] assertNotNull("Resource should not be null for app classloader", in); [EOL] assertEquals("hello", IOUtils.toString(in)); [EOL] } [EOL] private static File testDir = GenericTestUtils.getTestDir("appclassloader"); [EOL]
@Test(timeout = 4000) [EOL]   public void testtoPrimitive()  throws Throwable  { [EOL]       Boolean[] booleanArray0 = new Boolean[2]; [EOL]       Boolean boolean0 = Boolean.FALSE; [EOL]       booleanArray0[0] = boolean0; [EOL]       booleanArray0[1] = boolean0; [EOL]       boolean[] booleanArray1 = ArrayUtils.toPrimitive(booleanArray0); [EOL]       assertEquals(2, booleanArray1.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.trim(""); [EOL]        [EOL]       char[] charArray0 = new char[0]; [EOL]       int int0 = StringUtils.indexOfAny((CharSequence) "", charArray0); [EOL]       assertEquals(0, charArray0.length); [EOL]        [EOL]       boolean boolean0 = StringUtils.isNumericSpace(""); [EOL]        [EOL]       String string1 = StringUtils.chop(""); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetStart()  throws Throwable  { [EOL]       CharRange charRange0 = CharRange.isNotIn('\'', '~'); [EOL]       CharRange charRange1 = CharRange.isNot('M'); [EOL]       boolean boolean0 = charRange1.contains(charRange0); [EOL]       assertEquals('\'', charRange0.getStart()); [EOL]       assertEquals('M', charRange1.getStart()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetSubDir() throws Exception { [EOL] assertEquals(SUBDIR, deletionTask.getSubDir()); [EOL] } [EOL] private static final int ID = 0; [EOL] private static final String USER = "user"; [EOL] private static final Path SUBDIR = new Path("subdir"); [EOL] private static final Path BASEDIR = new Path("basedir"); [EOL] private List<Path> baseDirs = new ArrayList<>(); [EOL] private DeletionService deletionService; [EOL] private FileDeletionTask deletionTask; [EOL]
@Test(timeout = 4000) [EOL]   public void testadd()  throws Throwable  { [EOL]       Double double0 = new Double((-30.60225976818994)); [EOL]       MutableLong mutableLong0 = new MutableLong(double0); [EOL]       mutableLong0.add((Number) double0); [EOL]       assertEquals((short) (-60), mutableLong0.shortValue()); [EOL]   } [EOL]  [EOL]
@Test(expected = IOException.class) [EOL] public void testResetWithoutMark() throws IOException { [EOL] try (LimitInputStream limitInputStream = [EOL] new LimitInputStream(new RandomInputStream(), 128)) { [EOL] limitInputStream.reset(); [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testtoBoolean()  throws Throwable  { [EOL]       boolean boolean0 = BooleanUtils.toBooleanDefaultIfNull((Boolean) null, false); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testCompareToNulls8() throws DatatypeConfigurationException { [EOL] System.out.println("TModelInstanceDetailsComparator.compare nulls8"); [EOL] TModelInstanceDetails lhs = null; [EOL] TModelInstanceDetails rhs = null; [EOL] TModelInstanceDetailsComparator instance = new TModelInstanceDetailsComparator("hi", true, false, false); [EOL] int expResult = 0; [EOL] int result = instance.compare(lhs, rhs); [EOL] } [EOL]
@Test(timeout = 30000) [EOL] public void testCreateSnapshot() throws Exception { [EOL] Path snapRootPath = new Path("/snapPath"); [EOL] Path chRootedSnapRootPath = new Path("/a/b/snapPath"); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] conf.setClass("fs.mockfs.impl", MockFileSystem.class, FileSystem.class); [EOL] [EOL] URI chrootUri = URI.create("mockfs://foo/a/b"); [EOL] ChRootedFileSystem chrootFs = new ChRootedFileSystem(chrootUri, conf); [EOL] FileSystem mockFs = ((FilterFileSystem) chrootFs.getRawFileSystem()) [EOL] .getRawFileSystem(); [EOL] [EOL] chrootFs.createSnapshot(snapRootPath, "snap1"); [EOL] verify(mockFs).createSnapshot(chRootedSnapRootPath, "snap1"); [EOL] } [EOL] FileSystem fSys; [EOL] FileSystem fSysTarget; [EOL] Path chrootedTo; [EOL] FileSystemTestHelper fileSystemTestHelper; [EOL]
@Test(timeout = 4000) [EOL]   public void testnext()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getCSVInstance("$i%f"); [EOL]       strTokenizer0.nextToken(); [EOL]       strTokenizer0.setDelimiterChar('S'); [EOL]       assertEquals(0, strTokenizer0.previousIndex()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testMakeCompactString() { [EOL] final String GC1 = "group1.counter1:1"; [EOL] final String GC2 = "group2.counter2:3"; [EOL] Counters counters = new Counters(); [EOL] counters.incrCounter("group1", "counter1", 1); [EOL] assertEquals("group1.counter1:1", counters.makeCompactString()); [EOL] counters.incrCounter("group2", "counter2", 3); [EOL] String cs = counters.makeCompactString(); [EOL] assertTrue("Bad compact string", [EOL] cs.equals(GC1 + ',' + GC2) || cs.equals(GC2 + ',' + GC1)); [EOL] } [EOL] private static final long MAX_VALUE = 10; [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestCounters.class); [EOL] static final Enum<?> FRAMEWORK_COUNTER = TaskCounter.CPU_MILLISECONDS; [EOL] static final long FRAMEWORK_COUNTER_VALUE = 8; [EOL] static final String FS_SCHEME = "HDFS"; [EOL] static final FileSystemCounter FS_COUNTER = FileSystemCounter.BYTES_READ; [EOL] static final long FS_COUNTER_VALUE = 10; [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       int int0 = strBuilder_StrBuilderReader0.read(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-963), (-1), '/'); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher0 = StrMatcher.tabMatcher(); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.deleteAll(strMatcher0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]       assertTrue(strBuilder1.isEmpty()); [EOL]       assertTrue(strBuilder2.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[1] = '/'; [EOL]       CharBuffer charBuffer0 = CharBuffer.wrap(charArray0); [EOL]        [EOL]       int int1 = strBuilder_StrBuilderReader0.read(charBuffer0); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrMatcher strMatcher1 = StrMatcher.charSetMatcher("q=e;yKvV#~sM4D<2"); [EOL]        [EOL]       strBuilder_StrBuilderReader0.close(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder1.append((long) (-1)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.ensureCapacity((-1)); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]       assertFalse(strBuilder3.isEmpty()); [EOL]       assertFalse(strBuilder4.isEmpty()); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer(); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder_StrBuilderTokenizer0.isEmptyTokenAsNull()); [EOL]        [EOL]       List<String> list0 = strBuilder_StrBuilderTokenizer0.tokenize(charArray0, (-963), (-3316));yKvV#~sM4D<2")); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder_StrBuilderTokenizer0.isEmptyTokenAsNull()); [EOL]       assertTrue(list0.isEmpty()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder1.replaceFirst(strMatcher0, "Windows NT"); [EOL]       assertFalse(strBuilder5.isEmpty()); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder1.isEmpty()); [EOL]        [EOL]       char[] charArray1 = new char[2]; [EOL]        [EOL]       charArray1[0] = '/'; [EOL]       charArray1[1] = '/'; [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(charArray1); [EOL]       assertFalse(strBuilder0.isEmpty()); [EOL]       assertFalse(strBuilder6.isEmpty()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.appendln("hZ3CNnc|]e", 101, 97); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[8]; [EOL]       String string0 = StringUtils.mid("-", (-385), (-385)); [EOL]        [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       charSequenceArray0[5] = (CharSequence) "|qO{l0uUU|R8lUrfn"; [EOL]       long[] longArray0 = new long[9]; [EOL]       longArray0[0] = (long) (-385); [EOL]       longArray0[1] = (long) (-385); [EOL]       longArray0[2] = (long) (-385); [EOL]       longArray0[3] = (long) (-385); [EOL]       longArray0[4] = 3213L; [EOL]       longArray0[5] = (long) (-385); [EOL]       longArray0[6] = (long) (-385); [EOL]       longArray0[7] = (long) (-385); [EOL]       String string1 = StringUtils.join(longArray0, 'D'); [EOL]       assertFalse(string1.equals((Object)string0)); [EOL]        [EOL]       charSequenceArray0[6] = (CharSequence) "-385D-385D-385D-385D3213D-385D-385D-385D0"; [EOL]       charSequenceArray0[7] = (CharSequence) "|qO{l0uUU|R8lUrfn"; [EOL]       int int0 = StringUtils.indexOfDifference(charSequenceArray0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testhexDigitMsb0ToBinary()  throws Throwable  { [EOL]       boolean[] booleanArray0 = Conversion.hexDigitMsb0ToBinary('F'); [EOL]       assertTrue(Arrays.equals(new boolean[] {true, true, true, true}, booleanArray0)); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       String string0 = standardToStringStyle0.getFieldSeparator(); [EOL]       assertEquals("<", standardToStringStyle0.getSummaryObjectStartText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testArtifacts() throws IOException { [EOL] SliderFileSystem sfs = ServiceTestUtils.initMockFs(); [EOL] [EOL] Service app = new Service(); [EOL] app.setName("service1"); [EOL] app.setVersion("v1"); [EOL] Resource res = new Resource(); [EOL] app.setResource(res); [EOL] res.setMemory("512M"); [EOL] [EOL] // no artifact id fails with default type [EOL] Artifact artifact = new Artifact(); [EOL] app.setArtifact(artifact); [EOL] String compName = "comp1"; [EOL] Component comp = ServiceTestUtils.createComponent(compName); [EOL] [EOL] app.setComponents(Collections.singletonList(comp)); [EOL] try { [EOL] ServiceApiUtil.validateAndResolveService(app, sfs, CONF_DNS_ENABLED); [EOL] Assert.fail(EXCEPTION_PREFIX + "service with no artifact id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(String.format(ERROR_ARTIFACT_ID_FOR_COMP_INVALID, compName), [EOL] e.getMessage()); [EOL] } [EOL] [EOL] // no artifact id fails with SERVICE type [EOL] artifact.setType(Artifact.TypeEnum.SERVICE); [EOL] try { [EOL] ServiceApiUtil.validateAndResolveService(app, sfs, CONF_DNS_ENABLED); [EOL] Assert.fail(EXCEPTION_PREFIX + "service with no artifact id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(ERROR_ARTIFACT_ID_INVALID, e.getMessage()); [EOL] } [EOL] [EOL] // no artifact id fails with TARBALL type [EOL] artifact.setType(Artifact.TypeEnum.TARBALL); [EOL] try { [EOL] ServiceApiUtil.validateAndResolveService(app, sfs, CONF_DNS_ENABLED); [EOL] Assert.fail(EXCEPTION_PREFIX + "service with no artifact id"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals(String.format(ERROR_ARTIFACT_ID_FOR_COMP_INVALID, compName), [EOL] e.getMessage()); [EOL] } [EOL] [EOL] // everything valid here [EOL] artifact.setType(Artifact.TypeEnum.DOCKER); [EOL] artifact.setId("docker.io/centos:centos7"); [EOL] try { [EOL] ServiceApiUtil.validateAndResolveService(app, sfs, CONF_DNS_ENABLED); [EOL] } catch (IllegalArgumentException e) { [EOL] LOG.error("service attributes specified should be valid here", e); [EOL] Assert.fail(NO_EXCEPTION_PREFIX + e.getMessage()); [EOL] } [EOL] [EOL] assertThat(app.getLifetime()).isEqualTo(DEFAULT_UNLIMITED_LIFETIME); [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestServiceApiUtil.class); [EOL] private static final String EXCEPTION_PREFIX = "Should have thrown " + [EOL] "exception: "; [EOL] private static final String NO_EXCEPTION_PREFIX = "Should not have thrown " + [EOL] "exception: "; [EOL] private static final String LEN_64_STR = [EOL] "abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01"; [EOL] private static final YarnConfiguration CONF_DEFAULT_DNS = new [EOL] YarnConfiguration(); [EOL] private static final YarnConfiguration CONF_DNS_ENABLED = new [EOL] YarnConfiguration(); [EOL]
@Test(timeout = 4000) [EOL]   public void testtoString()  throws Throwable  { [EOL]       TimeZone timeZone0 = TimeZone.getTimeZone("<#"); [EOL]       Locale locale0 = Locale.CHINESE; [EOL]       FastDateParser fastDateParser0 = new FastDateParser("<#", timeZone0, locale0); [EOL]       Date date0 = fastDateParser0.parse("<#"); [EOL]       assertEquals("Fri Feb 14 20:21:21 GMT 2014", date0.toString()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testbuild()  throws Throwable  { [EOL]       CompareToBuilder compareToBuilder0 = new CompareToBuilder(); [EOL]       assertEquals(0, (int)compareToBuilder0.build()); [EOL]        [EOL]       char[] charArray0 = new char[8]; [EOL]       char[] charArray1 = new char[0]; [EOL]       compareToBuilder0.append(charArray0, charArray1); [EOL]       assertEquals(1, (int)compareToBuilder0.build()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNativeLibraryChecker() { [EOL] ExitUtil.disableSystemExit(); [EOL] // help should return normally [EOL] NativeLibraryChecker.main(new String[] {"-h"}); [EOL] // illegal argmuments should exit [EOL] expectExit(new String[] {"-a", "-h"}); [EOL] expectExit(new String[] {"aaa"}); [EOL] if (NativeCodeLoader.isNativeCodeLoaded()) { [EOL] // no argument should return normally [EOL] NativeLibraryChecker.main(new String[0]); [EOL] } else { [EOL] // no argument should exit [EOL] expectExit(new String[0]); [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testappendAsObjectToString()  throws Throwable  { [EOL]       Object object0 = new Object(); [EOL]       ToStringBuilder toStringBuilder0 = new ToStringBuilder(object0); [EOL]       ToStringBuilder toStringBuilder1 = toStringBuilder0.appendAsObjectToString(object0); [EOL]       assertSame(toStringBuilder0, toStringBuilder1); [EOL]   } [EOL]  [EOL]
@Test(expected = YarnException.class) [EOL] public void testReleaseError() throws Exception { [EOL] String message = "Mock IOExcepiton!"; [EOL] when(cProtocol.release(isA(ReleaseSharedCacheResourceRequest.class))) [EOL] .thenThrow(new IOException(message)); [EOL] client.release(mock(ApplicationId.class), "key"); [EOL] } [EOL] private static final Logger LOG = LoggerFactory [EOL] .getLogger(TestSharedCacheClientImpl.class); [EOL] public static SharedCacheClientImpl client; [EOL] public static ClientSCMProtocol cProtocol; [EOL] private static Path TEST_ROOT_DIR; [EOL] private static FileSystem localFs; [EOL] private static String input = "This is a test file."; [EOL] private static String inputChecksumSHA256 = [EOL] "f29bc64a9d3732b4b9035125fdb3285f5b6455778edca72414671e0ca3b2e0de"; [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOf()  throws Throwable  { [EOL]       int int0 = CharSequenceUtils.indexOf("", (-1), 2); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testAddNewIncludePathToConfiguration() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] rm = new MockRM(conf); [EOL] rm.start(); [EOL] MockNM nm1 = rm.registerNode("host1:1234", 5120); [EOL] MockNM nm2 = rm.registerNode("host2:5678", 10240); [EOL] ClusterMetrics metrics = ClusterMetrics.getMetrics(); [EOL] assert(metrics != null); [EOL] int initialMetricCount = metrics.getNumShutdownNMs(); [EOL] NodeHeartbeatResponse nodeHeartbeat = nm1.nodeHeartbeat(true); [EOL] Assert.assertEquals( [EOL] NodeAction.NORMAL, [EOL] nodeHeartbeat.getNodeAction()); [EOL] nodeHeartbeat = nm2.nodeHeartbeat(true); [EOL] Assert.assertEquals( [EOL] NodeAction.NORMAL, [EOL] nodeHeartbeat.getNodeAction()); [EOL] writeToHostsFile("host1"); [EOL] conf.set(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, hostFile [EOL] .getAbsolutePath()); [EOL] rm.getNodesListManager().refreshNodes(conf); [EOL] checkShutdownNMCount(rm, ++initialMetricCount); [EOL] nodeHeartbeat = nm1.nodeHeartbeat(true); [EOL] Assert.assertEquals( [EOL] "Node should not have been shutdown.", [EOL] NodeAction.NORMAL, [EOL] nodeHeartbeat.getNodeAction()); [EOL] NodeState nodeState = [EOL] rm.getRMContext().getInactiveRMNodes().get(nm2.getNodeId()).getState(); [EOL] Assert.assertEquals("Node should have been shutdown but is in state" + [EOL] nodeState, NodeState.SHUTDOWN, nodeState); [EOL] } [EOL] private final static File TEMP_DIR = new File(System.getProperty( [EOL] "test.build.data", "/tmp"), "decommision"); [EOL] private final File hostFile = [EOL] new File(TEMP_DIR + File.separator + "hostFile.txt"); [EOL] private final File excludeHostFile = new File(TEMP_DIR + File.separator + [EOL] "excludeHostFile.txt"); [EOL] private final File excludeHostXmlFile = [EOL] new File(TEMP_DIR + File.separator + "excludeHostFile.xml"); [EOL] private MockRM rm; [EOL]
@Test [EOL] @TestException(exception = ServiceException.class, msgRegExp = "H01.*") [EOL] @TestDir [EOL] public void noKerberosPrincipalProperty() throws Exception { [EOL] String dir = TestDirHelper.getTestDir().getAbsolutePath(); [EOL] String services = StringUtils.join(",", [EOL] Arrays.asList(InstrumentationService.class.getName(), [EOL] SchedulerService.class.getName(), [EOL] FileSystemAccessService.class.getName())); [EOL] Configuration conf = new Configuration(false); [EOL] conf.set("server.services", services); [EOL] conf.set("server.hadoop.authentication.type", "kerberos"); [EOL] conf.set("server.hadoop.authentication.kerberos.keytab", "/tmp/foo"); [EOL] conf.set("server.hadoop.authentication.kerberos.principal", " "); [EOL] Server server = new Server("server", dir, dir, dir, dir, conf); [EOL] server.init(); [EOL] } [EOL]
@Test [EOL] public void testGetAllocationFileFromFileSystem() [EOL] throws IOException, URISyntaxException { [EOL] File baseDir = [EOL] new File(TEST_DIR + Path.SEPARATOR + "getAllocHDFS").getAbsoluteFile(); [EOL] FileUtil.fullyDelete(baseDir); [EOL] conf.set(MiniDFSCluster.HDFS_MINIDFS_BASEDIR, baseDir.getAbsolutePath()); [EOL] MiniDFSCluster.Builder builder = new MiniDFSCluster.Builder(conf); [EOL] MiniDFSCluster hdfsCluster = builder.build(); [EOL] String fsAllocPath = "hdfs://localhost:" + hdfsCluster.getNameNodePort() [EOL] + Path.SEPARATOR + TEST_FAIRSCHED_XML; [EOL] [EOL] URL fschedURL = Thread.currentThread().getContextClassLoader() [EOL] .getResource(TEST_FAIRSCHED_XML); [EOL] FileSystem fs = FileSystem.get(conf); [EOL] fs.copyFromLocalFile(new Path(fschedURL.toURI()), new Path(fsAllocPath)); [EOL] conf.set(FairSchedulerConfiguration.ALLOCATION_FILE, fsAllocPath); [EOL] [EOL] AllocationFileLoaderService allocLoader = [EOL] new AllocationFileLoaderService(scheduler); [EOL] Path allocationFile = allocLoader.getAllocationFile(conf); [EOL] assertEquals(fsAllocPath, allocationFile.toString()); [EOL] assertTrue(fs.exists(allocationFile)); [EOL] [EOL] hdfsCluster.shutdown(true); [EOL] } [EOL] private static final String A_CUSTOM_RESOURCE = "a-custom-resource"; [EOL] final static String TEST_DIR = new File(System.getProperty("test.build.data", [EOL] "/tmp")).getAbsolutePath(); [EOL] final static String ALLOC_FILE = new File(TEST_DIR, [EOL] "test-queues").getAbsolutePath(); [EOL] private static final String TEST_FAIRSCHED_XML = "test-fair-scheduler.xml"; [EOL] private FairScheduler scheduler; [EOL] private Configuration conf; [EOL]
@Test [EOL] public void testGetYarnGpuResourceInfo() [EOL] throws YarnException, JSONException { [EOL] setupMockPluginsWithGpuResourceInfo(); [EOL] [EOL] WebResource r = resource(); [EOL] ClientResponse response = getNMResourceResponse(r, "resource-1"); [EOL] assertEquals("MediaType of the response is not the expected!", [EOL] MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] response.getType().toString()); [EOL] JSONObject json = response.getEntity(JSONObject.class); [EOL] assertEquals("Unexpected driverVersion in the json response!", [EOL] "1.2.3", [EOL] json.getJSONObject("gpuDeviceInformation").get("driverVersion")); [EOL] assertEquals("Unexpected totalGpuDevices in the json response!", [EOL] 3, json.getJSONArray("totalGpuDevices").length()); [EOL] assertEquals("Unexpected assignedGpuDevices in the json response!", [EOL] 2, json.getJSONArray("assignedGpuDevices").length()); [EOL] } [EOL] private static final long NM_RESOURCE_VALUE = 1000L; [EOL] private static NodeManager.NMContext nmContext; [EOL] private static ResourceView resourceView; [EOL] private static ApplicationACLsManager aclsManager; [EOL] private static LocalDirsHandlerService dirsHandler; [EOL] private static WebApp nmWebApp; [EOL] private static final String LOGSERVICEWSADDR = "test:1234"; [EOL] private static final String LOG_MESSAGE = "log message\n"; [EOL] private static final File testRootDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName()); [EOL] private static File testLogDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName() + "LogDir"); [EOL] private static File testRemoteLogDir = new File("target", [EOL] TestNMWebServices.class.getSimpleName() + "remote-log-dir"); [EOL]
@Test [EOL] public void testGroupPolicies() [EOL] throws IOException, ContainerExecutionException { [EOL] // Generate new policy files each containing one grant [EOL] File openSocketPolicyFile = [EOL] File.createTempFile("openSocket", "policy", baseTestDirectory); [EOL] File classLoaderPolicyFile = [EOL] File.createTempFile("createClassLoader", "policy", baseTestDirectory); [EOL] Permission socketPerm = new SocketPermission("localhost:0", "listen"); [EOL] Permission runtimePerm = new RuntimePermission("createClassLoader"); [EOL] [EOL] StringBuilder socketPermString = new StringBuilder(); [EOL] Formatter openSocketPolicyFormatter = new Formatter(socketPermString); [EOL] openSocketPolicyFormatter.format(SOCKET_PERMISSION_FORMAT, [EOL] socketPerm.getClass().getName(), socketPerm.getName(), [EOL] socketPerm.getActions()); [EOL] FileWriter socketPermWriter = new FileWriter(openSocketPolicyFile); [EOL] socketPermWriter.write(socketPermString.toString()); [EOL] socketPermWriter.close(); [EOL] [EOL] StringBuilder classLoaderPermString = new StringBuilder(); [EOL] Formatter classLoaderPolicyFormatter = new Formatter(classLoaderPermString); [EOL] classLoaderPolicyFormatter.format(RUNTIME_PERMISSION_FORMAT, [EOL] runtimePerm.getClass().getName(), runtimePerm.getName()); [EOL] FileWriter classLoaderPermWriter = new FileWriter(classLoaderPolicyFile); [EOL] classLoaderPermWriter.write(classLoaderPermString.toString()); [EOL] classLoaderPermWriter.close(); [EOL] [EOL] conf.set(YarnConfiguration.YARN_CONTAINER_SANDBOX_POLICY_GROUP_PREFIX + [EOL] WHITELIST_GROUP, openSocketPolicyFile.toString()); [EOL] conf.set(YarnConfiguration.YARN_CONTAINER_SANDBOX_POLICY_GROUP_PREFIX + [EOL] NORMAL_GROUP, classLoaderPolicyFile.toString()); [EOL] [EOL] String[] inputCommand = {"$JAVA_HOME/bin/java jar MyJob.jar"}; [EOL] List<String> commands = Arrays.asList(inputCommand); [EOL] [EOL] runtimeContextBuilder.setExecutionAttribute(USER, WHITELIST_USER); [EOL] runtimeContextBuilder.setExecutionAttribute(CONTAINER_RUN_CMDS, commands); [EOL] [EOL] runtime.prepareContainer(runtimeContextBuilder.build()); [EOL] [EOL] //pull generated policy from cmd [EOL] Matcher policyMatches = Pattern.compile(POLICY_APPEND_FLAG + "=?([^ ]+)") [EOL] .matcher(commands.get(0)); [EOL] policyMatches.find(); [EOL] String generatedPolicy = policyMatches.group(1); [EOL] [EOL] //Test that generated policy file has included both policies [EOL] Assert.assertTrue( [EOL] Files.readAllLines(Paths.get(generatedPolicy)).contains( [EOL] classLoaderPermString.toString().split("\n")[1])); [EOL] Assert.assertTrue( [EOL] Files.readAllLines(Paths.get(generatedPolicy)).contains( [EOL] socketPermString.toString().split("\n")[1])); [EOL] } [EOL] private final static String HADOOP_HOME = "hadoop.home.dir"; [EOL] private final static String HADOOP_HOME_DIR = System.getProperty(HADOOP_HOME); [EOL] private final Properties baseProps = new Properties(System.getProperties()); [EOL] @Rule [EOL] public ExpectedException exception = ExpectedException.none(); [EOL] private static File grantFile, denyFile, policyFile, [EOL] grantDir, denyDir, containerDir; [EOL] private static java.nio.file.Path policyFilePath; [EOL] private static SecurityManager securityManager; [EOL] private Map<Path, List<String>> resources; [EOL] private Map<String, String> env; [EOL] private List<String> whitelistGroup; [EOL] private PrivilegedOperationExecutor mockExecutor; [EOL] private JavaSandboxLinuxContainerRuntime runtime; [EOL] private ContainerRuntimeContext.Builder runtimeContextBuilder; [EOL] private Configuration conf; [EOL] private final static String NORMAL_USER = System.getProperty("user.name"); [EOL] private final static String NORMAL_GROUP = "normalGroup"; [EOL] private final static String WHITELIST_USER = "picard"; [EOL] private final static String WHITELIST_GROUP = "captains"; [EOL] private final static String CONTAINER_ID = "container_1234567890"; [EOL] private final static String APPLICATION_ID = "application_1234567890"; [EOL] private File baseTestDirectory; [EOL] public static final String SOCKET_PERMISSION_FORMAT = [EOL] "grant { \n" + [EOL] " permission %1s \"%2s\", \"%3s\";\n" + [EOL] "};\n"; [EOL] public static final String RUNTIME_PERMISSION_FORMAT = [EOL] "grant { \n" + [EOL] " permission %1s \"%2s\";\n" + [EOL] "};\n"; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = "SzpQ!4 ;U"; [EOL]       StrBuilder strBuilder0 = new StrBuilder("SzpQ!4 ;U"); [EOL]       assertEquals(9, strBuilder0.length()); [EOL]        [EOL]       char char0 = '`'; [EOL]       StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) "SzpQ!4 ;U", 97, '`'); [EOL]       assertEquals(106, strBuilder0.length()); [EOL]       assertEquals(106, strBuilder1.length()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder0.appendSeparator("SzpQ!4 ;U"); [EOL]       assertEquals(115, strBuilder0.length()); [EOL]       assertEquals(115, strBuilder2.length()); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.insert(97, (long) 2817); [EOL]       assertEquals(119, strBuilder0.length()); [EOL]       assertEquals(119, strBuilder2.length()); [EOL]       assertEquals(119, strBuilder3.length()); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder3.append('`'); [EOL]       assertEquals(120, strBuilder0.length()); [EOL]       assertEquals(120, strBuilder2.length()); [EOL]       assertEquals(120, strBuilder3.length()); [EOL]       assertEquals(120, strBuilder4.length()); [EOL]        [EOL]       StrBuilder strBuilder5 = strBuilder1.replaceFirst("SzpQ!4 ;U", "SzpQ!4 ;U"); [EOL]       assertEquals(120, strBuilder0.length()); [EOL]       assertEquals(120, strBuilder1.length()); [EOL]       assertEquals(120, strBuilder5.length()); [EOL]        [EOL]       String string1 = strBuilder0.getNullText(); [EOL]       assertEquals(120, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder2.replaceAll("SzpQ!4 ;U", "SzpQ!4 ;U"); [EOL]       assertEquals(120, strBuilder0.length()); [EOL]       assertEquals(120, strBuilder2.length()); [EOL]       assertEquals(120, strBuilder6.length()); [EOL]        [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert(2817, (-1.0F)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: 2817 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testtokenize()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("org.apache.commons.lang3.text.StrBuilder"); [EOL]       String string0 = strTokenizer0.toString(); [EOL]       assertEquals("StrTokenizer[not tokenized yet]", string0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisIgnoreEmptyTokens()  throws Throwable  { [EOL]       StrTokenizer strTokenizer0 = new StrTokenizer(); [EOL]       strTokenizer0.previousToken(); [EOL]       assertTrue(strTokenizer0.isIgnoreEmptyTokens()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testcapacity()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(0); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       String string0 = strBuilder0.build(); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendln('N'); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]        [EOL]       StrBuilder strBuilder2 = strBuilder1.replaceAll("", (String) null); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]       assertEquals(32, strBuilder1.capacity()); [EOL]       assertEquals(32, strBuilder2.capacity()); [EOL]        [EOL]       String string1 = strBuilder0.rightString((-2383)); [EOL]       assertEquals(32, strBuilder0.capacity()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testInfoFiltersParsing() throws Exception { [EOL] String expr = "(((key11 ne 234 AND key12 eq val12) AND " + [EOL] "(key13 ene val13 OR key14 eq 567)) OR (key21 eq val_21 OR key22 eq " + [EOL] "5.0))"; [EOL] TimelineFilterList expectedList = new TimelineFilterList( [EOL] Operator.OR, [EOL] new TimelineFilterList( [EOL] Operator.AND, [EOL] new TimelineFilterList( [EOL] Operator.AND, [EOL] new TimelineKeyValueFilter(TimelineCompareOp.NOT_EQUAL, [EOL] "key11", 234, false), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "key12", "val12", true) [EOL] ), [EOL] new TimelineFilterList( [EOL] Operator.OR, [EOL] new TimelineKeyValueFilter(TimelineCompareOp.NOT_EQUAL, [EOL] "key13", "val13", true), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "key14", 567, true) [EOL] ) [EOL] ), [EOL] new TimelineFilterList( [EOL] Operator.OR, [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "key21", "val_21", true), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "key22", 5.0, true) [EOL] ) [EOL] ); [EOL] verifyFilterList(expr, TimelineReaderWebServicesUtils. [EOL] parseKVFilters(expr, false), expectedList); [EOL] [EOL] expr = "abc ne 234 AND def eq 23 OR rst ene 24 OR xyz eq 456 AND pqr eq " + [EOL] "val.1234"; [EOL] expectedList = new TimelineFilterList( [EOL] new TimelineFilterList( [EOL] Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineKeyValueFilter(TimelineCompareOp.NOT_EQUAL, [EOL] "abc", 234, false), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "def", 23, true) [EOL] ), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.NOT_EQUAL, [EOL] "rst", 24, true), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "xyz", 456, true) [EOL] ), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "pqr", "val.1234", true) [EOL] ); [EOL] verifyFilterList(expr, TimelineReaderWebServicesUtils. [EOL] parseKVFilters(expr, false), expectedList); [EOL] [EOL] // Test with unnecessary spaces. [EOL] expr = " abc ne 234 AND def eq 23 OR rst ene "+ [EOL] " 24 OR xyz eq 456 AND pqr eq 2 "; [EOL] expectedList = new TimelineFilterList( [EOL] new TimelineFilterList( [EOL] Operator.OR, [EOL] new TimelineFilterList( [EOL] new TimelineKeyValueFilter(TimelineCompareOp.NOT_EQUAL, [EOL] "abc", 234, false), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "def", 23, true) [EOL] ), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.NOT_EQUAL, [EOL] "rst", 24, true), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "xyz", 456, true) [EOL] ), [EOL] new TimelineKeyValueFilter(TimelineCompareOp.EQUAL, [EOL] "pqr", 2, true) [EOL] ); [EOL] verifyFilterList(expr, TimelineReaderWebServicesUtils. [EOL] parseKVFilters(expr, false), expectedList); [EOL] [EOL] expr = "abdeq"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseKVFilters(expr, false); [EOL] Assert.fail("Expression valuation should throw exception."); [EOL] } catch (TimelineParseException e) { [EOL] // expected: do nothing [EOL] } [EOL] [EOL] expr = "abc gt 234 AND defeq"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseKVFilters(expr, false); [EOL] Assert.fail("Expression valuation should throw exception."); [EOL] } catch (TimelineParseException e) { [EOL] // expected: do nothing [EOL] } [EOL] [EOL] expr = "((key11 ne 234 AND key12 eq val12) AND (key13eq OR key14 eq va14))"; [EOL] try { [EOL] TimelineReaderWebServicesUtils.parseKVFilters(expr, false); [EOL] Assert.fail("Expression valuation should throw exception."); [EOL] } catch (TimelineParseException e) { [EOL] // expected: do nothing [EOL] } [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testisEmpty()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertTrue(strBuilder0.isEmpty()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '$'; [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder0.insert((-1774), charArray0, 2269, 2269); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // String index out of range: -1774 [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testGetJarsInDirectory() throws Exception { [EOL] List<Path> jars = FileUtil.getJarsInDirectory("/foo/bar/bogus/"); [EOL] assertTrue("no jars should be returned for a bogus path", [EOL] jars.isEmpty()); [EOL] [EOL] [EOL] // create jar files to be returned [EOL] File jar1 = new File(tmp, "wildcard1.jar"); [EOL] File jar2 = new File(tmp, "wildcard2.JAR"); [EOL] List<File> matches = Arrays.asList(jar1, jar2); [EOL] for (File match: matches) { [EOL] assertTrue("failure creating file: " + match, match.createNewFile()); [EOL] } [EOL] [EOL] // create non-jar files, which we expect to not be included in the result [EOL] assertTrue(new File(tmp, "text.txt").createNewFile()); [EOL] assertTrue(new File(tmp, "executable.exe").createNewFile()); [EOL] assertTrue(new File(tmp, "README").createNewFile()); [EOL] [EOL] // pass in the directory [EOL] String directory = tmp.getCanonicalPath(); [EOL] jars = FileUtil.getJarsInDirectory(directory); [EOL] assertEquals("there should be 2 jars", 2, jars.size()); [EOL] for (Path jar: jars) { [EOL] URL url = jar.toUri().toURL(); [EOL] assertTrue("the jar should match either of the jars", [EOL] url.equals(jar1.toURI().toURL()) || url.equals(jar2.toURI().toURL())); [EOL] } [EOL] } [EOL] private static final Logger LOG = LoggerFactory.getLogger(TestFileUtil.class); [EOL] @Rule [EOL] public TemporaryFolder testFolder = new TemporaryFolder(); [EOL] private static final String FILE = "x"; [EOL] private static final String LINK = "y"; [EOL] private static final String DIR = "dir"; [EOL] private static final String FILE_1_NAME = "file1"; [EOL] private File del; [EOL] private File tmp; [EOL] private File dir1; [EOL] private File dir2; [EOL] private File partitioned; [EOL] private File xSubDir; [EOL] private File xSubSubDir; [EOL] private File ySubDir; [EOL] private File file2; [EOL] private File file22; [EOL] private File file3; [EOL] private File zlink; [EOL] private InetAddress inet1; [EOL] private InetAddress inet2; [EOL] private InetAddress inet3; [EOL] private InetAddress inet4; [EOL] private InetAddress inet5; [EOL] private InetAddress inet6; [EOL] private URI uri1; [EOL] private URI uri2; [EOL] private URI uri3; [EOL] private URI uri4; [EOL] private URI uri5; [EOL] private URI uri6; [EOL] private FileSystem fs1; [EOL] private FileSystem fs2; [EOL] private FileSystem fs3; [EOL] private FileSystem fs4; [EOL] private FileSystem fs5; [EOL] private FileSystem fs6; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(); [EOL]       assertEquals(0, strBuilder0.length()); [EOL]        [EOL]       StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance("Invalid startIndex: "); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator<?>) strTokenizer0, "Invalid startIndex: "); [EOL]       assertEquals(27, strBuilder0.length()); [EOL]       assertEquals(27, strBuilder1.length()); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = '\\'; [EOL]       StrBuilder strBuilder2 = strBuilder1.appendln(charArray0); [EOL]       assertEquals(29, strBuilder0.length()); [EOL]       assertEquals(29, strBuilder1.length()); [EOL]       assertEquals(29, strBuilder2.length()); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       StrBuilder strBuilder3 = strBuilder2.appendln((Object) strBuilder0); [EOL]       assertEquals(81, strBuilder0.length()); [EOL]       assertEquals(81, strBuilder1.length()); [EOL]       assertEquals(81, strBuilder2.length()); [EOL]       assertEquals(81, strBuilder3.length()); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       StrBuilder strBuilder4 = strBuilder0.setLength(2822); [EOL]       assertEquals(2822, strBuilder0.length()); [EOL]       assertEquals(2822, strBuilder4.length()); [EOL]        [EOL]       Object[] objectArray0 = new Object[4]; [EOL]       objectArray0[0] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) strBuilder4; [EOL]       objectArray0[2] = (Object) '\\'; [EOL]       objectArray0[3] = (Object) strBuilder1; [EOL]       StrBuilder strBuilder5 = strBuilder4.appendAll(objectArray0); [EOL]       assertEquals(2954, strBuilder0.length()); [EOL]       assertEquals(2954, strBuilder4.length()); [EOL]       assertEquals(2954, strBuilder5.length()); [EOL]       assertEquals(4, objectArray0.length); [EOL]        [EOL]       StrBuilder strBuilder6 = strBuilder0.appendln(strBuilder1, 0, 2822); [EOL]       assertEquals(5777, strBuilder0.length()); [EOL]       assertEquals(5777, strBuilder1.length()); [EOL]       assertEquals(5777, strBuilder6.length()); [EOL]        [EOL]       int int0 = strBuilder6.lastIndexOf("Invalid startIndex: "); [EOL]       assertEquals(5777, strBuilder0.length()); [EOL]       assertEquals(5777, strBuilder1.length()); [EOL]       assertEquals(5777, strBuilder6.length()); [EOL]        [EOL]       StrBuilder strBuilder7 = strBuilder0.append(false); [EOL]       assertEquals(5782, strBuilder7.length()); [EOL]       assertEquals(5782, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder8 = strBuilder1.appendln(1490.882886748184); [EOL]       assertEquals(5800, strBuilder0.length()); [EOL]       assertEquals(5800, strBuilder8.length()); [EOL]       assertEquals(5800, strBuilder1.length()); [EOL]        [EOL]       StrBuilder strBuilder9 = strBuilder6.append(strBuilder3, 0, 2822); [EOL]       assertEquals(8622, strBuilder0.length()); [EOL]       assertEquals(8622, strBuilder9.length()); [EOL]       assertEquals(8622, strBuilder1.length()); [EOL]       assertEquals(8622, strBuilder2.length()); [EOL]       assertEquals(8622, strBuilder3.length()); [EOL]       assertEquals(8622, strBuilder6.length()); [EOL]       assertEquals(1, charArray0.length); [EOL]        [EOL]       StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder8.new StrBuilderTokenizer(); [EOL]       assertEquals(8622, strBuilder0.length()); [EOL]       assertEquals(8622, strBuilder8.length()); [EOL]       assertEquals(8622, strBuilder1.length()); [EOL]        [EOL]       StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getQuoteMatcher(); [EOL]       assertEquals(8622, strBuilder0.length()); [EOL]       assertEquals(8622, strBuilder8.length()); [EOL]       assertEquals(8622, strBuilder1.length()); [EOL]        [EOL]       StrBuilder strBuilder10 = strBuilder0.deleteAll(strMatcher0); [EOL]       assertEquals(8622, strBuilder0.length()); [EOL]       assertEquals(8622, strBuilder8.length()); [EOL]       assertEquals(8622, strBuilder1.length()); [EOL]       assertEquals(8622, strBuilder10.length()); [EOL]        [EOL]       StrBuilder strBuilder11 = strBuilder6.deleteFirst('\\'); [EOL]       assertEquals(8621, strBuilder0.length()); [EOL]       assertEquals(8621, strBuilder1.length()); [EOL]       assertEquals(8621, strBuilder11.length()); [EOL]       assertEquals(8621, strBuilder6.length()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testdecrement()  throws Throwable  { [EOL]       MutableDouble mutableDouble0 = new MutableDouble((-447.178917)); [EOL]       mutableDouble0.decrement(); [EOL]       mutableDouble0.subtract((-447.178917)); [EOL]       mutableDouble0.getValue(); [EOL]       assertEquals((-1), mutableDouble0.intValue()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testProfileParamsDefaults() { [EOL] JobConf configuration = new JobConf(); [EOL] String result = configuration.getProfileParams(); [EOL] Assert.assertNotNull(result); [EOL] Assert.assertTrue(result.contains("file=%s")); [EOL] Assert.assertTrue(result.startsWith("-agentlib:hprof")); [EOL] } [EOL]
@Test [EOL] public void testExecContainer() throws Exception { [EOL] Container container = mock(Container.class); [EOL] LinuxContainerExecutor lce = mock(LinuxContainerExecutor.class); [EOL] ContainerExecContext.Builder builder = [EOL] new ContainerExecContext.Builder(); [EOL] builder.setUser("foo").setAppId("app1").setContainer(container); [EOL] ContainerExecContext ctx = builder.build(); [EOL] lce.execContainer(ctx); [EOL] verify(lce, times(1)).execContainer(ctx); [EOL] } [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLinuxContainerExecutor.class); [EOL] private static File workSpace; [EOL] private LinuxContainerExecutor exec = null; [EOL] private String appSubmitter = null; [EOL] private LocalDirsHandlerService dirsHandler; [EOL] private Configuration conf; [EOL] private FileContext files; [EOL] private int id = 0; [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       String string0 = StringUtils.leftPad((String) null, 114); [EOL]        [EOL]       int int0 = StringUtils.indexOf((CharSequence) null, (CharSequence) null, 114); [EOL]        [EOL]       int int1 = StringUtils.lastIndexOf((CharSequence) null, (-1)); [EOL]        [EOL]       int int2 = StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null, 1124); [EOL]        [EOL]       String[] stringArray0 = StringUtils.split("\n", 'e'); [EOL]       assertEquals(1, stringArray0.length); [EOL]        [EOL]       String string1 = StringUtils.removeStart((String) null, "}%"); [EOL]        [EOL]       String string2 = StringUtils.defaultIfBlank((String) null, "3::s0DFSZzQA>V_CN"); [EOL]        [EOL]       String string3 = StringUtils.prependIfMissing((String) null, (CharSequence) null, stringArray0); [EOL]       assertEquals(1, stringArray0.length); [EOL]        [EOL]       String string4 = StringUtils.rightPad(" is not in the range '0' - '9'", 1124, (String) null); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitByWholeSeparator((String) null, (String) null, (-1)); [EOL]        [EOL]       String string5 = StringUtils.right((String) null, (-240)); [EOL]        [EOL]       String string6 = StringUtils.difference((String) null, (String) null); [EOL]        [EOL]       boolean boolean0 = StringUtils.endsWithIgnoreCase(string4, (CharSequence) null); [EOL]        [EOL]       String string7 = StringUtils.reverse(" is not in the range '0' - '9'"); [EOL]        [EOL]       char[] charArray0 = new char[2]; [EOL]       charArray0[0] = 'e'; [EOL]       boolean boolean1 = StringUtils.containsOnly((CharSequence) "'9' - '0' egnar eht ni ton si ", charArray0); [EOL]       assertEquals(2, charArray0.length); [EOL]        [EOL]       short[] shortArray0 = new short[8]; [EOL]       shortArray0[0] = (short) (-700); [EOL]       shortArray0[1] = (short)2431; [EOL]       shortArray0[2] = (short)336; [EOL]       shortArray0[3] = (short) (-1905); [EOL]       shortArray0[4] = (short)2; [EOL]       shortArray0[5] = (short)16; [EOL]       shortArray0[6] = (short)0; [EOL]       shortArray0[7] = (short) (-2743); [EOL]       String string8 = StringUtils.join(shortArray0, ')'); [EOL]       assertEquals(8, shortArray0.length); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testindexOfThrowable()  throws Throwable  { [EOL]       MockThrowable mockThrowable0 = new MockThrowable(); [EOL]       MockThrowable mockThrowable1 = new MockThrowable(); [EOL]       mockThrowable0.initCause(mockThrowable1); [EOL]       Class<Throwable> class0 = Throwable.class; [EOL]       int int0 = ExceptionUtils.indexOfThrowable((Throwable) mockThrowable0, (Class<?>) class0); [EOL]       assertEquals((-1), int0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testApplyReplicationTokenChanges() throws Exception { [EOL] System.out.println("applyReplicationTokenChanges"); [EOL] InputStream fis = getClass().getClassLoader().getResourceAsStream("juddi_install_data/root_replicationConfiguration.xml"); [EOL] [EOL] ReplicationConfiguration replicationCfg = (ReplicationConfiguration) XmlUtils.unmarshal(fis, ReplicationConfiguration.class); [EOL] Properties props = new Properties(); [EOL] props.put(Property.JUDDI_NODE_ID, "uddi:a_custom_node"); [EOL] props.put(Property.JUDDI_BASE_URL, "http://juddi.apache.org"); [EOL] props.put(Property.JUDDI_BASE_URL_SECURE, "https://juddi.apache.org"); [EOL] [EOL] Configuration config = new MapConfiguration(props); [EOL] String thisnode = "uddi:a_custom_node"; [EOL] [EOL] ReplicationConfiguration result = Install.applyReplicationTokenChanges(replicationCfg, config, thisnode); [EOL] StringWriter sw = new StringWriter(); [EOL] JAXB.marshal(result, sw); [EOL] Assert.assertFalse(sw.toString().contains("${juddi.nodeId}")); [EOL] Assert.assertFalse(sw.toString().contains("${juddi.server.baseurlsecure}")); [EOL] Assert.assertFalse(sw.toString().contains("${juddi.server.baseurl}")); [EOL] [EOL] } [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       String[] stringArray0 = StringUtils.stripAll((String[]) null, "TT"); [EOL]        [EOL]       String string0 = StringUtils.substringAfter("TT", "TT"); [EOL]        [EOL]       char[] charArray0 = new char[1]; [EOL]       charArray0[0] = 'E'; [EOL]       boolean boolean0 = StringUtils.containsOnly((CharSequence) "", charArray0); [EOL]        [EOL]       String string1 = StringUtils.substringBeforeLast("", ""); [EOL]       assertTrue(string1.equals((Object)string0)); [EOL]        [EOL]       String string2 = StringUtils.repeat("", 116); [EOL]       assertTrue(string2.equals((Object)string0)); [EOL]       assertTrue(string2.equals((Object)string1)); [EOL]        [EOL]       String[] stringArray1 = StringUtils.splitPreserveAllTokens(""); [EOL]        [EOL]       String string3 = StringUtils.removePattern("", ""); [EOL]       assertTrue(string3.equals((Object)string2)); [EOL]       assertTrue(string3.equals((Object)string0)); [EOL]       assertTrue(string3.equals((Object)string1)); [EOL]        [EOL]       String string4 = StringUtils.stripStart("pG$0h;W-R>", "TT"); [EOL]       assertFalse(string4.equals((Object)string0)); [EOL]       assertFalse(string4.equals((Object)string3)); [EOL]       assertFalse(string4.equals((Object)string2)); [EOL]       assertFalse(string4.equals((Object)string1));W-R>", string4); [EOL]        [EOL]       String[] stringArray2 = StringUtils.splitPreserveAllTokens("", ",FQU3=\"q$yCb$a\"_=Cm", 122); [EOL]        [EOL]       String[] stringArray3 = StringUtils.substringsBetween("LS", "Cannot store ", "xQD3IhI"); [EOL]        [EOL]       int int0 = StringUtils.getLevenshteinDistance((CharSequence) ",FQU3=\"q$yCb$a\"_=Cm", (CharSequence) "pG$0h;W-R>"); [EOL]        [EOL]       boolean boolean1 = StringUtils.containsOnly((CharSequence) "LS", charArray0); [EOL]        [EOL]       boolean boolean2 = StringUtils.isNumeric("xQD3IhI"); [EOL]        [EOL]       int int1 = StringUtils.indexOfAnyBut((CharSequence) ",FQU3=\"q$yCb$a\"_=Cm", (CharSequence) ""); [EOL]        [EOL]       boolean boolean3 = StringUtils.isAllUpperCase(""); [EOL]        [EOL]       CharSequence[] charSequenceArray0 = new CharSequence[4]; [EOL]       String string5 = StringUtils.reverseDelimited("", ']'); [EOL]       assertTrue(string5.equals((Object)string3)); [EOL]       assertFalse(string5.equals((Object)string4)); [EOL]       assertTrue(string5.equals((Object)string2)); [EOL]       assertTrue(string5.equals((Object)string0)); [EOL]       assertTrue(string5.equals((Object)string1)); [EOL]        [EOL]       charSequenceArray0[0] = (CharSequence) ""; [EOL]       charSequenceArray0[1] = (CharSequence) "xQD3IhI"; [EOL]       charSequenceArray0[2] = (CharSequence) ""; [EOL]       charSequenceArray0[3] = (CharSequence) "pG$0h;W-R>"; [EOL]       int int2 = StringUtils.lastIndexOfAny("pG$0h;W-R>", charSequenceArray0); [EOL]        [EOL]       int int3 = StringUtils.indexOfDifference((CharSequence) "", (CharSequence) ""); [EOL]        [EOL]       boolean boolean4 = StringUtils.isWhitespace("TT"); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAccessible()  throws Throwable  { [EOL]       Member member0 = mock(Member.class, new ViolatedAssumptionAnswer()); [EOL]       doReturn(0).when(member0).getModifiers(); [EOL]       boolean boolean0 = MemberUtils.isAccessible(member0); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] @Test [EOL] public void testComputeUserLimitAndSetHeadroom() throws IOException { [EOL] LeafQueue qb = stubLeafQueue((LeafQueue)queues.get(B)); [EOL] qb.setMaxCapacity(1.0f); [EOL] // Users [EOL] final String user_0 = "user_0"; [EOL] final String user_1 = "user_1"; [EOL] [EOL] //create nodes [EOL] String host_0 = "127.0.0.1"; [EOL] FiCaSchedulerNode node_0 = TestUtils.getMockNode(host_0, DEFAULT_RACK, 0, 8*GB); [EOL] String host_1 = "127.0.0.2"; [EOL] FiCaSchedulerNode node_1 = TestUtils.getMockNode(host_1, DEFAULT_RACK, 0, 8*GB); [EOL] [EOL] Map<NodeId, FiCaSchedulerNode> nodes = ImmutableMap.of(node_0.getNodeID(), [EOL] node_0, node_1.getNodeID(), node_1); [EOL] [EOL] final int numNodes = 2; [EOL] Resource clusterResource = Resources.createResource(numNodes * (8*GB), 1); [EOL] when(csContext.getNumClusterNodes()).thenReturn(numNodes); [EOL] root.updateClusterResource(clusterResource, [EOL] new ResourceLimits(clusterResource)); [EOL] [EOL] CapacitySchedulerQueueManager mockCapacitySchedulerQueueManager [EOL] = mock(CapacitySchedulerQueueManager.class); [EOL] QueueStateManager mockQueueStateManager = mock(QueueStateManager.class); [EOL] when(mockCapacitySchedulerQueueManager.getQueueStateManager()).thenReturn( [EOL] mockQueueStateManager); [EOL] when(csContext.getCapacitySchedulerQueueManager()).thenReturn( [EOL] mockCapacitySchedulerQueueManager); [EOL] [EOL] //our test plan contains three cases [EOL] //1. single user dominate the queue, we test the headroom [EOL] //2. two users, but user_0 is assigned 100% of the queue resource, [EOL] // submit user_1's application, check headroom correctness [EOL] //3. two users, each is assigned 50% of the queue resource [EOL] // each user submit one application and check their headrooms [EOL] //4. similarly to 3. but user_0 has no quote left and there are [EOL] // free resources left, check headroom [EOL] [EOL] //test case 1 [EOL] qb.setUserLimit(100); [EOL] qb.setUserLimitFactor(1); [EOL] [EOL] root.updateClusterResource(clusterResource, [EOL] new ResourceLimits(clusterResource)); [EOL] final ApplicationAttemptId appAttemptId_0 = [EOL] TestUtils.getMockApplicationAttemptId(0, 0); [EOL] FiCaSchedulerApp app_0 = [EOL] new FiCaSchedulerApp(appAttemptId_0, user_0, qb, [EOL] qb.getAbstractUsersManager(), spyRMContext); [EOL] Map<ApplicationAttemptId, FiCaSchedulerApp> apps = new HashMap<>(); [EOL] apps.put(app_0.getApplicationAttemptId(), app_0); [EOL] qb.submitApplicationAttempt(app_0, user_0); [EOL] Priority u0Priority = TestUtils.createMockPriority(1); [EOL] SchedulerRequestKey u0SchedKey = toSchedulerKey(u0Priority); [EOL] app_0.updateResourceRequests(Collections.singletonList( [EOL] TestUtils.createResourceRequest(ResourceRequest.ANY, 4*GB, 1, true, [EOL] u0Priority, recordFactory))); [EOL] [EOL] assertEquals("There should only be 1 active user!", [EOL] 1, qb.getAbstractUsersManager().getNumActiveUsers()); [EOL] //get headroom [EOL] applyCSAssignment(clusterResource, [EOL] qb.assignContainers(clusterResource, node_0, [EOL] new ResourceLimits(clusterResource), [EOL] SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), qb, nodes, apps); [EOL] qb.computeUserLimitAndSetHeadroom(app_0, clusterResource, [EOL] "", SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY, null); [EOL] [EOL] //maxqueue 16G, userlimit 13G, - 4G used = 9G [EOL] assertEquals(9*GB,app_0.getHeadroom().getMemorySize()); [EOL] [EOL] //test case 2 [EOL] final ApplicationAttemptId appAttemptId_2 = [EOL] TestUtils.getMockApplicationAttemptId(2, 0); [EOL] FiCaSchedulerApp app_2 = [EOL] new FiCaSchedulerApp(appAttemptId_2, user_1, qb, [EOL] qb.getAbstractUsersManager(), spyRMContext); [EOL] apps.put(app_2.getApplicationAttemptId(), app_2); [EOL] Priority u1Priority = TestUtils.createMockPriority(2); [EOL] SchedulerRequestKey u1SchedKey = toSchedulerKey(u1Priority); [EOL] app_2.updateResourceRequests(Collections.singletonList( [EOL] TestUtils.createResourceRequest(ResourceRequest.ANY, 4*GB, 1, true, [EOL] u1Priority, recordFactory))); [EOL] qb.submitApplicationAttempt(app_2, user_1); [EOL] applyCSAssignment(clusterResource, [EOL] qb.assignContainers(clusterResource, node_1, [EOL] new ResourceLimits(clusterResource), [EOL] SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), qb, nodes, apps); [EOL] qb.computeUserLimitAndSetHeadroom(app_0, clusterResource, [EOL] "", SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY, null); [EOL] [EOL] assertEquals(8*GB, qb.getUsedResources().getMemorySize()); [EOL] assertEquals(4*GB, app_0.getCurrentConsumption().getMemorySize()); [EOL] //maxqueue 16G, userlimit 13G, - 4G used = 9G BUT [EOL] //maxqueue 16G - used 8G (4 each app/user) = 8G max headroom (the new logic) [EOL] assertEquals(8*GB, app_0.getHeadroom().getMemorySize()); [EOL] assertEquals(4*GB, app_2.getCurrentConsumption().getMemorySize()); [EOL] assertEquals(8*GB, app_2.getHeadroom().getMemorySize()); [EOL] [EOL] //test case 3 [EOL] qb.finishApplication(app_0.getApplicationId(), user_0); [EOL] qb.finishApplication(app_2.getApplicationId(), user_1); [EOL] qb.releaseResource(clusterResource, app_0, Resource.newInstance(4*GB, 1), [EOL] "", null); [EOL] qb.releaseResource(clusterResource, app_2, Resource.newInstance(4*GB, 1), [EOL] "", null); [EOL] [EOL] qb.setUserLimit(50); [EOL] qb.setUserLimitFactor(1); [EOL] [EOL] final ApplicationAttemptId appAttemptId_1 = [EOL] TestUtils.getMockApplicationAttemptId(1, 0); [EOL] FiCaSchedulerApp app_1 = [EOL] new FiCaSchedulerApp(appAttemptId_1, user_0, qb, [EOL] qb.getAbstractUsersManager(), spyRMContext); [EOL] apps.put(app_1.getApplicationAttemptId(), app_1); [EOL] final ApplicationAttemptId appAttemptId_3 = [EOL] TestUtils.getMockApplicationAttemptId(3, 0); [EOL] FiCaSchedulerApp app_3 = [EOL] new FiCaSchedulerApp(appAttemptId_3, user_1, qb, [EOL] qb.getAbstractUsersManager(), spyRMContext); [EOL] apps.put(app_3.getApplicationAttemptId(), app_3); [EOL] app_1.updateResourceRequests(Collections.singletonList( [EOL] TestUtils.createResourceRequest(ResourceRequest.ANY, 2*GB, 1, true, [EOL] u0Priority, recordFactory))); [EOL] app_3.updateResourceRequests(Collections.singletonList( [EOL] TestUtils.createResourceRequest(ResourceRequest.ANY, 2*GB, 1, true, [EOL] u1Priority, recordFactory))); [EOL] qb.submitApplicationAttempt(app_1, user_0); [EOL] qb.submitApplicationAttempt(app_3, user_1); [EOL] applyCSAssignment(clusterResource, [EOL] qb.assignContainers(clusterResource, node_0, [EOL] new ResourceLimits(clusterResource), [EOL] SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), qb, nodes, apps); [EOL] applyCSAssignment(clusterResource, [EOL] qb.assignContainers(clusterResource, node_0, [EOL] new ResourceLimits(clusterResource), [EOL] SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), qb, nodes, apps); [EOL] qb.computeUserLimitAndSetHeadroom(app_3, clusterResource, [EOL] "", SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY, null); [EOL] assertEquals(4*GB, qb.getUsedResources().getMemorySize()); [EOL] //maxqueue 16G, userlimit 7G, used (by each user) 2G, headroom 5G (both) [EOL] assertEquals(5*GB, app_3.getHeadroom().getMemorySize()); [EOL] assertEquals(5*GB, app_1.getHeadroom().getMemorySize()); [EOL] //test case 4 [EOL] final ApplicationAttemptId appAttemptId_4 = [EOL] TestUtils.getMockApplicationAttemptId(4, 0); [EOL] FiCaSchedulerApp app_4 = [EOL] new FiCaSchedulerApp(appAttemptId_4, user_0, qb, [EOL] qb.getAbstractUsersManager(), spyRMContext); [EOL] apps.put(app_4.getApplicationAttemptId(), app_4); [EOL] qb.submitApplicationAttempt(app_4, user_0); [EOL] app_4.updateResourceRequests(Collections.singletonList( [EOL] TestUtils.createResourceRequest(ResourceRequest.ANY, 6*GB, 1, true, [EOL] u0Priority, recordFactory))); [EOL] applyCSAssignment(clusterResource, [EOL] qb.assignContainers(clusterResource, node_1, [EOL] new ResourceLimits(clusterResource), [EOL] SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY), qb, nodes, apps); [EOL] qb.computeUserLimitAndSetHeadroom(app_4, clusterResource, [EOL] "", SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY, null); [EOL] qb.computeUserLimitAndSetHeadroom(app_3, clusterResource, [EOL] "", SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY, null); [EOL] [EOL] [EOL] //app3 is user1, active from last test case [EOL] //maxqueue 16G, userlimit 13G, used 2G, would be headroom 10G BUT [EOL] //10G in use, so max possible headroom is 6G (new logic) [EOL] assertEquals(6*GB, app_3.getHeadroom().getMemorySize()); [EOL] //testcase3 still active - 2+2+6=10 [EOL] assertEquals(10*GB, qb.getUsedResources().getMemorySize()); [EOL] //app4 is user 0 [EOL] //maxqueue 16G, userlimit 7G, used 8G, headroom 5G [EOL] //(8G used is 6G from this test case - app4, 2 from last test case, app_1) [EOL] assertEquals(1*GB, app_4.getHeadroom().getMemorySize()); [EOL] } [EOL] private final RecordFactory recordFactory = [EOL] RecordFactoryProvider.getRecordFactory(null); [EOL] private static final Logger LOG = [EOL] LoggerFactory.getLogger(TestLeafQueue.class); [EOL] RMContext rmContext; [EOL] RMContext spyRMContext; [EOL] ResourceRequest amResourceRequest; [EOL] CapacityScheduler cs; [EOL] CapacitySchedulerConfiguration csConf; [EOL] CapacitySchedulerContext csContext; [EOL] CSQueue root; [EOL] private CSQueueStore queues; [EOL] final static int GB = 1024; [EOL] final static String DEFAULT_RACK = "/default"; [EOL] private final static String LABEL = "test"; [EOL] private final ResourceCalculator resourceCalculator = [EOL] new DefaultResourceCalculator(); [EOL] private final ResourceCalculator dominantResourceCalculator = [EOL] new DominantResourceCalculator(); [EOL] private static final String A = "a"; [EOL] private static final String B = "b"; [EOL] private static final String C = "c"; [EOL] private static final String C1 = "c1"; [EOL] private static final String D = "d"; [EOL] private static final String E = "e"; [EOL]
@Test [EOL] public void testExecutablePathWhenFileIsEmpty() [EOL] throws YarnException { [EOL] conf.set(YarnConfiguration.NM_FPGA_PATH_TO_EXEC, ""); [EOL] [EOL] fpgaDiscoverer.initialize(conf); [EOL] [EOL] assertEquals("configuration with empty string value, should use aocl", [EOL] "aocl", openclPlugin.getPathToExecutable()); [EOL] } [EOL] @Rule [EOL] public ExpectedException expected = ExpectedException.none(); [EOL] private File fakeBinary; [EOL] private IntelFpgaOpenclPlugin openclPlugin; [EOL] private Configuration conf; [EOL] private FpgaDiscoverer fpgaDiscoverer; [EOL]
@Test(timeout = 4000) [EOL]   public void testgetNullText()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder(4); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]        [EOL]       int int0 = strBuilder0.indexOf('2'); [EOL]       assertNull(strBuilder0.getNullText()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisFieldSeparatorAtStart()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.SIMPLE_STYLE.setArraySeparator((String) null); [EOL]       assertFalse(standardToStringStyle0.isFieldSeparatorAtStart()); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testequals()  throws Throwable  { [EOL]       IDKey iDKey0 = new IDKey("yXF20W=RcpY4f"); [EOL]       boolean boolean0 = iDKey0.equals("yXF20W=RcpY4f"); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testgetSummaryObjectStartText()  throws Throwable  { [EOL]       StandardToStringStyle standardToStringStyle0 = new StandardToStringStyle(); [EOL]       standardToStringStyle0.MULTI_LINE_STYLE.setFieldSeparator("g>s"); [EOL]       assertEquals("<", standardToStringStyle0.getSummaryObjectStartText()); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testNodeGroup() throws Exception { [EOL] String res = cluster.getNodeGroup(""); [EOL] assertTrue("NodeGroup should be NodeBase.ROOT for empty location", [EOL] res.equals(NodeBase.ROOT)); [EOL] try { [EOL] cluster.getNodeGroup(null); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue("Null Network Location should throw exception!", [EOL] e.getMessage().contains("Network Location is null")); [EOL] } [EOL] } [EOL] private final static NetworkTopologyWithNodeGroup cluster = new [EOL] NetworkTopologyWithNodeGroup(); [EOL] private final static NodeBase dataNodes[] = new NodeBase[] { [EOL] new NodeBase("h1", "/d1/r1/s1"), [EOL] new NodeBase("h2", "/d1/r1/s1"), [EOL] new NodeBase("h3", "/d1/r1/s2"), [EOL] new NodeBase("h4", "/d1/r2/s3"), [EOL] new NodeBase("h5", "/d1/r2/s3"), [EOL] new NodeBase("h6", "/d1/r2/s4"), [EOL] new NodeBase("h7", "/d2/r3/s5"), [EOL] new NodeBase("h8", "/d2/r3/s6") [EOL] }; [EOL] private final static NodeBase computeNode = new NodeBase("/d1/r1/s1/h9"); [EOL] private final static NodeBase rackOnlyNode = new NodeBase("h10", "/r2"); [EOL]
@Test(timeout = 4000) [EOL]   public void testlength()  throws Throwable  { [EOL]       StrBuilder strBuilder0 = new StrBuilder("T0]6[>UOMVX"); [EOL]       assertEquals(11, strBuilder0.length()); [EOL]        [EOL]       StrBuilder strBuilder1 = strBuilder0.setNewLineText("Invalid startIndex: "); [EOL]       assertEquals(11, strBuilder0.length()); [EOL]       assertEquals(11, strBuilder1.length()); [EOL]        [EOL]       int int0 = 554; [EOL]       int int1 = (-1164); [EOL]       // Undeclared exception! [EOL]       try {  [EOL]         strBuilder1.append("T0]6[>UOMVX", 554, (-1164)); [EOL]         fail("Expecting exception: StringIndexOutOfBoundsException"); [EOL]        [EOL]       } catch(StringIndexOutOfBoundsException e) { [EOL]          // [EOL]          // startIndex must be valid [EOL]          // [EOL]          verifyException("org.apache.commons.lang3.text.StrBuilder", e); [EOL]       } [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testadjustYear()  throws Throwable  { [EOL]       TimeZone timeZone0 = TimeZone.getTimeZone("\"NaI"); [EOL]       Locale locale0 = Locale.CHINESE; [EOL]       FastDateParser fastDateParser0 = new FastDateParser("<#", timeZone0, locale0); [EOL]       int int0 = fastDateParser0.adjustYear(2167); [EOL]       assertEquals(4067, int0); [EOL]   } [EOL]  [EOL]
@Test(timeout = 4000) [EOL]   public void testisAssignable()  throws Throwable  { [EOL]       Class<Long> class0 = Long.TYPE; [EOL]       Class<Boolean> class1 = Boolean.TYPE; [EOL]       boolean boolean0 = ClassUtils.isAssignable(class1, class0, true); [EOL]       assertFalse(boolean0); [EOL]   } [EOL]  [EOL]
@Test [EOL] public void testValidateEmptyEditLog() throws IOException { [EOL] File testDir = new File(TEST_DIR, "testValidateEmptyEditLog"); [EOL] SortedMap<Long, Long> offsetToTxId = Maps.newTreeMap(); [EOL] File logFile = prepareUnfinalizedTestEditLog(testDir, 0, offsetToTxId); [EOL] // Truncate the file so that there is nothing except the header and [EOL] // layout flags section. [EOL] truncateFile(logFile, 8); [EOL] EditLogValidation validation = [EOL] EditLogFileInputStream.scanEditLog(logFile, Long.MAX_VALUE, true); [EOL] assertTrue(!validation.hasCorruptHeader()); [EOL] assertEquals(HdfsServerConstants.INVALID_TXID, validation.getEndTxId()); [EOL] } [EOL] private static boolean useAsyncEditLog; [EOL] private static final File TEST_DIR = PathUtils.getTestDir(TestFSEditLogLoader.class); [EOL] private static final int NUM_DATA_NODES = 0; [EOL] private static final String FAKE_EDIT_STREAM_NAME = "FAKE_STREAM"; [EOL] private final ErasureCodingPolicy testECPolicy [EOL] = StripedFileTestUtil.getDefaultECPolicy(); [EOL] private static final Map<Byte, FSEditLogOpCodes> byteToEnum = [EOL] new HashMap<Byte, FSEditLogOpCodes>(); [EOL]
@Test(timeout = 4000) [EOL]   public void testparseObject()  throws Throwable  { [EOL]       TimeZone timeZone0 = TimeZone.getTimeZone("\"NaI"); [EOL]       Locale locale0 = Locale.CHINESE; [EOL]       FastDateParser fastDateParser0 = new FastDateParser("<#", timeZone0, locale0); [EOL]       Object object0 = fastDateParser0.parseObject("<#"); [EOL]       assertEquals("Fri Feb 14 20:21:21 GMT 2014", object0.toString()); [EOL]   } [EOL]  [EOL]
