@Test  public void testGetStaticFactPropertiesWithEmptyFact() {    Map<String, ?> props = MapUtils.map(helper.getStaticFactProperties(new FactRecord()), p -> T(p.getName(), p.getValue()));    assertEquals(0.0f, props.get("trust"));    assertEquals(0.0f, props.get("confidence"));    assertEquals(0.0f, props.get("certainty"));    assertEquals(0L, props.get("timestamp"));    assertEquals(0L, props.get("lastSeenTimestamp"));    assertNull(props.get("value"));  }
@Test(expected = ConfigurationException.class)  public void testMissingXmlRootElementName() {    configProperties.remove(CatalogUIAdapterConfiguration.KEY_XML_ROOT_ELEMENT_NAME);    CatalogUIAdapterConfiguration.loadFromDictionary(configProperties);  }
@Test(expected = ConfigurationModelListenerException.class)	public void testMaximumNumberOfTagsPerAssetNegative()		throws ConfigurationModelListenerException {		Dictionary<String, Object> properties = new HashMapDictionary<>();		properties.put("maximumNumberOfTagsPerAsset", -1);		_assetAutoTaggerSystemConfigurationModelListener.onBeforeSave(			RandomTestUtil.randomString(), properties);	}
@Test	public void testAutosaveWithNondefaultUser2() throws Exception {		RenderRequest renderRequest =			mockRenderRequestAutosaveWithNondefaultUser();		DDMFormInstanceSettings ddmFormInstanceSettings =			mockDDMFormInstanceSettingsAutosaveWithNondefaultUser();		when(			ddmFormInstanceSettings.autosaveEnabled()		).thenReturn(			Boolean.TRUE		);		when(			_ddmFormWebConfiguration.autosaveInterval()		).thenReturn(			1		);		DDMFormDisplayContext ddmFormDisplayContext =			createDDMFormDisplayContext(renderRequest);		Assert.assertEquals(true, ddmFormDisplayContext.isAutosaveEnabled());	}
@Test	public void testGetDecimalSymbolsWithBrazilianLocale() {		Map<String, String> separatorSymbolsMap =			_numericDDMFormFieldTemplateContextContributor.getSymbolsMap(				LocaleUtil.BRAZIL);		Assert.assertEquals(",", separatorSymbolsMap.get("decimalSymbol"));		Assert.assertEquals(".", separatorSymbolsMap.get("thousandsSeparator"));	}
@Test    public void testSetAttribute() throws Exception {        final String attribute = Attribute.DIALECT.getAttributeName();        plugin.setAttribute(attribute);        assertEquals(attribute,                     plugin.getAttribute());        verify(changeEvent).fire(any(WizardPageStatusChangeEvent.class));    }
@Test(expected = AccessDeniedException.class)  public void testFetchObjectByTypeValueWithoutViewPermission() throws Exception {    doThrow(AccessDeniedException.class).when(securityContext).checkPermission(TiFunctionConstants.viewThreatIntelFact);    delegate.handle(new GetObjectByTypeValueRequest());  }
@Test  public void testAccept() {    RolloverCondition.Visitor visitor = mock(RolloverCondition.Visitor.class);    condition.accept(visitor);    verify(firstCondition).accept(visitor);    verify(secondCondition).accept(visitor);    verify(visitor).visit(condition);  }
@Test    public void testGetNodeAsString() {        OMElement root = adapter.getRootElement();        // select text node        String textNode = adapter.getNodeAsString( root,                                                   new XPath( "wfs:Query/ogc:Filter/ogc:BBOX/ogc:PropertyName/text()",                                                              nsContext ), null );        assertEquals( "app:placeOfBirth/app:Place/app:country/app:Country/app:geom", textNode );        // select attribute node        QName attributeNode = adapter.getNodeAsQName( root, new XPath( "wfs:Query/@typeName", nsContext ), null );        assertEquals( QName.valueOf( "{http://www.deegree.org/app}Philosopher" ), attributeNode );        // select element node        String elementNode = adapter.getNodeAsString( root,                                                      new XPath(                                                                 "wfs:Query/ogc:Filter/ogc:BBOX/gml:Envelope/gml:coord/gml:X",                                                                 nsContext ), null );        assertEquals( "-1", elementNode );    }
@Test    void flatMapToInt() {        final int expected = refStream().flatMapToInt(e -> IntStream.range(0, e.getValue())).sum();        final int actual = instance.flatMapToInt(e -> IntStream.range(0, e.getValue())).sum();        assertEquals(expected, actual);    }
@Test  public void testGetResourceProvider() throws Exception {    Set<String> propertyIds = new HashSet<String>();    propertyIds.add("foo");    propertyIds.add("cat1/foo");    propertyIds.add("cat2/bar");    propertyIds.add("cat2/baz");    propertyIds.add("cat3/sub1/bam");    propertyIds.add("cat4/sub2/sub3/bat");    propertyIds.add("cat5/subcat5/map");    Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();    IvoryService ivoryService = createMock(IvoryService.class);    AbstractResourceProvider provider =        (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(            Resource.Type.DRFeed,            propertyIds,            keyPropertyIds,            ivoryService);    Assert.assertTrue(provider instanceof FeedResourceProvider);  }
@Test  public void testUpdateLiveEvent() throws Exception {    URI mpURI = LiveScheduleServiceImplTest.class.getResource("/assetmanager-mp-with-live.xml").toURI();    MediaPackage mp = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder()            .loadFromXml(mpURI.toURL().openStream());    setUpAssetManager(mp);    mpURI = LiveScheduleServiceImplTest.class.getResource("/live-mp.xml").toURI();    MediaPackage previousMp = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder()            .loadFromXml(mpURI.toURL().openStream());    URI catalogURI = LiveScheduleServiceImplTest.class.getResource("/episode.xml").toURI();    DublinCoreCatalog episodeDC = DublinCores.read(catalogURI.toURL().openStream());    catalogURI = LiveScheduleServiceImplTest.class.getResource("/series.xml").toURI();    DublinCoreCatalog seriesDC = DublinCores.read(catalogURI.toURL().openStream());    EasyMock.expect(seriesService.getSeries(SERIES_ID)).andReturn(seriesDC).anyTimes();    Job job = createJob(1L, "anything", "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"            + "<catalog id=\"9ad6ebcb-b414-4b15-ab62-5e5ddede447e\" type=\"dublincore/episode\" xmlns=\"http://mediapackage.opencastproject.org\">"            + "<mimetype>text/xml</mimetype>"            + "<url>http://10.10.10.50/static/mh_default_org/engage-live/episode_updated.xml</url></catalog>"            + "###<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"            + "<catalog id=\"23113662-1a84-457a-85d5-0b3e32d2413a\" type=\"dublincore/series\" xmlns=\"http://mediapackage.opencastproject.org\">"            + "<mimetype>text/xml</mimetype>"            + "<url>http://10.10.10.50/static/mh_default_org/engage-live/series.xml</url></catalog>"            + "###<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"            + "<attachment id=\"security-policy-episode\" type=\"security/xacml+episode\" xmlns=\"http://mediapackage.opencastproject.org\">"            + "<mimetype>text/xml</mimetype>"            + "<url>http://10.10.10.50/static/mh_default_org/engage-live/security_policy_episode.xml</url></attachment>");    EasyMock.expect(downloadDistributionService.distribute(EasyMock.anyString(), EasyMock.anyObject(MediaPackage.class),            EasyMock.anyObject(Set.class), EasyMock.anyBoolean())).andReturn(job);    EasyMock.expect(serviceRegistry.getJob(1L)).andReturn(job).anyTimes();    Job jobPub = createJob(2L, "anything", "anything");    Capture<MediaPackage> capturedMp = Capture.newInstance();    EasyMock.expect(searchService.add(EasyMock.capture(capturedMp))).andReturn(jobPub);    EasyMock.expect(serviceRegistry.getJob(2L)).andReturn(job).anyTimes();    Job jobRetract = createJob(3L, "anything", "anything");    EasyMock.expect(downloadDistributionService.retract(EasyMock.anyString(), EasyMock.anyObject(MediaPackage.class),            EasyMock.anyObject(Set.class))).andReturn(jobRetract);    EasyMock.expect(serviceRegistry.getJob(3L)).andReturn(jobRetract).anyTimes();    replayServices();    service.setDownloadDistributionService(downloadDistributionService);    // Capture agent change    episodeDC.set(DublinCore.PROPERTY_SPATIAL, DublinCoreValue.mk("another_ca"));    // Duration change    episodeDC.set(DublinCore.PROPERTY_TEMPORAL,            DublinCoreValue.mk("start=2017-10-12T19:00:00Z;end=2017-10-12T19:02:00Z; scheme=W3C-DTF;"));    Assert.assertTrue(service.updateLiveEvent(previousMp, episodeDC));    // Check published live media package    MediaPackage searchMp = capturedMp.getValue();    Assert.assertEquals(MP_ID, searchMp.getIdentifier().toString());    Assert.assertEquals(120000L, searchMp.getDuration().longValue());    Assert.assertEquals(2, searchMp.getCatalogs().length);    assertExpectedLiveTracks(searchMp.getTracks(), 120000L, "another_ca", "_suffix", false);    Assert.assertEquals(0, searchMp.getPublications().length);  }
@Test  public void testFindFailure2() {    final IncidentTree r = new IncidentTreeImpl(            Arrays.asList(mkIncident(Severity.INFO), mkIncident(Severity.INFO), mkIncident(Severity.INFO)),            Collections.singletonList(new IncidentTreeImpl(                    Arrays.asList(mkIncident(Severity.INFO), mkIncident(Severity.WARNING)),                    Collections.singletonList(new IncidentTreeImpl(                            Arrays.asList(mkIncident(Severity.WARNING), mkIncident(Severity.INFO)),                            Collections.emptyList())))));    assertFalse(Incidents.findFailure(r));  }
@Test    public void testInitManagedStoredQueries()                            throws Exception {        List<FeatureType> featureTypes = featureTypes();        File managedStoredQueries = Files.createTempDirectory( "managedStoredQueries" ).toFile();        OutputStream output = new FileOutputStream( new File( managedStoredQueries, "storedQuery_byName.xml" ) );        InputStream resourceAsStream = StoredQueryHandlerTest.class.getResourceAsStream( "storedQuery_byName.xml" );        IOUtils.copy( resourceAsStream, output );        resourceAsStream.close();        output.close();        StoredQueryHandler storedQueryHandler = new StoredQueryHandler( mockWFS( featureTypes ), new ArrayList<URL>(),                                                                        managedStoredQueries );        assertThat( storedQueryHandler.hasStoredQuery( GET_FEATURE_BY_ID ), is( true ) );        assertThat( storedQueryHandler.hasStoredQuery( GET_FEATURE_BY_TYPE ), is( true ) );        assertThat( storedQueryHandler.hasStoredQuery( "ByName" ), is( true ) );    }
@Test	public void testGetRelatedSuggestionsWithNullSuggestions() {		setUpSearchedKeywords("q", "a b");		List<SuggestionDisplayContext> suggestionDisplayContexts =			buildRelatedQueriesSuggestions(Arrays.asList(null, "", "a b C"));		Assert.assertEquals(			suggestionDisplayContexts.toString(), 1,			suggestionDisplayContexts.size());		assertSuggestion(			"a b [C] | q=a b(q<<a b C)", suggestionDisplayContexts.get(0));	}
@Test	public void testQuote() {		String expected =			"<div class=\"quote-title\">citer:</div><div class=\"quote\">" +				"<div class=\"quote-content\">text</div></div>";		String actual = _htmlBBCodeTranslatorImpl.parse(			"[quote=citer]text[/quote]");		Assert.assertEquals(expected, actual);	}
@Test  public void testSetFrom() throws Exception {    sec.setFrom( "from" );    assertEquals( "from", sec.getFrom() );  }
@Test    void testReduce() {        assertEqualsReducing(s -> s.reduce(3, Long::sum));    }
@Test  public void testAcceptJob() throws Exception {    replayAll();    Job job = new JobImpl();    job.setStatus(Status.DISPATCHING);    assertEquals(Status.DISPATCHING, job.getStatus());    jobProducer.acceptJob(job);    assertEquals(Status.RUNNING, job.getStatus());  }
@Test    public void testTimeCallableException()            throws Exception    {        SparseTimeStat stat = new SparseTimeStat(ticker);        stat.setBucketIdProvider(bucketIdProvider);        try {            stat.time(() -> {                ticker.elapseTime(10, TimeUnit.MILLISECONDS);                throw new RuntimeException("test exception");            });        }        catch (RuntimeException ignored) {        }        ++bucketIdProvider.id;        assertPreviousDistribution(stat, 1, 0.010, 0.010, 0.010);    }
@KuduClusterTestContext(kuduClusterBasedTest = false)  @Test  public void testAssignPartitions() throws Exception  {    AbstractKuduInputOperator<UnitTestTablePojo,InputOperatorControlTuple> mockedInputOperator =        PowerMockito.mock(AbstractKuduInputOperator.class);    when(mockedInputOperator.getNumberOfPartitions()).thenReturn(5);    PowerMockito.mockStatic(KryoCloneUtils.class);    when(KryoCloneUtils.cloneObject(mockedInputOperator)).thenReturn(mockedInputOperator);    KuduOneToManyPartitioner kuduOneToManyPartitioner = new KuduOneToManyPartitioner(mockedInputOperator);    buildMockWiring(mockedInputOperator, KuduClientTestCommons.TOTAL_KUDU_TABLETS_FOR_UNITTEST_TABLE);    kuduOneToManyPartitioner.setPrototypeKuduInputOperator(mockedInputOperator);    Map<Integer,List<KuduPartitionScanAssignmentMeta>> assignedPartitions = kuduOneToManyPartitioner.assign(        kuduOneToManyPartitioner.getListOfPartitionAssignments(        new ArrayList<Partitioner.Partition<AbstractKuduInputOperator>>(),        partitioningContext),partitioningContext);    assertThat(assignedPartitions.size(), is(5));    for (List<KuduPartitionScanAssignmentMeta> eachOperatorassignment: assignedPartitions.values()) {      assertThat(eachOperatorassignment.size(), lessThanOrEqualTo(3));    }    for (List<KuduPartitionScanAssignmentMeta> eachOperatorassignment: assignedPartitions.values()) {      assertThat(eachOperatorassignment.size(), greaterThanOrEqualTo(2));    }  }
@Test  public void testBuild() {    GeometryOperator preUnionGeometryOperator = mock(GeometryOperator.class);    GeometryOperator postUnionGeometryOperator = mock(GeometryOperator.class);    LocationUpdateFieldFactory factory =        new LocationUpdateFieldFactory(preUnionGeometryOperator, postUnionGeometryOperator);    UpdateParent.UpdateField updateField = factory.build();    assertThat(updateField, is(instanceOf(LocationUpdateField.class)));    LocationUpdateField locationUpdateField = (LocationUpdateField) updateField;    assertThat(locationUpdateField.getPreUnionGeometryOperator(), is(preUnionGeometryOperator));    assertThat(locationUpdateField.getPostUnionGeometryOperator(), is(postUnionGeometryOperator));  }
@Test  public void testAutoStartFalse() throws Exception {    PrerequisiteCheck check = new PrerequisiteCheck(CheckDescription.AUTO_START_DISABLED, "foo");    PrereqCheckRequest request = new PrereqCheckRequest("cluster");    Assert.assertTrue(m_check.isApplicable(request));    m_configMap.put(AutoStartDisabledCheck.RECOVERY_ENABLED_KEY, "false");    m_check.perform(check, request);    Assert.assertEquals(PrereqCheckStatus.PASS, check.getStatus());    Assert.assertTrue(StringUtils.isBlank(check.getFailReason()));  }
@Test	public void testGetSelectedIndexName() {		FieldMappingsDisplayBuilder fieldMappingsDisplayBuilder =			new FieldMappingsDisplayBuilder(http);		fieldMappingsDisplayBuilder.setCurrentURL("/");		fieldMappingsDisplayBuilder.setIndexInformation(indexInformation);		fieldMappingsDisplayBuilder.setNamespace("_namespace_");		fieldMappingsDisplayBuilder.setSelectedIndexName("index2");		FieldMappingsDisplayContext fieldMappingsDisplayContext =			fieldMappingsDisplayBuilder.build();		Assert.assertEquals(			"index2", fieldMappingsDisplayContext.getSelectedIndexName());		List<FieldMappingIndexDisplayContext> fieldMappingIndexDisplayContexts =			fieldMappingsDisplayContext.getFieldMappingIndexDisplayContexts();		Assert.assertEquals(			fieldMappingIndexDisplayContexts.toString(), 2,			fieldMappingIndexDisplayContexts.size());		FieldMappingIndexDisplayContext fieldMappingIndexDisplayContext =			fieldMappingIndexDisplayContexts.get(0);		Assert.assertEquals(			"index1", fieldMappingIndexDisplayContext.getName());		Assert.assertEquals("", fieldMappingIndexDisplayContext.getCssClass());		fieldMappingIndexDisplayContext = fieldMappingIndexDisplayContexts.get(			1);		Assert.assertEquals(			"index2", fieldMappingIndexDisplayContext.getName());		Assert.assertEquals(			"active", fieldMappingIndexDisplayContext.getCssClass());	}
@Test  public void testClientConfigFilesInheritance() throws Exception{    StackInfo stack = stackManager.getStack("HDP", "2.0.6");    ServiceInfo zkService = stack.getService("ZOOKEEPER");    List<ComponentInfo> components = zkService.getComponents();    assertTrue(components.size() == 2);    ComponentInfo componentInfo = components.get(1);    List<ClientConfigFileDefinition> clientConfigs = componentInfo.getClientConfigFiles();    assertEquals(2,clientConfigs.size());    assertEquals("zookeeper-env",clientConfigs.get(0).getDictionaryName());    assertEquals("zookeeper-env.sh",clientConfigs.get(0).getFileName());    assertEquals("env",clientConfigs.get(0).getType());    assertEquals("zookeeper-log4j",clientConfigs.get(1).getDictionaryName());    assertEquals("log4j.properties",clientConfigs.get(1).getFileName());    assertEquals("env", clientConfigs.get(1).getType());  }
@Test    void ofNullables9() {        assertTuple(TuplesOfNullables.ofNullables(0, 1, 2, 3, 4, 5, 6, 7, 8), 9);    }
@Test	public void testGetLocaleFromRequestWhenDDMFormIsNull() {		Locale locale = _ddmFormRendererTag.getLocale(			_httpServletRequest, null);		Assert.assertEquals(LocaleUtil.US, locale);	}
@Test    public void testBlockFilter() throws Exception {        PlatonLog ethLog = objectMapper.readValue(                "{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":["                        + "\"0x31c2342b1e0b8ffda1507fbffddf213c4b3c1e819ff6a84b943faabb0ebf2403\","                        + "\"0xccc0d2e07c1febcaca0c3341c4e1268204b06fefa4bb0c8c0d693d8e581c82da\""                        + "]}",                PlatonLog.class);        runTest(ethLog, web3j.ethBlockHashObservable());    }
@Test    public void onOkClick() {        popupView.okCommand = null;        popupView.onOkClick(mouseEventMock);        verify(okCommandMock, never()).execute();        verify(popupView, times(1)).hide();        reset(popupView);        popupView.okCommand = okCommandMock;        popupView.onOkClick(mouseEventMock);        verify(okCommandMock, times(1)).execute();        verify(popupView, times(1)).hide();    }
@Test  public void testSingleAttempt() throws Exception {    ApplicationId appId = ApplicationId.newInstance(0, 1);    ApplicationAttemptId appAttemptId =        ApplicationAttemptId.newInstance(appId, 1);    WebResource r = resource();    ClientResponse response =        r.path("ws").path("v1").path("applicationhistory").path("apps")          .path(appId.toString()).path("appattempts")          .path(appAttemptId.toString()).accept(MediaType.APPLICATION_JSON)          .get(ClientResponse.class);    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());    JSONObject json = response.getEntity(JSONObject.class);    assertEquals("incorrect number of elements", 1, json.length());    JSONObject appAttempt = json.getJSONObject("appAttempt");    assertEquals(appAttemptId.toString(), appAttempt.getString("appAttemptId"));    assertEquals(appAttemptId.toString(), appAttempt.getString("host"));    assertEquals(appAttemptId.toString(),      appAttempt.getString("diagnosticsInfo"));    assertEquals("test tracking url", appAttempt.getString("trackingUrl"));    assertEquals(YarnApplicationAttemptState.FINISHED.toString(),      appAttempt.get("appAttemptState"));  }
@Test    public void testSymbolToOperatorEquals() {        String symbol = "eq";        Assert.assertEquals(Convert.stringToOperator(symbol), Operator.EQUALS);    }
@Test	public void testTruncateToSizeSingleWordEqualToMax() {		int size = _randomSize();		String text = RandomTestUtil.randomString(size);		Assert.assertEquals(			text, GCloudNaturalLanguageUtil.truncateToSize(text, size));	}
@Test    public void setEventBus() {        settingsPresenterSpy.setEventBus(eventBusMock);        assertEquals(eventBusMock, settingsPresenterSpy.eventBus);    }
@Test    public void testGetThisVariable() throws Exception {        assertNotNull("Should not return null on test method.", VariableUtils.getThisVariable(getStackFrame()));        assertNull("Should return null on main method.", VariableUtils.getThisVariable(getSecondLevelStackFrame()));    }
@Test    public void testAbort() {        String key = TestData.getSimpleString();        TObject value = TestData.getTObject();        long record = TestData.getLong();        add(key, value, record);        Assert.assertTrue(store.verify(key, value, record));        ((AtomicOperation) store).abort();        Assert.assertFalse(destination.verify(key, value, record));    }
@Test  public void testValidateBindingsFailsWithoutBindingsOnFactType() throws Exception {    CreateFactRequest request = createRequest();    resolveFactType.setRelevantObjectBindings(null);    mockCreateNewFact();    InvalidArgumentException ex = assertThrows(InvalidArgumentException.class, () -> delegate.handle(request));    assertEquals(set("invalid.fact.object.binding"), set(ex.getValidationErrors(), InvalidArgumentException.ValidationError::getMessageTemplate));  }
@Test    public void testWriteThemeMultipleMetadataUrls()                            throws Exception {        final ByteArrayOutputStream bos = new ByteArrayOutputStream();        final XMLStreamWriter writer = newInstance().createXMLStreamWriter( bos );        writer.writeStartElement( "Layer" );        writer.writeNamespace( "", WMSNS );        writer.writeNamespace( "xlink", XLNNS );        XMLAdapter.writeElement( writer, "Title", "Container" );        final LayerMetadata layerMetadata = createLayerMetadata();        String mdurlTemplate = "http://md.url.org/template";        OWSMetadataProvider provider = Mockito.mock( OWSMetadataProvider.class );        List<DatasetMetadata> mds = new ArrayList<DatasetMetadata>();        mds.add( createDatasetMetadata( "http://url1", "http://url2" ) );        mds.add( createDatasetMetadata( "http://url3" ) );        when( provider.getAllDatasetMetadata( Mockito.any( QName.class ) ) ).thenReturn( mds );                WmsCapabilities130ThemeWriter themeWriter = new WmsCapabilities130ThemeWriter( provider, null, mdurlTemplate );        Theme theme = new StandardTheme( layerMetadata, Collections.<Theme> emptyList(),                                         Collections.<Layer> emptyList(), null );        themeWriter.writeTheme( writer, theme );        writer.writeEndElement();        writer.flush();        bos.close();        final InputStream is = WmsCapabilities130ThemeWriterTest.class.getResourceAsStream( "wms130_layer_multipleMetadataUrls.xml" );        final byte[] expected = IOUtils.readBytesAndClose( is, -1 );        assertValidity( new ByteArrayInputStream( bos.toByteArray() ), SCHEMA_URL );        assertArrayEquals( expected, bos.toByteArray() );    }
@Test    public void testAddSchema() {        InspectionResults inspectionResults = mock(InspectionResults.class);        Schema schema = addSchema(inspectionResults, "catalog", "schema");        verify(inspectionResults).addObject(schema);        verify(inspectionResults).addObject(schema.getCatalog());        verify(inspectionResults).addObject(schema.getDatabase());    }
@Test  public void testCreateDropRole() throws Exception {    runTestAsSubject(new TestOperation() {      @Override      public void runTestAsSubject() throws Exception {        // test: create role with -cr        String[] args = { "-cr", "-r", TEST_ROLE_NAME_1, "-conf", confPath.getAbsolutePath() };        SentryShellHive.main(args);        // test: create role with --create_role        args = new String[] { "--create_role", "-r", TEST_ROLE_NAME_2, "-conf",            confPath.getAbsolutePath() };        SentryShellHive.main(args);        // validate the result, list roles with -lr        args = new String[] { "-lr", "-conf", confPath.getAbsolutePath() };        SentryShellHive sentryShell = new SentryShellHive();        Set<String> roleNames = getShellResultWithOSRedirect(sentryShell, args, true);        validateRoleNames(roleNames, TEST_ROLE_NAME_1, TEST_ROLE_NAME_2);        // validate the result, list roles with --list_role        args = new String[] { "--list_role", "-conf", confPath.getAbsolutePath() };        sentryShell = new SentryShellHive();        roleNames = getShellResultWithOSRedirect(sentryShell, args, true);        validateRoleNames(roleNames, TEST_ROLE_NAME_1, TEST_ROLE_NAME_2);        // test: drop role with -dr        args = new String[] { "-dr", "-r", TEST_ROLE_NAME_1, "-conf", confPath.getAbsolutePath() };        SentryShellHive.main(args);        // test: drop role with --drop_role        args = new String[] { "--drop_role", "-r", TEST_ROLE_NAME_2, "-conf",            confPath.getAbsolutePath() };        SentryShellHive.main(args);        // validate the result        Set<TSentryRole> roles = client.listRoles(requestorName);        assertEquals("Incorrect number of roles", 0, roles.size());      }    });  }
@Test    void text() {        String text = ClasspathResources.text("classpath-resource-test/resource.txt");        assertThat(text).isEqualTo("value");    }
@Test    void fromJSON() {        assertThatThrownBy(() -> reader.fromJSON(String.class, new byte[0]))                .isInstanceOf(Error.class)                .hasMessageContaining("bean class must not be java built-in class");    }
@Test    void addNewIndex() {        assertNotNull(getMutatorInstance().addNewIndex());    }
@Test	public void testMissingRequirements() {		TableReferenceInfo<ReferenceExampleTable> tableReferenceInfo =			TableReferenceInfoFactory.create(				ReferenceExampleTable.CLASS_NAME_ID,				ReferenceExampleTable.INSTANCE.mainExampleId,				new MissingRequirementsTableReferenceDefinition());		Map<Table<?>, List<TableJoinHolder>> parentTableJoinHoldersMap =			tableReferenceInfo.getParentTableJoinHoldersMap();		Assert.assertEquals(			parentTableJoinHoldersMap.toString(), 3,			parentTableJoinHoldersMap.size());		_assertMissingRequirementsSQL(			parentTableJoinHoldersMap.get(MainExampleTable.INSTANCE),			DSLQueryFactoryUtil.select(				ReferenceExampleTable.INSTANCE.mainExampleId,				new Scalar<>(MainExampleTable.INSTANCE.getTableName())			).from(				ReferenceExampleTable.INSTANCE			).leftJoinOn(				MainExampleTable.INSTANCE,				ReferenceExampleTable.INSTANCE.referenceExampleId.eq(					MainExampleTable.INSTANCE.classPK)			).leftJoinOn(				ClassNameTable.INSTANCE,				ClassNameTable.INSTANCE.classNameId.eq(					MainExampleTable.INSTANCE.classNameId)			).where(				() -> {					Predicate predicate =						MainExampleTable.INSTANCE.mainExampleId.isNull();					Scalar<String> key = new Scalar<>("key");					return predicate.and(						key.eq(MainExampleTable.INSTANCE.name)					).and(						MainExampleTable.INSTANCE.flag.eq(0)					).and(						ClassNameTable.INSTANCE.value.eq(							TableReferenceInfoFactoryTest.class.getName())					).and(						ReferenceExampleTable.INSTANCE.referenceExampleId.							isNotNull()					).and(						ReferenceExampleTable.INSTANCE.referenceExampleId.neq(							0L)					);				}			));		ReferenceExampleTable aliasReferenceExampleTable =			ReferenceExampleTable.INSTANCE.as("aliasParentTable");		_assertMissingRequirementsSQL(			parentTableJoinHoldersMap.get(ReferenceExampleTable.INSTANCE),			DSLQueryFactoryUtil.select(				ReferenceExampleTable.INSTANCE.mainExampleId,				new Scalar<>(ReferenceExampleTable.INSTANCE.getTableName())			).from(				ReferenceExampleTable.INSTANCE			).leftJoinOn(				aliasReferenceExampleTable,				ReferenceExampleTable.INSTANCE.parentReferenceExampleId.eq(					aliasReferenceExampleTable.referenceExampleId)			).where(				() -> {					Predicate predicate =						aliasReferenceExampleTable.referenceExampleId.isNull();					return predicate.and(						ReferenceExampleTable.INSTANCE.parentReferenceExampleId.							isNotNull()					).and(						ReferenceExampleTable.INSTANCE.parentReferenceExampleId.							neq(0L)					);				}			));		_assertMissingRequirementsSQL(			parentTableJoinHoldersMap.get(StringIntExampleTable.INSTANCE),			DSLQueryFactoryUtil.select(				ReferenceExampleTable.INSTANCE.mainExampleId,				new Scalar<>(StringIntExampleTable.INSTANCE.getTableName())			).from(				ReferenceExampleTable.INSTANCE			).leftJoinOn(				StringIntExampleTable.INSTANCE,				ReferenceExampleTable.INSTANCE.stringKey.eq(					StringIntExampleTable.INSTANCE.stringKey				).and(					ReferenceExampleTable.INSTANCE.integerKey.eq(						StringIntExampleTable.INSTANCE.integerKey)				)			).where(				() -> {					Predicate predicate =						StringIntExampleTable.INSTANCE.id.isNull();					return predicate.and(						ReferenceExampleTable.INSTANCE.stringKey.isNotNull()					).and(						ReferenceExampleTable.INSTANCE.stringKey.neq("")					).and(						ReferenceExampleTable.INSTANCE.integerKey.isNotNull()					);				}			));	}
@Test    public void priorityExclusive() {        Http2Frame frame = TestMessages.PRIORITY_EXCLUSIVE_MODE_FRAME;        assertArrayEquals(TestMessages.PRIORITY_EXCLUSIVE_MODE_BUFFER, toByteArray(encoder.encode(frame, null)));    }
@Test  public void testFinalizeProperties__collection_properties() {    SchemaFactory schemaFactory = createNiceMock(SchemaFactory.class);    Schema schema = createNiceMock(Schema.class);    // schema expectations    expect(schemaFactory.getSchema(Resource.Type.Service)).andReturn(schema).anyTimes();    expect(schema.getKeyPropertyId(Resource.Type.Service)).andReturn("ServiceInfo/service_name").anyTimes();    replay(schemaFactory, schema);    HashSet<String> serviceProperties = new HashSet<String>();    serviceProperties.add("foo/bar");    QueryInfo rootQuery = new QueryInfo(new ServiceResourceDefinition(), serviceProperties);    TreeNode<QueryInfo> queryTree = new TreeNodeImpl<QueryInfo>(null, rootQuery, "Service");    MinimalRenderer renderer = new MinimalRenderer();    renderer.init(schemaFactory);    TreeNode<Set<String>> propertyTree = renderer.finalizeProperties(queryTree, true);    assertEquals(2, propertyTree.getObject().size());    assertTrue(propertyTree.getObject().contains("ServiceInfo/service_name"));    assertTrue(propertyTree.getObject().contains("foo/bar"));    assertEquals(0, propertyTree.getChildren().size());    verify(schemaFactory, schema);  }
@Test    public void testParseDate() throws Exception {        Harvester h = new Harvester(null, Log.createLogger("TEST"), null, null);        // test EN date        h.parseDate("Mon, 04 Feb 2013 10:19:00 +1000");        // test DE date        h.parseDate("Fr, 24 MÃ¤r 2017 10:58:59 +0100");    }
@Test  public void testMatchesDirectionIgnoresLoops() {    ObjectRecord objectA = new ObjectRecord().setId(UUID.randomUUID());    // objectA --- fact ---> objectA    FactRecord loopFact = new FactRecord()            .setId(UUID.randomUUID())            .setSourceObject(objectA)            .setDestinationObject(objectA);    assertFalse(ObjectVertex.matchesDirection(loopFact, objectA, OUT));    assertFalse(ObjectVertex.matchesDirection(loopFact, objectA, IN));    assertFalse(ObjectVertex.matchesDirection(loopFact, objectA, BOTH));  }
@Test    public void testOpenBombDoesNotOpenNeighbors() {        openAt(1, 0, itsGame2by2);        assertEquals(true, itsGame2by2.getBoard().getField(1, 0).isOpen());        assertEquals(true, itsGame2by2.getBoard().getField(1, 0).isExploded());        assertEquals(false, itsGame2by2.getBoard().getField(0, 0).isOpen());        assertEquals(false, itsGame2by2.getBoard().getField(0, 1).isOpen());        assertEquals(false, itsGame2by2.getBoard().getField(1, 1).isOpen());    }
@Test    public void testFindCircleCenter() {        Point p0 = geomFac.createPoint( null, new double[] { 8, -1 }, null );        Point p1 = geomFac.createPoint( null, new double[] { 3, 1.6 }, null );        Point p2 = geomFac.createPoint( null, new double[] { -110, 16.77777 }, null );        Point center = linearizer.calcCircleCenter( p0, p1, p2 );        arePointsOnCircle( center, p0, p1, p2 );    }
@SuppressWarnings("static-method")	@Test	public void getDefaultConfiguration() {		BaseConfiguration defaultConfig = new ConfigurationFactory()				.getConfiguration("elk", BaseConfiguration.class);		assertEquals(3, defaultConfig.getParameterNames().size());	}
@Test    public void allowsTypeAndDescriptionOfNonOptionArguments() {        OptionSpec<File> nonOptions = parser.nonOptions( "directories" ).ofType( File.class );        OptionSet options = parser.parse( "/opt", "/var" );        assertEquals( asList( new File( "/opt" ), new File( "/var" ) ), nonOptions.values( options ) );    }
@Test    void getAll() {        Map<String, TestCache> values = cacheStore.getAll(new String[]{"key1", "key2"}, null);        assertThat(values).isEmpty();        var value = new TestCache();        cacheStore.put("key1", value, Duration.ofMinutes(1), null);        values = cacheStore.getAll(new String[]{"key1", "key2"}, null);        assertThat(values).hasSize(1).containsEntry("key1", value);    }
@Test    void get3Test() {        assertEquals(3, (int) instance.get3().orElseThrow(NoSuchElementException::new));    }
@Test  public void testPathExistsFalse() {    Path invalidPath = new Path("/invalid/path");    assertFalse(HdfsUtils.pathExists(fs, invalidPath));  }
@Test    public void testClearInView() {        GraphStore graphStore = generateBasicGraphStoreWithColumns();        GraphView view = graphStore.viewStore.createView();        Graph graph = graphStore.viewStore.getGraph(view);        Column column = graphStore.nodeTable.store.getColumn("foo");        Node n1 = graphStore.factory.newNode("1");        n1.setAttribute(column, "bar");        graphStore.addNode(n1);        graph.addNode(n1);        IndexStore<Node> indexStore = graphStore.nodeTable.store.indexStore;        IndexImpl index = indexStore.createViewIndex(graphStore.viewStore.getGraph(view));        graph.removeNode(n1);        Assert.assertEquals(index.countElements(column), 0);        Assert.assertEquals(index.countValues(column), 0);        Assert.assertEquals(index.count(column, "bar"), 0);    }
@Test    public void continuationNoHeaderBlock() {        Http2Frame frame = TestMessages.CONTINUATION_NO_HEADER_FRAGMENT_FRAME;        assertArrayEquals(TestMessages.CONTINUATION_NO_HEADER_FRAGMENT_BUFFER, toByteArray(encoder.encode(frame, null)));    }
@Test	public void testParseWithEqBinaryExpressionWithSingleQuotes()		throws ExpressionVisitException {		Expression expression = _filterParserImpl.parse(			"fieldExternal eq 'value'");		Assert.assertNotNull(expression);		BinaryExpression binaryExpression = (BinaryExpression)expression;		Assert.assertEquals(			BinaryExpression.Operation.EQ, binaryExpression.getOperation());		MemberExpression memberExpression =			(MemberExpression)binaryExpression.getLeftOperationExpression();		PrimitivePropertyExpression primitivePropertyExpression =			(PrimitivePropertyExpression)memberExpression.getExpression();		Assert.assertEquals(			"fieldExternal", primitivePropertyExpression.getName());		LiteralExpression literalExpression =			(LiteralExpression)binaryExpression.getRightOperationExpression();		Assert.assertEquals("'value'", literalExpression.getText());		Assert.assertEquals(			LiteralExpression.Type.STRING, literalExpression.getType());	}
@Test	public void testGetFileExtension_1()		throws Exception {		String fileName = ".zip";		String result = FileNameUtils.getFileExtension(fileName);		assertEquals(".zip", result);	}
@Test    public void testExecuteRawOutput()                            throws OWSExceptionReport, IOException, XMLStreamException {        String demoWPSURL = TestProperties.getProperty( "demo_wps_url" );        Assume.assumeNotNull( demoWPSURL );        WPSClient wpsClient = new WPSClient( new URL( demoWPSURL ) );        org.deegree.protocol.wps.client.process.Process proc = wpsClient.getProcess( "ParameterDemoProcess", null );        RawProcessExecution execution = proc.prepareRawExecution();        execution.addLiteralInput( "LiteralInput", null, "0", "integer", "seconds" );        execution.addBBoxInput( "BBOXInput", null, new double[] { 0, 0 }, new double[] { 90, 180 }, "EPSG:4326" );        execution.addXMLInput( "XMLInput", null, CURVE_FILE.toURI(), false, "text/xml", null, null );        execution.addBinaryInput( "BinaryInput", null, BINARY_INPUT.toURI(), false, "image/png", null );        ComplexOutput out = execution.executeComplexOutput( "BinaryOutput", null, "image/png", null, null );        InputStream stream = out.getAsBinaryStream();        FileOutputStream fileStream = new FileOutputStream( File.createTempFile( "wpsBinaryOut", "" ) );        byte[] b = new byte[1024];        int read = -1;        while ( ( read = stream.read( b ) ) != -1 ) {            fileStream.write( b, 0, read );        }        fileStream.close();        stream.close();    }
@Test	public void testValidateConfigurationValuesTextFieldTypeValidNumber()		throws Exception {		_fragmentEntryValidatorImpl.validateConfigurationValues(			_read(				"configuration_field_text_typeoptions_validation_number.json"),			JSONUtil.put("numberField", 256));	}
@Test  public void testUpdateOriginOrganization() throws Exception {    OriginEntity entity = new OriginEntity()            .setId(UUID.randomUUID());    UpdateOriginRequest request = new UpdateOriginRequest()            .setId(entity.getId())            .setOrganization(UUID.randomUUID());    when(originResolver.apply(entity.getId())).thenReturn(entity);    when(securityContext.getAvailableOrganizationID()).thenReturn(Collections.singleton(request.getOrganization()));    delegate.handle(request);    verify(securityContext).checkPermission(TiFunctionConstants.updateThreatIntelOrigin, request.getOrganization());    verify(originManager).saveOrigin(argThat(origin -> Objects.equals(request.getOrganization(), origin.getOrganizationID())));  }
@Test    public void testBuildOption() throws Exception {        BasicOption option = optionToolkit.newBasicOptionBuilder().withId(OPTION_ID).build();        assertNotNull(option);        assertEquals(option.getId(), OPTION_ID);    }
@Test	public void testGetMBMessageURLIncludesMessageAnchor() {		RenderResponse renderResponse = Mockito.mock(RenderResponse.class);		Mockito.when(			renderResponse.createRenderURL()		).thenReturn(			Mockito.mock(PortletURL.class)		);		String namespace = StringUtil.randomString();		Mockito.when(			renderResponse.getNamespace()		).thenReturn(			namespace		);		long messageId = RandomTestUtil.randomInt();		Assert.assertTrue(			StringUtil.endsWith(				MBUtil.getMBMessageURL(messageId, renderResponse),				StringBundler.concat(					StringPool.POUND, namespace, "message_", messageId)));		Assert.assertTrue(			StringUtil.endsWith(				MBUtil.getMBMessageURL(					messageId, StringUtil.randomString(), renderResponse),				StringBundler.concat(					StringPool.POUND, namespace, "message_", messageId)));	}
@Test  @Ignore  public void testApplicationReport() throws IOException, YarnException {    ApplicationId appId = null;    appId = ApplicationId.newInstance(0, 1);    writeApplicationStartData(appId);    writeApplicationFinishData(appId);    ApplicationAttemptId appAttemptId =        ApplicationAttemptId.newInstance(appId, 1);    writeApplicationAttemptStartData(appAttemptId);    writeApplicationAttemptFinishData(appAttemptId);    ApplicationReport appReport =        applicationHistoryManagerImpl.getApplication(appId);    Assert.assertNotNull(appReport);    Assert.assertEquals(appId, appReport.getApplicationId());    Assert.assertEquals(appAttemptId,      appReport.getCurrentApplicationAttemptId());    Assert.assertEquals(appAttemptId.toString(), appReport.getHost());    Assert.assertEquals("test type", appReport.getApplicationType().toString());    Assert.assertEquals("test queue", appReport.getQueue().toString());  }
@Test    void shouldCreateTree() {        final Tree<TestResult> tree = SuitesPlugin.getData(getSimpleLaunchResults());        assertThat(tree.getChildren())                .hasSize(2)                .extracting(TreeNode::getName)                .containsExactlyInAnyOrder("s1", "s2");    }
@Test    public void checkOnOpenDocumentsInEditor() {        final Path dtPath1 = PathFactory.newPath("file1",                                                 "file1Url");        final Path dtPath2 = PathFactory.newPath("file2",                                                 "file2Url");        final List<Path> dtPaths = new ArrayList<Path>() {{            add(dtPath1);            add(dtPath2);        }};        final ObservablePath dtPath = mock(ObservablePath.class);        final PlaceRequest dtPlaceRequest = mock(PlaceRequest.class);        final GuidedDecisionTableEditorContent dtContent = makeDecisionTableContent(0);        final GuidedDecisionTableView.Presenter dtPresenter = makeDecisionTable(dtPath,                                                                                dtPath,                                                                                dtPlaceRequest,                                                                                dtContent);        when(modeller.addDecisionTable(any(ObservablePath.class),                                       any(PlaceRequest.class),                                       any(GuidedDecisionTableEditorContent.class),                                       any(Boolean.class),                                       any(Double.class),                                       any(Double.class))).thenReturn(dtPresenter);        presenter.onOpenDocumentsInEditor(dtPaths);        verify(dtService,               times(2)).loadContent(dtPathCaptor.capture());        final List<Path> dtLoadedPaths = dtPathCaptor.getAllValues();        assertNotNull(dtLoadedPaths);        assertEquals(2,                     dtLoadedPaths.size());        assertContains(dtLoadedPaths,                       dtPath1);        assertContains(dtLoadedPaths,                       dtPath2);    }
@Test    public void testInsertSort() throws Exception {        int[] origin = SortUtil.initArray(arraySize);        SortUtil.print(origin);        long start = System.currentTimeMillis();        SortUtil.insertSort(origin);        long interval = System.currentTimeMillis() - start;        System.out.println("call insertSort, time cost is: " + interval + "ms");        SortUtil.print(origin);    }
@Test    void header() {        sessionManager.header("SessionId");        ActionLog actionLog = new ActionLog(null, null);        String sessionId = UUID.randomUUID().toString();        store.save(sessionId, "localhost", Map.of("key", "value"), Set.of(), Duration.ofMinutes(30));        when(request.scheme()).thenReturn("https");        when(request.header("SessionId")).thenReturn(Optional.of(sessionId));        Session session = sessionManager.load(request, actionLog);        assertThat(session).isNotNull();        assertThat(session.get("key")).isNotNull().hasValue("value");        assertThat(actionLog.context.get("session_hash")).isNotEmpty();    }
@Test  public void testEndingZero() {    StringLongSequence seq = new StringLongSequence();    for (int i = 0;i < 10000;i++) {      Assert.assertEquals(0, seq.next() & 0xFF);    }  }
@Test	public void testChunksOtherThanZTXTArePreserved() throws Exception {		InputStream inputStream = _createInputStream(			_PNG_SIGNATURE, _MISC_CHUNK1);		byte[] bytes = new byte[_PNG_SIGNATURE.length + _MISC_CHUNK1.length];		inputStream.read(bytes);		Assert.assertArrayEquals(			ArrayUtil.append(_PNG_SIGNATURE, _MISC_CHUNK1), bytes);		Assert.assertEquals(-1, inputStream.read());	}
@Test    public void testGetMax() {        GraphStore graphStore = new GraphStore();        TimeStore store = new TimeStore(graphStore, null, true);        store.nodeIndexStore.add(1.0);        store.nodeIndexStore.add(2.0);        Assert.assertEquals(store.getMax(graphStore), 2.0);    }
@Test    void classOf() {        assertSingleParameter(Class.class, Integer.class, DefaultType::classOf);    }
@Test    public void testSetMetaData() throws Exception {        final String metaData = "metaData";        plugin.setMetaData(metaData);        assertEquals(metaData,                     plugin.getMetaData());        verify(changeEvent).fire(any(WizardPageStatusChangeEvent.class));    }
@Test    public void testGetThesaurusByName() throws Exception {        this.settingManager.setValue(Settings.SYSTEM_ENABLE_ALL_THESAURUS, false);        assertNull(this.thesaurusManager.getThesaurusByName(AllThesaurus.ALL_THESAURUS_KEY));        this.settingManager.setValue(Settings.SYSTEM_ENABLE_ALL_THESAURUS, true);        assertNotNull(this.thesaurusManager.getThesaurusByName(AllThesaurus.ALL_THESAURUS_KEY));        this.settingManager.setValue(Settings.SYSTEM_ENABLE_ALL_THESAURUS, false);        assertNull(this.thesaurusManager.getThesaurusByName(AllThesaurus.ALL_THESAURUS_KEY));    }
@Test	public void testParseWithStartsWithMethodAndDateType() {		AbstractThrowableAssert exception = Assertions.assertThatThrownBy(			() -> _filterParserImpl.parse(				"startswith(dateExternal, 2012-05-29T09:13:28Z)")		).isInstanceOf(			ExpressionVisitException.class		);		exception.hasMessage("Incompatible types.");	}
@Test    public void getEventBus() {        EventBus retrieved = abstractScenarioSimulationProducer.getEventBus();        assertNotNull(retrieved);        assertEquals(retrieved, eventBusMock);        verify(eventBusProducerMock, times(1)).getEventBus();    }
@Test  public void testApply() throws Exception {    Resource resource = new ResourceImpl(Resource.Type.HostComponent);    String propertyId = PropertyHelper.getPropertyId("category1", "ip");    Predicate predicate = new FilterPredicate(propertyId, IP_ADDRESS_PATTERN);    resource.setProperty(propertyId, "monkey");    Assert.assertFalse(predicate.evaluate(resource));    resource.setProperty(propertyId, "10.0.0.1");    Assert.assertTrue(predicate.evaluate(resource));    resource.setProperty(propertyId, "127.0.0.1");    Assert.assertTrue(predicate.evaluate(resource));    resource.setProperty(propertyId, "0.0.0.0");    Assert.assertTrue(predicate.evaluate(resource));    propertyId = PropertyHelper.getPropertyId("category1", "fun");    predicate = new FilterPredicate(propertyId, IP_ADDRESS_PATTERN);    Assert.assertFalse(predicate.evaluate(resource));  }
@Test    public void testReadExplicitlyDeclaredTables() {        Backup expected = new Backup();        Database database = new Database();        Schema schema = database.addCatalog("test").addSchema(EMPTY);        Table foreignTable = schema.addTable("t1");        Column foreignColumn = foreignTable.addColumn("t1_f1");        foreignColumn.setJdbcType(new JdbcType(new JdbcTypeDesc(4, "INT"), newOptions(10, 10, 0)));        ForeignKey foreignKey = new ForeignKey("fk_1");        Table primaryTable = schema.addTable("t2");        Column primaryColumn = primaryTable.addColumn("t2_f1");        foreignKey.addReference(primaryColumn, foreignColumn);        foreignTable.addForeignKey(foreignKey);        expected.setFormat("csv");        expected.setDatabase(database);        String input = "<?xml version=\"1.0\"?>\n" + "<backup version=\"" + Migrator.getVersion()                + "\" format=\"csv\">\n" + "  <database>\n" + "    <catalog name=\"test\">\n" + "      <schema>\n"                + "        <table name=\"t1\" type=\"TABLE\">\n" + "          <column name=\"t1_f1\">\n"                + "            <type code=\"4\" name=\"INT\" size=\"10\" precision=\"10\" scale=\"0\"/>\n"                + "          </column>\n"                + "          <foreign-key name=\"fk_1\" primary-catalog=\"test\" primary-table=\"t2\" "                + "foreign-catalog=\"test\" foreign-table=\"t1\" update-action=\"no_action\" "                + "delete-action=\"no_action\" deferrability=\"not_deferrable\">\n"                + "            <reference primary-column=\"t2_f1\" foreign-column=\"t1_f1\"/>\n"                + "          </foreign-key>\n" + "        </table>\n" + "      </schema>\n" + "    </catalog>\n"                + "  </database>\n" + "</backup>";        Backup actual = xmlBackupOps.read(toInputStream(input));        assertEquals(actual, expected);        assertEquals(actual.getDatabase().getSchemas(), expected.getDatabase().getSchemas());    }
@Test	public void testToWildcardWildcardText() {		Assert.assertEquals("abc*", KeywordsUtil.toWildcard("abc*"));	}
@Test    public void testUseForwardedForInternalTwoHops()    {        when(request.getRemoteAddr()).thenReturn("10.10.10.10");        when(request.getHeaders("X-FORWARDED-FOR")).thenReturn(Collections.enumeration(ImmutableList.of("10.14.15.16, 10.11.12.13")));        assertEquals(new ClientAddressExtractor().clientAddressFor(request), "10.14.15.16");    }
@Test	public void testOldTypeSettingsShouldBeUpdate2() {		String oldTypeSettings =			"column-1=" + _PORTLET_KEY + ",\ncolumn-2=1_WAR_kaleoformsportlet";		String newTypeSettings = _upgradePortletId.getNewTypeSettings(			oldTypeSettings, "1_WAR_kaleoformsportlet");		String expectedTypeSettings = "column-1=" + _PORTLET_KEY + ",\n";		Assert.assertEquals(expectedTypeSettings, newTypeSettings);	}
@Test    void shouldHaveRecordsWhenSuccessful()    {        RoutingProcedureResponse response = new RoutingProcedureResponse( PROCEDURE, asList( RECORD_1, RECORD_2 ) );        assertEquals( asList( RECORD_1, RECORD_2 ), response.records() );    }
@Test    public void testNameOverrideSystemProperty() throws IOException, ServletException {        System.setProperty(SegmentNamingStrategy.NAME_OVERRIDE_SYSTEM_PROPERTY_KEY, "pass");        AWSXRayServletFilter servletFilter = new AWSXRayServletFilter("fail");        HttpServletRequest request = mock(HttpServletRequest.class);        when(request.getRequestURL()).thenReturn(new StringBuffer("test_url"));        when(request.getMethod()).thenReturn("TEST_METHOD");        when(request.isAsyncStarted()).thenReturn(false);        HttpServletResponse response = mock(HttpServletResponse.class);        FilterChain chain = mock(FilterChain.class);        servletFilter.doFilter(request, response, chain);        ArgumentCaptor<Segment> emittedSegment = ArgumentCaptor.forClass(Segment.class);        verify(AWSXRay.getGlobalRecorder().getEmitter(), Mockito.times(1)).sendSegment(emittedSegment.capture());        Assert.assertEquals("pass", emittedSegment.getValue().getName());    }
@Test	public void testToDataRecordCollectionEquals() throws Exception {		when(			_ddlRecordSet.getDDMStructureId()		).thenReturn(			123L		);		when(			_ddlRecordSet.getDescriptionMap()		).thenReturn(			HashMapBuilder.put(				LocaleUtil.BRAZIL, "DescriÃ§Ã£o"			).put(				LocaleUtil.US, "Description"			).build()		);		when(			_ddlRecordSet.getGroupId()		).thenReturn(			789L		);		when(			_ddlRecordSet.getNameMap()		).thenReturn(			HashMapBuilder.put(				LocaleUtil.BRAZIL, "Nome"			).put(				LocaleUtil.US, "Name"			).build()		);		when(			_ddlRecordSet.getRecordSetId()		).thenReturn(			456L		);		when(			_ddlRecordSet.getRecordSetKey()		).thenReturn(			"RecordSetId"		);		Assert.assertEquals(			new DataRecordCollection() {				{					setDataDefinitionId(123L);					setDataRecordCollectionKey("RecordSetId");					setDescription(						HashMapBuilder.<String, Object>put(							"en_US", "Description"						).put(							"pt_BR", "DescriÃ§Ã£o"						).build());					setId(456L);					setName(						HashMapBuilder.<String, Object>put(							"en_US", "Name"						).put(							"pt_BR", "Nome"						).build());					setSiteId(789L);				}			},			DataRecordCollectionUtil.toDataRecordCollection(_ddlRecordSet));	}
@Test(expected = NoSuchElementException.class)  public void testIterator1() {    Iterator<Integer> i = iterator(new Integer[0]);    assertFalse(i.hasNext());    i.next();  }
@Test    public void searchUsers_OtherHttpError_SearchTerminatedWithError() {        //Given        when(githubUserRestService.searchGithubUsers(anyString())).thenReturn(get403ForbiddenError());        //When        TestSubscriber<List<User>> subscriber = new TestSubscriber<>();        userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber);        //Then        subscriber.awaitTerminalEvent();        subscriber.assertError(HttpException.class);        verify(githubUserRestService).searchGithubUsers(USER_LOGIN_RIGGAROO);        verify(githubUserRestService, never()).getUser(USER_LOGIN_RIGGAROO);        verify(githubUserRestService, never()).getUser(USER_LOGIN_2_REBECCA);    }
@Test    public void testIconLabelDefaultB() {        Icon icon = XTestUtils.loadDefaultIcon();        assertNotNull("sanity: default icon loaded", icon);        UIManager.put("Header.defaultIcon", icon);        JXHeader header = new JXHeader();        try {            assertSame(icon, getIconLabel(header).getIcon());        } finally {            UIManager.put("Header.defaultIcon", null);        }    }
@Test	public void testReindexSystemCompanyDictionaries() throws SearchException {		DictionaryReindexer dictionaryReindexer = new DictionaryReindexer(			_indexWriterHelper, _portalInstancesLocalService);		dictionaryReindexer.reindexDictionaries();		assertIndexWriterHelperReindexDictionariesWithCompanyId(			CompanyConstants.SYSTEM);	}
@Test    public void testReadUnlockAll() {        GraphLock lock = new GraphLock();        lock.readLock();        lock.readLock();        Assert.assertEquals(lock.readWriteLock.getReadHoldCount(), 2);        lock.readUnlockAll();        Assert.assertEquals(lock.readWriteLock.getReadLockCount(), 0);    }
@Test    public void testFromKey() throws Exception {        BundleInfo info = BundleInfo.fromKey("org.jahia.modules/article/2.0.0");        assertEquals("org.jahia.modules", info.getGroupId());        assertEquals("article", info.getSymbolicName());        assertEquals("2.0.0", info.getVersion());        info = BundleInfo.fromKey("article/2.0.0");        assertNull(info.getGroupId());        assertEquals("article", info.getSymbolicName());        assertEquals("2.0.0", info.getVersion());    }
@Test    public void testJsonCodec()    {        JsonCodec<Person> jsonCodec = jsonCodecFactory.jsonCodec(Person.class);        Person expected = new Person().setName("dain").setRocks(true);        String json = jsonCodec.toJson(expected);        Person actual = jsonCodec.fromJson(json);        assertEquals(actual, expected);    }
@Test  public void repeatedMiddleMissingTest() throws LoadException {    // GIVEN    Table t = loadFromJson("[ { " //        + "\"a\": [ "//    /* */ + "{ \"b\": [ " //    /*   */ + "{ \"c\": 1 }," //    /*   */ + "{ \"d\": 1 }," //    /*   */ + "{ \"c\": 3 }" //    /* */ + "] }, "//    /* */ + "{ \"b\": [ " //    /*   */ + "{ \"c\": 2 }," //    /*   */ + "{ \"d\": 2 }," //    /*   */ + "{ \"c\": 4 }" //    /* */ + "] } "//        + "]" + //        "},"        //        + "{ " //        + "\"a\": [ "//    /* */ + "{ \"b\": [ " //    /*   */ + "{ \"c\": 5 }," //    /*   */ + "{ \"d\": 5 }," //    /*   */ + "{ \"c\": 6 }" //    /* */ + "] }, "//    /* */ + "{ \"b\": [ " //    /*   */ + "{ \"c\": 7 }," //    /*   */ + "{ \"d\": 7 }," //    /*   */ + "{ \"c\": 8 }" //    /* */ + "] } "//        + "]" + //        "}" + " ]");    // WHEN    FlattenedTable flattenedTable = flattener.flattenTable(t, null, "a[*].b[*]", UUID.randomUUID());    // THEN    Assert.assertEquals(flattenedTable.getShards().size(), 1, "Expected correct table shard count");    TableShard tableShard = flattenedTable.getShards().iterator().next();    Assert.assertEquals(tableShard.getLowestRowId(), 0L, "Expected correct lowest row ID");    Assert.assertEquals(tableShard.getNumberOfRowsInShard(), 12, "Expected correct number of rows.");    Assert.assertEquals(tableShard.getColumns().keySet(), new HashSet<>(Arrays.asList("a.b.c", "a.b.d")),        "Expected correct columns.");    SortedSet<SortedMap<String, Long>> expectedRows = new TreeSet<>(MAP_COMPARATOR);    SortedMap<String, Long> row = new TreeMap<>();    row.put("a.b.c", 1L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", LoaderColumnInfo.DEFAULT_LONG);    row.put("a.b.d", 1L);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 3L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 2L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", LoaderColumnInfo.DEFAULT_LONG);    row.put("a.b.d", 2L);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 4L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 5L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", LoaderColumnInfo.DEFAULT_LONG);    row.put("a.b.d", 5L);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 6L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 7L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", LoaderColumnInfo.DEFAULT_LONG);    row.put("a.b.d", 7L);    expectedRows.add(row);    row = new TreeMap<>();    row.put("a.b.c", 8L);    row.put("a.b.d", LoaderColumnInfo.DEFAULT_LONG);    expectedRows.add(row);    Assert.assertEquals(getAllRows(tableShard), expectedRows, "Expected to have correct rows.");  }
@Test        public void tcStrArray2ListStr_NoValue()        {        	ArrayList<String> actual = new ArrayList<String>();        	ArrayList<String> expected = new ArrayList<String>();            String[] Input = { };            // Keinwert            actual = OKW_Helper.StringArray2ListStr(Input);            expected.clear();            assertEquals(expected, actual);        }
@Test    public void calculatesOpposite() {        final Vect<Double> vecta = new FixedVector<>(            new Scalars<>(1 + new Random().nextInt(OppositeTest.COORDS_LENGTH))        );        final Scalar<Double>[] sum = new Sum<>(            new Opposite<>(vecta), vecta        ).coords();        final Decimal field = new Decimal();        for (final Scalar<Double> scalar : sum) {            MatcherAssert.assertThat(field.actual(scalar), Matchers.is(0.));        }    }
@Test    public void equalTest() {        Assert.assertTrue(socketInfo.equals(socketInfo));        Assert.assertFalse(socketInfo.equals(null));        Assert.assertFalse(socketInfo.equals(0));        Assert.assertFalse(socketInfo.equals(new SocketInfo(ALT_SOCKET_PATH, SOCKET_PREFIX, VHOSTUSER_MODE)));        Assert.assertFalse(socketInfo.equals(new SocketInfo(SOCKET_PATH, ALT_SOCKET_PREFIX, VHOSTUSER_MODE)));        Assert.assertFalse(socketInfo.equals(new SocketInfo(SOCKET_PATH, SOCKET_PATH, ALT_VHOSTUSER_MODE)));    }
@Test  public void testGetSourceVersion() {    final DBAccessor dbAccessor = createNiceMock(DBAccessor.class);    UpgradeCatalog upgradeCatalog = getUpgradeCatalog(dbAccessor);    Assert.assertEquals("2.1.2.1", upgradeCatalog.getSourceVersion());  }
@Test    public void testFromStringParsing2() {        //Fact is not prefixed with '        final String content = "Fact.field' : ['a', 'b']";        final List<EnumRow> enums = EnumParser.fromString( content );        assertFalse( enums.isEmpty() );        assertEquals( "Fact.field' : ['a', 'b']",                      enums.get( 0 ).getRaw() );    }
@Test	public void testGetUpgradePath() {		UpgradeInfo upgradeInfo1 = createUpgradeInfo("0.0.0", "0.1.0");		UpgradeInfo upgradeInfo2 = createUpgradeInfo("0.1.0", "0.2.0");		UpgradeInfo upgradeInfo3 = createUpgradeInfo("0.2.0", "1.0.0");		UpgradeInfo upgradeInfo4 = createUpgradeInfo("1.0.0", "2.0.0");		ReleaseGraphManager releaseGraphManager = new ReleaseGraphManager(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4));		List<UpgradeInfo> upgradePath = releaseGraphManager.getUpgradeInfos(			"0.0.0", "2.0.0");		Assert.assertEquals(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4),			upgradePath);	}
@Test    public void getFactModelTupleEmptyElements() {        attributesMapInput.put(TYPEREF_QNAME, "number");        FactModelTuple factModelTuple = abstractKogitoDMNServiceSpy.getFactModelTuple(jsiITDefinitionsMock);        assertTrue(factModelTuple.getVisibleFacts().isEmpty());        assertTrue(factModelTuple.getHiddenFacts().isEmpty());    }
@Test	public void testConstructor() {		CharPipe charPipe = new CharPipe();		Assert.assertNotNull(charPipe.buffer);		Assert.assertEquals(8192, charPipe.buffer.length);		Assert.assertEquals(0, charPipe.count);		Assert.assertEquals(0, charPipe.readIndex);		Assert.assertEquals(0, charPipe.writeIndex);		Assert.assertNotNull(charPipe.bufferLock);		Assert.assertNotNull(charPipe.notEmpty);		Assert.assertNotNull(charPipe.notFull);		charPipe = new CharPipe(1024);		Assert.assertNotNull(charPipe.buffer);		Assert.assertEquals(1024, charPipe.buffer.length);		Assert.assertEquals(0, charPipe.count);		Assert.assertEquals(0, charPipe.readIndex);		Assert.assertEquals(0, charPipe.writeIndex);		Assert.assertNotNull(charPipe.bufferLock);		Assert.assertNotNull(charPipe.notEmpty);		Assert.assertNotNull(charPipe.notFull);		charPipe.close();	}
@Test    public void testDiscardsBuckets()            throws Exception    {        SparseCounterStat counter = new SparseCounterStat();        counter.add(100);        counter.setBucketIdProvider(bucketIdProvider);        counter.add(1);        assertPreviousCountNull(counter);        ++bucketIdProvider.id;        counter.add(2);        counter.add(2.2);        assertPreviousCount(counter, 1);        ++bucketIdProvider.id;        ++bucketIdProvider.id;        counter.add(100);        assertPreviousCountNull(counter);        ++bucketIdProvider.id;        assertPreviousCount(counter, 100);        counter.add(200);        ++bucketIdProvider.id;        ++bucketIdProvider.id;        assertPreviousCountNull(counter);    }
@Test    public void testGetElement() throws Exception {        OMElement sElement = ServiceElement.getElement(createXML(        		"<parent>" +				"	<eb3:Service type=\"org:holodeckb2b:services\"" +				"        xmlns:eb3=\"http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/\">" + 				"PackagingTest</eb3:Service>\n" +         		"</parent>"));        assertNotNull(sElement);        assertEquals(SERVICE_ELEMENT_NAME, sElement.getQName());    }
@Test	public void testNotReadOnlyTextFieldAndReadOnlyForm() {		// Dynamic data mapping form		DDMForm ddmForm = DDMFormTestUtil.createDDMForm();		DDMFormField ddmFormField = DDMFormTestUtil.createTextDDMFormField(			"Field1", false, false, false);		boolean readOnly = false;		ddmFormField.setReadOnly(readOnly);		ddmForm.addDDMFormField(ddmFormField);		// Dynamic data mapping form field evaluation		String instanceId = StringUtil.randomString();		Map<DDMFormEvaluatorFieldContextKey, Map<String, Object>>			ddmFormFieldsPropertyChanges =				HashMapBuilder.					<DDMFormEvaluatorFieldContextKey, Map<String, Object>>put(						new DDMFormEvaluatorFieldContextKey(							"Field1", instanceId),						HashMapBuilder.<String, Object>put(							"readOnly", readOnly						).put(							"visible", true						).build()					).build();		// Dynamic data mapping form values		List<DDMFormFieldValue> ddmFormFieldValues = new ArrayList<>();		DDMFormFieldValue ddmFormFieldValue =			DDMFormValuesTestUtil.createUnlocalizedDDMFormFieldValue(				"Field1", "Value 1");		ddmFormFieldValue.setInstanceId(instanceId);		ddmFormFieldValues.add(ddmFormFieldValue);		DDMFormFieldTemplateContextFactory ddmFormFieldTemplateContextFactory =			createDDMFormFieldTemplateContextFactory(				ddmForm, ddmFormField.getName(), ddmFormFieldsPropertyChanges,				ddmFormFieldValues, true, getTextDDMFormFieldRenderer(),				getTextDDMFormFieldTemplateContextContributor());		List<Object> fields = ddmFormFieldTemplateContextFactory.create();		Assert.assertEquals(fields.toString(), 1, fields.size());		Map<String, Object> fieldTemplateContext =			(Map<String, Object>)fields.get(0);		Assert.assertEquals(			true, MapUtil.getBoolean(fieldTemplateContext, "readOnly"));	}
@Test    void get5() {        assertEquals(m5, instance.get5());    }
@Test  public void testCreateResourcesWithAutoSkipFailures() throws Exception {    Cluster cluster = clusters.getCluster("c1");    Map<String, Object> requestProps = new HashMap<>();    requestProps.put(UpgradeResourceProvider.UPGRADE_CLUSTER_NAME, "c1");    requestProps.put(UpgradeResourceProvider.UPGRADE_VERSION, "2.2.0.0");    requestProps.put(UpgradeResourceProvider.UPGRADE_PACK, "upgrade_test");    requestProps.put(UpgradeResourceProvider.UPGRADE_TYPE, UpgradeType.ROLLING.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_FAILURES, Boolean.TRUE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_SC_FAILURES, Boolean.TRUE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_MANUAL_VERIFICATION, Boolean.FALSE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_PREREQUISITE_CHECKS, Boolean.TRUE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_DIRECTION, Direction.UPGRADE.name());    ResourceProvider upgradeResourceProvider = createProvider(amc);    Request request = PropertyHelper.getCreateRequest(Collections.singleton(requestProps), null);    upgradeResourceProvider.createResources(request);    List<UpgradeEntity> upgrades = upgradeDao.findUpgrades(cluster.getClusterId());    assertEquals(1, upgrades.size());    UpgradeEntity entity = upgrades.get(0);    assertEquals(cluster.getClusterId(), entity.getClusterId().longValue());    List<UpgradeGroupEntity> upgradeGroups = entity.getUpgradeGroups();    assertEquals(3, upgradeGroups.size());    UpgradeGroupEntity preClusterGroup = upgradeGroups.get(0);    assertEquals("PRE_CLUSTER", preClusterGroup.getName());    List<UpgradeItemEntity> preClusterUpgradeItems = preClusterGroup.getItems();    assertEquals(2, preClusterUpgradeItems.size());    assertEquals("Foo", parseSingleMessage(preClusterUpgradeItems.get(0).getText()));    assertEquals("Foo", parseSingleMessage(preClusterUpgradeItems.get(1).getText()));    UpgradeGroupEntity zookeeperGroup = upgradeGroups.get(1);    assertEquals("ZOOKEEPER", zookeeperGroup.getName());    List<UpgradeItemEntity> zookeeperUpgradeItems = zookeeperGroup.getItems();    assertEquals(5, zookeeperUpgradeItems.size());    assertEquals("This is a manual task with a placeholder of placeholder-rendered-properly",        parseSingleMessage(zookeeperUpgradeItems.get(0).getText()));    assertEquals("Restarting ZooKeeper Server on h1", zookeeperUpgradeItems.get(1).getText());    assertEquals("Updating configuration zookeeper-newconfig",        zookeeperUpgradeItems.get(2).getText());    assertEquals("Service Check ZooKeeper", zookeeperUpgradeItems.get(3).getText());    assertTrue(zookeeperUpgradeItems.get(4).getText().contains("There are failures that were automatically skipped"));    // the last upgrade item is the skipped failure check    UpgradeItemEntity skippedFailureCheck = zookeeperUpgradeItems.get(zookeeperUpgradeItems.size() - 1);    skippedFailureCheck.getTasks().contains(AutoSkipFailedSummaryAction.class.getName());    UpgradeGroupEntity postClusterGroup = upgradeGroups.get(2);    assertEquals("POST_CLUSTER", postClusterGroup.getName());    List<UpgradeItemEntity> postClusterUpgradeItems = postClusterGroup.getItems();    assertEquals(2, postClusterUpgradeItems.size());    assertEquals("Please confirm you are ready to finalize", parseSingleMessage(postClusterUpgradeItems.get(0).getText()));    assertEquals("Save Cluster State", postClusterUpgradeItems.get(1).getText());  }
@Test    void getFields() {        assertTrue(instance().getFields().isEmpty());    }
@Test    public void testLayoutWithOut() {        // This test will not work in a headless configuration.        if (GraphicsEnvironment.isHeadless()) {            LOG.fine("cannot run testLAFDecorationLayout - headless environment");            return;        }        JXFrame frame = new JXFrame();        frame.add(new JXTable(new AncientSwingTeam()));        frame.pack();        Dimension dim = frame.getSize();        assertEquals(dim, frame.getPreferredSize());        JXStatusBar bar = new JXStatusBar();        bar.add(new JLabel("need some content"));        frame.setStatusBar(bar);        frame.pack();        try {            assertEquals(dim.height + bar.getPreferredSize().height, frame.getPreferredSize().height);        } finally {            JFrame.setDefaultLookAndFeelDecorated(false);        }    }
@Test    void skipCSP() {        interceptor.contentSecurityPolicy = null;        when(response.contentType()).thenReturn(Optional.of(ContentType.TEXT_HTML));        interceptor.appendSecurityHeaders(response);        verify(response, never()).header(eq("Content-Security-Policy"), anyString());    }
@Test	public void testItemSelectorURLWhenNotAllowBrowseAndNullWikiPage()		throws Exception {		setAllowBrowseDocuments(false);		setWikiPageResourcePrimKey(0);		JSONObject originalJSONObject =			getJSONObjectWithDefaultItemSelectorURL();		JSONObject jsonObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		WikiAttachmentImageCreoleEditorConfigContributor			wikiAttachmentImageCreoleEditorConfigContributor =				new WikiAttachmentImageCreoleEditorConfigContributor();		wikiAttachmentImageCreoleEditorConfigContributor.setItemSelector(			_itemSelector);		wikiAttachmentImageCreoleEditorConfigContributor.			populateConfigJSONObject(				jsonObject, _inputEditorTaglibAttributes, null, null);		JSONObject expectedJSONObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		expectedJSONObject.put("removePlugins", "plugin1");		JSONAssert.assertEquals(			expectedJSONObject.toJSONString(), jsonObject.toJSONString(), true);	}
@Test    public void runWithJunitTest() {        List<Failure> failures = new ArrayList<>();        List<Failure> failureDetails = new ArrayList<>();        Path path = mock(Path.class);        Result result = runWithJunit(path, fakeRunner, failures, failureDetails);        assertFalse(result.wasSuccessful());        assertEquals(1, failures.size());        assertEquals(2, failureDetails.size());        assertEquals("Test", failures.get(0).getMessage());        assertEquals(path, failures.get(0).getPath());    }
@Test public void testPaginate() throws Exception {    Assert.assertEquals( 0, xlsxOutput.paginate( null, 0 ) );  }
@Test    public void testConflictingDependencyPresent() {        PluginsAware pluginRegistry = mock(PluginsAware.class);        doReturn(getPluginIdentityMetadata(FIXED_VERSION_NAME))                .when(pluginRegistry).getPlugin(eq(FIXED_VERSION_NAME));        doReturn(getPluginIdentityMetadata(VERSION_RANGE_NAME))                .when(pluginRegistry).getPlugin(eq(VERSION_RANGE_NAME));        List<Dependency> conflictingDependencies = new ArrayList<>();        try {            new DefaultDependencyChecker().check(pluginRegistry, getPluginDependenciesMetadata(new Dependency[0], new Dependency[]{                    DEPENDENCY_WITH_FIXED_VERSION, DEPENDENCY_WITH_VERSION_RANGE            }));        } catch (PluginException e) {            assertTrue(e.getDependencyProblem().isPresent());            conflictingDependencies.addAll(e.getDependencyProblem().get().getConflictingDependencies());        }        assertThat(conflictingDependencies, hasSize(1));        assertThat(conflictingDependencies, contains(DEPENDENCY_WITH_VERSION_RANGE));    }
@Test    public void testAIXMTimeSliceDeclarations()                            throws ClassCastException, ClassNotFoundException, InstantiationException,                            IllegalAccessException {        String schemaUrl = this.getClass().getResource( "../aixm/schema/message/AIXM_BasicMessage.xsd" ).toString();        GMLAppSchemaReader adapter = new GMLAppSchemaReader( null, null, schemaUrl );        AppSchema schema = adapter.extractAppSchema();        GMLSchemaInfoSet gmlSchema = schema.getGMLSchema();        List<XSElementDeclaration> timeSliceElementDecls = gmlSchema.getTimeSliceElementDeclarations( null, true );        Assert.assertEquals( 126, timeSliceElementDecls.size() );    }
@Test    public void dictsToTrie_nonnull_should_return_trie() throws Exception {        List<PinyinDict> dicts = new ArrayList<PinyinDict>();        dicts.add(new PinyinMapDict() {            @Override            public Map<String, String[]> mapping() {                Map<String, String[]> map = new HashMap<String, String[]>();                map.put("1", null);                return map;            }        });        assertThat(Utils.dictsToTrie(dicts), notNullValue());    }
@Test  public void testGetDescendingOrganizationsWithoutAccessToParent() throws Exception {    String content = "" +            "subject.1.name = subject\n" +            "organization.1.name = organization1\n" +            "organization.2.name = organization2\n" +            "organization.2.type = group\n" +            "organization.2.members = 1\n" +            "subject.1.permission.1 = function" +            "";    setup(content);    assertEmpty(accessController.getDescendingOrganizations(createCredentials(1), createOrganizationIdentifier(2)));  }
@Test    public void updateMenuItemAttributes() {        LIElement toUpdateMock = mock(LIElement.class);        NodeList<Element> elementsByTagNameMock = mock(NodeList.class);        Element itemMock = mock(Element.class);        when(elementsByTagNameMock.getItem(0)).thenReturn(itemMock);        when(toUpdateMock.getElementsByTagName("span")).thenReturn(elementsByTagNameMock);        String id = "TEST-ID";        String label = "TEST-LABEL";        String i18n = "TEST-i18n";        String boldLabel = "<b>" + label + "</b>";        baseMenu.updateMenuItemAttributes(toUpdateMock, id, label, i18n);        verify(toUpdateMock, times(1)).setId(eq(id));        verify(itemMock, times(1)).setInnerHTML(eq(boldLabel));    }
@Test    public void enableCreateCollectionContainer_CreateMap() {        enableCreateCollectionContainer(true, false);    }
@Test  public void testMapperFieldName_configNotMap() {    LOG.info("testMapperFieldName_configNotMap()");    MapperFieldName mapperFieldName = new MapperFieldName();    assertFalse("Was able to initialize!", mapperFieldName.init(null, "someField", null, ""));  }
@Test    void construct3() throws InstantiationException {        final InjectorBuilder builder = new InjectorBuilderImpl(singleton(Foo.class));        final Injector injector = builder.build();        assertEquals(1, injector.injectables().count());    }
@Test    public void testAddColumnWithOrigin() {        TableImpl<Node> table = new TableImpl<Node>(Node.class, false);        Column col = table.addColumn("Id", Integer.class, Origin.PROPERTY);        Assert.assertEquals(col.getOrigin(), Origin.PROPERTY);        Assert.assertTrue(col.isProperty());    }
@Test  public void testEmptyRowList() {    List<KeyOffset> rowKeys = new ArrayList<>();    List<HRegionLocation> locations = adapter.adaptResponse(rowKeys);    Assert.assertEquals(1, locations.size());    HRegionLocation location = locations.get(0);    Assert.assertArrayEquals(HConstants.EMPTY_START_ROW, location.getRegionInfo().getStartKey());    Assert.assertArrayEquals(HConstants.EMPTY_END_ROW, location.getRegionInfo().getEndKey());    Assert.assertEquals("host", location.getHostname());    Assert.assertEquals(123, location.getPort());  }
@Test  public void testAdapt_BinaryAndEquals() throws IOException {    byte[] bytes = new byte[] {0, 1, 2};    BinaryComparator comparator = new BinaryComparator(bytes);    org.apache.hadoop.hbase.filter.RowFilter filter =        new org.apache.hadoop.hbase.filter.RowFilter(CompareFilter.CompareOp.EQUAL, comparator);    Assert.assertEquals(        RowFilter.newBuilder()            .setRowKeyRegexFilter(ReaderExpressionHelper.quoteRegularExpression(bytes))            .build(),        adapter.adapt(context, filter).toProto());  }
@Test    void testFullyQualifiedTypeName_0args() {        assertEquals(fullName("User"), instance.fullyQualifiedTypeName());    }
@Test  public void testTokens_invalidRelationalOp() {    try {      new QueryLexer().tokens("foo=1&bar|5");      fail("Expected InvalidQueryException due to invalid relational op");    } catch (InvalidQueryException e) {      //expected    }  }
@Test    public void testGetReportUrlJSON() {        String reportUrl = inspireValidatorUtils.getReportUrlJSON(URL, "123");        assertEquals(URL + "/v2/TestRuns/123.json", reportUrl);    }
@Test	public void testIncompleteTag() {		String expected = "<strong>text</strong>";		String actual = _htmlBBCodeTranslatorImpl.parse("[b]text");		Assert.assertEquals(expected, actual);	}
@Test     public void testGetUDDIClient() throws Exception {          System.out.println("getUDDIClient");          ServletContext req = createNiceMock(ServletContext.class);          req.setAttribute(JUDDI_CLIENT_NAME, null);          expect(req.getInitParameter(WebHelper.JUDDI_CLIENT_NAME)).andReturn(null).times(0, 1);          //using default config          //     expect(req.getInitParameter(WebHelper.UDDI_CLIENT_NAME)).andReturn(null).times(0, 2);          //   expect(req.getInitParameter(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(null).times(0, 2);          // expect(req.getInitParameter(WebHelper.JUDDI_CLIENT_TRANSPORT)).andReturn(null).times(0, 2);          //expect(req.getAttribute(WebHelper.JUDDI_CLIENT_NAME)).andReturn(null).times(0, 2);          //using default config          // expect(req.getAttribute(WebHelper.UDDI_CLIENT_NAME)).andReturn(null).times(0, 2);          //expect(req.getAttribute(WebHelper.UDDI_CLIENT_CONFIG_FILE)).andReturn(null).times(0, 2);          //expect(req.getAttribute(WebHelper.JUDDI_CLIENT_TRANSPORT)).andReturn(null).times(0, 2);          replay(req);          UDDIClient result = WebHelper.getUDDIClient(req);          Assert.assertNotNull(result);     }
@Test    public void webAuthnAuthenticationToken() {        WebAuthnAuthenticationToken webAuthnAuthenticationToken = new WebAuthnAuthenticationToken(null, null, null);        assertThat(webAuthnAuthenticationToken.isAuthenticated()).isTrue();    }
@Test(expected = InvalidArgumentException.class)  public void testUpdateFactTypeWithFactBindingsFailsOnExistingObjectBindings() throws Exception {    UpdateFactTypeRequest request = new UpdateFactTypeRequest()            .setId(UUID.randomUUID())            .addAddFactBinding(new MetaFactBindingDefinition());    FactTypeEntity existingEntity = new FactTypeEntity()            .addRelevantObjectBinding(new FactTypeEntity.FactObjectBindingDefinition());    when(factTypeRequestResolver.fetchExistingFactType(request.getId())).thenReturn(existingEntity);    delegate.handle(request);  }
@Test    public void testDiskSizeRestrictionReplace() throws Exception {        Key[] keys = prepareDiskSizeRestrictionTests();        store.put(keys[4], new StoreInfoAndData(new byte[200], 4, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[0], new StoreInfoAndData(new byte[200], 0, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[1], new StoreInfoAndData(new byte[200], 1, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[3], new StoreInfoAndData(new byte[200], 3, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[2], new StoreInfoAndData(new byte[200], 2, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        try (            Statement statement = store.metadataDb.createStatement();            ResultSet rs = statement.executeQuery(FilesystemStore.QUERY_GETCURRENT_SIZE)) {            assertTrue(rs.next());            assertEquals(1000L, Long.parseLong(rs.getString(1)));        }        store.put(keys[4], new StoreInfoAndData(new byte[100], 4, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[0], new StoreInfoAndData(new byte[300], 0, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[1], new StoreInfoAndData(new byte[200], 1, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[3], new StoreInfoAndData(new byte[100], 3, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[2], new StoreInfoAndData(new byte[300], 2, false));        assertStoreContains(keys, keys[0], keys[1], keys[2], keys[3], keys[4]);        store.put(keys[2], new StoreInfoAndData(new byte[400], 2, false));        assertStoreContains(keys, keys[2], keys[3], keys[4]);    }
@Test	public void testCreateConfigurable() {		// Test dictionary		Dictionary<String, String> dictionary = new HashMapDictionary<>();		dictionary.put("testReqiredString", "testReqiredString1");		_assertTestConfiguration(			ConfigurableUtil.createConfigurable(				TestConfiguration.class, dictionary),			"testReqiredString1");		// Test map		_assertTestConfiguration(			ConfigurableUtil.createConfigurable(				TestConfiguration.class,				Collections.singletonMap(					"testReqiredString", "testReqiredString2")),			"testReqiredString2");	}
@Test    public void testAtomicityIsNotEnforcedWithTimestamp() {        AtomicSupport store = getStore();        setupGraph(store);        Operations.countKeyAtomic("foo", Time.now(), store);        Assert.assertTrue(true);    }
@Test  public void testHasPermissionInheritedFromSubjectGroup() throws Exception {    String content = "" +            "subject.1.name = subject1\n" +            "subject.2.name = subject2\n" +            "subject.2.type = group\n" +            "subject.2.members = 1\n" +            "subject.3.name = subject3\n" +            "subject.3.type = group\n" +            "subject.3.members = 2\n" +            "organization.1.name = organization\n" +            "subject.3.permission.1 = function" +            "";    setup(content);    assertTrue(accessController.hasPermission(createCredentials(1), createFunctionIdentifier("function")));    assertTrue(accessController.hasPermission(createCredentials(1), () -> "function"));  }
@Test( expected = NullPointerException.class )    public void rejectsNullDefaultValueRemainder() {        new RequiredArgumentOptionSpec<Integer>( "d" ).defaultsTo( 2, (Integer[]) null );    }
@Test  public void testUpdateSkipFailures() throws Exception {    testCreateResourcesWithAutoSkipFailures();    List<UpgradeEntity> upgrades = upgradeDao.findUpgrades(1);    assertEquals(1, upgrades.size());    UpgradeEntity entity = upgrades.get(0);    HostRoleCommandDAO dao = injector.getInstance(HostRoleCommandDAO.class);    List<HostRoleCommandEntity> tasks = dao.findByRequest(entity.getRequestId());    for (HostRoleCommandEntity task : tasks) {      StageEntity stage = task.getStage();      if (stage.isSkippable() && stage.isAutoSkipOnFailureSupported()) {        assertTrue(task.isFailureAutoSkipped());      } else {        assertFalse(task.isFailureAutoSkipped());      }    }    Map<String, Object> requestProps = new HashMap<>();    requestProps.put(UpgradeResourceProvider.UPGRADE_CLUSTER_NAME, "c1");    requestProps.put(UpgradeResourceProvider.UPGRADE_VERSION, "2.2.0.0");    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_FAILURES, Boolean.TRUE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_SC_FAILURES, Boolean.FALSE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_REQUEST_ID, "" + entity.getRequestId());    ResourceProvider upgradeResourceProvider = createProvider(amc);    Request request = PropertyHelper.getUpdateRequest(requestProps, null);    upgradeResourceProvider.updateResources(request, null);    tasks = dao.findByRequest(entity.getRequestId());    for (HostRoleCommandEntity task : tasks) {      if (task.getRoleCommand() == RoleCommand.SERVICE_CHECK) {        assertFalse(task.isFailureAutoSkipped());      } else {        StageEntity stage = task.getStage();        if (stage.isSkippable() && stage.isAutoSkipOnFailureSupported()) {          assertTrue(task.isFailureAutoSkipped());        } else {          assertFalse(task.isFailureAutoSkipped());        }      }    }    requestProps = new HashMap<>();    requestProps.put(UpgradeResourceProvider.UPGRADE_CLUSTER_NAME, "c1");    requestProps.put(UpgradeResourceProvider.UPGRADE_VERSION, "2.2.0.0");    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_FAILURES, Boolean.FALSE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_SC_FAILURES, Boolean.TRUE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_REQUEST_ID, "" + entity.getRequestId());    request = PropertyHelper.getUpdateRequest(requestProps, null);    upgradeResourceProvider.updateResources(request, null);    tasks = dao.findByRequest(entity.getRequestId());    for (HostRoleCommandEntity task : tasks) {      if (task.getRoleCommand() == RoleCommand.SERVICE_CHECK) {        StageEntity stage = task.getStage();        if (stage.isSkippable() && stage.isAutoSkipOnFailureSupported()) {          assertTrue(task.isFailureAutoSkipped());        } else {          assertFalse(task.isFailureAutoSkipped());        }      } else {        assertFalse(task.isFailureAutoSkipped());      }    }    requestProps = new HashMap<>();    requestProps.put(UpgradeResourceProvider.UPGRADE_CLUSTER_NAME, "c1");    requestProps.put(UpgradeResourceProvider.UPGRADE_VERSION, "2.2.0.0");    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_FAILURES, Boolean.FALSE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_SKIP_SC_FAILURES, Boolean.FALSE.toString());    requestProps.put(UpgradeResourceProvider.UPGRADE_REQUEST_ID, "" + entity.getRequestId());    request = PropertyHelper.getUpdateRequest(requestProps, null);    upgradeResourceProvider.updateResources(request, null);    tasks = dao.findByRequest(entity.getRequestId());    for (HostRoleCommandEntity task : tasks) {      assertFalse(task.isFailureAutoSkipped());    }  }
@Test    public void selectSimulationTabWithItem() {        scenarioSimulationEditorBusinessClientWrapper.selectSimulationTab();        verify(simulationTabListItemMock, times(1)).showTab(eq(false));    }
@Test  public void rolledBackForKnownException() {    Transactional transactional = createNiceMock(Transactional.class);    EntityTransaction transaction = createStrictMock(EntityTransaction.class);    expect(transaction.getRollbackOnly()).andReturn(false);    expect(transactional.rollbackOn()).andReturn(asArray(NullPointerException.class, IllegalArgumentException.class));    expect(transactional.ignore()).andReturn(asArray());    transaction.rollback();    replayAll();    boolean canCommit = rollbackIfNecessary(transactional, new IllegalArgumentException("rolling back"), transaction);    Assert.assertFalse("Should be rolled back, since exception matches rollbackOn clause", canCommit);    verifyAll();  }
@Test  public void testSendFailure() throws Exception {    Destination corruptDestination = new TestDestination();    Mutation<?> firstMutation = mock(Mutation.class);    Mutation<?> secondMutation = mock(Mutation.class);    when(keyProvider.get(firstMutation)).thenReturn("0");    when(keyProvider.get(secondMutation)).thenReturn("1");    Destination.Listener listener = mock(Destination.Listener.class);    DestinationPool pool =        new DestinationPool(            keyProvider, Arrays.asList(mock(Destination.class), corruptDestination));    pool.addListener(listener);    pool.send(ImmutableList.of(firstMutation, secondMutation));    verify(listener, times(1)).onError(any(RuntimeException.class));  }
@Test	public void testAppend() throws Exception {		StringWriter stringWriter = new StringWriter();		UnsyncPrintWriter unsyncPrintWriter = new UnsyncPrintWriter(			stringWriter);		unsyncPrintWriter.append('A');		Assert.assertEquals("A", stringWriter.toString());		unsyncPrintWriter.append(null);		Assert.assertEquals("Anull", stringWriter.toString());		unsyncPrintWriter.append("B");		Assert.assertEquals("AnullB", stringWriter.toString());		unsyncPrintWriter.append(null, 0, 4);		Assert.assertEquals("AnullBnull", stringWriter.toString());		unsyncPrintWriter.append("C", 0, 1);		Assert.assertEquals("AnullBnullC", stringWriter.toString());	}
@Test    public void addDelegatesToFieldAddition() {        final Scalar<Object> first = new Scalar.Default<>(new Object());        final Scalar<Object> second = new Scalar.Default<>(new Object());        final MkAddition<Object> add = new MkAddition<>(new Object());        final SpyField<Object> field = new SpyField<>(            new MkField<Object>(new Object(), add)        );        final List<Scalar<Object>> operands = Arrays.asList(first, second, first);        new Add<>(operands).value(field);        MatcherAssert.assertThat(            field.calls().additioned(), Matchers.is(true)        );        MatcherAssert.assertThat(            add.neutraled(), Matchers.is(true)        );        MatcherAssert.assertThat(            add.added(), Matchers.is(operands.size())        );    }
@Test    public void getSafeHtml_Attribute() {        AttributeCol52 originalColumn = new AttributeCol52();        originalColumn.setReverseOrder(false);        originalColumn.setUseRowNumber(false);        originalColumn.setHideColumn(false);        originalColumn.setDefaultValue(new DTCellValue52("def1"));        // header & attribute name of an attribute column cannot be updated in the ui        originalColumn.setAttribute(Attribute.SALIENCE.getAttributeName());        originalColumn.setHeader(Attribute.SALIENCE.getAttributeName());        AttributeCol52 newColumn = new AttributeCol52();        newColumn.setReverseOrder(true);        newColumn.setUseRowNumber(true);        newColumn.setHideColumn(true);        newColumn.setDefaultValue(new DTCellValue52("def2"));        // header & attribute name of an attribute column cannot be updated in the ui        newColumn.setAttribute(Attribute.SALIENCE.getAttributeName());        newColumn.setHeader(Attribute.SALIENCE.getAttributeName());        List<BaseColumnFieldDiff> diffs = originalColumn.diff(newColumn);        SafeHtml result = helper.getSafeHtml(new UpdateColumnAuditLogEntry("mock user", originalColumn, newColumn, diffs));        assertEquals(getAttributeHeaderRepre(newColumn.getAttribute()) + getDiffRepre(diffs), result.asString());    }
@Test public void testPaginate() throws Exception {    Assert.assertEquals( 0, fastXLSXOutput.paginate( null, 0 ) );  }
@Test  public void testActUserIdIsSetInRequestHeader() {    when(httpHeaders.getHeaderString("ACT-User-ID")).thenReturn("1");    RequestHeader rh = resolver.getRequestHeader();    assertNotNull(rh.getCredentials());    assertTrue(rh.getCredentials() instanceof SubjectCredentials);    assertEquals(1, ((SubjectCredentials) rh.getCredentials()).getSubjectID());  }
@Test(description = "This test case tests updating a non existent profile feature",          expectedExceptions = {FeatureManagementException.class},          dependsOnMethods = "testUpdateProfileFeature")    public void testUpdateProfileFeatureThrowingFeatureManagementException() throws Exception {        Profile profile = ProfileCreator.getProfile(FeatureCreator.getFeatureList(), DEVICE_TYPE_D);        int nonExistentProfileId = 9999;        ProfileFeature profileFeature = profile.getProfileFeaturesList().get(0);        featureManager.updateProfileFeature(profileFeature, nonExistentProfileId);    }
@Test    void apply() {        assertEquals(Tuples.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), instance.apply(0));    }
@Test  public void simpleOTFTest()  {    DimensionalConfigurationSchema des = new DimensionalConfigurationSchema(        SchemaUtils.jarResourceFileToString("adsGenericEventSchemaOTF.json"),        AggregatorRegistry.DEFAULT_AGGREGATOR_REGISTRY);    Assert.assertEquals(4, des.getDimensionsDescriptorIDToAggregatorIDs().get(0).size());  }
@Test    public void ofLong() {        assertByte(SampleSize.of(1), "0x01000000");        assertByte(SampleSize.of(65535), "0xffff0000");        assertThrows(IllegalArgumentException.class, () -> SampleSize.of(-1));        assertThrows(IllegalArgumentException.class, () -> SampleSize.of(4294967296L));    }
@Test    @SuppressWarnings("unchecked")    public void testOnIssueSelectedEvent_HighlightsRows() {        dtPresenter.onIssueSelectedEvent(new IssueSelectedEvent(dtPlaceRequest,                                                                mock(Issue.class)));        verify(renderer,               never()).clearHighlights();        verify(renderer,               times(1)).highlightRows(any(Severity.class),                                       any(Set.class));        verify(view,               times(1)).draw();    }
@Test    public void testInvalidUsernameTokenParameters() {    	PMode invalidPMode = new PMode();    	    	invalidPMode.setMep(EbMSConstants.ONE_WAY_MEP);        invalidPMode.setMepBinding(EbMSConstants.ONE_WAY_PUSH);        invalidPMode.addLeg(new Leg());        assertTrue(Utils.isNullOrEmpty(validator.validatePMode(invalidPMode)));        PartnerConfig initiator = new PartnerConfig();        SecurityConfig secConfig = new SecurityConfig();        SigningConfig sigConfig = new SigningConfig();        sigConfig.setKeystoreAlias("exampleca");        secConfig.setSignatureConfiguration(sigConfig);        EncryptionConfig encConfig = new EncryptionConfig();        encConfig.setKeystoreAlias("partya");        secConfig.setEncryptionConfiguration(encConfig);        initiator.setSecurityConfiguration(secConfig);        invalidPMode.setInitiator(initiator);        UsernameTokenConfig tokenConfig = new UsernameTokenConfig();        assertTrue(Utils.isNullOrEmpty(tokenConfig.getUsername()));        // non null empty token with default header        secConfig.setUsernameTokenConfiguration(                SecurityHeaderTarget.DEFAULT, tokenConfig);        assertFalse(Utils.isNullOrEmpty(validator.validatePMode(invalidPMode)));        tokenConfig.setUsername("username");        tokenConfig.setPassword("secret");        assertTrue(Utils.isNullOrEmpty(validator.validatePMode(invalidPMode)));        tokenConfig = new UsernameTokenConfig();        // non null empty token with EBMS header        secConfig.setUsernameTokenConfiguration(                SecurityHeaderTarget.EBMS, tokenConfig);        assertFalse(Utils.isNullOrEmpty(validator.validatePMode(invalidPMode)));    }
@Test    public void testHasUserName() throws Exception {        User user1 = _userRepo.save(newUser(_inc));        _userRepo.save(newUser(_inc));        final List<User> found = _userRepo.findAll(hasUserName(user1.getUsername()));        assertEquals(1, found.size());        assertEquals(user1.getId(), found.get(0).getId());    }
@Test	public void testInvalidGetReviews() {		when(service.getReviewsByPlace(review.getPlace())).thenReturn(reviews);		when(service.getReviewsByPlace(review2.getPlace())).thenReturn(reviews);		assertEquals(controller.GetReviews(review2), controller.GetReviews(review));	}
@Test    void toTuple10OfNullables() {        final Function<Integer, Tuple10OfNullables<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>> mapper = TuplesOfNullables.toTupleOfNullables(i -> i + 0, i -> i + 1, i -> i + 2, i -> i + 3, i -> i + 4, i -> i + 5, i -> i + 6, i -> i + 7, i -> i + 8, i -> i + 9);        assertTuple(mapper.apply(0), 10);    }
@Test    void shouldTreatProtocolErrorAsFatal()    {        assertTrue( isFatal( new ClientException( "Neo.ClientError.Request.Invalid", "Illegal request" ) ) );        assertTrue( isFatal( new ClientException( "Neo.ClientError.Request.InvalidFormat", "Wrong format" ) ) );        assertTrue( isFatal( new ClientException( "Neo.ClientError.Request.TransactionRequired", "No tx!" ) ) );    }
@Test  public void testProxyDeleteRequest() throws Exception {    ProxyService ps = new ProxyService();    URLStreamProvider streamProviderMock = PowerMock.createNiceMock(URLStreamProvider.class);    HttpURLConnection urlConnectionMock = createMock(HttpURLConnection.class);    URI uriMock = PowerMock.createMock(URI.class);    MultivaluedMap<String, String> queryParams = new MultivaluedMapImpl();    MultivaluedMap<String, String> headerParams = new MultivaluedMapImpl();    Map<String, List<String>> headerParamsToForward = new HashMap<String, List<String>>();    Response.ResponseBuilder responseBuilderMock = PowerMock.createMock(ResponseBuilderImpl.class);    Response responseMock = createMock(ResponseImpl.class);    headerParams.add("AmbariProxy-User-Remote","testuser");    headerParams.add("Content-Type","testtype");    List<String> userRemoteParams = new LinkedList<String>();    userRemoteParams.add("testuser");    headerParamsToForward.put("User-Remote", userRemoteParams);    InputStream is = new ByteArrayInputStream("test".getBytes());    PowerMock.mockStatic(Response.class);    expect(getHttpHeaders().getRequestHeaders()).andReturn(headerParams);    expect(getHttpHeaders().getRequestHeader("AmbariProxy-User-Remote")).andReturn(userRemoteParams);    expect(getUriInfo().getRequestUri()).andReturn(uriMock);    expect(getUriInfo().getQueryParameters()).andReturn(queryParams);    expect(uriMock.getQuery()).andReturn("url=testurl");    expect(streamProviderMock.processURL("testurl", "DELETE", (InputStream) null, headerParamsToForward)).andReturn(urlConnectionMock);    expect(urlConnectionMock.getResponseCode()).andReturn(200);    expect(urlConnectionMock.getContentType()).andReturn("text/plain");    expect(urlConnectionMock.getInputStream()).andReturn(is);    PowerMock.expectNew(URLStreamProvider.class, 20000, 15000, null, null, null).andReturn(streamProviderMock);    expect(Response.status(200)).andReturn(responseBuilderMock);    expect(responseBuilderMock.entity(is)).andReturn(responseBuilderMock);    expect(responseBuilderMock.type("text/plain")).andReturn(responseBuilderMock);    expect(responseBuilderMock.build()).andReturn(responseMock);    PowerMock.replay(streamProviderMock, URLStreamProvider.class, Response.class, responseBuilderMock, uriMock, URI.class);    replay(getUriInfo(), urlConnectionMock, getHttpHeaders());    Response resultForDeleteRequest = ps.processDeleteRequestForwarding(getHttpHeaders(), getUriInfo());    assertSame(resultForDeleteRequest, responseMock);  }
@Test(expected = SchedulerConflictException.class)  public void testAddMultipleEventsConflict() throws Exception {    for (int i = 0; i < 2; i++) {      final RRule rrule = new RRule("FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR;BYHOUR=7;BYMINUTE=30");      final Date start = new Date(1546844400000L); // 2019-01-07T07:00:00Z      final Date end = new Date(1570953300000L); // 2019-10-13T07:55:00Z      final Long duration = 6900000L;      final TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");      final String captureAgentId = "Device A";      final Set<String> userIds = Collections.emptySet();      final String id = "Recording" + i;      final MediaPackage mpTemplate = generateEvent(Opt.some(id));      final DublinCoreCatalog dublinCoreCatalog = generateEvent(captureAgentId,        Opt.some(mpTemplate.getIdentifier().toString()), Opt.some("Test Title"), start, end);      addDublinCore(Opt.some(mpTemplate.getIdentifier().toString()), mpTemplate, dublinCoreCatalog);      final Map<String, String> wfProperties = this.wfProperties;      final Map<String, String> caProperties = Collections.singletonMap("foo", "bar");      final Opt<String> schedulingSource = Opt.none();      final Map<String, Period> scheduled = schedSvc.addMultipleEvents(          rrule,          start,          end,          duration,          tz,          captureAgentId,          userIds,          mpTemplate,          wfProperties,          caProperties,          schedulingSource      );    }  }
@Test  public void testSearchFacts() throws Exception {    ResultSet<Fact> result = delegate.handle(new SearchFactRequest().setIncludeRetracted(true));    assertEquals(25, result.getLimit());    assertEquals(100, result.getCount());    assertEquals(1, ListUtils.list(result.iterator()).size());    verify(requestConverter).apply(isNotNull());    verify(factSearchHandler).search(isNotNull(), eq(true));  }
@Test	public void testGetMetadata() {		TaskID task = new TaskID(8);		XTraceMetadata md = new XTraceMetadata(task, 0);				Report r = new Report();		r.put("X-Trace", md.toString());		r.put("Key1", "Value1");		r.put("Key2", "Value2");				assertEquals(md, r.getMetadata());				r = new Report();		r.put("Key1", "Value1");		r.put("X-Trace", md.toString());		r.put("Key2", "Value2");				assertEquals(md, r.getMetadata());	}
@Test    public void moveStickUpDescendant() {        for (MotionEvent me : mUpDesc) {            mTranslator.handle(me);        }        assertNull("Event should NOT be produced when moving in descendant direction", mLastKeyEvent);    }
@Test	public void testInvalidExpression2() throws Exception {		Boolean result = (Boolean)_allFunction.apply("#value# >>> 10", 11);		Assert.assertFalse(result);	}
@Test    void testPutRules() {        Instant now = Instant.ofEpochSecond(1500000000);        CentralizedManifest manifest = new CentralizedManifest();        // Liberal sampling rule        SamplingRule r1 = new SamplingRule()            .withRuleName("r1")            .withPriority(10)            .withReservoirSize(20)            .withFixedRate(0.05)            .withHost("*")            .withServiceName("*")            .withHTTPMethod("*")            .withURLPath("*")            .withResourceARN("*")            .withServiceType("*");        manifest.putRules(Arrays.asList(r1), now);        SamplingRequest req = new SamplingRequest(            "privileged",            "resourceARN",            "service",            "host",            "method",            "url",            "serviceType",            null        );        Assertions.assertEquals("r1", manifest.match(req, now).sample(now).getRuleName().get());    }
@Test	public void testGetExactMatchExecutor() {		Assert.assertEquals("/", _executorPathResolver.getExecutorPath("/"));		Assert.assertEquals(			"/server", _executorPathResolver.getExecutorPath("/server"));		Assert.assertEquals(			"/plugins", _executorPathResolver.getExecutorPath("/plugins"));	}
@Test    public void testDefaults()    {        assertRecordedDefaults(recordDefaults(ReportTagConfig.class)                .setTags(ImmutableMap.of()));    }
@Test    public void writeThemeMinimal()                            throws Exception {        final ByteArrayOutputStream bos = new ByteArrayOutputStream();        final XMLStreamWriter writer = newInstance().createXMLStreamWriter( bos );        writer.writeStartElement( "Layer" );        XMLAdapter.writeElement( writer, "Title", "Container" );        final LayerMetadata layerMetadata = createLayerMetadataMinimal();        layerMetadata.setQueryable( false );        final DatasetMetadata datasetMetadata = createDatasetMetadataMinimal();        final Map<String, String> authorityNameToUrl = emptyMap();        themeWriter.writeTheme( writer, layerMetadata, datasetMetadata, authorityNameToUrl, null, null );        writer.writeEndElement();        writer.flush();        bos.close();        final InputStream is = WmsCapabilities111ThemeWriterTest.class.getResourceAsStream( "wms111_layer_minimal.xml" );        final byte[] expected = IOUtils.readBytesAndClose( is, -1 );        assertArrayEquals( expected, bos.toByteArray() );    }
@Test    public void testGetTile()                            throws UnknownCRSException {        GeometryFactory fac = new GeometryFactory();        ICRS crs = CRSManager.lookup( "EPSG:4326" );        Envelope env = fac.createEnvelope( -10, -10, 10, 10, crs );        SpatialMetadata smd = new SpatialMetadata( env, Collections.singletonList( crs ) );        TileMatrix md = new TileMatrix( "someid", smd, 256, 256, 1, 1, 1 );        TileDataLevel tm = mock( TileDataLevel.class );        Tile t = mock( Tile.class );        tm.getMetadata();        tm.getTile( 0, 0 );        when( tm.getMetadata() ).thenReturn( md );        when( tm.getTile( 0, 0 ) ).thenReturn( t );        assertEquals( 256, tm.getMetadata().getTilePixelsX() );        verify( tm ).getTile( 0, 0 );    }
@Test  public void testFindByClusterHostAndState() {    Assert.assertEquals(1, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host1", RepositoryVersionState.CURRENT).size());    Assert.assertEquals(0, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host1", RepositoryVersionState.INSTALLED).size());    Assert.assertEquals(0, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host2", RepositoryVersionState.INSTALLING).size());    Assert.assertEquals(0, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host3", RepositoryVersionState.INSTALL_FAILED).size());    addMoreVersions();    Assert.assertEquals(2, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host1", RepositoryVersionState.INSTALLED).size());    Assert.assertEquals(2, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host2", RepositoryVersionState.INSTALLED).size());    Assert.assertEquals(2, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host3", RepositoryVersionState.INSTALLED).size());    Assert.assertEquals(1, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host1", RepositoryVersionState.CURRENT).size());    Assert.assertEquals(1, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host2", RepositoryVersionState.INSTALLING).size());    Assert.assertEquals(1, hostVersionDAO.findByClusterHostAndState("test_cluster1", "test_host3", RepositoryVersionState.INSTALL_FAILED).size());  }
@Test    public void testIdLowercase() {        TableImpl<Node> table = new TableImpl<Node>(Node.class, false);        Column col = table.addColumn("A", Integer.class);        Assert.assertEquals(col.getId(), "a");    }
@Test    public void testHasSchemaId() throws Exception {        String schemaId1 = "schemaId1";        String schemaId2 = "schemaId2";        final Metadata metadata = newMetadata(_inc);        metadata.getDataInfo().setSchemaId(schemaId1);        Metadata md1 = _repository.save(metadata);        final Metadata metadata2 = newMetadata(_inc);        metadata2.getDataInfo().setSchemaId(schemaId2);        Metadata md2 = _repository.save(metadata2);        assertEquals(1, _repository.findAll((Specification<Metadata>)hasSchemaId(schemaId1)).size());        assertEquals(1, _repository.findAll((Specification<Metadata>)hasSchemaId(schemaId2)).size());        assertEquals(0, _repository.findAll((Specification<Metadata>)hasSchemaId("other")).size());        assertEquals(md1.getId(), _repository.findOne((Specification<Metadata>)hasSchemaId(schemaId1)).getId());        assertEquals(md2.getId(), _repository.findOne((Specification<Metadata>)hasSchemaId(schemaId2)).getId());    }
@Test  public void testAssertValidFactValue() {    FactTypeEntity factType = new FactTypeEntity().setValidator("SomeValidator").setValidatorParameter("SomeParam");    Validator validator = mock(Validator.class);    when(validator.validate(eq("test"))).thenReturn(false);    when(validatorFactory.get(factType.getValidator(), factType.getValidatorParameter())).thenReturn(validator);    InvalidArgumentException ex = assertThrows(InvalidArgumentException.class,            () -> handler.assertValidFactValue(factType, "test"));    assertEquals(SetUtils.set("fact.not.valid"), SetUtils.set(ex.getValidationErrors(), InvalidArgumentException.ValidationError::getMessageTemplate));  }
@Test  public void testFetchObjectsByIdWithUnknownId() {    assertEquals(0, ListUtils.list(getObjectManager().getObjects(null)).size());    assertEquals(0, ListUtils.list(getObjectManager().getObjects(ListUtils.list())).size());    assertEquals(0, ListUtils.list(getObjectManager().getObjects(ListUtils.list(UUID.randomUUID()))).size());  }
@Test  public void testSetRestartRequiredAfterRackChange() throws Exception {    ServiceInfo serviceInfo = new ServiceInfo();    serviceInfo.setRestartRequiredAfterRackChange(true);    assertTrue(serviceInfo.isRestartRequiredAfterRackChange());    serviceInfo.setRestartRequiredAfterRackChange(false);    assertFalse(serviceInfo.isRestartRequiredAfterRackChange());  }
@Test  public void testCurrentGreaterThanThreshold() {    when(packetBuffer.getByteCount()).thenReturn(getThresholdAsBytes() + 1);    assertThat(condition.isRolloverReady(packetBuffer), is(true));  }
@Test    public void testShowNewPatternModal() throws Exception {        page.showNewPatternModal();        verify(newPatternPresenter).show();    }
@Test	public void testValidateConfigurationValuesTextFieldTypeInvalidRegexp()		throws Exception {		expectedException.expect(FragmentEntryConfigurationException.class);		_fragmentEntryValidatorImpl.validateConfigurationValues(			_read(				"configuration_field_text_typeoptions_validation_regexp.json"),			JSONUtil.put("regexpField", StringUtil.randomString()));	}
@Test(expected = UnsupportedOperationException.class)    public void testAddRelation() throws Exception {        this.allThesaurus.addRelation("subject", KeywordRelation.RELATED, "relatedSubject");    }
@Test    void get2() {        assertEquals(m2, instance.get2());    }
@Test  public void addAServiceRepoToExistingRepoVersion() throws Exception {    init(true);    activeRepoUpdater.process();    verifyRepoIsAdded();  }
@Test  public void createCommandLineWithEnvVarTest() {    teraDataBulkLoader.setVariable( "TbuilPath", "buildpathvalue" );    teraDataBulkLoader.setVariable( "VariableFile", "variablefilevalue" );    teraDataBulkLoader.setVariable( "JobName", "jobnamevalue" );    setInternalState( teraDataBulkLoader, "tempScriptFile", "scriptValue" );    when( teraDataBulkLoaderMetaMock.getTbuildPath() ).thenReturn( "${TbuilPath}" );    when( teraDataBulkLoaderMetaMock.getVariableFile() ).thenReturn( "${VariableFile}" );    when( teraDataBulkLoaderMetaMock.getJobName() ).thenReturn( "${JobName}" );    try {      String commandLine = teraDataBulkLoader.createCommandLine();      String expected = "buildpathvalue -f scriptValue -v variablefilevalue jobnamevalue";      assertTrue( commandLine.contains( expected ) );    } catch ( KettleException e ) {      fail( e.getMessage() );    }  }
@Test    public void testReadElement() throws Exception {    	UserMessage userMessage = UserMessageElement.readElement(createXML(			"<eb3:UserMessage xmlns:eb3=\"http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/\">\n" + 			"    <eb3:MessageInfo>\n" + 			"        <eb3:Timestamp>2019-08-05T10:50:09.192Z</eb3:Timestamp>\n" + 			"        <eb3:MessageId>8fba80a5-2a4b-42c4-9c8f-f53207d21673@gecko.fritz.box</eb3:MessageId>\n" + 			"    </eb3:MessageInfo>\n" + 			"    <eb3:PartyInfo>\n" + 			"        <eb3:From>\n" + 			"            <eb3:PartyId>org:holodeckb2b:example:company:A</eb3:PartyId>\n" + 			"            <eb3:Role>http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/initiator</eb3:Role>\n" + 			"        </eb3:From>\n" + 			"        <eb3:To>\n" + 			"            <eb3:PartyId type=\"org:holodeckb2b:example:company\">partyb</eb3:PartyId>\n" + 			"            <eb3:Role>http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/responder</eb3:Role>\n" + 			"        </eb3:To>\n" + 			"    </eb3:PartyInfo>\n" + 			"    <eb3:CollaborationInfo>\n" + 			"        <eb3:AgreementRef>UnitTesting</eb3:AgreementRef>\n" + 			"        <eb3:Service>PackagingTest</eb3:Service>\n" + 			"        <eb3:Action>GetElements</eb3:Action>\n" + 			"        <eb3:ConversationId>org:holodeckb2b:test:conversation</eb3:ConversationId>\n" + 			"    </eb3:CollaborationInfo>\n" +			"	 <eb3:MessageProperties>" +			"        <eb3:Property name=\"additional-meta-data\">message description</eb3:Property>\n" + 						"	 </eb3:MessageProperties>" +				"    <eb3:PayloadInfo>\n" + 			"        <eb3:PartInfo>\n" + 			"            <eb3:PartProperties>\n" + 			"                <eb3:Property name=\"original-file-name\"\n" + 			"                    >simple_document.xml</eb3:Property>\n" + 			"            </eb3:PartProperties>\n" + 			"        </eb3:PartInfo>\n" + 			"        <eb3:PartInfo\n" + 			"            href=\"cid:8fba80a5-2a4b-42c4-9c8f-f53207d21673-142514300@gecko.fritz.box\"/>\n" + 			"    </eb3:PayloadInfo>\n" + 			"</eb3:UserMessage>"));    	    	assertNotNull(userMessage);    	assertNotNull(userMessage.getMessageId());    	assertNotNull(userMessage.getSender());    	assertNotNull(userMessage.getReceiver());    	assertNotNull(userMessage.getCollaborationInfo());    	assertFalse(Utils.isNullOrEmpty(userMessage.getMessageProperties()));    	assertFalse(Utils.isNullOrEmpty(userMessage.getPayloads()));    }
@Test	public void testNoteChords() {		assertEquals(toAtomList("60 67 64 72"), toAtomList(p.parse("[C4 G4 e4 b#4]")));		assertEquals(toAtomList(60, "67 64", 72), toAtomList(p.parse("C4 [G4 e4] b#4")));	}
@Test  public void testAssignDoubleArray() throws Exception {    double[] array = new double[test.size()];    test.assign(array);    for (int i = 0; i < test.size(); i++) {      assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }  }
@Test    public void testFocusedInitialFalse() {        JComboBox field = new JComboBox();        field.setEditable(true);        assertFalse("sanity: combo not focused", field.hasFocus());        CompoundFocusListener l = new CompoundFocusListener(field);        assertEquals(field.hasFocus(), l.isFocused());    }
@Test    void expectResponse() {        SUT.expectResponse(Object.class, Duration.ZERO);        assertThat(SUT.expectClazz, is(Object.class));        assertThat(SUT.commands, hasSize(1));        assertThat(SUT.commands.getLast().get(), notNullValue());        assertThrows(ConversationContext.PlcWiringException.class, () -> SUT.expectResponse(Object.class, Duration.ZERO));    }
@Test(expected = StackAdvisorException.class)  public void testRunScript_processStartThrowsException_returnFalse() throws Exception {    String script = "echo";    StackAdvisorCommandType saCommandType = StackAdvisorCommandType.RECOMMEND_COMPONENT_LAYOUT;    File actionDirectory = temp.newFolder("actionDir");    ProcessBuilder processBuilder = createNiceMock(ProcessBuilder.class);    StackAdvisorRunner saRunner = new StackAdvisorRunner();    stub(PowerMock.method(StackAdvisorRunner.class, "prepareShellCommand"))        .toReturn(processBuilder);    expect(processBuilder.start()).andThrow(new IOException());    replay(processBuilder);    saRunner.runScript(script, saCommandType, actionDirectory);  }
@Test    public void shouldGetJobType() {        assertThat(testee.getJobType(), is("someJob"));    }
@Test  public void testResolve_AlertsFile() throws Exception {    File alertsFile = new File("testAlertsFile");    // specified in child only    ServiceInfo info = new ServiceInfo();    ServiceInfo parentInfo = new ServiceInfo();    ServiceModule child = createServiceModule(info);    ServiceModule parent = createServiceModule(parentInfo);    // set in the module constructor from a value obtained from service directory which is mocked    assertEquals(alertsFile, child.getModuleInfo().getAlertsFile());    parent.getModuleInfo().setAlertsFile(null);    resolveService(child, parent);    assertEquals(alertsFile, child.getModuleInfo().getAlertsFile());    // specified in parent only    child = createServiceModule(info);    parent = createServiceModule(parentInfo);    parent.getModuleInfo().setAlertsFile(alertsFile);    child.getModuleInfo().setAlertsFile(null);    resolveService(child, parent);    assertEquals(alertsFile, child.getModuleInfo().getAlertsFile());    // specified in both    child = createServiceModule(info);    parent = createServiceModule(parentInfo);    parent.getModuleInfo().setAlertsFile(new File("someOtherDir"));    child.getModuleInfo().setAlertsFile(alertsFile);    resolveService(child, parent);    assertEquals(alertsFile, child.getModuleInfo().getAlertsFile());  }
@Test  public void testCreateVertexWithoutObject() {    assertThrows(RuntimeException.class, () -> ObjectVertex.builder()            .setGraph(getActGraph())            .setObjectType(ObjectTypeStruct.builder().build())            .build());  }
@Test	public void testMediaURIWhenPathDoesNotEndInSlash() {		String pathModule = StringPool.SLASH + RandomTestUtil.randomString();		Mockito.when(			_portal.getPathModule()		).thenReturn(			pathModule		);		URI relativeURI = URI.create(RandomTestUtil.randomString());		String uriString = String.valueOf(			_amURIResolver.resolveURI(relativeURI));		Assert.assertTrue(uriString, uriString.contains(pathModule));		Assert.assertTrue(			uriString, uriString.contains(AMWebConstants.SERVLET_PATH));		Assert.assertTrue(			uriString, uriString.contains(relativeURI.toString()));	}
@Test	public void testGetUpgradePathNotInOrder() {		UpgradeInfo upgradeInfo1 = createUpgradeInfo("0.0.0", "0.1.0");		UpgradeInfo upgradeInfo2 = createUpgradeInfo("0.1.0", "0.2.0");		UpgradeInfo upgradeInfo3 = createUpgradeInfo("0.2.0", "1.0.0");		UpgradeInfo upgradeInfo4 = createUpgradeInfo("1.0.0", "2.0.0");		ReleaseGraphManager releaseGraphManager = new ReleaseGraphManager(			Arrays.asList(				upgradeInfo4, upgradeInfo2, upgradeInfo1, upgradeInfo3));		List<UpgradeInfo> upgradePath = releaseGraphManager.getUpgradeInfos(			"0.0.0", "2.0.0");		Assert.assertEquals(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4),			upgradePath);	}
@Test    public void testAddNode() {        GraphStore graphStore = new GraphStore();        NodeImpl[] nodes = GraphGenerator.generateNodeList(1);        Assert.assertTrue(graphStore.addNode(nodes[0]));        Assert.assertFalse(graphStore.addNode(nodes[0]));        Assert.assertTrue(graphStore.contains(nodes[0]));    }
@Test    public void testGetCanonicalNamespaceAliasNone() {        Assert.assertEquals("/com/company/plugin/",                getCanonicalNamespace("com.company.plugin.IndexRouter"));        Assert.assertEquals("/com/company/plugin/help/",                getCanonicalNamespace("com.company.plugin.HelpRouter"));        Assert.assertEquals("/com/company/plugin/foo-bar/",                getCanonicalNamespace("com.company.plugin.FooBar"));        Assert.assertEquals("/com/company/plugin/foo-bar/one/",                getCanonicalNamespace("com.company.plugin.FooBar_One"));    }
@Test  public void testActivate() throws Exception {    BundleContext bctx = EasyMock.createMock(BundleContext.class);    EasyMock.expect(bctx.getProperty(MessageBaseFacility.ACTIVEMQ_BROKER_URL_KEY))      .andReturn("failover://(tcp://127.0.0.1:9)?initialReconnectDelay=2000&maxReconnectAttempts=2");    EasyMock.expect(bctx.getProperty(MessageBaseFacility.ACTIVEMQ_BROKER_USERNAME_KEY)).andReturn(null);    EasyMock.expect(bctx.getProperty(MessageBaseFacility.ACTIVEMQ_BROKER_PASSWORD_KEY)).andReturn(null);    EasyMock.replay(bctx);    /* Regular (de-)activate */    MessageReceiverImpl messageReceiverImpl = new MessageReceiverImpl();    messageReceiverImpl.activate(bctx);    assertFalse(messageReceiverImpl.reconnect());    messageReceiverImpl.deactivate();    assertFalse(messageReceiverImpl.isConnected());  }
@Test    void get15Test() {        assertEquals(15, (int) instance.get15().orElseThrow(NoSuchElementException::new));    }
@Test        public void testgetTModelListJSON() {                System.out.println("testgetTModelListJSON");                String id = UUID.randomUUID().toString();                UriContainer expResult = null;                KeyBag serviceListXML = instance.getTModelListJSON();                Assert.assertNotNull(serviceListXML);                Assert.assertFalse(serviceListXML.getTModelKey().isEmpty());        }
@Test	public void testGetTitle() {		JournalArticle journalArticle = _getJournalArticle();		JournalArticleContentDashboardItem journalArticleContentDashboardItem =			new JournalArticleContentDashboardItem(				null, null, null, null, null, null, journalArticle, null, null);		Assert.assertEquals(			journalArticle.getTitle(LocaleUtil.US),			journalArticleContentDashboardItem.getTitle(LocaleUtil.US));	}
@Test    void get3Test() {        assertEquals(3, (int) instance.get3());    }
@Test(expected = AMRuntimeException.class)	public void testFileEntryPathDLAppFailure() throws Exception {		Mockito.when(			_dlAppService.getFileEntry(0)		).thenThrow(			PortalException.class		);		_pathInterpreter.interpretPath("/image/0/x/foo.jpg");	}
@Test    public void testFromWei() {        assertThat(Convert.fromVon("21000000000000", Convert.Unit.VON),                is(new BigDecimal("21000000000000")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.KVON),                is(new BigDecimal("21000000000")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.MVON),                is(new BigDecimal("21000000")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.GVON),                is(new BigDecimal("21000")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.SZABO),                is(new BigDecimal("21")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.FINNEY),                is(new BigDecimal("0.021")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.LAT),                is(new BigDecimal("0.000021")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.KLAT),                is(new BigDecimal("0.000000021")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.MLAT),                is(new BigDecimal("0.000000000021")));        assertThat(Convert.fromVon("21000000000000", Convert.Unit.GLAT),                is(new BigDecimal("0.000000000000021")));    }
@Test(expectedExceptions = IllegalArgumentException.class)    public void testGetAttributeUnknownColumn() {        GraphStore store = new GraphStore();        ColumnImpl columnImpl = new ColumnImpl("0", String.class, "title", "", Origin.DATA, false, false);        NodeImpl node = new NodeImpl("0", store);        node.getAttribute(columnImpl);    }
@Test    void testSetPrefix() {        Log4JSegmentListener listener = (Log4JSegmentListener) AWSXRay.getGlobalRecorder().getSegmentListeners().get(0);        listener.setPrefix("");        Segment seg = new SegmentImpl(AWSXRay.getGlobalRecorder(), "test", TRACE_ID);        listener.onSetEntity(null, seg);        Assertions.assertEquals(TRACE_ID.toString() + "@" + seg.getId(), ThreadContext.get(TRACE_ID_KEY));    }
@Test	public void testLoadandStoreMultilineString() throws IOException {		String line = "testKey = \"testValue1,\\\n\ttestValue2\"";		TypedProperties typedProperties = _createTypedProperties(line);		Assert.assertEquals(			"testValue1,testValue2", typedProperties.get("testKey"));		_assertSave(typedProperties, line);	}
@Test    public void testGetMaxNull() {        GraphStore graphStore = new GraphStore();        TimeStore store = new TimeStore(graphStore, null, true);        Assert.assertEquals(store.getMax(graphStore), Double.POSITIVE_INFINITY);    }
@Test(expected = WorkflowOperationException.class)  public void testStartMissingTargetFlavor() throws Exception {    operationHandler.start(workflowInstance, null);  }
@Test    void shouldAllowByteArrays()    {        InitResponseHandler handler = new InitResponseHandler( channel.newPromise() );        Map<String,Value> metadata = singletonMap( "server", value( anyServerVersion().toString() ) );        handler.onSuccess( metadata );        Map<String,Value> params = singletonMap( "array", value( new byte[]{1, 2, 3} ) );        assertTrue( channel.writeOutbound( new Query( "RETURN 1", Values.value( params ) ) ) );        assertTrue( channel.finish() );    }
@Test(expectedExceptions = IllegalArgumentException.class)    public void testParseIntervalSetBadDateFormat2() {        IntervalsParser.parseIntervalSet("[2015-01-35, 2015-01-31]");    }
@Test    public void statesShortTest() {        DataPipe pipeToTransform = new DataPipe();        EquivalenceClassTransformer eqTransformer = new EquivalenceClassTransformer();        String[] statesShort = {                "AL", "AK", "AS", "AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "GA", "GU", "HI", "ID",                 "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MH", "MA", "MI", "FM", "MN", "MS", "MO",                 "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND", "MP", "OH", "OK", "OR", "PW", "PA",                 "PR", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "VI", "WA", "WV", "WI", "WY"};        Assert.assertTrue("Missed state short name(s)!", EquivalenceClassTransformer.STATES_SHORT.length == 59);                HashSet<String> statesShortLookUp = new HashSet<>(Arrays.asList(statesShort));        for (int i = 0; i < 500; i++) {            pipeToTransform.getDataMap().put("TEST_statesShort", "%stateShort");            eqTransformer.transform(pipeToTransform);            Assert.assertTrue("Wrong state short name(s)! Have '" + pipeToTransform.getDataMap().get("TEST_statesShort") + "',"                    + " but wait for one of '" + statesShortLookUp + "'...",                    statesShortLookUp.contains(pipeToTransform.getDataMap().get("TEST_statesShort")));        }    }
@Test	public void testValidEmailAddress() {		Assert.assertTrue(			InternetAddressUtil.isValid("miguel.pastor@liferay.com"));	}
@Test	public void testRestrictedMethodNames() throws Exception {		RestrictedLiferayObjectWrapper restrictedLiferayObjectWrapper =			new RestrictedLiferayObjectWrapper(				null, null,				new String[] {					TestLiferayMethodObject.class.getName() + "#getName"				});		TemplateModel templateModel = restrictedLiferayObjectWrapper.wrap(			new TestLiferayMethodObject("test"));		Assert.assertThat(			templateModel,			CoreMatchers.instanceOf(LiferayFreeMarkerStringModel.class));		LiferayFreeMarkerStringModel liferayFreeMarkerStringModel =			(LiferayFreeMarkerStringModel)templateModel;		_testRestrictedMethodNames(liferayFreeMarkerStringModel, "name");		_testRestrictedMethodNames(liferayFreeMarkerStringModel, "Name");		_testRestrictedMethodNames(liferayFreeMarkerStringModel, "getName");		_testRestrictedMethodNames(liferayFreeMarkerStringModel, "getname");		SimpleMethodModel simpleMethodModel =			(SimpleMethodModel)liferayFreeMarkerStringModel.get("generate");		TemplateModel resultTemplateModel =			(TemplateModel)simpleMethodModel.exec(				Collections.singletonList(new SimpleScalar("generate")));		Assert.assertEquals("test-generate", resultTemplateModel.toString());	}
@Test  public void testGetBasePrecedence() {    assertEquals(1, new OrOperator(1).getBasePrecedence());  }
@Test        public void tcGetLeftFromDelimiterNumber_2() throws XPathExpressionException        {            assertEquals("AAAACBBBB", OKW_Helper.getLeftFromDelimiterNumber("AAAACBBBBCDDDD", "C", 2));        }
@Test	public void testDoProcessing() throws Exception {		UserMessage userMessage = new UserMessage();		userMessage.setMessageId(MessageIdUtils.createMessageId());		MessageContext mc = new MessageContext();		mc.setServerSide(true);		mc.setFLOW(MessageContext.IN_FLOW);		mc.setAxisService(new AxisService("TEST"));		EbmsError ebmsError = new EbmsError();		ebmsError.setSeverity(IEbmsError.Severity.failure);		ebmsError.setErrorCode("some_error_code");		ebmsError.setRefToMessageInError(userMessage.getMessageId());		ebmsError.setMessage("some error message");		ErrorMessage errorMessage = new ErrorMessage(ebmsError);		errorMessage.setMessageId(MessageIdUtils.createMessageId());		errorMessage.setRefToMessageId(userMessage.getMessageId());		StorageManager storageManager = HolodeckB2BCore.getStorageManager();		storageManager.storeOutGoingMessageUnit(userMessage);		IErrorMessageEntity errorMessageEntity = storageManager.storeIncomingMessageUnit(errorMessage);		storageManager.setProcessingState(errorMessageEntity, ProcessingState.RECEIVED);		IMessageProcessingContext procCtx = MessageProcessingContext.getFromMessageContext(mc);		procCtx.addReceivedError(errorMessageEntity);		try {			Handler.InvocationResponse invokeResp = handler.invoke(mc);			assertEquals(Handler.InvocationResponse.CONTINUE, invokeResp);		} catch (Exception e) {			fail(e.getMessage());		}		assertEquals(ProcessingState.FAILURE,				HolodeckB2BCoreInterface.getQueryManager().getMessageUnitsWithId(userMessage.getMessageId()).iterator()						.next().getCurrentProcessingState().getState());		assertEquals(ProcessingState.READY_FOR_DELIVERY, errorMessageEntity.getCurrentProcessingState().getState());	}
@Test public void indexNoteNameUpdatedOnNoteSave() throws IOException {    //given: total 2 notebooks, 3 paragraphs    Note note1 = newNoteWithParagraph("Notebook1", "test");    Note note2 = newNoteWithParagraphs("Notebook2", "not test", "not test at all");    notebookIndex.addIndexDocs(Arrays.asList(note1, note2));    assertThat(resultForQuery("test").size()).isEqualTo(3);    //when    note1.setName("NotebookN");    note1.persist(null);    //then    assertThat(resultForQuery("Notebook1")).isEmpty();    assertThat(resultForQuery("NotebookN")).isNotEmpty();    assertThat(resultForQuery("NotebookN").size()).isEqualTo(1);  }
@Test  public void testCallModuleMethod4() throws Exception {    JSONArray args = new JSONArray();    args.add("testarg");    args.add("testcallbackId");    WXModuleManager.callModuleMethod(instance.getInstanceId(),"test1","testCallbackMethod",args);  }
@Test    void testTryAdvance() {        IntStream.range(0, SIZE).forEach(i -> assertTrue( instance.tryAdvance(DO_NOTHING), "error for:" + i));        assertFalse(instance.tryAdvance(DO_NOTHING));    }
@Test  public void testDoFilterLastApplies() throws Exception {    HttpServletRequest httpServletRequest = createMock(HttpServletRequest.class);    HttpServletResponse httpServletResponse = createMock(HttpServletResponse.class);    FilterChain filterChain = createMock(FilterChain.class);    AmbariAuthenticationFilter filter1 = createMock(AmbariAuthenticationFilter.class);    expect(filter1.shouldApply(httpServletRequest)).andReturn(false).once();    AmbariAuthenticationFilter filter2 = createMock(AmbariAuthenticationFilter.class);    expect(filter2.shouldApply(httpServletRequest)).andReturn(false).once();    AmbariAuthenticationFilter filter3 = createMock(AmbariAuthenticationFilter.class);    expect(filter3.shouldApply(httpServletRequest)).andReturn(true).once();    filter3.doFilter(httpServletRequest, httpServletResponse, filterChain);    expectLastCall().once();    replayAll();    Filter filter = new AmbariDelegatingAuthenticationFilter(Arrays.asList(filter1, filter2, filter3));    filter.doFilter(httpServletRequest, httpServletResponse, filterChain);    verifyAll();  }
@Test	public void testAutosaveWithNondefaultUser3() throws Exception {		RenderRequest renderRequest =			mockRenderRequestAutosaveWithNondefaultUser();		DDMFormInstanceSettings ddmFormInstanceSettings =			mockDDMFormInstanceSettingsAutosaveWithNondefaultUser();		when(			ddmFormInstanceSettings.autosaveEnabled()		).thenReturn(			Boolean.TRUE		);		when(			_ddmFormWebConfiguration.autosaveInterval()		).thenReturn(			0		);		DDMFormDisplayContext ddmFormDisplayContext =			createDDMFormDisplayContext(renderRequest);		Assert.assertEquals(false, ddmFormDisplayContext.isAutosaveEnabled());	}
@Test  public void testExecute__Stack_instance_noSpecifiedProps() throws Exception {    ResourceDefinition resourceDefinition = new StackResourceDefinition();    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();    mapIds.put(Resource.Type.Stack, "HDP");    //test    QueryImpl instance = new TestQuery(mapIds, resourceDefinition);    Result result = instance.execute();    TreeNode<Resource> tree = result.getResultTree();    Assert.assertEquals(1, tree.getChildren().size());    TreeNode<Resource> stackNode = tree.getChild("Stack:1");    Assert.assertEquals("Stack:1", stackNode.getName());    Assert.assertEquals(Resource.Type.Stack, stackNode.getObject().getType());    Assert.assertEquals(1, stackNode.getChildren().size());    TreeNode<Resource> versionsNode = stackNode.getChild("versions");    Assert.assertEquals(3, versionsNode.getChildren().size());  }
@Test    public void testToHexString() {        assertThat(PaintUtils.toHexString(Color.BLACK), is("#000000"));        assertThat(PaintUtils.toHexString(Color.WHITE), is("#ffffff"));    }
@Test    public void testInit() throws Exception {        columnConfigRow.init(attributeColumn, presenter);        verify(view).setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);        verify(view).addColumnLabel(attributeColumn);    }
@Test    public void testPrepareJrxmlAndReadInputParameters()                            throws ProcessletException {        List<CodeType> processedIds = new ArrayList<CodeType>();        InputStream jrxml = TestDataTableContentProviderTest.class.getResourceAsStream( "../templateWithPropsFromResourceBundle.jrxml" );        Map<String, Object> params = new HashMap<String, Object>();        List<ProcessletInput> inputs = new ArrayList<ProcessletInput>();        inputs.add( new LiteralInputImpl(                                          propertiesContentProvider.getInputDefinition( new HashMap<String, ParameterDescription>() ),                                          null, null, "de", null ) );        ProcessletInputs in = new ProcessletInputs( inputs );        propertiesContentProvider.prepareJrxmlAndReadInputParameters( jrxml, params, in, processedIds, parameters );        assertEquals( 1, processedIds.size() );        assertEquals( 4, params.size() );    }
@Test  public void testExceptionInTask() throws Exception {    //Set up mocks: db1.tb1, with tb1 returning a wrong dbname (db2)    Database db1 = Mockito.mock(Database.class);    Mockito.when(db1.getName()).thenReturn("db1");    Mockito.when(db1.getLocationUri()).thenReturn("hdfs:///db1");    Table tab1 = Mockito.mock(Table.class);    //Return a wrong db name, so that this triggers an exception    Mockito.when(tab1.getDbName()).thenReturn("db2");    Mockito.when(tab1.getTableName()).thenReturn("tab1");    IHMSHandler hmsHandler = Mockito.mock(IHMSHandler.class);    Mockito.when(hmsHandler.get_all_databases()).thenReturn(Lists        .newArrayList("db1"));    Mockito.when(hmsHandler.get_database("db1")).thenReturn(db1);    Mockito.when(hmsHandler.get_table_objects_by_name("db1",        Lists.newArrayList("tab1")))        .thenReturn(Lists.newArrayList(tab1));    Mockito.when(hmsHandler.get_all_tables("db1")).thenReturn(Lists        .newArrayList("tab1"));    Configuration conf = new Configuration();    conf.setInt(ServiceConstants.ServerConfig        .SENTRY_HDFS_SYNC_METASTORE_CACHE_MAX_PART_PER_RPC, 1);    conf.setInt(ServiceConstants.ServerConfig        .SENTRY_HDFS_SYNC_METASTORE_CACHE_MAX_TABLES_PER_RPC, 1);    conf.setInt(ServiceConstants.ServerConfig        .SENTRY_HDFS_SYNC_METASTORE_CACHE_INIT_THREADS, 1);    conf.setInt(ServiceConstants.ServerConfig            .SENTRY_HDFS_SYNC_METASTORE_CACHE_RETRY_MAX_NUM, 2);    try {      MetastoreCacheInitializer cacheInitializer = new          MetastoreCacheInitializer(hmsHandler, conf);      cacheInitializer.createInitialUpdate();      Assert.fail("Expected cacheInitializer to fail");    } catch (Exception e) {      Assert.assertTrue(e instanceof RuntimeException);    }  }
@Test  public void testSignAgentCrtInvalidHostname() throws Exception {    Injector injector = getInjector();    Configuration configuration = injector.getInstance(Configuration.class);    expect(configuration.validateAgentHostnames()).andReturn(true).once();    replayAll();    CertificateManager certificateManager = new CertificateManager();    injector.injectMembers(certificateManager);    SignCertResponse response = certificateManager.signAgentCrt("hostname; echo \"hello\" > /tmp/hello.txt;", "crtContent", "passphrase");    verifyAll();    Assert.assertEquals(SignCertResponse.ERROR_STATUS, response.getResult());    Assert.assertEquals("The agent hostname is not a valid hostname", response.getMessage());  }
@Test    void action() {        assertThat(new ExecutorTask<Void>("actionId", "action", Instant.now(), null, null, () -> null).action())                .isEqualTo("task:action");        var parentActionLog = new ActionLog(null, null);        parentActionLog.action = "parentAction";        assertThat(new ExecutorTask<Void>("actionId", "action", Instant.now(), parentActionLog, null, () -> null).action())                .isEqualTo("parentAction:action");        parentActionLog.context("root_action", "rootAction");        assertThat(new ExecutorTask<Void>("actionId", "action", Instant.now(), parentActionLog, null, () -> null).action())                .isEqualTo("rootAction:action");    }
@Test  public void testGetPreviousResource() throws Exception {    Iterable<Resource> iterable = new HashSet<Resource>();    Resource prev = new ResourceImpl(Resource.Type.Cluster);    Resource next = new ResourceImpl(Resource.Type.Cluster);    PageResponse response = new PageResponseImpl(iterable, 99, prev, next, 0);    Assert.assertEquals(prev, response.getPreviousResource());  }
@Test    void shouldNotLogRequestIfInactive() throws IOException {        when(writer.isActive()).thenReturn(false);        sendAndReceive();        verify(writer, never()).write(any(Precorrelation.class), any());    }
@Test  public void testGetSessionAttributes() throws Exception {    Map<String, Object> attributes = new HashMap<String, Object>();    attributes.put("foo", "bar");    Cluster cluster = createMock(Cluster.class);    ClustersImpl clusters =        createMockBuilder(ClustersImpl.class).addMockedMethod("findCluster", String.class).createMock();    expect(clusters.findCluster("c1")).andReturn(cluster);    expect(cluster.getSessionAttributes()).andReturn(attributes);    replay(clusters, cluster);    assertEquals(attributes, clusters.getSessionAttributes("c1"));    verify(clusters, cluster);  }
@Test public void testRunOnUiThreadWhenNotAttached() {		// Arrange:		final BaseFragment fragment = new TestFragment();		// Act + Assert:		assertThat(fragment.runOnUiThread(new Runnable() {			@Override public void run() {				// Will not run.				throw new AssertionError("Should not but run on Ui thread!");			}		}), is(false));	}
@Test  public void testValidPrivileges() throws Exception {    KafkaPrivilegeValidator kafkaPrivilegeValidator = new KafkaPrivilegeValidator();    try {      kafkaPrivilegeValidator.validate(new PrivilegeValidatorContext("host=host1->cluster=kafka-cluster->action=read"));    } catch (ConfigurationException ex) {      Assert.fail("Not expected ConfigurationException");    }    try {      kafkaPrivilegeValidator.validate(new PrivilegeValidatorContext("host=host1->topic=t1->action=read"));    } catch (ConfigurationException ex) {      Assert.fail("Not expected ConfigurationException");    }    try {      kafkaPrivilegeValidator.validate(new PrivilegeValidatorContext("host=host1->consumergroup=g1->action=read"));    } catch (ConfigurationException ex) {      Assert.fail("Not expected ConfigurationException");    }  }
@Test    public void testDeleteDirectoryWithContents() throws Exception {        final ConfigurationFileManager subject = getTestJenkinsConfiguration();        final File directory = tempDir.newFolder("directory");        new File(directory, "file").createNewFile();        subject.deleteFile(directory.getName());        assertFalse(directory.exists());    }
@Test    public void testFlushedEndOfWeek() {        CalendarUtils.endOfWeek(midJune);        assertFlushed(midJune);    }
@Test    public void testParseSingleInvokedBlacklistedMethod() {        Set<String> methods = SyntaxTools.parseShortInvokedMethods("time(x)");        Assert.assertEquals(0, methods.size());        Assert.assertFalse(methods.contains("time"));    }
@Test(expected = RuntimeException.class)  public void testCreateElementFactoryWithoutOwner() {    ElementFactory.builder().build();  }
@Test	public void testReadObjectOrdinary() throws Exception {		UnsyncByteArrayOutputStream unsyncByteArrayOutputStream =			new UnsyncByteArrayOutputStream();		unsyncByteArrayOutputStream.write(SerializationConstants.TC_OBJECT);		ObjectOutputStream objectOutputStream = new AnnotatedObjectOutputStream(			unsyncByteArrayOutputStream);		Date date = new Date(123456);		objectOutputStream.writeObject(date);		ByteBuffer byteBuffer =			unsyncByteArrayOutputStream.unsafeGetByteBuffer();		Deserializer deserializer = new Deserializer(byteBuffer);		Object object = deserializer.readObject();		Assert.assertTrue(object instanceof Date);		Assert.assertEquals(date, object);	}
@Test	public void testFacotorize() {		final int MAX_ITERATIONS = 1000000;		// Ð­Ð¼ÑÐ»ÑÑÐ¸Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ "ÑÐµÑÐ²Ð»ÐµÑÐ° Ñ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸ÐµÐ¼"		UnsafeCountingFactorizer factorizer = new UnsafeCountingFactorizer();		// Ð­Ð¼ÑÐ»ÑÑÐ¸Ñ Ð¾Ð±ÑÐ°ÑÐµÐ½Ð¸Ñ Ðº "ÑÐµÑÐ²Ð»ÐµÑÑ Ñ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸ÐµÐ¼" Ð¸Ð· 20 Ð¿Ð¾ÑÐ¾ÐºÐ¾Ð²		ExecutorService executor = Executors.newFixedThreadPool(20);		for (int i = 0; i < MAX_ITERATIONS; i++) {			Runnable worker = new FactorizerWorkerThread(factorizer);			executor.execute(worker);		}		executor.shutdown();		while (!executor.isTerminated()) {		}		// ÐÐ° Ð¼Ð¾ÐµÐ¹ Ð¼Ð°ÑÐ¸Ð½Ðµ ÑÐµÑÑ Ð³Ð°ÑÐ°Ð½ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾ Ð¿Ð°Ð´Ð°ÐµÑ Ð½Ð°ÑÐ¸Ð½Ð°Ñ Ñ Ð¼Ð¸Ð»Ð»Ð¸Ð¾Ð½Ð° Ð¸ÑÐµÑÐ°ÑÐ¸Ð¹		assertEquals(MAX_ITERATIONS, factorizer.getCount());	}
@Test    public void getSettingsView() {        SettingsView settingsViewMock = mock(SettingsView.class);        AbstractWorkbenchActivity activityMock = mock(AbstractWorkbenchActivity.class);        when(activityMock.getWidget()).thenReturn(settingsViewMock);        PlaceRequest placeRequest = abstractScenarioSimulationDocksHandlerSpy.getCurrentRightDockPlaceRequest(SettingsPresenter.IDENTIFIER);        when(placeManagerMock.getActivity(eq(placeRequest))).thenReturn(activityMock);        Optional<SettingsView> optional = abstractScenarioSimulationDocksHandlerSpy.getSettingsView(placeRequest);        assertSame(settingsViewMock, optional.get());    }
@Test    public void getGroup() throws Exception {        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();        this.mockHttpSession = loginAsAdmin();        this.mockMvc.perform(get("/srv/api/groups/2")            .session(this.mockHttpSession)            .accept(MediaType.parseMediaType("application/json")))            .andExpect(status().isOk())            .andExpect(jsonPath("$.name", is("sample")))            .andExpect(content().contentType(API_JSON_EXPECTED_ENCODING));    }
@Test  public void testPasswordPropertyAttribute() throws Exception {    ServiceInfo service = metaInfo.getService(STACK_NAME_HDP, "2.0.1", "HIVE");    List<PropertyInfo> propertyInfoList = service.getProperties();    Assert.assertNotNull(propertyInfoList);    PropertyInfo passwordProperty = null;    for (PropertyInfo propertyInfo : propertyInfoList) {      if (propertyInfo.isRequireInput()          && propertyInfo.getPropertyTypes().contains(PropertyInfo.PropertyType.PASSWORD)) {        passwordProperty = propertyInfo;      } else {        Assert.assertTrue(propertyInfo.getPropertyTypes().isEmpty());      }    }    Assert.assertNotNull(passwordProperty);    Assert.assertEquals("javax.jdo.option.ConnectionPassword", passwordProperty.getName());  }
@Test    public void unknownColumnTypeDoesNotTriggerBuilder() {        final BaseColumn column = new RowNumberCol52();        builder.generateDefinition(dtPresenter,                                   column,                                   (String definition) -> {                                       fail("RowNumberCol52 should not be handled by ActionInsertFactCol52DefinitionBuilder");                                   });    }
@Test  public void testGetHostComponentDesiredStateEntities() throws Exception {    HostEntity hostEntity = new HostEntity();    HostComponentDesiredStateEntity stateEntity = new HostComponentDesiredStateEntity();    hostEntity.setHostComponentDesiredStateEntities(new HashSet<HostComponentDesiredStateEntity>());    Collection<HostComponentDesiredStateEntity> stateEntities = hostEntity.getHostComponentDesiredStateEntities();    assertTrue(stateEntities.isEmpty());    try {      stateEntities.add(stateEntity);      fail("Expected UnsupportedOperationException");    } catch (UnsupportedOperationException e) {      // expected    }  }
@Test    public void testIsHideColumn() {        plugin.isHideColumn();        verify(editingCol).isHideColumn();    }
@Test	public void testBuildInsert() {		String[] fields = {"a", "b", "c", "d"};		InsertSQLBuilder insertSQLBuilder = new InsertSQLBuilder();		Assert.assertEquals(			"insert into Foo values (a, b, c, d);\n",			insertSQLBuilder.buildInsert("Foo", fields));	}
@Test  public void testValidateAlertValidation_incorrectSNMPversion() throws Exception {    Map<String, Object> properties = new HashMap<String, Object>();    properties.put(SNMPDispatcher.SUBJECT_OID_PROPERTY, "1");    properties.put(SNMPDispatcher.BODY_OID_PROPERTY, "2");    properties.put(SNMPDispatcher.PORT_PROPERTY, "162");    properties.put(SNMPDispatcher.TRAP_OID_PROPERTY, "1.3.6.1.6.3.1.1.5.4");    properties.put(SNMPDispatcher.SNMP_VERSION_PROPERTY, "SNMPv4");    properties.put(SNMPDispatcher.COMMUNITY_PROPERTY, "public");    NotificationDispatcher dispatcher = new SNMPDispatcher(DEFAULT_SNMP_PORT);    TargetConfigurationResult configValidationResult = dispatcher.validateTargetConfig(properties);    assertEquals(TargetConfigurationResult.Status.INVALID, configValidationResult.getStatus());  }
@Test	public void testGetKeyValuePairsFileEntryWithEmptyTiffMetadata()		throws Exception {		Mockito.when(			_fileEntry.getModel()		).thenReturn(			Mockito.mock(DLFileEntry.class)		);		Mockito.when(			_fileEntry.getFileVersion()		).thenReturn(			Mockito.mock(FileVersion.class)		);		Mockito.when(			_ddmStructureLocalService.getClassStructures(				Mockito.anyLong(), Mockito.anyLong(),				Mockito.any(OrderByComparator.class))		).thenReturn(			Collections.singletonList(Mockito.mock(DDMStructure.class))		);		Mockito.when(			_dlFileEntryMetadataLocalService.fetchFileEntryMetadata(				Mockito.anyLong(), Mockito.anyLong())		).thenReturn(			_dlFileEntryMetadata		);		Mockito.when(			_storageEngine.getDDMFormValues(Mockito.anyLong())		).thenReturn(			_ddmFormValues		);		Mockito.when(			_ddmFormValues.getDDMFormFieldValuesMap()		).thenReturn(			Collections.singletonMap(				"TIFF_IMAGE_LENGTH", Collections.emptyList())		);		Assert.assertEquals(			Collections.emptyList(),			_fileEntryMetadataOpenGraphTagsProvider.				getFileEntryMetadataOpenGraphTagKeyValuePairs(_fileEntry));	}
@Test    public void nineFM() {        final TestSubscriber<Object> observer = TestSubscriber.create();        RxComprehensions.doFlatMap(zero(1), one(true), two("result"), three("other"), four("other".length()),                five("other".length() < 5), six(Boolean.toString(false)), seven("true"), eight(Long.class),                this.<Long>nine()).subscribe(observer);        observer.awaitTerminalEvent();        observer.assertCompleted();        observer.assertNoErrors();        observer.assertValues(1, true, "result", "other", (long) "other".length(), "other".length() < 5,                Boolean.toString(false), false, Long.class);    }
@Test  public void testUpdateHiveEnvContent() throws Exception {    UpgradeCatalog220 upgradeCatalog220 = new UpgradeCatalog220(injector);    // Test first case    String testContent = "# The heap size of the jvm stared by hive shell script can be controlled via:\n" +            "\n" +            "if [ \"$SERVICE\" = \"metastore\" ]; then\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_metastore_heapsize}}\"\n" +            "else\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_heapsize}}\"\n" +            "fi\n" +            "\n" +            "export HADOOP_CLIENT_OPTS=\"-Xmx${HADOOP_HEAPSIZE}m $HADOOP_CLIENT_OPTS\"\n" +            "\n" +            "# Larger heap size may be required when running queries over large number of files or partitions.\n";    String expectedResult = "# The heap size of the jvm stared by hive shell script can be controlled via:\n" +            "\n" +            "if [ \"$SERVICE\" = \"metastore\" ]; then\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_metastore_heapsize}}\"\n" +            "else\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_heapsize}}\"\n" +            "fi\n" +            "\n" +            "export HADOOP_CLIENT_OPTS=\"$HADOOP_CLIENT_OPTS  -Xmx${HADOOP_HEAPSIZE}m\"\n" +            "\n" +            "# Larger heap size may be required when running queries over large number of files or partitions.\n";    Assert.assertEquals(expectedResult, upgradeCatalog220.updateHiveEnvContent(testContent));    // Test second case    testContent = "# The heap size of the jvm stared by hive shell script can be controlled via:\n" +            "export SERVICE=$SERVICE\n" +            "if [ \"$SERVICE\" = \"metastore\" ]; then\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_metastore_heapsize}}\"\n" +            "else\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_heapsize}}\"\n" +            "fi\n" +            "\n" +            "# Larger heap size may be required when running queries over large number of files or partitions.\n";    expectedResult = "# The heap size of the jvm stared by hive shell script can be controlled via:\n" +            "export SERVICE=$SERVICE\n" +            "if [ \"$SERVICE\" = \"metastore\" ]; then\n" +            "  export HADOOP_HEAPSIZE=\"{{hive_metastore_heapsize}}\"\n" +            "else\n" +            "  export HADOOP_HEAPSIZE={{hive_heapsize}} # Setting for HiveServer2 and Client\n" +            "fi\n" +            "\n" +            "export HADOOP_CLIENT_OPTS=\"$HADOOP_CLIENT_OPTS  -Xmx${HADOOP_HEAPSIZE}m\"\n" +            "# Larger heap size may be required when running queries over large number of files or partitions.\n";    Assert.assertEquals(expectedResult, upgradeCatalog220.updateHiveEnvContent(testContent));  }
@Test(expected = NullPointerException.class)  public void testSetFilenameGeneratorNullArg() {    udpStreamMonitor.setFilenameGenerator(null);  }
@Test(expected=SentryConfigurationException.class)  public void testConfigCannotCreateSentryStore() throws Exception {    Configuration conf = new Configuration();    conf.set(PolicyStoreConstants.SENTRY_GENERIC_POLICY_STORE,"junk");    SentryGenericPolicyProcessor.createStore(conf);  }
@SuppressWarnings("ConstantConditions")	@Test public void testSingleSharedElement() {		// Arrange:    	final FragmentRequest request = new FragmentRequest(mock(FragmentController.class), FragmentRequest.NO_ID);		final View firstElement = new View(context);		// Act + Assert:		request.sharedElement(firstElement, "first_element");		assertThat(request.singleSharedElement(), is(notNullValue()));		assertThat(request.singleSharedElement().first, is(firstElement));		assertThat(request.singleSharedElement().second, is("first_element"));		final View secondElement = new View(context);		request.sharedElement(secondElement, "second_element");		assertThat(request.singleSharedElement(), is(notNullValue()));		assertThat(request.singleSharedElement().first, is(firstElement));		assertThat(request.singleSharedElement().second, is("first_element"));	}
@Test    public void testCreateElementNoLang() {    	Description description = new Description("Some descriptive text");    	OMElement dElement = DescriptionElement.createElement(createParent(), description);    	    	assertNotNull(dElement);    	assertEquals(Q_ELEMENT_NAME, dElement.getQName());    	assertNull(description.getLanguage(), dElement.getAttributeValue(LANG_ATTR_NAME));    	assertEquals(description.getText(), dElement.getText());    }
@Test    public void addLink() {        //Link link = new LinkImpl("http://link/");        instance.addLink(null);        Assert.assertNotNull(instance.getLink());    }
@Test    public void testGetRecordsWithLimitedMaxRecord()                            throws Exception {        StoredISORecords storedIsoRecords = getStoredIsoRecords();        int maxRecords = 2;        MetadataQuery query = new MetadataQuery( null, null, null, null, 1, maxRecords );        MetadataResultSet<ISORecord> allRecords = storedIsoRecords.getRecords( query );        assertEquals( maxRecords, allRecords.getRemaining() );    }
@Test	public void testExecuteDeleteByQueryDocumentRequest() {		DeleteByQueryDocumentRequest deleteByQueryDocumentRequest =			new DeleteByQueryDocumentRequest((Query)null);		_elasticsearchDocumentRequestExecutor.executeDocumentRequest(			deleteByQueryDocumentRequest);		Mockito.verify(			_deleteByQueryDocumentRequestExecutor		).execute(			deleteByQueryDocumentRequest		);	}
@Test    public void testMoveRowsMoveUpCheckRowNumbers() throws VetoException {        modelSynchronizer.appendRow();        modelSynchronizer.appendRow();        modelSynchronizer.appendRow();        final GridRow uiRow1 = uiModel.getRow(1);        final GridRow uiRow2 = uiModel.getRow(2);        uiModel.moveRowsTo(0,                           new ArrayList<GridRow>() {{                               add(uiRow1);                               add(uiRow2);                           }});        assertEquals(1,                     uiModel.getRow(0).getCells().get(0).getValue().getValue());        assertEquals(2,                     uiModel.getRow(1).getCells().get(0).getValue().getValue());        assertEquals(3,                     uiModel.getRow(2).getCells().get(0).getValue().getValue());        assertEquals(1,                     model.getData().get(0).get(0).getNumericValue());        assertEquals(2,                     model.getData().get(1).get(0).getNumericValue());        assertEquals(3,                     model.getData().get(2).get(0).getNumericValue());    }
@Test    public void testLinkControllerListening() {        JXList table = new JXList();        table.setRolloverEnabled(true);        assertNotNull("LinkController must be listening", getLinkControllerAsPropertyChangeListener(table, RolloverProducer.CLICKED_KEY));        assertNotNull("LinkController must be listening", getLinkControllerAsPropertyChangeListener(table, RolloverProducer.ROLLOVER_KEY));        assertNotNull("execute button action must be registered", table.getActionMap().get(JXList.EXECUTE_BUTTON_ACTIONCOMMAND));        table.setRolloverEnabled(false);        assertNull("LinkController must not be listening", getLinkControllerAsPropertyChangeListener(table, RolloverProducer.CLICKED_KEY ));        assertNull("LinkController must be listening", getLinkControllerAsPropertyChangeListener(table, RolloverProducer.ROLLOVER_KEY));        assertNull("execute button action must be de-registered", table.getActionMap().get(JXList.EXECUTE_BUTTON_ACTIONCOMMAND));    }
@Test  public void testGetName() {    assertEquals("NotOperator", new NotOperator(1).getName());  }
@Test  public void testResolve_VersionAdvertised() {    List<ComponentInfo> components = createComponentInfo(2);    ComponentInfo info = components.get(0);    ComponentInfo parentInfo = components.get(1);    // Test cases where the current Component Info explicitly sets the value.    // 1. Chain of versionAdvertised is: true (parent) -> true (current) => true    parentInfo.setVersionAdvertisedField(new Boolean(true));    parentInfo.setVersionAdvertised(true);    info.setVersionAdvertisedField(new Boolean(true));    assertEquals(true, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // 2. Chain of versionAdvertised is: true (parent) -> false (current) => false    parentInfo.setVersionAdvertisedField(new Boolean(true));    parentInfo.setVersionAdvertised(true);    info.setVersionAdvertisedField(new Boolean(false));    assertEquals(false, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // 3. Chain of versionAdvertised is: false (parent) -> true (current) => true    parentInfo.setVersionAdvertisedField(new Boolean(false));    parentInfo.setVersionAdvertised(false);    info.setVersionAdvertisedField(new Boolean(true));    assertEquals(true, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // 4. Chain of versionAdvertised is: null (parent) -> true (current) => true    parentInfo.setVersionAdvertisedField(null);    parentInfo.setVersionAdvertised(false);    info.setVersionAdvertisedField(new Boolean(true));    assertEquals(true, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // Test cases where current Component Info is null so it should inherit from parent.    // 5. Chain of versionAdvertised is: true (parent) -> null (current) => true    parentInfo.setVersionAdvertisedField(new Boolean(true));    parentInfo.setVersionAdvertised(true);    info.setVersionAdvertisedField(null);    assertEquals(true, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // 6. Chain of versionAdvertised is: true (parent) -> inherit (current) => true    parentInfo.setVersionAdvertisedField(new Boolean(true));    parentInfo.setVersionAdvertised(true);    info.setVersionAdvertisedField(null);    assertEquals(true, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // 7. Chain of versionAdvertised is: false (parent) -> null (current) => false    parentInfo.setVersionAdvertisedField(new Boolean(false));    parentInfo.setVersionAdvertised(false);    info.setVersionAdvertisedField(null);    assertEquals(false, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());    // 8. Chain of versionAdvertised is: false (parent) -> inherit (current) => false    parentInfo.setVersionAdvertisedField(new Boolean(false));    parentInfo.setVersionAdvertised(false);    info.setVersionAdvertisedField(null);    assertEquals(false, resolveComponent(info, parentInfo).getModuleInfo().isVersionAdvertised());  }
@Test    public final void tc_getProperty_With_ParamatersAndDefaultValues() throws IOException    {        /*        # Properties mit Parametern        ParamaterValues.One_Param = P1: $P1$        ParamaterValues.Two_Params_1 = P1: $P1$; P2: $P2$        ParamaterValues.Two_Params_2 = P2: $P2$; P1: $P1$        */                assertEquals(  "P1: Param1", myProperties.getProperty( "ParamaterValues.One_Param", "With DefaultValue P1: %P1%", "Param1" ) );        assertEquals(  "P1: Param1; P2: Param2", myProperties.getProperty( "ParamaterValues.Two_Params_1", "With DefaultValue P1: %P1%; P2: %P2%", "Param1", "Param2" ) );        assertEquals(  "With DefaultValue P1: Param1", myProperties.getProperty( "ParamaterValues.One_Param_NotExist", "With DefaultValue P1: %P1%", "Param1" ) );        assertEquals(  "With DefaultValue P1: Param1; P2: Param2", myProperties.getProperty( "ParamaterValues.Two_Params_1_NotExist", "With DefaultValue P1: %P1%; P2: %P2%", "Param1", "Param2" ) );    }
@Test    public void testBorderOnLFChange() {        JXTitledPanel titledPanel = new JXTitledPanel();        assertTrue("sanity: titledPanels default border must be ui-installable " + titledPanel.getBorder(),                 SwingXUtilities.isUIInstallable(titledPanel.getBorder()));        LineBorder border = new LineBorder(titledPanel.getBackground());        titledPanel.setBorder(border);        assertEquals("sanity: border set", border, titledPanel.getBorder());        titledPanel.updateUI();        assertEquals("border untouched ", border, titledPanel.getBorder());    }
@Test    void testEqualityNegativeBecauseArn() {        Assertions.assertEquals(false, referenceA.equals(differentArn));        Assertions.assertEquals(false, differentArn.equals(referenceA));    }
@Test    public void testIsConditionHeaderUniqueWhenHeaderIsValid() throws Exception {        final ConditionCol52 conditionCol1 = fakeConditionCol52("header1");        final ConditionCol52 conditionCol2 = fakeConditionCol52("header2");        final Validator validator = new Validator(fakeCompositeColumn(conditionCol1,                                                                      conditionCol2));        assertTrue(validator.isConditionHeaderUnique(conditionCol2));    }
@Test    public void testDefaultState() {        assertEquals(0, itsField.getState());    }
@Test    public void shouldCreateNobtWithDefaultValues() throws Exception {        NobtFactory sut = new NobtFactory(                Optimizer::defaultOptimizer,                Clock.fixed(FIRST_OF_2017.toInstant(ZoneOffset.UTC), ZoneOffset.UTC)        );        Nobt nobt = sut.create("Test", Sets.newHashSet(thomas), EUR);        assertThat(nobt, allOf(                hasName(equalTo("Test")),                hasCurrency(equalTo(EUR)),                hasParticipants(containsInAnyOrder(thomas)),                hasId(notNullValue(NobtId.class)),                hasCreationTime(equalTo(ZonedDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).toInstant()))        ));    }
@Test(expected = IllegalArgumentException.class)  public void testEmptyPut() {    byte[] row = dataHelper.randomData("rk-");    Put emptyPut = new Put(row);    adapt(emptyPut);  }
@Test	public void testProcessDDMFormInstanceReportOnDeleteEvent()		throws Exception {		DDMFormFieldValue ddmFormFieldValue = mock(DDMFormFieldValue.class);		when(			ddmFormFieldValue.getName()		).thenReturn(			"field1"		);		when(			ddmFormFieldValue.getType()		).thenReturn(			DDMFormFieldType.RADIO		);		Value value = new LocalizedValue();		value.addString(value.getDefaultLocale(), "option1");		value.setDefaultLocale(LocaleUtil.US);		when(			ddmFormFieldValue.getValue()		).thenReturn(			value		);		JSONObject processedFieldJSONObject =			_radioDDMFormFieldTypeReportProcessor.process(				ddmFormFieldValue,				JSONUtil.put(					"type", DDMFormFieldType.RADIO				).put(					"values", JSONFactoryUtil.createJSONObject("{option1 : 1}")				),				0, DDMFormInstanceReportConstants.EVENT_DELETE_RECORD_VERSION);		JSONObject valuesJSONObject = processedFieldJSONObject.getJSONObject(			"values");		Assert.assertEquals(0, valuesJSONObject.getLong("option1"));	}
@Test  public void testGetRequestsByStatus() throws AmbariException {    List<Long> requestIds = new ArrayList<Long>();    requestIds.add(requestId + 1);    requestIds.add(requestId);    populateActionDB(db, hostName, requestId, stageId);    clusters.addHost("host2");    populateActionDB(db, hostName, requestId + 1, stageId);    List<Long> requestIdsResult =      db.getRequestsByStatus(null, BaseRequest.DEFAULT_PAGE_SIZE, false);    assertNotNull("List of request IDs is null", requestIdsResult);    assertEquals("Request IDs not matches", requestIds, requestIdsResult);  }
@Test	public void testGetDistance(){		assertEquals(2,vector.getDistance(1),0);	}
@Test    public void testExceptionOnWrongConfigurationValue() {        Response response = configurationService.getConfigurationValue("random-site", "random-key");        JSONObject jsonObject = (JSONObject) response.getEntity();        JSONArray arr = (JSONArray) jsonObject.get("configs");        Assert.assertEquals(arr.size(), 1);        JSONObject obj = (JSONObject) arr.get(0);        Assert.assertEquals(obj.get("siteName"), "random-site");        Assert.assertEquals(obj.get("configName"), "random-key");        Assert.assertEquals(obj.get("configValue"), null);    }
@Test    public void testParseNew()    {        assertEquals(JavaVersion.parse("9-ea+19"), new JavaVersion(9, 0));        assertEquals(JavaVersion.parse("9+100"), new JavaVersion(9, 0));        assertEquals(JavaVersion.parse("9.0.1+20"), new JavaVersion(9, 0));        assertEquals(JavaVersion.parse("9.1.1+20"), new JavaVersion(9, 1));    }
@Test  public void testFindByState() {    List<AlertState> allStates = new ArrayList<AlertState>();    allStates.add(AlertState.OK);    allStates.add(AlertState.WARNING);    allStates.add(AlertState.CRITICAL);    List<AlertHistoryEntity> history = m_dao.findAll(m_cluster.getClusterId(),        allStates);    assertNotNull(history);    assertEquals(50, history.size());    history = m_dao.findAll(m_cluster.getClusterId(),        Collections.singletonList(AlertState.OK));    assertNotNull(history);    assertEquals(40, history.size());    history = m_dao.findAll(m_cluster.getClusterId(),        Collections.singletonList(AlertState.CRITICAL));    assertNotNull(history);    assertEquals(10, history.size());    history = m_dao.findAll(m_cluster.getClusterId(),        Collections.singletonList(AlertState.WARNING));    assertNotNull(history);    assertEquals(0, history.size());  }
@Test    public void testGetEditingPattern() throws Exception {        final PatternWrapper patternWrapper = mock(PatternWrapper.class);        final InOrder inOrder = inOrder(plugin);        plugin.setEditingPattern(patternWrapper);        inOrder.verify(plugin).setupDefaultValues();        inOrder.verify(plugin).setPatternWrapper(patternWrapper);        verify(plugin).setupDefaultValues();        verify(plugin).fireChangeEvent(patternPage);        verify(plugin).fireChangeEvent(calculationTypePage);        verify(plugin).fireChangeEvent(fieldPage);        verify(plugin).fireChangeEvent(operatorPage);        verify(plugin).fireChangeEvent(valueOptionsPage);        verify(plugin).fireChangeEvent(additionalInfoPage);    }
@Test    public void testInsert() throws VetoException {        modelSynchronizer.appendRow();        modelSynchronizer.insertRow(0);        assertEquals(2,                     model.getData().size());        assertEquals(2,                     uiModel.getRowCount());        assertEquals(GuidedDecisionTableView.ROW_HEIGHT,                     uiModel.getRow(0).getHeight(),                     0.0);        assertEquals(GuidedDecisionTableView.ROW_HEIGHT,                     uiModel.getRow(1).getHeight(),                     0.0);    }
@Test(description = "This method tests the getDevicesOfGroup under various conditions")    public void testGetDevicesOfGroup() throws GroupManagementException {        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getGroupManagementProviderService"))                .toReturn(groupManagementProviderService);        Mockito.doReturn(1).when(groupManagementProviderService).getDeviceCount(Mockito.anyInt());        Mockito.doReturn(new ArrayList<Device>()).when(groupManagementProviderService).getDevices(1, 0, 10);        Mockito.doReturn(null).when(groupManagementProviderService).getDevices(2, 0, 10);        Mockito.doThrow(new GroupManagementException()).when(groupManagementProviderService).getDevices(3, 0, 10);        Response response = groupManagementService.getDevicesOfGroup(1, 0, 10);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode(),                "getDevicesOfGroup request failed for a request with valid parameters");        response = groupManagementService.getDevicesOfGroup(2, 0, 10);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode(),                "getDevicesOfGroup request failed for a request with valid parameters");        response = groupManagementService.getDevicesOfGroup(3, 0, 10);        Assert.assertEquals(response.getStatus(), Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(),                "getDevicesOfGroup request succeded for a request with in-valid parameters");    }
@Test    public void customerRetentionScenarioDsl() {        Trigger trigger = new Trigger(TEST_TENANT, "customer-retention-scenario", "Customer Retention Scenario");        String expression = "event:groupBy(tags.traceId):" +                "filter((category == \"Credit Check\" && text == \"Exceptionally Good\") || " +                       "(category == \"Stock Check\" && text == \"Out of Stock\")):" +                "having(count > 1, count.tags.accountId == 1)";        ExternalCondition condition = new ExternalCondition(trigger.getId(), FIRING, DATA_ID, ALERTER_ID, expression);        Expression exp = new Expression(Arrays.asList(new FullTrigger(trigger, null, Arrays.asList(condition))));        String drl = exp.getDrl();        // System.out.println(drl);        startSession(drl);        // Init t0        clock.setStartupTime(1);        long now = clock.getCurrentTime();        Event e1 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Credit Check", "Exceptionally Good");        e1.addTag("duration", "1000");        e1.addTag("traceId", "trace1");        e1.addTag("accountId", "user1");        Event e11 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Credit Check", "Exceptionally Good");        e11.addTag("duration", "1000");        e11.addTag("traceId", "trace4");        e11.addTag("accountId", "user2");        insert(e1, e11);        // t0 + 1000        now = clock.advanceTime(1000, TimeUnit.MILLISECONDS);        Event e2 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Stock Check", "Out of Stock");        e2.addTag("duration", "2000");        e2.addTag("traceId", "trace1");        e2.addTag("accountId", "user1");        Event e12 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Stock Check", "Out of Stock");        e12.addTag("duration", "2000");        e12.addTag("traceId", "trace4");        e12.addTag("accountId", "user2");        insert(e2, e12);        // t0 + 2000        now = clock.advanceTime(1000, TimeUnit.MILLISECONDS);        Event e3 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Credit Check", "Good");        e3.addTag("duration", "1500");        e3.addTag("traceId", "trace2");        e3.addTag("accountId", "user1");        Event e13 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Credit Check", "Good");        e13.addTag("duration", "1500");        e13.addTag("traceId", "trace5");        e13.addTag("accountId", "user2");        insert(e3, e13);        // t0 + 3000        now = clock.advanceTime(1000, TimeUnit.MILLISECONDS);        Event e4 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Stock Check", "Out of Stock");        e4.addTag("duration", "2000");        e4.addTag("traceId", "trace2");        e4.addTag("accountId", "user1");        Event e14 = new Event(TEST_TENANT, uuid(), now + 3, DATA_ID, "Stock Check", "Out of Stock");        e14.addTag("duration", "2000");        e14.addTag("traceId", "trace5");        e14.addTag("accountId", "user2");        insert(e4, e14);        // t0 + 4000        now = clock.advanceTime(1000, TimeUnit.MILLISECONDS);        Event e5 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Credit Check", "Exceptionally Good");        e5.addTag("duration", "1500");        e5.addTag("traceId", "trace3");        e5.addTag("accountId", "user1");        Event e15 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Credit Check", "Exceptionally Good");        e15.addTag("duration", "1500");        e15.addTag("traceId", "trace6");        e15.addTag("accountId", "user2");        insert(e5, e15);        // t0 + 5000        now = clock.advanceTime(1000, TimeUnit.MILLISECONDS);        Event e6 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Stock Check", "Available");        e6.addTag("duration", "2000");        e6.addTag("traceId", "trace3");        e6.addTag("accountId", "user1");        Event e16 = new Event(TEST_TENANT, uuid(), now, DATA_ID, "Stock Check", "Available");        e16.addTag("duration", "2000");        e16.addTag("traceId", "trace6");        e16.addTag("accountId", "user2");        insert(e6, e16);        stopSession();        Assert.assertEquals(2, results.size());        results.stream().forEach(e -> {            String traceId = e.getContext().get("traceId");            Assert.assertTrue(traceId.equals("trace1") || traceId.equals("trace4"));            /*                System.out.println("Event: ");                System.out.println(e);                System.out.println("Source events:");                extractEvents(e).stream().forEach(extracted -> {                    System.out.println(extracted);                });                System.out.println("\n");            */        });    }
@Test    public void testLambdaTaskRootNotSetDoesNotResolveLambdaContext() {        Assert.assertNull(mockResolver(null).resolve());    }
@Test    void close() {        assertDoesNotThrow(instance::close);    }
@Test    public void testGetElements() throws Exception {    	Iterator<OMElement> umElements = UserMessageElement.getElements(createXML(			"<eb3:Messaging xmlns:eb3=\"http://docs.oasis-open.org/ebxml-msg/ebms/v3.0/ns/core/200704/\">\n" + 			"    <eb3:UserMessage>\n" +			"		Normal contents of User Message would go here" +			"    </eb3:UserMessage>\n" + 			"    <eb3:UserMessage>\n" +			"		Bundled User Message (NOTE: By default this is not allowed!" +			"    </eb3:UserMessage>\n" + 			"</eb3:Messaging>"));    	    	assertFalse(Utils.isNullOrEmpty(umElements));    	assertEquals(USER_MESSAGE_ELEMENT_NAME, umElements.next().getQName());    	assertTrue(umElements.hasNext());    	assertEquals(USER_MESSAGE_ELEMENT_NAME, umElements.next().getQName());    	assertFalse(umElements.hasNext());    	    }
@Test    public void testSecondBootstrapDoesNothing() {        final StoredOrDefaultConfigurationProvider configurationProvider =            new StoredOrDefaultConfigurationProvider(StoredOrDefaultConfigurationProviderTest.setupMockStorage(null));        final ConfigurationFileManager subject = getTestJenkinsConfiguration(configurationProvider);        subject.initConfiguration();        // modify the extracted configuration        assertTrue(defaultFile.delete());        // running bootstrap again must not restore the file        subject.initConfiguration();        assertFalse(defaultFile.exists());    }
@Test(expectedExceptions = LoadException.class)  public void unparsableCsv() throws LoadException {    // GIVEN    String csv = //        CSV_COL_A + "," + CSV_COL_B + "\n" + //            "1," + Long.MAX_VALUE + "9\n";    colInfo.registerColumnType(CSV_COL_A, ColumnType.LONG);    colInfo.registerColumnType(CSV_COL_B, ColumnType.LONG);    // WHEN    csvLoader.load(0L, new BigByteBuffer(csv.getBytes()), "Test", colInfo);    // THEN: exception  }
@Test    void exactMatch() throws Exception {        assertTrue(SearchPattern.wildcardMatch("6543210", "6543210"));    }
@Test public void testObtainFragmentHandler() {		// Act:		final FragmentAnnotationHandler handler = BaseAnnotationHandlers.obtainFragmentHandler(TestFragment.class);		// Assert:		assertThat(handler, is(notNullValue()));		assertThat(handler, instanceOf(BaseAnnotationHandlers.FragmentHandler.class));	}
@Test    void packageNameNone() {        assertEquals(Optional.empty(), Formatting.packageName(A));    }
@Test  public void testResolve_Cardinality() {    String cardinality = "foo";    ComponentInfo info = new ComponentInfo();    // parent is null, child cardinality is null    assertEquals("0+", resolveComponent(info, null).getModuleInfo().getCardinality());    ComponentInfo parentInfo = new ComponentInfo();    info = new ComponentInfo();    // parent has value set, child value is null    parentInfo.setCardinality(cardinality);    assertEquals("foo", resolveComponent(info, parentInfo).getModuleInfo().getCardinality());    // child has value set, parent value is null    info.setCardinality(cardinality);    parentInfo.setCardinality(null);    assertEquals(cardinality, resolveComponent(info, parentInfo).getModuleInfo().getCardinality());    // value set in both parent and child; child overwrites    String cardinality2 = "foo2";    info.setCardinality(cardinality2);    parentInfo.setCardinality(cardinality);    assertEquals(cardinality2, resolveComponent(info, parentInfo).getModuleInfo().getCardinality());  }
@Test  public void testGenerateNoContext() throws Exception {    MicroPlatform microPlatform = MicroPlatformFactory.create();    try {      microPlatform.start();      ClassicEngineBoot.getInstance().start();      PentahoSystem.setApplicationContext( null );      assertEquals( -1, emailOutput.generate( new MasterReport(), 1, new ByteArrayOutputStream(), 1 ) );    } finally {      microPlatform.stop();      microPlatform = null;    }  }
@Test    public void testFromUndefinedToUndefined() {        Element params = new Element("request");        boolean ret = (boolean) ReflectionUtils.invokeMethod(setSafeBoundaries, xs, params);        assertTrue("expected modified passed params", ret);        assertTrue(params.getChild("from").getText().equals("1"));        assertTrue(params.getChild("to").getText().equals(Integer.toString(xs.getMaxRecordValue())));    }
@Test    public void getKeyValueContainer() {        elementViewListLocal.clear();        LIElement keyValueContainer = elementPresenter.getKeyValueContainer(TEST_ITEM_ID, TEST_KEY_PROPERTY_MAP, TEST_VALUE_PROPERTYY_MAP);        verify(elementView1Mock, times(1)).init(elementPresenter);        verify(elementView1Mock, times(1)).setItemId(TEST_ITEM_ID);        verify(elementView1Mock, times(1)).getKeyContainer();        verify(keyContainerMock, times(1)).appendChild(propertyFieldsMock);        verify(elementView1Mock, times(1)).getValueContainer();        verify(valueContainerMock, times(1)).appendChild(propertyFieldsMock);        assertNotNull(keyValueContainer);        assertTrue(elementViewListLocal.contains(elementView1Mock));    }
@Test    public void testGenerationOfLogReference() throws IOException {        List<Path> pathList = new ArrayList<>();        pathList.add(Paths.get("/"));        Mockito.doReturn(pathList).when(fakeFs).getRootDirectories();        List<String> groupList = new ArrayList<>();        groupList.add("test_group");        BDDMockito.given(JsonUtils.getMatchingListFromJsonArrayNode(Mockito.any(), Mockito.any())).willReturn(groupList);        Set<AWSLogReference> logReferences = ec2Plugin.getLogReferences();        assertThat(logReferences).hasOnlyOneElementSatisfying(            reference -> assertThat(reference.getLogGroup()).isEqualTo("test_group"));    }
@Test  public void testGetViewerSessionId() throws Exception {    assertNull( sra.getViewerSessionId() );    Map<String, Object> inputs = new HashMap<String, Object>() {      {        put( "::session", 1 );      }    };    sra.setVarArgs( inputs );    assertNull( sra.getViewerSessionId() );    inputs = new HashMap<String, Object>() {      {        put( "::session", "1" );      }    };    sra.setVarArgs( inputs );    assertEquals( "1", sra.getViewerSessionId() );  }
@Test    public void test_V110_EXAMPLE_2()                            throws Exception {        URL exampleURL = this.getClass().getResource( V110_EXAMPLE_2 );        Map<String, String> kvpMap = KVPUtils.readFileIntoMap( exampleURL );        GetFeature getFeature = GetFeatureKVPAdapter.parse( kvpMap, null );        List<Query> queries = getFeature.getQueries();        assertEquals( ( (PropertyName) ( (FilterQuery) queries.get( 0 ) ).getProjectionClauses()[0] ).getPropertyName().getAsText(),                      "InWaterA_1M/wkbGeom" );        assertEquals( ( (PropertyName) ( (FilterQuery) queries.get( 0 ) ).getProjectionClauses()[1] ).getPropertyName().getAsText(),                      "InWaterA_1M/tileId" );        assertEquals( ( (FilterQuery) queries.get( 0 ) ).getTypeNames()[0].getFeatureTypeName(),                      new QName( "InWaterA_1M" ) );    }
@Test    public void syncDmoSession() {        settingsPresenterSpy.syncDmoSession();        verify(settingsSpy, times(1)).setDmoSession(eq(DMO_SESSION));    }
@Test    public void testParseBigInteger() {        BigInteger[] a1 = ArraysParser                .parseArray(BigInteger[].class, "[123456789123456789123456789, -123456789123456789123456789]");        Assert.assertEquals(new BigInteger[] { new BigInteger("123456789123456789123456789"), new BigInteger(                "-123456789123456789123456789") }, a1);    }
@Test    void get0Test() {        assertEquals(0, (int) instance.get0());    }
@Test    public void testPushStore() {        int[] n = {100, 1000, 10000, 100000};        for (int nodes : n) {            NanoBench.create().measurements(10).measure("push node store " + nodes, new NodeStoreBenchmark().pushStore(nodes));        }    }
@Test	public void testOr() {		SafeLdapFilter safeLdapFilter = SafeLdapFilterConstraints.eq(			"key1", "value1");		test(			safeLdapFilter.or(SafeLdapFilterConstraints.eq("key2", "value2")),			"(|(key1={0})(key2={1}))", new Object[] {"value1", "value2"});	}
@Test (expected = IllegalStateException.class)    public void testEditorObjectColumn() {        cellEditor.getTableCellEditorComponent(table, null, false, 0, OBJECT_COLUMN);    }
@Test  public void testDeleteOrigin() throws Exception {    UUID id = UUID.randomUUID();    when(getTiService().deleteOrigin(any(), isA(DeleteOriginRequest.class))).then(i -> {      assertEquals(id, i.<DeleteOriginRequest>getArgument(1).getId());      return Origin.builder().setId(id).build();    });    Response response = target(String.format("/v1/origin/uuid/%s", id)).request().delete();    assertEquals(200, response.getStatus());    assertEquals(id.toString(), getPayload(response).get("id").textValue());    verify(getTiService(), times(1)).deleteOrigin(notNull(), isA(DeleteOriginRequest.class));  }
@Test  public void testGetOvalIfInnerCornerExist() throws Exception {    RectF topLeft = createBorderCorner(TOP_LEFT, 100, 10, 50, borderBox)        .getOvalIfInnerCornerExist();    assertThat(topLeft, is(new RectF(5, 25, 195, 175)));    RectF topRight = createBorderCorner(TOP_RIGHT, 100, 10, 50, borderBox)        .getOvalIfInnerCornerExist();    assertThat(topRight, is(new RectF(225, 5, 375, 195)));    RectF bottomRight = createBorderCorner(BOTTOM_RIGHT, 100, 10, 50, borderBox)        .getOvalIfInnerCornerExist();    assertThat(bottomRight, is(new RectF(205, 225, 395, 375)));    RectF bottomLeft = createBorderCorner(BOTTOM_LEFT, 100, 10, 50, borderBox)        .getOvalIfInnerCornerExist();    assertThat(bottomLeft, is(new RectF(25, 205, 175, 395)));  }
@Test	public void testIsBreached() {		LocalDateTime nowLocalDateTime = _createLocalDateTime();		_assertIsBreached(			false,			_createDocument(				HashMapBuilder.<String, Object>put(					"createDate", _format(nowLocalDateTime)				).build()),			nowLocalDateTime, nowLocalDateTime.plusHours(1));		_assertIsBreached(			false,			_createDocument(				HashMapBuilder.<String, Object>put(					"createDate", _format(nowLocalDateTime.minusHours(1))				).build()),			nowLocalDateTime, nowLocalDateTime.minusHours(2));		_assertIsBreached(			false,			_createDocument(				HashMapBuilder.<String, Object>put(					"completionDate", _format(nowLocalDateTime.minusHours(1))				).put(					"createDate", _format(nowLocalDateTime.minusHours(2))				).build()),			nowLocalDateTime, nowLocalDateTime.minusHours(1));		_assertIsBreached(			true,			_createDocument(				HashMapBuilder.<String, Object>put(					"createDate", _format(nowLocalDateTime.minusHours(2))				).build()),			nowLocalDateTime, nowLocalDateTime.minusHours(1));		_assertIsBreached(			true,			_createDocument(				HashMapBuilder.<String, Object>put(					"completionDate", _format(nowLocalDateTime)				).put(					"createDate", _format(nowLocalDateTime.minusHours(2))				).build()),			nowLocalDateTime, nowLocalDateTime.minusHours(1));	}
@Test    void getSubSelectAlias() {        assertNotNull(instance.getSubSelectAlias());    }
@Test    void get4Test() {        assertEquals(4, (int) instance.get4().orElseThrow(NoSuchElementException::new));    }
@Test    public void onSelectBookmark() throws Exception {        presenter.onRefresh();        presenter.onSelectBookmark(0);        verify(view).startBookmarkAction(eq(bookmarksWithoutTag.get(0).name));    }
@SuppressWarnings("unchecked")    @Test    public void testParse()                            throws Exception {        GetMapParser getMapXMLAdapter = new GetMapParser();        XMLStreamReader xmlStreamReader = createXmlStreamReader( "wms-1.3.0-GetMap.xml" );        GetMap getMap = getMapXMLAdapter.parse( xmlStreamReader );        LinkedList<LayerRef> layers = getMap.getLayers();        assertThat( layers.size(), is( 3 ) );        assertThat( layers, hasLayerRef( "municipalities" ) );        assertThat( layers, hasLayerRef( "counties" ) );        assertThat( layers, hasLayerRef( "zipcodes" ) );        LinkedList<StyleRef> styles = getMap.getStyles();        assertThat( styles.size(), is( 3 ) );        assertThat( styles, hasStyleRef( "Municipalities" ) );        assertThat( styles, hasStyleRef( "CountyBoundary" ) );        assertThat( styles, hasStyleRef( "default" ) );        assertThat( getMap.getWidth(), is( 1024 ) );        assertThat( getMap.getHeight(), is( 512 ) );        assertThat( getMap.getFormat(), is( "image/png" ) );        assertThat( getMap.getTransparent(), is( true ) );        assertThat( getMap.getBgColor(), is( BLACK ) );        assertThat( getMap.getCoordinateSystem(), is( CRSManager.lookup( "EPSG:4326" ) ) );        Envelope boundingBox = getMap.getBoundingBox();        assertThat( boundingBox.getMin().get0(), is( -115.4 ) );        assertThat( boundingBox.getMin().get1(), is( 35.0 ) );        assertThat( boundingBox.getMax().get0(), is( -108.0 ) );        assertThat( boundingBox.getMax().get1(), is( 44.0 ) );        Map<String, String> parameterMap = getMap.getParameterMap();        assertThat( parameterMap.size(), is( 1 ) );        assertThat( parameterMap.get( "EXCEPTIONS" ), is( "INIMAGE" ) );        HashMap<String, List<?>> dimensions = getMap.getDimensions();        assertThat( dimensions.size(), is( 2 ) );        assertThat( ( (List<DateTime>) dimensions.get( "time" ) ).size(), is( 1 ) );        assertThat( ( (List<DateTime>) dimensions.get( "time" ) ).get( 0 ).getDate(), is( expectedDateTime() ) );        assertThat( ( (List<Double>) dimensions.get( "elevation" ) ).size(), is( 1 ) );        assertThat( ( (List<Double>) dimensions.get( "elevation" ) ).get( 0 ), is( 5d ) );    }
@Test  public void testFailWhenServiceWithOutdatedServiceCheckExistsRepeated() throws AmbariException {    ServiceComponent serviceComponent = mock(ServiceComponent.class);    when(serviceComponent.isVersionAdvertised()).thenReturn(true);    when(service.getMaintenanceState()).thenReturn(MaintenanceState.OFF);    when(service.getServiceComponents()).thenReturn(ImmutableMap.of(SERVICE_COMPONENT_NAME, serviceComponent));    ServiceConfigEntity serviceConfigEntity = new ServiceConfigEntity();    serviceConfigEntity.setServiceName(SERVICE_NAME);    serviceConfigEntity.setCreateTimestamp(CONFIG_CREATE_TIMESTAMP);    HostRoleCommandEntity hostRoleCommandEntity1 = new HostRoleCommandEntity();    hostRoleCommandEntity1.setRoleCommand(RoleCommand.SERVICE_CHECK);    hostRoleCommandEntity1.setCommandDetail(COMMAND_DETAIL);    hostRoleCommandEntity1.setStartTime(SERVICE_CHECK_START_TIME);    hostRoleCommandEntity1.setRole(Role.HDFS_SERVICE_CHECK);    HostRoleCommandEntity hostRoleCommandEntity2 = new HostRoleCommandEntity();    hostRoleCommandEntity2.setRoleCommand(RoleCommand.SERVICE_CHECK);    hostRoleCommandEntity2.setCommandDetail(COMMAND_DETAIL);    hostRoleCommandEntity2.setStartTime(CONFIG_CREATE_TIMESTAMP - 1L);    hostRoleCommandEntity2.setRole(Role.HDFS_SERVICE_CHECK);    when(serviceConfigDAO.getLastServiceConfig(eq(CLUSTER_ID), eq(SERVICE_NAME))).thenReturn(serviceConfigEntity);    when(hostRoleCommandDAO.findAll(any(Request.class), any(Predicate.class))).thenReturn(Arrays.asList(hostRoleCommandEntity1, hostRoleCommandEntity2));    PrerequisiteCheck check = new PrerequisiteCheck(null, CLUSTER_NAME);    serviceCheckValidityCheck.perform(check, new PrereqCheckRequest(CLUSTER_NAME));    Assert.assertEquals(PrereqCheckStatus.FAIL, check.getStatus());  }
@Test    void ifelse() {        assertEquals(A, Formatting.ifelse(Optional.of(A), s -> s, B));        assertEquals(B, Formatting.ifelse(Optional.empty(), s -> s, B));    }
@Test    public void testWrongScheme()    {        try {            new AdminServerCredentialVerifier(ADMIN_SERVER_CONFIG, HTTP_SERVER_CONFIG)                    .authenticate(SECURITY_CONTEXT_DENY, "Digest " + Base64.getEncoder().encodeToString("foo:bar".getBytes(UTF_8)));            fail("Expected WebApplicationException");        }        catch (WebApplicationException e) {            assertEquals(e.getResponse().getStatus(), 401);        }    }
@Test    public void testSave() throws Exception {        final User user = createUser();        final User user2 = createUser();        action.setUser(user);        // set mock response so setting cookies doesn't fail        ServletActionContext.setResponse(new MockHttpServletResponse());        // start SMTP Server        final Wiser wiser = startWiser(getSmtpPort());        assertNull(action.getUser().getId());        assertEquals("success", action.save());        assertFalse(action.hasActionErrors());        assertNotNull(action.getUser().getId());        // verify an account information e-mail was sent        wiser.stop();        assertTrue(wiser.getMessages().size() == 1);        // verify that success messages are in the session        assertNotNull(action.getSession().getAttribute(Constants.REGISTERED));        // try it again with same user        action.setUser(user2);        assertEquals(Action.INPUT, action.save());        assertTrue(action.hasActionErrors());        SecurityContextHolder.getContext().setAuthentication(null);    }
@Test    void shouldThrowWhenConnectionIdIsNull()    {        ChannelPromise channelPromise = channel.newPromise();        HelloResponseHandler handler = new HelloResponseHandler( channelPromise, BoltProtocolV3.VERSION );        Map<String,Value> metadata = metadata( anyServerVersion(), Values.NULL );        assertThrows( IllegalStateException.class, () -> handler.onSuccess( metadata ) );        assertFalse( channelPromise.isSuccess() ); // initialization failed        assertTrue( channel.closeFuture().isDone() ); // channel was closed    }
@Test	public void testSupportedConnectorTopologies() {		Set<ConnectorTopology> topologySet =			_tLiferayConnectionDefinition.getSupportedConnectorTopologies();		Assert.assertThat(			topologySet, CoreMatchers.hasItems(ConnectorTopology.NONE));	}
@Test    public void testGetActive_roomToTV() throws Exception {        DateTimeFormatter dtf = DateTimeUtils.PARAMETER_WITH_DAY_DTF.withZone(dtZone);        String startTimeStr = dtf.print(mentionTime.minusDays(1));        String endTimeStr = dtf.print(mentionTime.plusDays(1));        Map<String, Double> scores = underTest.getActive(startTimeStr, endTimeStr,                                                         DimensionType.ROOM.toString(),                                                         ActiveMethod.ToTV.toString(), "10",                                                         "true");        assertFalse(scores.isEmpty());    }
@Test  public void simpleSignAndValidatePlainKey() {    synchronized (TestTicketRsaKeyFileProvider.class) {      TestTicketRsaKeyFileProvider.clean();      TestTicketRsaKeyFileProvider.files.add(PRIVATE_PLAIN);      TestTicketRsaKeyFileProvider.isFilesWithPrivateKeyAreRequired = true;      startNewContext();      // GIVEN      Ticket t = new Ticket();      t.setClaim(new TicketClaim());      t.getClaim().setTicketId(RUuidUtil.toRUuid(UUID.randomUUID()));      t.getClaim().setUsername("abc");      t.getClaim().setValidUntil(123);      t.getClaim().setIsSuperUser(false);      // WHEN      ticketSignatureService.signTicket(t);      boolean isValid = isValid(t);      // THEN      Assert.assertTrue(isValid, "Ticket should be valid.");    }  }
@Test	public void testDailyEveryTwoDaysRecurrence() {		ActionRequest actionRequest = Mockito.mock(ActionRequest.class);		whenActionRequestGetParameter(actionRequest, "dailyInterval", "2");		String actualCronText = _addSchedulerMVCActionCommand.getCronText(			actionRequest, calendarOf(2017, 1, 1, 7, 0), true,			Recurrence.DAILY);		Assert.assertEquals("0 0 7 1/2 * ? *", actualCronText);	}
@Test	public void testMarkSupported() {		UnsyncByteArrayInputStream unsyncByteArrayInputStream =			new UnsyncByteArrayInputStream(_BUFFER);		Assert.assertTrue(unsyncByteArrayInputStream.markSupported());	}
@Test    public void getLowAddrTest() {        NeutronSubnet objectUT = new NeutronSubnet();        objectUT.setIpVersion(4);        objectUT.setCidr("10.18.0.0/24");        NeutronSubnetIpAllocationPool allocationPool = new NeutronSubnetIpAllocationPool();        allocationPool.setPoolStart("10.18.0.2");        allocationPool.setPoolEnd("10.18.0.6");        List<NeutronSubnetIpAllocationPool> pools = new ArrayList<>();        pools.add(allocationPool);        allocationPool = new NeutronSubnetIpAllocationPool();        allocationPool.setPoolStart("10.18.0.10");        allocationPool.setPoolEnd("10.18.0.15");        objectUT.setAllocationPools(pools);        Assert.assertEquals("getLowAddr Test 1: test of returned address", "10.18.0.2", objectUT.getLowAddr());        objectUT.setIpVersion(6);        objectUT.setCidr("2015::0/24");        allocationPool = new NeutronSubnetIpAllocationPool();        allocationPool.setPoolStart("2015::2");        allocationPool.setPoolEnd("2015::6");        pools = new ArrayList<>();        pools.add(allocationPool);        allocationPool = new NeutronSubnetIpAllocationPool();        allocationPool.setPoolStart("2015::10");        allocationPool.setPoolEnd("2015::15");        objectUT.setAllocationPools(pools);        Assert.assertEquals("getLowAddr v6 Test 1: test of returned address", "2015::2", objectUT.getLowAddr());    }
@Test  public void testGet() {    InterpreterResult res = interpreter.interpret("get /logs/http/unknown", null);    assertEquals(Code.ERROR, res.code());    res = interpreter.interpret("get /logs/http/10", null);    assertEquals(Code.SUCCESS, res.code());  }
@Test(description = "This test case tests handling ProfileManagerDAOException when retrieving all profiles of a " +            "device type",          dependsOnMethods = "testGetProfilesOfDeviceType")    public void testGetProfilesOfDeviceTypeThrowingProfileManagerDAOException() throws Exception {        ProfileDAO profileDAO = mock(ProfileDAOImpl.class);        when(profileDAO.getProfilesOfDeviceType(anyString())).thenThrow(new ProfileManagerDAOException());        testThrowingException(profileManager, profile1, p -> profileManager.getProfilesOfDeviceType(DEVICE_TYPE_C),                              "profileDAO",                              profileDAO,                              ProfileManagerDAOException.class);    }
@Test  public void testExecuteDDLUpdates() throws SQLException, AmbariException, ClassNotFoundException {    Capture<DBAccessor.DBColumnInfo> capturedSortOrderColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedPermissionIDColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedScColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedScDesiredVersionColumnInfo = newCapture();    final DBAccessor dbAccessor = createStrictMock(DBAccessor.class);    Configuration configuration = createNiceMock(Configuration.class);    Connection connection = createNiceMock(Connection.class);    Statement statement = createNiceMock(Statement.class);    ResultSet resultSet = createNiceMock(ResultSet.class);    Capture<List<DBAccessor.DBColumnInfo>> capturedExtensionColumns = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> capturedExtensionLinkColumns = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> capturedSettingColumns = EasyMock.newCapture();    dbAccessor.addColumn(eq("adminpermission"), capture(capturedSortOrderColumnInfo));    dbAccessor.addColumn(eq("adminpermission"), capture(capturedPermissionIDColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.SERVICE_COMPONENT_DESIRED_STATE_TABLE), capture(capturedScColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.SERVICE_COMPONENT_DESIRED_STATE_TABLE),        capture(capturedScDesiredVersionColumnInfo));    dbAccessor.createTable(eq("extension"), capture(capturedExtensionColumns), eq("extension_id"));    dbAccessor.addUniqueConstraint("extension", "UQ_extension", "extension_name", "extension_version");    expect(dbAccessor.getConnection()).andReturn(connection);    dbAccessor.createTable(eq("extensionlink"), capture(capturedExtensionLinkColumns), eq("link_id"));    dbAccessor.addUniqueConstraint("extensionlink", "UQ_extension_link", "stack_id", "extension_id");    dbAccessor.addFKConstraint("extensionlink", "FK_extensionlink_extension_id", "extension_id", "extension",                               "extension_id", false);    dbAccessor.addFKConstraint("extensionlink", "FK_extensionlink_stack_id", "stack_id", "stack",                               "stack_id", false);    expect(dbAccessor.getConnection()).andReturn(connection);    dbAccessor.createTable(eq("setting"), capture(capturedSettingColumns), eq("id"));    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet);    Capture<DBAccessor.DBColumnInfo> repoVersionRepoTypeColumnCapture = newCapture();    Capture<DBAccessor.DBColumnInfo> repoVersionUrlColumnCapture = newCapture();    Capture<DBAccessor.DBColumnInfo> repoVersionXmlColumnCapture = newCapture();    Capture<DBAccessor.DBColumnInfo> repoVersionXsdColumnCapture = newCapture();    Capture<DBAccessor.DBColumnInfo> repoVersionParentIdColumnCapture = newCapture();    dbAccessor.addColumn(eq("repo_version"), capture(repoVersionRepoTypeColumnCapture));    dbAccessor.addColumn(eq("repo_version"), capture(repoVersionUrlColumnCapture));    dbAccessor.addColumn(eq("repo_version"), capture(repoVersionXmlColumnCapture));    dbAccessor.addColumn(eq("repo_version"), capture(repoVersionXsdColumnCapture));    dbAccessor.addColumn(eq("repo_version"), capture(repoVersionParentIdColumnCapture));    // skip all of the drama of the servicecomponentdesiredstate table for now    expect(dbAccessor.tableHasPrimaryKey("servicecomponentdesiredstate", "id")).andReturn(true);    Capture<List<DBAccessor.DBColumnInfo>> capturedHistoryColumns = EasyMock.newCapture();    dbAccessor.createTable(eq("servicecomponent_history"), capture(capturedHistoryColumns),            eq((String[]) null));    dbAccessor.addPKConstraint("servicecomponent_history", "PK_sc_history", "id");    dbAccessor.addFKConstraint("servicecomponent_history", "FK_sc_history_component_id",        "component_id", "servicecomponentdesiredstate", "id", false);    dbAccessor.addFKConstraint("servicecomponent_history", "FK_sc_history_upgrade_id", "upgrade_id",        "upgrade", "upgrade_id", false);    dbAccessor.addFKConstraint("servicecomponent_history", "FK_sc_history_from_stack_id",            "from_stack_id", "stack", "stack_id", false);    dbAccessor.addFKConstraint("servicecomponent_history", "FK_sc_history_to_stack_id",            "to_stack_id", "stack", "stack_id", false);    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet);    Capture<DBAccessor.DBColumnInfo> capturedClusterUpgradeColumnInfo = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.CLUSTER_TABLE), capture(capturedClusterUpgradeColumnInfo));    dbAccessor.addFKConstraint(UpgradeCatalog240.CLUSTER_TABLE, "FK_clusters_upgrade_id",            UpgradeCatalog240.CLUSTER_UPGRADE_ID_COLUMN, UpgradeCatalog240.UPGRADE_TABLE, "upgrade_id", false);    Capture<DBAccessor.DBColumnInfo> capturedHelpURLColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedRepeatToleranceColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedRepeatToleranceEnabledColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedOccurrencesColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedFirmnessColumnInfo = newCapture();    Capture<DBAccessor.DBColumnInfo> capturedTargetEnabledColumnInfo = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.ALERT_DEFINITION_TABLE), capture(capturedHelpURLColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.ALERT_DEFINITION_TABLE), capture(capturedRepeatToleranceColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.ALERT_DEFINITION_TABLE), capture(capturedRepeatToleranceEnabledColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.ALERT_CURRENT_TABLE), capture(capturedOccurrencesColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.ALERT_CURRENT_TABLE), capture(capturedFirmnessColumnInfo));    dbAccessor.addColumn(eq(UpgradeCatalog240.ALERT_TARGET_TABLE), capture(capturedTargetEnabledColumnInfo));    // Test creation of blueprint_setting table    Capture<List<DBAccessor.DBColumnInfo>> capturedBlueprintSettingColumns = EasyMock.newCapture();    dbAccessor.createTable(eq(UpgradeCatalog240.BLUEPRINT_SETTING_TABLE), capture(capturedBlueprintSettingColumns));    dbAccessor.addPKConstraint(UpgradeCatalog240.BLUEPRINT_SETTING_TABLE, "PK_blueprint_setting", UpgradeCatalog240.ID);    dbAccessor.addUniqueConstraint(UpgradeCatalog240.BLUEPRINT_SETTING_TABLE, "UQ_blueprint_setting_name",            UpgradeCatalog240.BLUEPRINT_NAME_COL, UpgradeCatalog240.SETTING_NAME_COL);    dbAccessor.addFKConstraint(UpgradeCatalog240.BLUEPRINT_SETTING_TABLE, "FK_blueprint_setting_name",            UpgradeCatalog240.BLUEPRINT_NAME_COL, UpgradeCatalog240.BLUEPRINT_TABLE,            UpgradeCatalog240.BLUEPRINT_NAME_COL, false);    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    expect(statement.executeQuery(anyObject(String.class))).andReturn(resultSet);    // Test host_role_command adds a column called original_start_time    Capture<DBAccessor.DBColumnInfo> hostRoleCommandOriginalStartTimeColumnInfo = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.HOST_ROLE_COMMAND_TABLE), capture(hostRoleCommandOriginalStartTimeColumnInfo));    Capture<List<DBAccessor.DBColumnInfo>> capturedViewUrlColums = EasyMock.newCapture();    dbAccessor.createTable(eq(UpgradeCatalog240.VIEWURL_TABLE), capture(capturedViewUrlColums),eq("url_id"));    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    Capture<DBAccessor.DBColumnInfo> viewInstanceShortUrlInfo = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.VIEWINSTANCE_TABLE), capture(viewInstanceShortUrlInfo));    dbAccessor.addFKConstraint(UpgradeCatalog240.VIEWINSTANCE_TABLE, "FK_instance_url_id",            UpgradeCatalog240.SHORT_URL_COLUMN, UpgradeCatalog240.VIEWURL_TABLE, "url_id", false);    Capture<DBAccessor.DBColumnInfo> viewInstanceClusterType = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.VIEWINSTANCE_TABLE), capture(viewInstanceClusterType));    // Test remote Cluster Tables    Capture<List<DBAccessor.DBColumnInfo>> capturedRemoteAmbariClusterColumns = EasyMock.newCapture();    dbAccessor.createTable(eq(UpgradeCatalog240.REMOTE_AMBARI_CLUSTER_TABLE), capture(capturedRemoteAmbariClusterColumns),anyString());    dbAccessor.addUniqueConstraint(UpgradeCatalog240.REMOTE_AMBARI_CLUSTER_TABLE , "UQ_remote_ambari_cluster" , UpgradeCatalog240.CLUSTER_NAME);    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    Capture<List<DBAccessor.DBColumnInfo>> capturedRemoteClusterServiceColumns = EasyMock.newCapture();    dbAccessor.createTable(eq(UpgradeCatalog240.REMOTE_AMBARI_CLUSTER_SERVICE_TABLE), capture(capturedRemoteClusterServiceColumns),anyString());    dbAccessor.addFKConstraint(UpgradeCatalog240.REMOTE_AMBARI_CLUSTER_SERVICE_TABLE, "FK_remote_ambari_cluster_id",      UpgradeCatalog240.CLUSTER_ID, UpgradeCatalog240.REMOTE_AMBARI_CLUSTER_TABLE, UpgradeCatalog240.CLUSTER_ID, false);    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    // Test viewInstance update    expect(dbAccessor.getColumnClass(UpgradeCatalog240.VIEWINSTANCE_TABLE, UpgradeCatalog240.CLUSTER_HANDLE_COLUMN)).andReturn(String.class);    dbAccessor.addColumn(eq(UpgradeCatalog240.VIEWINSTANCE_TABLE), anyObject(DBAccessor.DBColumnInfo.class));    expect(dbAccessor.getConnection()).andReturn(connection);    expect(connection.createStatement()).andReturn(statement);    dbAccessor.dropColumn(UpgradeCatalog240.VIEWINSTANCE_TABLE, UpgradeCatalog240.CLUSTER_HANDLE_COLUMN);    Capture<DBAccessor.DBColumnInfo> capturedClusterHandleColumn = EasyMock.newCapture();    dbAccessor.renameColumn(eq(UpgradeCatalog240.VIEWINSTANCE_TABLE), anyString(), capture(capturedClusterHandleColumn));    Capture<DBAccessor.DBColumnInfo> requestScheduleUserIdInfo = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.REQUESTSCHEDULE_TABLE), capture(requestScheduleUserIdInfo));    Capture<DBAccessor.DBColumnInfo> provisionActionColumnInfo = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog240.TOPOLOGY_REQUEST_TABLE), capture(provisionActionColumnInfo));    replay(dbAccessor, configuration, connection, statement, resultSet);    Module module = new Module() {      @Override      public void configure(Binder binder) {        binder.bind(DBAccessor.class).toInstance(dbAccessor);        binder.bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class));        binder.bind(EntityManager.class).toInstance(entityManager);        binder.bind(PasswordEncoder.class).toInstance(createNiceMock(PasswordEncoder.class));        binder.bind(HookContextFactory.class).toInstance(createMock(HookContextFactory.class));        binder.bind(HookService.class).toInstance(createMock(HookService.class));      }      };    Injector injector = Guice.createInjector(module);    UpgradeCatalog240 upgradeCatalog240 = injector.getInstance(UpgradeCatalog240.class);    upgradeCatalog240.executeDDLUpdates();    DBAccessor.DBColumnInfo columnSortOrderInfo = capturedSortOrderColumnInfo.getValue();    Assert.assertNotNull(columnSortOrderInfo);    Assert.assertEquals(UpgradeCatalog240.SORT_ORDER_COL, columnSortOrderInfo.getName());    Assert.assertEquals(null, columnSortOrderInfo.getLength());    Assert.assertEquals(Short.class, columnSortOrderInfo.getType());    Assert.assertEquals(1, columnSortOrderInfo.getDefaultValue());    Assert.assertEquals(false, columnSortOrderInfo.isNullable());    DBAccessor.DBColumnInfo columnPrincipalIDInfo = capturedPermissionIDColumnInfo.getValue();    Assert.assertNotNull(columnPrincipalIDInfo);    Assert.assertEquals(UpgradeCatalog240.PRINCIPAL_ID_COL, columnPrincipalIDInfo.getName());    Assert.assertEquals(null, columnPrincipalIDInfo.getLength());    Assert.assertEquals(Long.class, columnPrincipalIDInfo.getType());    Assert.assertEquals(null, columnPrincipalIDInfo.getDefaultValue());    Assert.assertEquals(true, columnPrincipalIDInfo.isNullable());    // Verify if recovery_enabled column was added to servicecomponentdesiredstate table    DBAccessor.DBColumnInfo columnScInfo = capturedScColumnInfo.getValue();    Assert.assertNotNull(columnScInfo);    Assert.assertEquals(UpgradeCatalog240.RECOVERY_ENABLED_COL, columnScInfo.getName());    Assert.assertEquals(null, columnScInfo.getLength());    Assert.assertEquals(Short.class, columnScInfo.getType());    Assert.assertEquals(0, columnScInfo.getDefaultValue());    Assert.assertEquals(false, columnScInfo.isNullable());    DBAccessor.DBColumnInfo columnScDesiredVersionInfo = capturedScDesiredVersionColumnInfo.getValue();    Assert.assertNotNull(columnScDesiredVersionInfo);    Assert.assertEquals(UpgradeCatalog240.DESIRED_VERSION_COLUMN_NAME, columnScDesiredVersionInfo.getName());    Assert.assertEquals(Integer.valueOf(255), columnScDesiredVersionInfo.getLength());    Assert.assertEquals(String.class, columnScDesiredVersionInfo.getType());    Assert.assertEquals("UNKNOWN", columnScDesiredVersionInfo.getDefaultValue());    Assert.assertEquals(false, columnScDesiredVersionInfo.isNullable());    // Verify if upgrade_id column was added to clusters table    DBAccessor.DBColumnInfo clusterUpgradeColumnInfo = capturedClusterUpgradeColumnInfo.getValue();    Assert.assertNotNull(clusterUpgradeColumnInfo);    Assert.assertEquals(UpgradeCatalog240.CLUSTER_UPGRADE_ID_COLUMN, clusterUpgradeColumnInfo.getName());    Assert.assertEquals(null, clusterUpgradeColumnInfo.getLength());    Assert.assertEquals(Long.class, clusterUpgradeColumnInfo.getType());    Assert.assertEquals(null, clusterUpgradeColumnInfo.getDefaultValue());    Assert.assertEquals(true, clusterUpgradeColumnInfo.isNullable());    Map<String, Class> expectedCaptures = new HashMap<>();    expectedCaptures.put("id", Long.class);    expectedCaptures.put("name", String.class);    expectedCaptures.put("setting_type", String.class);    expectedCaptures.put("content", String.class);    expectedCaptures.put("updated_by", String.class);    expectedCaptures.put("update_timestamp", Long.class);    Map<String, Class> actualCaptures = new HashMap<>();    for(DBAccessor.DBColumnInfo settingColumnInfo : capturedSettingColumns.getValue()) {      actualCaptures.put(settingColumnInfo.getName(), settingColumnInfo.getType());    }    assertEquals(expectedCaptures, actualCaptures);    expectedCaptures = new HashMap<>();    expectedCaptures.put("extension_id", Long.class);    expectedCaptures.put("extension_name", String.class);    expectedCaptures.put("extension_version", String.class);    actualCaptures = new HashMap<>();    for(DBAccessor.DBColumnInfo settingColumnInfo : capturedExtensionColumns.getValue()) {      actualCaptures.put(settingColumnInfo.getName(), settingColumnInfo.getType());    }    assertEquals(expectedCaptures, actualCaptures);    expectedCaptures = new HashMap<>();    expectedCaptures.put("link_id", Long.class);    expectedCaptures.put("stack_id", Long.class);    expectedCaptures.put("extension_id", Long.class);    actualCaptures = new HashMap<>();    for(DBAccessor.DBColumnInfo settingColumnInfo : capturedExtensionLinkColumns.getValue()) {      actualCaptures.put(settingColumnInfo.getName(), settingColumnInfo.getType());    }    assertEquals(expectedCaptures, actualCaptures);    expectedCaptures = new HashMap<>();    expectedCaptures.put("id", Long.class);    expectedCaptures.put("component_id", Long.class);    expectedCaptures.put("upgrade_id", Long.class);    expectedCaptures.put("from_stack_id", Long.class);    expectedCaptures.put("to_stack_id", Long.class);    actualCaptures = new HashMap<>();    for (DBAccessor.DBColumnInfo historyColumnInfo : capturedHistoryColumns.getValue()) {      actualCaptures.put(historyColumnInfo.getName(), historyColumnInfo.getType());    }    DBAccessor.DBColumnInfo columnHelpURLInfo = capturedHelpURLColumnInfo.getValue();    Assert.assertNotNull(columnHelpURLInfo);    Assert.assertEquals(UpgradeCatalog240.HELP_URL_COLUMN, columnHelpURLInfo.getName());    Assert.assertEquals(Integer.valueOf(512), columnHelpURLInfo.getLength());    Assert.assertEquals(String.class, columnHelpURLInfo.getType());    Assert.assertEquals(null, columnHelpURLInfo.getDefaultValue());    Assert.assertEquals(true, columnHelpURLInfo.isNullable());    DBAccessor.DBColumnInfo columnRepeatToleranceInfo = capturedRepeatToleranceColumnInfo.getValue();    Assert.assertNotNull(columnRepeatToleranceInfo);    Assert.assertEquals(UpgradeCatalog240.REPEAT_TOLERANCE_COLUMN, columnRepeatToleranceInfo.getName());    Assert.assertEquals(Integer.class, columnRepeatToleranceInfo.getType());    Assert.assertEquals(1, columnRepeatToleranceInfo.getDefaultValue());    Assert.assertEquals(false, columnRepeatToleranceInfo.isNullable());    DBAccessor.DBColumnInfo columnRepeatToleranceEnabledInfo = capturedRepeatToleranceEnabledColumnInfo.getValue();    Assert.assertNotNull(columnRepeatToleranceEnabledInfo);    Assert.assertEquals(UpgradeCatalog240.REPEAT_TOLERANCE_ENABLED_COLUMN, columnRepeatToleranceEnabledInfo.getName());    Assert.assertEquals(Short.class, columnRepeatToleranceEnabledInfo.getType());    Assert.assertEquals(0, columnRepeatToleranceEnabledInfo.getDefaultValue());    Assert.assertEquals(false, columnRepeatToleranceEnabledInfo.isNullable());    DBAccessor.DBColumnInfo columnOccurrencesInfo = capturedOccurrencesColumnInfo.getValue();    Assert.assertNotNull(columnOccurrencesInfo);    Assert.assertEquals(UpgradeCatalog240.ALERT_CURRENT_OCCURRENCES_COLUMN, columnOccurrencesInfo.getName());    Assert.assertEquals(Long.class, columnOccurrencesInfo.getType());    Assert.assertEquals(1, columnOccurrencesInfo.getDefaultValue());    Assert.assertEquals(false, columnOccurrencesInfo.isNullable());    DBAccessor.DBColumnInfo columnFirmnessInfo = capturedFirmnessColumnInfo.getValue();    Assert.assertNotNull(columnFirmnessInfo);    Assert.assertEquals(UpgradeCatalog240.ALERT_CURRENT_FIRMNESS_COLUMN, columnFirmnessInfo.getName());    Assert.assertEquals(String.class, columnFirmnessInfo.getType());    Assert.assertEquals(AlertFirmness.HARD.name(), columnFirmnessInfo.getDefaultValue());    Assert.assertEquals(false, columnFirmnessInfo.isNullable());    DBAccessor.DBColumnInfo targetEnabledColumnInfo = capturedTargetEnabledColumnInfo.getValue();    Assert.assertNotNull(targetEnabledColumnInfo);    Assert.assertEquals(UpgradeCatalog240.ALERT_TARGET_ENABLED_COLUMN, targetEnabledColumnInfo.getName());    Assert.assertEquals(Short.class, targetEnabledColumnInfo.getType());    Assert.assertEquals(1, targetEnabledColumnInfo.getDefaultValue());    Assert.assertEquals(false, targetEnabledColumnInfo.isNullable());    assertEquals(expectedCaptures, actualCaptures);    // Verify blueprint_setting columns    expectedCaptures = new HashMap<>();    expectedCaptures.put(UpgradeCatalog240.ID, Long.class);    expectedCaptures.put(UpgradeCatalog240.BLUEPRINT_NAME_COL, String.class);    expectedCaptures.put(UpgradeCatalog240.SETTING_NAME_COL, String.class);    expectedCaptures.put(UpgradeCatalog240.SETTING_DATA_COL, char[].class);    actualCaptures = new HashMap<>();    for(DBAccessor.DBColumnInfo blueprintSettingsColumnInfo : capturedBlueprintSettingColumns.getValue()) {      actualCaptures.put(blueprintSettingsColumnInfo.getName(), blueprintSettingsColumnInfo.getType());    }    assertEquals(expectedCaptures, actualCaptures);    // Verify host_role_command column    DBAccessor.DBColumnInfo originalStartTimeInfo = hostRoleCommandOriginalStartTimeColumnInfo.getValue();    Assert.assertNotNull(originalStartTimeInfo);    Assert.assertEquals("original_start_time", originalStartTimeInfo.getName());    Assert.assertEquals(Long.class, originalStartTimeInfo.getType());    Assert.assertEquals(-1L, originalStartTimeInfo.getDefaultValue());    DBAccessor.DBColumnInfo viewInstanceEntityUrlColInfoValue = viewInstanceShortUrlInfo.getValue();    Assert.assertNotNull(viewInstanceEntityUrlColInfoValue);    Assert.assertEquals("short_url", viewInstanceEntityUrlColInfoValue.getName());    Assert.assertEquals(Long.class, viewInstanceEntityUrlColInfoValue.getType());    List<DBAccessor.DBColumnInfo> capturedViewUrlColumsValue = capturedViewUrlColums.getValue();    Assert.assertNotNull(capturedViewUrlColumsValue);    Assert.assertEquals(3, capturedViewUrlColumsValue.size());    // Verify cluster_type column    DBAccessor.DBColumnInfo viewInstanceEntityClusterTypeValue = viewInstanceClusterType.getValue();    Assert.assertNotNull(viewInstanceClusterType);    Assert.assertEquals("cluster_type", viewInstanceEntityClusterTypeValue.getName());    Assert.assertEquals(String.class, viewInstanceEntityClusterTypeValue.getType());    List<DBAccessor.DBColumnInfo> capturedRemoteAmbariClusterColumnsValue = capturedRemoteAmbariClusterColumns.getValue();    Assert.assertNotNull(capturedRemoteAmbariClusterColumnsValue);    Assert.assertEquals(5, capturedRemoteAmbariClusterColumnsValue.size());    List<DBAccessor.DBColumnInfo> capturedRemoteClusterServiceColumnsValue = capturedRemoteClusterServiceColumns.getValue();    Assert.assertNotNull(capturedRemoteClusterServiceColumnsValue);    Assert.assertEquals(3, capturedRemoteClusterServiceColumnsValue.size());    DBAccessor.DBColumnInfo clusterHandleColumn = capturedClusterHandleColumn.getValue();    Assert.assertEquals(UpgradeCatalog240.CLUSTER_HANDLE_COLUMN, clusterHandleColumn.getName());    Assert.assertEquals(Long.class, clusterHandleColumn.getType());    // Verify authenticated_user_id column    DBAccessor.DBColumnInfo requestScheduleUserIdInfoValue = requestScheduleUserIdInfo.getValue();    Assert.assertNotNull(requestScheduleUserIdInfoValue);    Assert.assertEquals("authenticated_user_id", requestScheduleUserIdInfoValue.getName());    Assert.assertEquals(Integer.class, requestScheduleUserIdInfoValue.getType());    Assert.assertEquals(null, requestScheduleUserIdInfoValue.getDefaultValue());    DBAccessor.DBColumnInfo provisionActionColumnInfoValue = provisionActionColumnInfo.getValue();    Assert.assertNotNull(provisionActionColumnInfoValue);    Assert.assertEquals(UpgradeCatalog240.PROVISION_ACTION_COL, provisionActionColumnInfoValue.getName());    Assert.assertEquals(String.class, provisionActionColumnInfoValue.getType());    Assert.assertEquals(true, provisionActionColumnInfoValue.isNullable());    verify(dbAccessor);  }
@Test    void shouldAddSslHandlerWhenRequiresEncryption() throws Exception    {        SecurityPlan security = trustAllCertificates();        NettyChannelInitializer initializer = newInitializer( security );        initializer.initChannel( channel );        assertNotNull( channel.pipeline().get( SslHandler.class ) );    }
@Test(expectedExceptions = ClassCastException.class)    public void testAddNodeClass() {        GraphStore graphStore = new GraphStore();        graphStore.addNode(new Node() {            @Override            public Object getId() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(String key) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(Column column) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(Column column, double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(String key, double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object[] getAttributes() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Set<String> getAttributeKeys() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public ColumnIterable getAttributeColumns() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object removeAttribute(String key) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object removeAttribute(Column column) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAttribute(String key, Object value) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAttribute(Column column, Object value) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void clearAttributes() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAttribute(String key, Object value, double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAttribute(Column column, Object value, double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean addTimestamp(double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean removeTimestamp(double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public double[] getTimestamps() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float x() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float y() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float z() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float r() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float g() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float b() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public int getRGBA() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Color getColor() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float alpha() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public float size() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setX(float x) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setY(float y) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setZ(float z) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setPosition(float x, float y) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setPosition(float x, float y, float z) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setR(float r) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setG(float g) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setB(float b) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAlpha(float a) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setColor(Color color) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setSize(float size) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean isFixed() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public <T extends LayoutData> T getLayoutData() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setFixed(boolean fixed) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setLayoutData(LayoutData layoutData) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public TextProperties getTextProperties() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public String getLabel() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setLabel(String label) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public int getStoreId() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(String key, GraphView view) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(Column column, GraphView view) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean hasTimestamp(double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object removeAttribute(String key, double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object removeAttribute(Column column, double timestamp) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(String key, Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object getAttribute(Column column, Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object removeAttribute(String key, Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Object removeAttribute(Column column, Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAttribute(String key, Object value, Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public void setAttribute(Column column, Object value, Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean addInterval(Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean removeInterval(Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public boolean hasInterval(Interval interval) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Interval[] getIntervals() {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Iterable<Map.Entry> getAttributes(Column column) {                throw new UnsupportedOperationException("Not supported yet.");            }            @Override            public Table getTable() {                throw new UnsupportedOperationException("Not supported yet.");            }        });    }
@Test(dataProvider = "reverseNumbers")    public void testReverseNumber(int number, int expected) {        assertEquals(new ReverseInteger().reverse(number), expected);    }
@Test(expected=NoSuchStackException.class)  public void testCreateInvalidStack() throws Exception {    EasyMockSupport mockSupport = new EasyMockSupport();    BlueprintFactory.StackFactory mockStackFactory =      mockSupport.createMock(BlueprintFactory.StackFactory.class);    // setup mock to throw exception, to simulate invalid stack request    expect(mockStackFactory.createStack("null", "null", null)).andThrow(new ObjectNotFoundException("Invalid Stack"));    mockSupport.replayAll();    BlueprintFactory factoryUnderTest =      new BlueprintFactory(mockStackFactory);    factoryUnderTest.createStack(new HashMap<String, Object>());    mockSupport.verifyAll();  }
@Test(expectedExceptions = NullPointerException.class)    public void testNull()    {        ConfigurationMetadata.getConfigurationMetadata(null);    }
@Test  public void testGetVertexNotExists() {    assertNull(elementFactory.getVertex(UUID.randomUUID()));  }
@Test    public void given$logOut_whenQuery_thenShouldCallNativeApi() {        // given        PowerMockito.mockStatic(Instabug.class);        // when        rnModule.logOut();        // then        PowerMockito.verifyStatic(VerificationModeFactory.times(1));        Instabug.logoutUser();    }
@Test	public void createPolicyTest() throws Exception{		WebResource webResource = resource();		String policyStr = getPolicyContent();		ClientResponse response = webResource.path("/apps/" + TESTAPPID + "/policy").type(MediaType.APPLICATION_JSON).put(ClientResponse.class,policyStr);        assertEquals(response.getStatus(), STATUS200);	}
@Test    public final void tc_loadFromResourceTest()    {        myProperties.init();                //core.test.overwrite=Value from core.properties        assertEquals( "Value from core.properties", myProperties.get( "core.test.overwrite" ) );        //core.test.property=core.test.property        assertEquals( "core.test.property", myProperties.get( "core.test.property" ) );                                assertEquals( "Wert 0 aus properties_Test1", myProperties.get( "Wert0" ) );        assertEquals( "Wert 1 aus properties_Test2", myProperties.get( "Wert1" ) );        assertEquals( "Wert 2 aus properties_Test2", myProperties.get( "Wert2" ) );        assertEquals( "Wert 3 aus properties_Test2", myProperties.get( "Wert3" ) );        assertEquals( "Wert 4 aus properties_Test2", myProperties.get( "Wert4" ) );        assertEquals( "Wert 5 aus properties_Test2", myProperties.get( "Wert5" ) );    }
@Test public void testGetReportLock() throws Exception {    Assert.assertEquals( xlsOutput, xlsOutput.getReportLock() );  }
@Test  public void loadFileTest() throws IOException, AlluxioException {    FileSystemTestUtils.createByteFile(fs, "/testFile", WriteType.CACHE_THROUGH, 10, 10);    int memPercentage = fs.getStatus(new AlluxioURI("/testFile")).getInMemoryPercentage();    Assert.assertFalse(memPercentage == 0);    alluxioInterpreter.interpret("load /testFile", null);    memPercentage = fs.getStatus(new AlluxioURI("/testFile")).getInMemoryPercentage();    Assert.assertTrue(memPercentage == 100);  }
@Test    void redirectURL() {        when(request.hostName()).thenReturn("host");        when(request.path()).thenReturn("/path");        Map<String, String> queryParams = new LinkedHashMap<>();        queryParams.put("key1", "value1");        queryParams.put("key2", "value2");        queryParams.put("key3", "");        when(request.queryParams()).thenReturn(queryParams);        String redirectURL = interceptor.redirectURL(request);        assertThat(redirectURL).isEqualTo("https://host/path?key1=value1&key2=value2&key3=");    }
@Test    public void testRemoveType() {        EdgeTypeStore edgeTypeStore = new EdgeTypeStore();        int type = edgeTypeStore.addType("0");        type = edgeTypeStore.removeType("0");        Assert.assertEquals(type, 1);        Assert.assertFalse(edgeTypeStore.contains("0"));        Assert.assertEquals(edgeTypeStore.size(), 1);        type = edgeTypeStore.removeType("0");        Assert.assertEquals(type, EdgeTypeStore.NULL_TYPE);    }
@Test	public void testFontSize() {		String expected = "<span style=\"font-size: 18px;\">text</span>";		String actual = _htmlBBCodeTranslatorImpl.parse("[size=5]text[/size]");		Assert.assertEquals(expected, actual);	}
@Test    public void testEmptyStringAssemblyFrameworks()        throws NugetFormatException    {        // GIVEN        InputStream inputStream = NugetTestResourceUtil.getAsStream("nuspec/DockPanelSuite.nuspec.xml");        // WHEN        Nuspec nuspecFile = Nuspec.parse(inputStream);        // THEN        assertThat(nuspecFile).isNotNull();    }
@Test	public void testEquals(){		Edge e1 = new Edge(0,1,3);		e1.setBidirectional(true);		Edge e2 = new Edge(0,2,3);		e2.setBidirectional(true);		Edge e3 = new Edge(3,1,3);		e3.setBidirectional(true);		Edge e4 = new Edge(0,1,4);		e4.setBidirectional(true);//		Edge e5 = new Edge(0,1,3,false);		//		assertEquals(false, e.equals(new Long(5)));				assertEquals(true, e.equals(e1));		assertEquals(false, e.equals(e2));		assertEquals(false, e.equals(e3));		assertEquals(false, e.equals(e4));//		assertEquals(false, e.equals(e5));	}
@Test    public void init() throws Exception {        service.init();        verify(saveAndRenameServiceMock).init(service);    }
@Test  public void testGetPropertyIds() throws Exception {    Set<String> ids = new HashSet<String>();    ids.add("p1");    ids.add("p2");    UnsupportedPropertyException exception = new UnsupportedPropertyException("type", ids);    Assert.assertEquals(ids, exception.getPropertyIds());  }
@Test(expected = IllegalArgumentException.class)  public void testMonitoredAddressUnsupportedProtocol() {    String addr = "tcp://127.0.0.1";    udpStreamMonitor.setMonitoredAddress(addr);  }
@Test(description = "Testing changing device status")    public void testChangeDeviceStatus() {        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceManagementService"))                .toReturn(this.deviceManagementProviderService);        Response response = this.deviceManagementService                .changeDeviceStatus(TEST_DEVICE_TYPE, UUID.randomUUID().toString(), EnrolmentInfo.Status.INACTIVE);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode());    }
@Test    public void testGetKeywordFound() throws Exception {        addKeywordToWritableThesaurus(TEST_KEYWORD);        KeywordBean result = writableThesaurus.getKeyword(TEST_KEYWORD);        assertEquals(result.getUriCode(), TEST_KEYWORD);    }
@Test    public void testNotEqualsSelectSingleResult() {        final List<List<Object>> res = _personDao.findAll(SQL.select( Person.NAME).from( Person.TABLE).where( Person.LASTNAME.neq( "Prefect")).orderBy( Person.ID));        Assert.assertEquals(res, RESULT_NOT_SINGLE);    }
@Test        public void testEncrypt() throws Exception {                System.out.println("encrypt");                String str = "test";                DefaultCryptor instance = new DefaultCryptor();                String expResult = "test";                String result =instance.decrypt(instance.encrypt(str));                assertEquals(expResult, result);        }
@Test(description = "This test case tests handling ProfileManagerDAOException when retrieving features of a " +            "profile",          dependsOnMethods = "testGetFeaturesForProfile")    public void testGetFeaturesForProfileThrowingProfileManagerDAOException() throws Exception {        Profile profile = ProfileCreator.getProfile(FeatureCreator.getFeatureList(), DEVICE_TYPE_D);        profile1 = profileManager.addProfile(profile);        ProfileDAO profileDAO = mock(ProfileDAO.class);        when(profileDAO.getProfile(anyInt())).thenThrow(new ProfileManagerDAOException());        testThrowingException(featureManager,                              null,                              p -> featureManager.getFeaturesForProfile(profile1.getProfileId()),                              "profileDAO", profileDAO,                              ProfileManagerDAOException.class);    }
@Test  public void testRequestValidationSucceeds() {    assertTrue(getValidator().validate(new UpdateOriginRequest()            .setId(UUID.randomUUID())    ).isEmpty());  }
@Test  public void testReloadAllNotes() throws IOException {    File srcDir = new File("src/test/resources/2A94M5J1Z");    File destDir = new File(notebookDir.getAbsolutePath() + "/2A94M5J1Z");    // copy the notebook    try {      FileUtils.copyDirectory(srcDir, destDir);    } catch (IOException e) {      logger.error(e.toString(), e);    }    // doesn't have copied notebook in memory before reloading    List<Note> notes = notebook.getAllNotes();    assertEquals(notes.size(), 0);    // load copied notebook on memory when reloadAllNotes() is called    Note copiedNote = notebookRepo.get("2A94M5J1Z", null);    notebook.reloadAllNotes(null);    notes = notebook.getAllNotes();    assertEquals(notes.size(), 1);    assertEquals(notes.get(0).id(), copiedNote.id());    assertEquals(notes.get(0).getName(), copiedNote.getName());    assertEquals(notes.get(0).getParagraphs(), copiedNote.getParagraphs());    // delete the notebook    FileUtils.deleteDirectory(destDir);    // keep notebook in memory before reloading    notes = notebook.getAllNotes();    assertEquals(notes.size(), 1);    // delete notebook from notebook list when reloadAllNotes() is called    notebook.reloadAllNotes(null);    notes = notebook.getAllNotes();    assertEquals(notes.size(), 0);  }
@Test	public void testPrintf() {		StringWriter stringWriter = new StringWriter();		UnsyncPrintWriter unsyncPrintWriter = new UnsyncPrintWriter(			stringWriter);		unsyncPrintWriter.printf("%2$2d %1$2s", "a", 1);		Assert.assertEquals(" 1  a", stringWriter.toString());		StringBuffer stringBuffer = stringWriter.getBuffer();		stringBuffer.setLength(0);		unsyncPrintWriter.printf("%1$s", "reuse formatter");		Assert.assertEquals("reuse formatter", stringWriter.toString());		stringBuffer.setLength(0);		unsyncPrintWriter.printf(Locale.CANADA, "%1$s", "replace formatter");		Assert.assertEquals("replace formatter", stringWriter.toString());		unsyncPrintWriter.close();		unsyncPrintWriter.printf(Locale.getDefault(), null);		Assert.assertTrue(unsyncPrintWriter.checkError());	}
@Test  public void testPropertiesWithMatchingProperty() {    Edge edge = createEdge();    assertTrue(edge.properties("value").hasNext());  }
@Test  public void testResolveCurrentUserWithoutAffiliation() throws Exception {    setup("subject.1.name = subject");    Subject subject = accessController.resolveCurrentUser(createCredentials(1));    assertEquals(UUID.fromString("00000000-0000-0000-0000-000000000001"), subject.getId());    assertEquals("subject", subject.getName());    assertNull(subject.getOrganization());  }
@Test    public void testManageLeftClick_ReadOnly() {        when(informationHeaderMetaDataMock.isReadOnly()).thenReturn(true);        scenarioSimulationMainGridPanelClickHandler.setEventBus(eventBusMock);        assertTrue("Click to readonly header cell.",                   scenarioSimulationMainGridPanelClickHandler.manageCoordinates((int) CLICK_POINT_X,                                                                                 (int) CLICK_POINT_Y));        verify(scenarioGridMock, times(1)).setSelectedColumn(anyInt());        verify(eventBusMock, times(1)).fireEvent(any(EnableTestToolsEvent.class));    }
@Test	public void testCompareGreaterThanMinor() {		SharepointVersion sharepointVersion1 = createSharepointVersion("9.0");		SharepointVersion sharepointVersion2 = createSharepointVersion("9.1");		Assert.assertEquals(			1,			_sharepointVersionComparator.compare(				sharepointVersion1, sharepointVersion2));	}
@Test	public void testParseWithEqBinaryExpressionWithNoSingleQuotes() {		String filterString = "(fieldExternal eq value)";		AbstractThrowableAssert exception = Assertions.assertThatThrownBy(			() -> _filterParserImpl.parse(filterString)		).isInstanceOf(			ExpressionVisitException.class		);		exception.hasMessage(			"A property used in the filter criteria is not supported: %s",			filterString);	}
@Test    void thenComparing() throws Exception {        comparatorsAndReverses().forEachOrdered(comp1 -> {            final Comparator<Entity> mock1 = mockComparator(                comp1.getField(),                comp1.getNullOrder(),                comp1.isReversed()            );            comparatorsAndReverses().forEachOrdered(comp2 -> {                final Comparator<Entity> mock2 = mockComparator(                    comp2.getField(),                    comp2.getNullOrder(),                    comp2.isReversed()                );                final Comparator<Entity> mock = mock1.thenComparing(mock2);                final Comparator<Entity> comp = comp1.thenComparing(comp2);                final List<Entity> expected = list.stream().sorted(mock).collect(toList());                final List<Entity> actual   = list.stream().sorted(comp).collect(toList());                assertEquals(actual, expected, format("Compare %s then %s (reversed) using %s",                    comp1.getField().identifier().getColumnId(),                    comp2.getField().identifier().getColumnId(),                    comp                )                );            });        });    }
@Test    public void canFactoryProcessViewsShouldWorkWithExtensions() {        Dictionary<String, String> headers = new Hashtable<>(2);        headers.put(BundleScriptingConfigurationConstants.JAHIA_MODULE_SCRIPTING_VIEWS, "foo,js,groovy");        headers.put("color", "black");        assertTrue(ScriptEngineUtils.canFactoryProcessViews(new TestScriptEngineFactory(), headers));    }
@Test    void get() {        assertThat(message.get("key1", "zh")).isEqualTo("value1");        assertThat(message.get("key1", "en")).isEqualTo("value1");        assertThat(message.get("key1", "en_US")).isEqualTo("value1");        assertThat(message.get("key2", "zh")).isEqualTo("value2");        assertThat(message.get("key2", "en")).isEqualTo("en_value2");        assertThat(message.get("key2", "en_US")).isEqualTo("en_value2");        assertThat(message.get("key3", "zh")).isEqualTo("value3");        assertThat(message.get("key3", "en")).isEqualTo("en_value3");        assertThat(message.get("key3", "en_US")).isEqualTo("en_US_value3");    }
@Test    public void testGenerateRandomAlphaNumericString_withProvidedRandom() {        int length = 10;        StringBuilder strBuilder = new StringBuilder();        for (int i = 0; i < length; i++) {            strBuilder.append("a");        }        Random rand = mock(Random.class);        when(rand.nextInt(anyInt())).thenReturn(0);        String result = RandomStringUtils.generateRandomAlphaNumericString(length, rand);        assertEquals(length, result.length());        assertEquals(strBuilder.toString(), result);    }
@Test	public void testClose() throws Exception {		// Do not delete on close		ByteArrayFileInputStream byteArrayFileInputStream =			new ByteArrayFileInputStream(_testFile, 512);		byteArrayFileInputStream.read();		byteArrayFileInputStream.close();		Assert.assertNull(_dataField.get(byteArrayFileInputStream));		Assert.assertNull(_fileField.get(byteArrayFileInputStream));		Assert.assertNull(_fileInputStreamField.get(byteArrayFileInputStream));		Assert.assertTrue(_testFile.exists());		// Delete on close		byteArrayFileInputStream = new ByteArrayFileInputStream(			_testFile, 512, true);		byteArrayFileInputStream.close();		Assert.assertNull(_dataField.get(byteArrayFileInputStream));		Assert.assertNull(_fileField.get(byteArrayFileInputStream));		Assert.assertNull(_fileInputStreamField.get(byteArrayFileInputStream));		Assert.assertFalse(_testFile.exists());		byteArrayFileInputStream.close();	}
@Test public void testGetReportLock() throws Exception {    assertEquals( emailOutput, emailOutput.getReportLock() );  }
@Test  public void testInvalidUri2() throws JSONException, Exception {    WebResource r = resource();    String responseStr = "";    try {      responseStr = r.accept(MediaType.APPLICATION_JSON).get(String.class);      fail("should have thrown exception on invalid uri");    } catch (UniformInterfaceException ue) {      ClientResponse response = ue.getResponse();      assertEquals(Status.NOT_FOUND, response.getClientResponseStatus());      WebServicesTestUtils.checkStringMatch(        "error string exists and shouldn't", "", responseStr);    }  }
@Test	public void testAdaptiveMediaIsAddedToExtraPlugins() throws Exception {		PortletURL itemSelectorPortletURL = mock(PortletURL.class);		when(			itemSelectorPortletURL.toString()		).thenReturn(			"itemSelectorPortletURL"		);		when(			_itemSelector.getItemSelectorURL(				Mockito.any(RequestBackedPortletURLFactory.class),				Mockito.anyString(), Mockito.any(ItemSelectorCriterion.class))		).thenReturn(			itemSelectorPortletURL		);		when(			_itemSelector.getItemSelectedEventName(Mockito.anyString())		).thenReturn(			"selectedEventName"		);		when(			_itemSelector.getItemSelectorCriteria(				"blogsItemSelectorCriterionFileEntryItemSelectorReturnType")		).thenReturn(			_getBlogsItemSelectorCriterionFileEntryItemSelectorReturnType()		);		JSONObject originalJSONObject = JSONUtil.put(			"filebrowserImageBrowseLinkUrl",			"blogsItemSelectorCriterionFileEntryItemSelectorReturnType");		JSONObject jsonObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		AMBlogsEditorConfigContributor amBlogsEditorConfigContributor =			new AMBlogsEditorConfigContributor();		ReflectionTestUtil.setFieldValue(			amBlogsEditorConfigContributor, "_itemSelector", _itemSelector);		amBlogsEditorConfigContributor.populateConfigJSONObject(			jsonObject, _inputEditorTaglibAttributes, _themeDisplay,			_requestBackedPortletURLFactory);		Assert.assertEquals(			"adaptivemedia", jsonObject.getString("extraPlugins"));	}
@Test public void testDefaultLogger() {		// Act:		final Logger logger = FragmentsLogging.getLogger();		// Assert:		assertThat(logger, is(notNullValue()));		assertThat(logger.getLogLevel(), is(Log.ASSERT));	}
@Test    public void testGetNameWithEscapedTableAndColumnName() {        String identifier = "\"table.column\"";        String expected = "\"column\"";        SQLIdentifier actual = new SQLIdentifier( identifier );        Assert.assertEquals( expected, actual.getName() );    }
@Test	public void testIsNothingSelected() {		ModifiedFacetDisplayBuilder modifiedFacetDisplayBuilder =			createDisplayBuilder();		ModifiedFacetDisplayContext modifiedFacetDisplayContext =			modifiedFacetDisplayBuilder.build();		Assert.assertTrue(modifiedFacetDisplayContext.isNothingSelected());	}
@Test    public void decodeExtraPayload() {        Http2Connection connection = new Http2Connection();        ByteBuffer buffer = ByteBuffer.wrap(TestMessages.RST_STREAM_EXTRA_PAYLOAD_BUFFER);        Http2RstStreamFrame frame = (Http2RstStreamFrame) connection.decode(buffer);        assertNotNull(frame);        assertEquals(6, frame.getLength());        assertEquals(3, frame.getType());        assertEquals(0x00, frame.getFlags());        assertEquals(32, frame.getStreamID());        assertEquals(256, frame.getErrorCode());    }
@Test  public void testRead() throws Exception {    MysqlSourceState state = mock(MysqlSourceState.class);    when(repository.get()).thenReturn(state);    when(repository.exists()).thenReturn(false);    assertNull(stateRepository.read());    when(repository.exists()).thenReturn(true);    Assert.assertEquals(state, stateRepository.read());    verify(metrics, times(2)).stateRead();  }
@Test    public void testConvertJsonStringNumber() {        Number value = Random.getNumber();        String json = "{\"elt\": \"" + value + "\"}";        Multimap<String, Object> data = Convert.jsonToJava(json);        Assert.assertEquals("" + value + "",                Iterables.getOnlyElement(data.get("elt")));    }
@Test  public void lsRecursiveTest() throws IOException, AlluxioException {    URIStatus[] files = new URIStatus[4];    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileA",            WriteType.MUST_CACHE, 10, 10);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testDir/testFileB",            WriteType.MUST_CACHE, 20, 20);    FileSystemTestUtils.createByteFile(fs, "/testRoot/testFileC",            WriteType.THROUGH, 30, 30);    files[0] = fs.getStatus(new AlluxioURI("/testRoot/testFileA"));    files[1] = fs.getStatus(new AlluxioURI("/testRoot/testDir"));    files[2] = fs.getStatus(new AlluxioURI("/testRoot/testDir/testFileB"));    files[3] = fs.getStatus(new AlluxioURI("/testRoot/testFileC"));    InterpreterResult output = alluxioInterpreter.interpret("ls -R /testRoot", null);    String expected = "";    String format = "%-10s%-25s%-15s%-5s\n";    expected +=            String.format(format, FormatUtils.getSizeFromBytes(10),                    CommandUtils.convertMsToDate(files[0].getCreationTimeMs()), "In Memory",                    "/testRoot/testFileA");    expected +=            String.format(format, FormatUtils.getSizeFromBytes(0),                    CommandUtils.convertMsToDate(files[1].getCreationTimeMs()), "", "/testRoot/testDir");    expected +=            String.format(format, FormatUtils.getSizeFromBytes(20),                    CommandUtils.convertMsToDate(files[2].getCreationTimeMs()), "In Memory",                    "/testRoot/testDir/testFileB");    expected +=            String.format(format, FormatUtils.getSizeFromBytes(30),                    CommandUtils.convertMsToDate(files[3].getCreationTimeMs()), "Not In Memory",                    "/testRoot/testFileC");    expected += "\n";    Assert.assertEquals(expected, output.message());  }
@Test	public void testGetSinkNodes() {		UpgradeInfo upgradeInfo1 = createUpgradeInfo("0.0.0", "0.1.0");		UpgradeInfo upgradeInfo2 = createUpgradeInfo("0.1.0", "0.2.0");		UpgradeInfo upgradeInfo3 = createUpgradeInfo("0.2.0", "1.0.0");		UpgradeInfo upgradeInfo4 = createUpgradeInfo("1.0.0", "2.0.0");		ReleaseGraphManager releaseGraphManager = new ReleaseGraphManager(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4));		List<String> sinkNodes = releaseGraphManager.getEndVertices();		Assert.assertTrue(sinkNodes.toString(), sinkNodes.contains("2.0.0"));	}
@Test    public void nullCommand() {        handler = new ConstraintValueChangeHandler(constraint,                                                   null);        handler.onValueChange(valueChangeEvent);        verify(onChangeCommand, never()).execute();    }
@Test  public void testDoFilterWithUserNameInUri() throws Exception {    // Given    expect(userRelatedRequest.getRequestURI()).andReturn("/test/users/testUserName/test1").anyTimes();    // filterChain should be invoked with the same req and resp as the OverrideUserName filter doesn't change these    filterChain.doFilter(same(userRelatedRequest), same(response));    expectLastCall();    replayAll();    // When    filter.doFilter(userRelatedRequest, response, filterChain);    // Then    verifyAll();  }
@Test  public void destroyShouldNotUnsubScribeIfFalse() {    searchUserPresenter = new SearchUserPresenter(mockSearchUserUseCase);    searchUserPresenter.destroy(false);    verifyZeroInteractions(mockSearchUserUseCase);  }
@Test  public void testGetUserAuthorizationDefinition() {    ResourceDefinition resourceDefinition = ResourceInstanceFactoryImpl.getResourceDefinition(        Resource.Type.UserAuthorization, null);    assertNotNull(resourceDefinition);    assertEquals("authorization", resourceDefinition.getSingularName());    assertEquals("authorizations", resourceDefinition.getPluralName());    assertEquals(Resource.Type.UserAuthorization, resourceDefinition.getType());  }
@Test    public void testInitialState()            throws Exception    {        SparseTimeStat stat = new SparseTimeStat();        stat.add(1, NANOSECONDS);        assertPreviousDistributionEmpty(stat);    }
@Test(dataProvider = "swapDataProvider")    public void swap(int[] array, int[] expected) {        SwapTwoInt.swap(array);        assertEquals(array, expected);    }
@Test    public void twoCM() {        Assert.assertEquals(RxComprehensions.doConcatMap(zero(2), one(true), two("result")).toBlocking().first(), "result");    }
@Test    public void getPlaceholder_InstanceAndPropertyAssigned() {        String placeholder = ScenarioSimulationUtils.getPlaceHolder(true, true, FactMappingValueType.EXPRESSION, "com.Test");        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.insertExpression(), placeholder);        placeholder = ScenarioSimulationUtils.getPlaceHolder(true, true, FactMappingValueType.NOT_EXPRESSION, "com.Test");        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.insertValue(), placeholder);        placeholder = ScenarioSimulationUtils.getPlaceHolder(true, true, FactMappingValueType.NOT_EXPRESSION, LOCALDATE_CANONICAL_NAME);        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.dateFormatPlaceholder(), placeholder);        placeholder = ScenarioSimulationUtils.getPlaceHolder(true, true, FactMappingValueType.NOT_EXPRESSION, DMN_DATE);        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.dmnDateFormatPlaceholder(), placeholder);    }
@Test  public void testApply() throws ParseException {    Geometry geometry = new WKTReader().read("LINESTRING( 0 0, 1 1, 2 2)");    Geometry normalizedGeometry = geometry.norm();    assertThat(        normalizeGeometry.apply(geometry, new GeometryOperator.Context()), is(normalizedGeometry));  }
@Test  public void testAddSmilToArchive() throws Exception {    final String mpId = UUID.randomUUID().toString();    final URI archiveElementURI = new URI("http://host.tld/archive/cut.smil");    final String smilId = "s-afe311c6-9161-41f4-98d0-e951fe66d89e";    Workspace workspace = createNiceMock(Workspace.class);    expect(workspace.put(same(mpId), same(smilId), same("cut.smil"), anyObject(InputStream.class)))            .andReturn(archiveElementURI);    replay(workspace);    endpoint.setWorkspace(workspace);    AssetManager assetManager = createNiceMock(AssetManager.class);    replay(assetManager);    endpoint.setAssetManager(assetManager);    MediaPackage mp = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder().createNew(new IdImpl(mpId));    endpoint.addSmilToArchive(mp, smil);    assertEquals(1, mp.getCatalogs().length);    assertEquals(smil.getId(), mp.getCatalogs()[0].getIdentifier());    assertEquals("smil/cutting", mp.getCatalogs()[0].getFlavor().toString());  }
@Test    public void testInvalidPath()            throws IOException    {        assertThatExceptionOfType(FileNotFoundException.class)                .isThrownBy( () -> {                    assertThat(P2ArtifactReader.getArtifact(".", "some/invalid@path")).isNull();                    assertThat(P2ArtifactReader.getArtifact(".", "somePath")).isNull();                    assertThat(P2ArtifactReader.getArtifact(".", "")).isNull();                    assertThat(P2ArtifactReader.getArtifact(".", "osgi.bundle/missingName/1.0.1")).isNull();        });    }
@Test    void testHashCode() {        assertNotEquals(0, instance.hashCode());    }
@Test(expected = WebApplicationException.class)        public void testGetServiceDetailXML_NULL() {                System.out.println("getServiceDetailXML_NULL");                String id = UUID.randomUUID().toString();                BusinessService expResult = null;                BusinessService result = instance.getServiceDetailXML(id);        }
@Test    public void initMenu() {        super.initMenu(businessCentralGridContextMenuSpy);        verify(businessCentralGridContextMenuSpy, times(1)).addExecutableMenuItem(eq(GRIDCONTEXTMENU_RUN_SINGLE_SCENARIO), eq(ScenarioSimulationEditorConstants.INSTANCE.runSingleScenario()), eq("runSingleScenario"));    }
@Test  public void testGetDatabaseDriver() throws Exception {    SinkConnectionFactory factory = getFactory("myURL", "myDriver");    Assert.assertEquals("myDriver", factory.getDatabaseDriver());  }
@Test  public void testFetchFactCommentsWithNonExistingFact() {    assertEquals(0, getFactManager().fetchFactComments(null).size());    assertEquals(0, getFactManager().fetchFactComments(UUID.randomUUID()).size());  }
@Test(expected = BlockchainValidationException.class)	public void testRemovingNotExistingObject() throws FailedVerificationException {		for (OpOperation op : generateStartOperationAndObject()) {			assertTrue(blocksManager.addOperation(op));		}		OpObject object = blockChain.getObjectByName(OP_ID, OBJ_ID + 1);		assertNull(object);		blocksManager.addOperation(generateRemoveOp(OBJ_ID + 1));	}
@Test    public void compileDummySwc()        throws Exception    {        File output = new File( as3, "result.swc" );        DefaultFlexCompiler compiler = (DefaultFlexCompiler) plexus.lookup( FlexCompiler.class );        ICompcConfiguration cfg = mock( ICompcConfiguration.class, RETURNS_NULL );        ICompilerConfiguration compilerCfg = getBaseCompilerCfg();        when( cfg.getIncludeSources() ).thenReturn( new File[] { as3 } );        when( cfg.getLoadConfig() ).thenReturn( new String[] {} );        when( cfg.getOutput() ).thenReturn( output.getAbsolutePath() );        when( cfg.getCompilerConfiguration() ).thenReturn( compilerCfg );        Assert.assertEquals( compiler.compileSwc( cfg, true, null ).getExitCode(), 0 );    }
@Test    void shouldCreateJacksonContext() {        final JacksonContext context = new JacksonContext();        assertThat(context.getValue())                .isNotNull();    }
@Test    public void testWrapByteBuffer() throws Exception {        //given        final ByteBuffer byteBuffer = allocateDirect(5);        byteBuffer.put(new byte[]{                1, 1, 2, 3, 5        });        //when        final Pointer<Void> voidPointer = wrap(byteBuffer);        //then        final long address = voidPointer.address;        assertThat(address).isNotEqualTo(0L);    }
@Test    void logValue() {        assertThat(new BsonLogParam(Filters.eq("field", TestUnregisteredEnum.V1), MongoClientSettings.getDefaultCodecRegistry()).logValue())                .contains("V1");        assertThat(new BsonLogParam(null, MongoClientSettings.getDefaultCodecRegistry()).logValue())                .isEqualTo("null");    }
@Test  public void testParsingHostName() {    uri = "mysql://vertx.io";    actualParsedResult = parse(uri);    expectedParsedResult = new JsonObject()      .put("host", "vertx.io");    assertEquals(expectedParsedResult, actualParsedResult);  }
@Test	public void testGetExtensionWithExtension() {		Assert.assertEquals("ext", PathUtil.getExtension("/name.ext"));	}
@Test  public void testDeserializeFloatRoundDown() throws IOException {    when(parser.hasToken(eq(JsonToken.VALUE_NUMBER_FLOAT))).thenReturn(true);    when(parser.getFloatValue()).thenReturn(0.444f);    assertEquals(0.44f, deserializer.deserialize(parser, context), 0.0f);  }
@Test    void validate() {        validator.beanClasses.put(Classes.className(TestBean.class), Void.class);        assertThatThrownBy(() -> validator.validate(TestBean.class))            .isInstanceOf(Error.class).hasMessageContaining("found bean class with duplicate name");    }
@Test    public void testSmileErrorResponse()    {        SmileResponse<User> response = handler.handle(null, createSmileResponse(INTERNAL_SERVER_ERROR, ImmutableMap.of(                "error", true        )));        assertTrue(response.hasValue());        assertNull(response.getValue().getName());        assertEquals(response.getValue().getAge(), 0);    }
@Test    public void testUnselectableDatesNPE() {        JXMonthView monthView = new JXMonthView();        try {            monthView.setUnselectableDates((Date[])null);            fail("null array must throw NPE");        } catch (NullPointerException e) {            // expected        }        try {            monthView.setUnselectableDates(new Date[] {new Date(), null});            fail("null elements must throw NPE");        } catch (NullPointerException e) {            // expected        }    }
@Test    public void testSessionInfoOnCreate() {        service.create( path,                        inputstream,                        sessionId,                        comment );        final CommentedOption commentedOption = commentedOptionArgumentCaptor.getValue();        assertNotNull( commentedOption );        assertEquals( "user",                      commentedOption.getName() );        assertEquals( "123",                      commentedOption.getSessionId() );    }
@Test	public void testIntersectingCycles() {		Node node1 = new Node(1, 1);		Node node2 = new Node(1, 2);		Node node3 = new Node(1, 3);		Node node4 = new Node(1, 4);		Set<Node> nodes = new HashSet<>(			Arrays.asList(node1, node2, node3, node4));		Map<Node, Collection<Node>> nodeMap = GraphUtil.getNodeMap(			nodes,			HashMapBuilder.<Node, Collection<Edge>>put(				node1, Collections.singletonList(new Edge(node1, node2))			).put(				node2, Collections.singletonList(new Edge(node2, node3))			).put(				node3,				Arrays.asList(					new Edge(node3, node1), new Edge(node3, node2),					new Edge(node3, node4))			).put(				node4, Collections.singletonList(new Edge(node4, node2))			).build());		Assert.assertEquals(			Collections.singleton(node3), nodeMap.remove(new Node(0, 0)));		Assert.assertEquals(			new HashSet<>(Arrays.asList(node1, node2, node4)),			nodeMap.remove(node3));		Assert.assertEquals(			Collections.singleton(node2), nodeMap.remove(node4));		Assert.assertTrue(nodeMap.toString(), nodeMap.isEmpty());	}
@Test(expected = DecisionTableParseException.class)    public void checkConversionOfXLSWithInvalidContent() {        final InputStream is = this.getClass().getResourceAsStream("wrong_file.xls");        when(ioService.newInputStream(any(org.uberfire.java.nio.file.Path.class))).thenReturn(is);        converter.convert(path);    }
@Test    public void testSetHeader() throws Exception {        final String header = "Header";        doReturn(editingCol).when(plugin).editingCol();        plugin.setHeader(header);        verify(editingCol).setHeader(header);        verify(plugin).fireChangeEvent(additionalInfoPage);    }
@Test    void shouldDelegateLogResponse() throws IOException {        final HttpLogFormatter fallback = mock(HttpLogFormatter.class);        final HttpLogFormatter unit = new CurlHttpLogFormatter(fallback);        final MockHttpResponse response = MockHttpResponse.create();        final Correlation correlation = new SimpleCorrelation("3881ae92-6824-11e5-921b-10ddb1ee7671", MIN, MIN);        unit.format(correlation, response);        verify(fallback).format(correlation, response);    }
@Test  public void testAudioVideo() throws Exception {    operationInstance.setConfiguration("source-tags", "");    operationInstance.setConfiguration("source-flavor", "*/video-audio");    operationInstance.setConfiguration("source-flavors", "");    operationInstance.setConfiguration("force-transcode", "false");    WorkflowOperationResult result = operationHandler.start(instance, null);    Assert.assertEquals(Action.CONTINUE, result.getAction());    Assert.assertEquals("Resulting mediapackage has the wrong number of tracks", 3, result.getMediaPackage()            .getElements().length);    Track[] tracks = result.getMediaPackage().getTracks(new MediaPackageElementFlavor("presentation", "video-audio"));    Assert.assertEquals("Resulting mediapackage has the wrong number of tracks", 1, tracks.length);    TrackImpl audioVideo = (TrackImpl) tracks[0];    Assert.assertEquals(-20f, audioVideo.getAudio().get(0).getRmsLevDb().floatValue(), 0.001d);  }
@Test    public void testEnumHasPriorityButSimpleOperatorByte() throws Exception {        testEnumAndOperator(DataType.TYPE_NUMERIC_BYTE, "==");        verify(testedFactory).decoratedGridCellValueAdaptor(puddCaptor.capture());        assertTrue(puddCaptor.getValue() instanceof ProxyPopupNumericByteDropDownEditCell);    }
@Test(expectedExceptions=NullPointerException.class)    public void convertToReference_NULL_matchableEntity() {                // given                IdWithSimilarity idWithSimilarity = Mockito.mock(IdWithSimilarity.class);        Tuple2<MatchableEntity, IdWithSimilarity> entityWithId = new Tuple2<>(null, idWithSimilarity);                // execute                matchableEntityWithSimilarityConverter.convertToReference(entityWithId);            }
@Test    void shouldNeverRetrieveBodyIfInactiveWriter() throws IOException {        when(sink.isActive()).thenReturn(false);        unit.process(request).write();        verify(request, never()).withBody();    }
@Test	public void testGreaterThanOrEquals1() throws Exception {		DDMExpressionImpl<Boolean> ddmExpressionImpl = createDDMExpression(			"-2 >= -3");		Assert.assertTrue(ddmExpressionImpl.evaluate());	}
@Test	public void testGridFieldTemplateContext() throws Exception {		// Dynamic data mapping form		DDMForm ddmForm = DDMFormTestUtil.createDDMForm();		String formFieldLabel = String.format(_HTML_WRAPPER, "label");		String formFieldTip = String.format(_HTML_WRAPPER, "tip");		String formFieldOption = String.format(_HTML_WRAPPER, "option");		ddmForm.addDDMFormField(			DDMFormTestUtil.createGridDDMFormField(				"Field1", formFieldLabel, "grid", "string", false, false, true,				formFieldTip, formFieldOption));		mockDDMFormFieldTypeServicesTracker(			"grid",			_ddmFormFieldTemplateContextContributorTestHelper.				createGridDDMFormFieldTemplateContextContributor());		// Dynamic data mapping form layout		DDMFormLayout ddmFormLayout = new DDMFormLayout();		ddmFormLayout = createDDMFormLayoutPage(			ddmFormLayout, "Page 1", "Page 1 Description", "Field1");		// Template context		DDMFormValues ddmFormValues = DDMFormValuesTestUtil.createDDMFormValues(			ddmForm);		ddmFormValues.addDDMFormFieldValue(			DDMFormValuesTestUtil.createDDMFormFieldValue(				"Field1", new UnlocalizedValue("{}")));		DDMFormPagesTemplateContextFactory ddmFormPagesTemplateContextFactory =			createDDMFormPagesTemplateContextFactory(				ddmForm, ddmFormLayout, ddmFormValues, false, true, true);		List<Object> pages = ddmFormPagesTemplateContextFactory.create();		Map<String, Object> fieldTemplateContext = getFieldTemplateContext(			pages);		Assert.assertEquals(formFieldLabel, fieldTemplateContext.get("label"));		List<Map<String, String>> columns =			(List<Map<String, String>>)fieldTemplateContext.get("columns");		Map<String, String> columnField = columns.get(0);		Assert.assertEquals(formFieldOption, columnField.get("label"));		List<Map<String, String>> rows =			(List<Map<String, String>>)fieldTemplateContext.get("rows");		Map<String, String> rowField = rows.get(0);		Assert.assertEquals(formFieldOption, rowField.get("label"));		Assert.assertEquals(formFieldTip, fieldTemplateContext.get("tip"));	}
@Test    public void testGetTitle() {        final String errorKey = GuidedDecisionTableErraiConstants.ActionWorkItemSetFieldPlugin_SetValue;        final String errorMessage = "Title";        when(translationService.format(errorKey)).thenReturn(errorMessage);        final String title = plugin.getTitle();        assertEquals(errorMessage,                     title);    }
@Test  public void testGetEdgeWithNullId() {    assertNull(elementFactory.getEdge(null));  }
@Test  public void testListReadRows() {    ReadRowsRequest.Builder requestBuilder = ReadRowsRequest.newBuilder().setTableName(TABLE_NAME);    requestBuilder.getRowsBuilder().addRowKeys(ByteString.EMPTY);    setResponse(ReadRowsResponse.getDefaultInstance());    defaultClient.readFlatRowsList(requestBuilder.build());    verifyRequestCalled(requestBuilder.build());  }
@Test    public void convertImagePathsToBase64WithoutAlt() throws Exception {        String result3 = repository.cacheFileFromArchive(module, "test string with <img src='bible.png'> and other symbols");        assertNotNull(result3);        assertEquals(27909, result3.length());    }
@Test  public void testUpdateAmsHbaseEnvContent() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {    Method updateAmsHbaseEnvContent = UpgradeCatalog220.class.getDeclaredMethod("updateAmsHbaseEnvContent", String.class);    UpgradeCatalog220 upgradeCatalog220 = new UpgradeCatalog220(injector);    String oldContent = "export HBASE_CLASSPATH=${HBASE_CLASSPATH}\n" +      "\n" +      "# The maximum amount of heap to use, in MB. Default is 1000.\n" +      "export HBASE_HEAPSIZE={{hbase_heapsize}}\n";    String expectedContent = "export HBASE_CLASSPATH=${HBASE_CLASSPATH}\n" +      "\n" +      "# The maximum amount of heap to use, in MB. Default is 1000.\n" +      "#export HBASE_HEAPSIZE={{hbase_heapsize}}\n" +      "\n" +      "# The maximum amount of heap to use for hbase shell.\n" +      "export HBASE_SHELL_OPTS=\"-Xmx256m\"\n";    String result = (String) updateAmsHbaseEnvContent.invoke(upgradeCatalog220, oldContent);    Assert.assertEquals(expectedContent, result);  }
@Test	public void testImgIsAllowedContent() throws Exception {		JSONObject originalJSONObject = JSONFactoryUtil.createJSONObject();		JSONObject jsonObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		AMJournalEditorConfigContributor amJournalEditorConfigContributor =			new AMJournalEditorConfigContributor();		amJournalEditorConfigContributor.populateConfigJSONObject(			jsonObject, _inputEditorTaglibAttributes, _themeDisplay,			_requestBackedPortletURLFactory);		JSONObject expectedJSONObject = JSONFactoryUtil.createJSONObject();		JSONAssert.assertEquals(			expectedJSONObject.toJSONString(), jsonObject.toJSONString(), true);	}
@Test  public void testSomeMethod() throws Exception  {    LocalMode lma = LocalMode.newInstance();    new ApplicationWithDerbySQL().populateDAG(lma.getDAG(), new Configuration(false));    LocalMode.Controller lc = lma.getController();    long start = System.currentTimeMillis();    lc.run();    long end = System.currentTimeMillis();    long time = end - start;    LOG.debug("Test used " + time + " ms");  }
@Test  public void testAuthenticate() throws Exception {    PAM pam = createNiceMock(PAM.class);    UnixUser unixUser = createNiceMock(UnixUser.class);    expect(pam.authenticate(EasyMock.anyObject(String.class), EasyMock.anyObject(String.class))).andReturn(unixUser).atLeastOnce();    expect(unixUser.getGroups()).andReturn(new HashSet<String>(Arrays.asList("group"))).atLeastOnce();    EasyMock.replay(unixUser);    EasyMock.replay(pam);    Authentication authentication = new UsernamePasswordAuthenticationToken("allowedUser", "password");    Authentication result = authenticationProvider.authenticateViaPam(pam,authentication);    assertEquals("allowedUser", result.getName());  }
@Test    void parse() {        assertThat(new KafkaURI("kafka-0.kafka").bootstrapURIs)                .containsExactly("kafka-0.kafka:9092");        assertThat(new KafkaURI("kafka-0.kafka:9092").bootstrapURIs)                .containsExactly("kafka-0.kafka:9092");        assertThat(new KafkaURI("kafka-0.kafka, kafka-1.kafka:9092").bootstrapURIs)                .containsExactly("kafka-0.kafka:9092", "kafka-1.kafka:9092");    }
@Test    public void testHasPrevNull() throws Exception {        assertTrue(mMonth.hasPrev());    }
@Test	public void testGetReturnProperties() {		List<Property<?>> propertyList = Arrays.asList(			_tLiferayInputDefinition.getReturnProperties());		assertThat(propertyList, hasSize(2));		Assert.assertTrue(			propertyList.contains(				ComponentDefinition.RETURN_TOTAL_RECORD_COUNT_PROP));		Assert.assertTrue(			propertyList.contains(				ComponentDefinition.RETURN_ERROR_MESSAGE_PROP));	}
@Test	public void testItemSelectorURLWhenNotAllowBrowseAndNullWikiPage()		throws Exception {		setAllowBrowseDocuments(false);		setWikiPageResourcePrimKey(0);		JSONObject originalJSONObject =			getJSONObjectWithDefaultItemSelectorURL();		JSONObject jsonObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		WikiAttachmentImageHTMLEditorConfigContributor			wikiAttachmentImageHTMLEditorConfigContributor =				new WikiAttachmentImageHTMLEditorConfigContributor();		wikiAttachmentImageHTMLEditorConfigContributor.setItemSelector(			_itemSelector);		wikiAttachmentImageHTMLEditorConfigContributor.populateConfigJSONObject(			jsonObject, _inputEditorTaglibAttributes, null, null);		JSONObject expectedJSONObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		expectedJSONObject.put("removePlugins", "plugin1");		JSONAssert.assertEquals(			expectedJSONObject.toJSONString(), jsonObject.toJSONString(), true);	}
@Test  public void testReplaceVariables() throws Exception {    replayServices();    MediaPackageElementFlavor flavor = new MediaPackageElementFlavor("presenter", "delivery");    String expectedStreamName = MP_ID + "-" + CAPTURE_AGENT_NAME + "-presenter-delivery-stream-3840x1080_suffix";    String actualStreamName = service.replaceVariables(MP_ID, CAPTURE_AGENT_NAME, STREAM_NAME, flavor, "3840x1080");    Assert.assertEquals(expectedStreamName, actualStreamName);  }
@Test  public void testGetAllJobTypes() {    Configuration conf = new Configuration();    conf.addResource("tony-default.xml");    conf.setInt("tony.worker.instances", 3);    conf.setInt("tony.evaluator.instances", 1);    conf.setInt("tony.worker.gpus", 1);    conf.setInt("tony.evaluator.vcores", 2);    conf.setInt("tony.chief.gpus", 1);    assertEquals(Utils.getAllJobTypes(conf),            new HashSet(Arrays.asList("worker", "evaluator")));  }
@Test    public void testLinkPanelAction() {        JXDatePicker picker = new JXDatePicker();        JComponent linkPanel = picker.getLinkPanel();        assertLinkPanelBindings(linkPanel, true);    }
@Test    void shouldSupportAsLocalDate()    {        LocalDate localDate = LocalDate.now();        DateValue dateValue = new DateValue( localDate );        assertEquals( localDate, dateValue.asLocalDate() );    }
@Test	public void testConcatStrings() {		Assert.assertSame("test1", StringBundler.concat("test1"));		Assert.assertSame(			StringPool.NULL, StringBundler.concat(new String[] {null}));		Assert.assertEquals(			"test1test2", StringBundler.concat("test1", "test2"));		Assert.assertEquals("abcdef", StringBundler.concat("a", "bc", "def"));		Assert.assertEquals("abcdef", StringBundler.concat("abc", "de", "f"));		Assert.assertEquals(			"test1test2test3test4",			StringBundler.concat("test1", "test2", "test3", "test4"));	}
@Test    public void testGetIntervals() {        GraphStore store = getIntervalGraphStore();        Interval i1 = new Interval(1.0, 2.0);        Interval i2 = new Interval(3.0, 4.0);        NodeImpl node = new NodeImpl("0", store);        node.addInterval(i1);        node.addInterval(i2);        Assert.assertEquals(node.getIntervals(), new Interval[] { i1, i2 });        node.removeInterval(i1);        Assert.assertEquals(node.getIntervals(), new Interval[] { i2 });    }
@Test	public void testGetTabIndexActions() {		SearchAdminDisplayBuilder searchAdminDisplayBuilder =			new SearchAdminDisplayBuilder(				_language, _portal,				getRenderRequestWithSelectedTab("index-actions"),				new MockRenderResponse());		searchAdminDisplayBuilder.setIndexInformation(			Mockito.mock(IndexInformation.class));		SearchAdminDisplayContext searchAdminDisplayContext =			searchAdminDisplayBuilder.build();		Assert.assertEquals(			"index-actions", searchAdminDisplayContext.getSelectedTab());	}
@Test    void encodeString() {        assertThat(RedisEncodings.encode("value")).isEqualTo(Strings.bytes("value"));    }
@Test  public void testSetPdfAvailable() throws Exception {    assertTrue( roh.isPdfAvailable() );    roh.setPdfAvailable( false );    assertFalse( roh.isPdfAvailable() );  }
@Test    public void testDescendingSame() {        JComponent comp = new JLabel();        assertTrue("same component must be interpreted as descending",                 SwingXUtilities.isDescendingFrom(comp, comp));    }
@Test(expected = TermNotFoundException.class)    public void testGetKeywordWithLabelCantFind() throws Exception {        this.allThesaurus.getKeywordWithLabel("jkdjfdklsdj", "eng");    }
@Test    public void testGenerateKey() {        DocumentProtos.DocumentMetadata doc = MockDocumentMetadataFactory.createDocumentMetadata("A comparison of associated dsd sd");                Assert.assertEquals("cmaio", keyGen.generateKey(doc));    }
@Test  public void testBundleInfoJsonSerialization() {    final JsonPath p = JsonPath.from(bundleInfoJson(bundleInfo("host", "bundle", 1L, "version", some("sha"))).toJson());    run(BundleInfo.class, new BundleInfo() {      @Override      public String getHost() {        assertEquals("host", p.getString("host"));        return null;      }      @Override      public String getBundleSymbolicName() {        assertEquals("bundle", p.getString("bundleSymbolicName"));        return null;      }      @Override      public long getBundleId() {        assertEquals(1L, p.getLong("bundleId"));        return 0;      }      @Override      public String getBundleVersion() {        assertEquals("bundle", p.getString("bundleSymbolicName"));        return null;      }      @Override      public Option<String> getBuildNumber() {        assertEquals("sha", p.getString("buildNumber"));        return null;      }      @Override      public BundleVersion getVersion() {        assertEquals("sha", p.getString("buildNumber"));        return null;      }    });  }
@Test  public void testSaveFactReturnsSameEntity() {    FactEntity entity = createFact(createAndSaveFactType().getId());    assertSame(entity, getFactManager().saveFact(entity));  }
@Test	public void testPutandSave() throws IOException {		TypedProperties typedProperties = new TypedProperties();		typedProperties.put("testKey", "testValue");		_assertSave(typedProperties, "testKey = \"testValue\"");	}
@Test    public void setDownloadReportCommandNull() {        presenterSpy.setDownloadReportCommand(null);        assertNull(presenterSpy.downloadReportCommand);        assertTrue(downloadReportButtonMock.disabled);    }
@Test    void testRequirePositive3() {        assertThrows(RuntimeException.class, () -> IntRangeUtil.requirePositive(0, RuntimeException::new));    }
@Test	public void testMasterTokenAcquired() {		masterTokenAcquired();		assertReplicasChanged();	}
@Test    public void onChangeSettings() throws Exception {        presenter.onChangeSettings();        verify(view, times(1)).setTextAppearance(any(TextAppearance.class));        verify(view, times(1)).setReaderMode(any(ReaderWebView.Mode.class));        verify(view, times(1)).setKeepScreen(anyBoolean());        verify(view, times(1)).setCurrentOrientation(anyBoolean());        verify(view, times(1)).updateActivityMode();        verify(view).updateContent();    }
@Test  public void testRequestValidationFailsOnBlank() {    Set<ConstraintViolation<TraverseByObjectSearchRequest>> violations = getValidator().validate(new TraverseByObjectSearchRequest()            .setQuery(" ")    );    assertEquals(1, violations.size());    assertPropertyInvalid(violations, "query");  }
@Test    void testFormatTextBox() {        String text = "A AB ABC AB Abc ad skh sjh ajsh a aksjka ka sdja aVeryLongWordThatCertainlyWillOverflow bye";        int width = 10;        String tenChars            = "          ";        String expResult            = "A AB ABC\n"            + "AB Abc ad\n"            + "skh sjh\n"            + "ajsh a\n"            + "aksjka ka\n"            + "sdja\n"            + "aVeryLongWordThatCertainlyWillOverflow\n"            + "bye";        final String result = TextUtil.formatTextBox(text, width);        //System.out.println(result);        assertEquals(expResult, result);    }
@Test  public void testAuthenticationSuccessful() {    List<GrantedAuthority> grantedAuths = Arrays.<GrantedAuthority>asList(new SimpleGrantedAuthority("ROLE_USER"));    User user = new User("principal", CommonUtil.encryptPassword("principal", "credentials"), grantedAuths);        expect(mockAuthPropsConfig.isAuthFileEnabled()).andReturn(true);    expect(mockUserDetailsService.loadUserByUsername("principal")).andReturn(user);        replay(mockAuthPropsConfig, mockUserDetailsService);        Authentication authentication = new TestingAuthenticationToken("principal", "credentials");        Authentication authenticationResult = provider.authenticate(authentication);    assertEquals("principal", authenticationResult.getName());    assertEquals(CommonUtil.encryptPassword("principal", "credentials"), authenticationResult.getCredentials());    assertEquals(1, authenticationResult.getAuthorities().size());    assertEquals(new SimpleGrantedAuthority("ROLE_USER"), authenticationResult.getAuthorities().iterator().next());        verify(mockAuthPropsConfig, mockUserDetailsService);  }
@Test    void scheduleFixedRateTask() {        Duration rate = Duration.ofHours(1);        scheduler.schedule(new FixedRateTask("hourly-job", null, rate));        ArgumentCaptor<Runnable> scheduledTask = ArgumentCaptor.forClass(Runnable.class);        verify(schedulerExecutor).scheduleAtFixedRate(scheduledTask.capture(), anyLong(), eq(rate.toNanos()), eq(TimeUnit.NANOSECONDS));        scheduledTask.getValue().run();        verify(jobExecutor).submit((Callable<?>) any(Callable.class));    }
@Test  public void arrayContainingDifferentLengthLongsJson() throws LoadException {    // GIVEN    String json = "[ { \"a\": 1, \"c\": [4, 5, 6]}," + "{\"a\": 2, \"c\": [ 1 ] } ]";    // WHEN    TableShard tableShard =        Iterables.getOnlyElement(loader.load(0L, new BigByteBuffer(json.getBytes()), TABLE, colInfo));    // THEN    Assert.assertEquals(tableShard.getLongColumns().size(), 5, "Expected all long columns to be available");    Set<Pair<Long, List<Long>>> expectedValues = new HashSet<>();    expectedValues.add(new Pair<>(1L, Arrays.asList(new Long[] { 4L, 5L, 6L })));    expectedValues.add(new Pair<>(2L, Arrays.asList(new Long[] { 1L })));    Set<Pair<Long, List<Long>>> actualValues = new HashSet<>();    LongStandardColumnShard colA = tableShard.getLongColumns().get("a");    LongStandardColumnShard[] colC =        new LongStandardColumnShard[] { tableShard.getLongColumns().get(repeatedColNames.repeatedAtIndex("c", 0)),            tableShard.getLongColumns().get(repeatedColNames.repeatedAtIndex("c", 1)),            tableShard.getLongColumns().get(repeatedColNames.repeatedAtIndex("c", 2)) };    LongStandardColumnShard colCLength = tableShard.getLongColumns().get(repeatedColNames.repeatedLength("c"));    for (long i = tableShard.getLowestRowId(); i < tableShard.getLowestRowId()        + tableShard.getNumberOfRowsInShard(); i++) {      Long valueA = resolveSingleRowValue(colA, i);      List<Long> valueC = new ArrayList<>();      for (int c = 0; c < resolveSingleRowValue(colCLength, i); c++)        valueC.add(resolveSingleRowValue(colC[c], i));      actualValues.add(new Pair<>(valueA, valueC));    }    Assert.assertEquals(actualValues, expectedValues, "Expected correct values to be encoded");  }
@Test  public void testGetConfigurationValue() throws Exception {    Cluster cluster = createNiceMock(Cluster.class);    Config config = createNiceMock(Config.class);    Map<String, String> properties = new HashMap<String, String>();    properties.put("foo", "bar");    expect(cluster.getDesiredConfigByType("core-site")).andReturn(config).anyTimes();    expect(config.getProperties()).andReturn(properties).anyTimes();    replay(cluster, config);    ClusterImpl clusterImpl = new ClusterImpl(cluster);    Assert.assertEquals("bar", clusterImpl.getConfigurationValue("core-site", "foo"));    verify(cluster, config);  }
@Test    void intFunction() {        assertSingleParameter(IntFunction.class, Long.class, DefaultType::intFunction);    }
@Test  public void testGenerate() throws Exception {    ClassicEngineBoot.getInstance().start();    ReportListenerThreadHolder.clear();    xlsOutput.generate( new MasterReport(), 1, new ByteArrayOutputStream(), 1 );    verify( listener, times( 0 ) ).reportProcessingStarted( any( ReportProgressEvent.class ) );    verify( listener, times( 0 ) ).reportProcessingFinished( any( ReportProgressEvent.class ) );    verify( listener, times( 0 ) ).reportProcessingUpdate( any( ReportProgressEvent.class ) );  }
@Test  public void testIterateVerticesWithUuidIdSupportUsingVertex() {    Vertex vertex1 = createVertex();    Vertex vertex2 = getActGraph().vertices(vertex1).next();    assertEquals(vertex1.id(), vertex2.id());  }
@Test  public void testColumnRangeFilterWithASingleFamily_openStart() throws IOException {    ColumnRangeFilter filter = new ColumnRangeFilter(null, true, Bytes.toBytes("b"), false);    Scan familyScan = new Scan().addFamily(Bytes.toBytes("foo"));    Filters.Filter expectedFilter =        filterAdapter.adapt(new FilterAdapterContext(familyScan, null), filter);    ColumnRange columnRange = expectedFilter.toProto().getColumnRangeFilter();    Assert.assertEquals(0, columnRange.getStartQualifierClosed().size());    Assert.assertEquals(0, columnRange.getStartQualifierOpen().size());    Assert.assertEquals("b", toString(columnRange.getEndQualifierOpen()));    Assert.assertEquals(0, columnRange.getEndQualifierClosed().size());  }
@Test    void testRequireEquals9() {        assertThrows(RuntimeException.class, () -> LongRangeUtil.requireEquals(-1,1, RuntimeException::new));    }
@Test    public void testGenerateColumnWhenColumnIsNotNewAndVetoed() throws Exception {        doReturn(false).when(plugin).isNewColumn();        doThrow(VetoUpdatePatternInUseException.class).when(presenter).updateColumn(any(BRLConditionColumn.class),                                                                                    any(BRLConditionColumn.class));        assertFalse(plugin.generateColumn());        verify(wizard).showPatternInUseError();    }
@Test	public void testReplacesImageTagsWithSingleQuotes() throws Exception {		Assert.assertEquals(			_CONTENT_PREFIX + "[REPLACED]" + _CONTENT_SUFFIX,			_contentTransformer.transform(				_CONTENT_WITH_IMAGE_AND_SINGLE_QUOTES));	}
@Test    public void equalsSymmetric() throws Exception {        AttributeKey<Number> key1 = new AttributeKey<Number>(Number.class, "keyName");        AttributeKey<Number> key2 = new AttributeKey<Number>(Number.class, "keyName");        assertThat(key1.equals(key2), is(true));        assertThat(key2.equals(key1), is(true));    }
@Test(expected = AmbariApiException.class)  public void shouldCheckForEmptyATSUrlInCustomConfig() {    ViewContext viewContext = getViewContext(new HashMap<String, String>());    AmbariApi ambariApi = createNiceMock(AmbariApi.class);    expect(ambariApi.isClusterAssociated()).andReturn(false);    replay(viewContext);    Services services = new Services(ambariApi, viewContext);    services.getTimelineServerUrl();  }
@Test    public void defaultRateShouldBeOne() throws Exception {        assertThat(defaultConversionInformation(EUR), hasRate(equalTo(BigDecimal.ONE)));    }
@Test    public void shouldSucceedWhenIgnoringCase() throws Exception {        EnumListValidator enumListValidator = createAndInitializeValidator(true, false);        boolean valid = enumListValidator.isValid(Collections.singletonList("Foo"), createContext());        assertThat(valid, is(true));    }
@Test    public void testCreateElementForExternalContainmentType() throws Exception {        Payload partInfo = new Payload();        addOptionalAttributesToPartInfo(partInfo);        // check attachment        partInfo.setContainment(IPayload.Containment.EXTERNAL);        String payloadURI = "path_to_file";        partInfo.setPayloadURI(payloadURI);        OMElement piElement = PartInfoElement.createElement(plElement, partInfo);        assertNotNull(piElement);        // check the presence of the href attribute        assertEquals(payloadURI,                piElement.getAttribute(new QName("href")).getAttributeValue());        checkPresenceOfOptionalOMElements(piElement);    }
@Test  public void testRun()  {    LocalMode lma = LocalMode.newInstance();    DAG dag = lma.getDAG();    RomeSyndicationOperator rop = dag.addOperator("romesyndication", RomeSyndicationOperator.class);    FeedCollector fc = dag.addOperator("feedcollector", FeedCollector.class);    dag.addStream("ss", rop.outputPort, fc.input);    rop.setInterval(2000);    //rop.setLocation("http://rss.cnn.com/rss/cnn_topstories.rss");    rop.setStreamProvider(new CNNSyndicationTestProvider());    try {      LocalMode.Controller lc = lma.getController();      lc.setHeartbeatMonitoringEnabled(false);      lc.run(10000);      Assert.assertEquals("Entries size", entries.size(), 10);      // Check first entry      Assert.assertEquals("First entry title", entries.get(0).getSyndEntry().getTitle(), "Dimensions Computation (Aggregate Navigator) Part 1: Intro");      Assert.assertEquals("First entry URI", entries.get(0).getSyndEntry().getUri(), "https://www.datatorrent.com/?p=2399");      // Check first entry from second run      Assert.assertEquals("Second run first entry title", entries.get(7).getSyndEntry().getTitle(), "Building Applications with Apache Apex and Malhar");      Assert.assertEquals("Second run first entry URI", entries.get(7).getSyndEntry().getUri(), "https://www.datatorrent.com/?p=2054");      // Check last entry      Assert.assertEquals("Last entry title", entries.get(9).getSyndEntry().getTitle(), "Dimensions Computation (Aggregate Navigator) Part 2: Implementation");      Assert.assertEquals("Last entry URI", entries.get(9).getSyndEntry().getUri(), "https://www.datatorrent.com/?p=2401");    } catch (Exception ex) {      logger.error(ex.getMessage());      Assert.assertFalse(true);    }  }
@Test    public void testPrintFontB() throws Exception {        //Before        final Printer printer = TextPrinterBuilder                .aPrinterBuilder()                .withTextControlSequence( DeviceFont.DEVICE_FONT_B )                .buildPrinter( "test" );        //When        final byte[] command = printer.getCommand();        //Then        Assert.assertEquals( "[8, 77, 0, 66, 116, 101, 115, 116, 10, 0]", Arrays.toString( command ) );    }
@Test  public void testCreateCollectionWhenCollectionExists() throws Exception {    // GIVEN    NamedList<Object> namedList = new NamedList<>();    namedList.add("collections", Arrays.asList("collection2", "collection3"));    expect(mockedSolrClient.request(anyObject(CollectionAdminRequest.class), anyString())).andReturn(namedList).times(2);    replay(mockedSolrClient);    // WHEN    String result = underTest.createCollection();    // THEN    assertEquals("collection1", result);    verify(mockedSolrClient);  }
@Test(expectedExceptions = IllegalArgumentException.class)    public void testParseInfinityBadIntervalsOverlapping() {        IntervalsParser.parseIntervalSet("[-Infinity, 0.0]; [-3.0, 1.0]");// Overlapping    }
@Test    void shouldReturnNoErrorWhenNoCursorStages()    {        ResultCursorsHolder holder = new ResultCursorsHolder();        Throwable error = await( holder.retrieveNotConsumedError() );        assertNull( error );    }
@Test  public void earlyCloseOfAvailableConnections() throws ConnectionException, InterruptedException, IOException {    initPool(Integer.MAX_VALUE, //        1, // Only 1 connection simultaneously        Integer.MAX_VALUE, //        .95);    TestConnection<ClusterManagementService.Iface> conn = (TestConnection<ClusterManagementService.Iface>) pool        .reserveConnection(ClusterManagementService.Iface.class, ADDR1, null);    int connId = conn.getId();    Assert.assertEquals(conn.getServiceInfo().getServiceInterface(), ClusterManagementService.Iface.class,        "Correct service expected");    conn.close(); // release connection    // request a connection to another host (so it won't get re-used), which in our case should NOT be blocked, as the    // pool should reach the "early close" level and close the first connection right away without waiting for it to    // timeout.    TestConnection<ClusterManagementService.Iface> conn2 = (TestConnection<ClusterManagementService.Iface>) pool        .reserveConnection(ClusterManagementService.Iface.class, ADDR2, null);    conn2.close();    // ensure that the "close" method on the first connection was called    Mockito.verify(conn.getTransport()).close();    Assert.assertNotEquals(conn2.getId(), connId, "Expected that connection was not re-used, as first "        + "connection should have been closed before the second was opened");    Assert.assertEquals(conn2.getServiceInfo().getServiceInterface(), ClusterManagementService.Iface.class,        "Correct service expected");  }
@Test  public void testProviderWithUnseededObjectCachesResolvedObject() {    when(unscopedProvider.get()).thenReturn(seed);    executeInsideScope(() -> {      assertSame(scope.scope(key, unscopedProvider).get(), scope.scope(key, unscopedProvider).get());      verify(unscopedProvider, times(1)).get();    });  }
@Test(description = "This test case tests handling FeatureManagementException when updating profile features",          dependsOnMethods = "testUpdateProfileFeatures",          expectedExceptions = {FeatureManagementException.class})    public void testUpdateProfileFeaturesThrowingFeatureManagementException() throws Exception {        String newFeatureCode = "C002";        int nonExistentProfileId = 9999;        profileFeaturesList1.get(0).setFeatureCode(newFeatureCode);        List<ProfileFeature> updatedProfileFeatures = featureManager.updateProfileFeatures(profileFeaturesList1,                                                                                           nonExistentProfileId);        Assert.assertEquals(updatedProfileFeatures.get(0).getFeatureCode(), newFeatureCode);    }
@Test  public void testGenerateListener() throws Exception {    ClassicEngineBoot.getInstance().start();    csvOutput.generate( new MasterReport(), 1, new ByteArrayOutputStream(), 1 );    verify( listener, times( 1 ) ).reportProcessingStarted( any( ReportProgressEvent.class ) );    verify( listener, times( 1 ) ).reportProcessingFinished( any( ReportProgressEvent.class ) );    verify( listener, atLeastOnce() ).reportProcessingUpdate( any( ReportProgressEvent.class ) );  }
@Test    public void testGetPathsCollectionOfFile()    {        assertThat( PathUtil.paths( (Collection<File>) null ), nullValue() );        assertThat( PathUtil.paths( Arrays.asList( f1, f2 ) ), equalTo( new String[] { _PATH, ABSOLUTE_PATH } ) );    }
@Test    public void testDayGridPositionAtLocationFirstColumnRToL() {        // This test will not work in a headless configuration.        if (GraphicsEnvironment.isHeadless()) {            LOG.fine("cannot run test - headless environment");            return;        }        BasicMonthViewUI ui = getRealizedMonthViewUI(ComponentOrientation.RIGHT_TO_LEFT);        Point location = getLocationInColumn(ui, BasicMonthViewUI.DAYS_IN_WEEK - 1);        Point dayGridPosition = ui.getDayGridPositionAtLocation(location.x, location.y);         assertEquals("last logical column in RToL", BasicMonthViewUI.FIRST_DAY_COLUMN,                 dayGridPosition.x);     }
@Test    void shouldNotAllowBasicAuthTokenWithNullPassword()    {        NullPointerException e = assertThrows( NullPointerException.class, () -> AuthTokens.basic( "username", null ) );        assertEquals( "Password can't be null", e.getMessage() );    }
@Test    public void testOSNPE() {        String oldProperty = System.getProperty("os.name");        try {            if (oldProperty != null) {                System.clearProperty("os.name");                assertNull(System.getProperty("os.name"));            }            OS.isLinux();                    } finally {            if (oldProperty != null) {                System.setProperty("os.name", oldProperty);                assertEquals(oldProperty, System.getProperty("os.name"));            }        }    }
@Test	public void testEndpointsWithoutSubsetsAllNamespaces() {		EndpointsList endpoints = createSingleEndpointEndpointListWithoutSubsets();		when(this.endpointsOperation.list()).thenReturn(endpoints);		when(this.kubernetesClient.endpoints()).thenReturn(this.endpointsOperation);		when(this.kubernetesClient.endpoints().inAnyNamespace()).thenReturn(this.endpointsOperation);		when(this.kubernetesClient.endpoints().inAnyNamespace().withLabels(anyMap()))				.thenReturn(this.endpointsOperation);		this.underTest.catalogServicesWatch();		// second execution on shuffleServices		this.underTest.catalogServicesWatch();		verify(this.applicationEventPublisher).publishEvent(any(HeartbeatEvent.class));	}
@Test	public void initialContextInfo_XML2JAVA()	{		try {			String INITIAL_CONTEXT_XML = "<initialContextInfo>" +								"<contextProperty value=\"value1\" name=\"name1\"/>" +								"<contextProperty value=\"value2\" name=\"name2\"/>" +							 "</initialContextInfo>";						StringReader reader = new StringReader(INITIAL_CONTEXT_XML);			JAXBContext jc = JAXBContext.newInstance(InitialContextInfo.class);			Unmarshaller um = jc.createUnmarshaller();			InitialContextInfo icInfo = (InitialContextInfo)  um.unmarshal(new StreamSource(reader), InitialContextInfo.class).getValue();			assertEquals("name1", icInfo.getContextProperty().get(0).getName());			assertEquals("name2", icInfo.getContextProperty().get(1).getName());			assertEquals("value2", icInfo.getContextProperty().get(1).getValue());		} catch (JAXBException jaxbe) {			jaxbe.printStackTrace();			fail("No exception should be thrown");		}	}
@Test  public void testWithAclAddsEntryToExistingAcl() {    UUID subjectID = UUID.randomUUID();    FactRecord fact = new FactRecord().addAclEntry(new FactAclEntryRecord().setSubjectID(UUID.randomUUID()));    fact = withAcl(fact, UUID.randomUUID(), list(subjectID));    assertEquals(2, fact.getAcl().size());  }
@Test(expectedExceptions = RuntimeException.class,      expectedExceptionsMessageRegExp = ".*amount of " + Constants.GPUS + ".*requested exceeds.*")  public void testValidateTonyConfTooManyGpus() {    Configuration conf = new Configuration();    conf.setInt(TonyConfigurationKeys.getResourceKey(Constants.WORKER_JOB_NAME, Constants.GPUS), 1);    conf.setInt(TonyConfigurationKeys.getInstancesKey(Constants.WORKER_JOB_NAME), 10);    conf.setInt(TonyConfigurationKeys.getMaxTotalResourceKey(Constants.GPUS), 5);    TonyClient.validateTonyConf(conf);  }
@Test  public void testGetPluralName() throws Exception {    PrivilegeResourceDefinition privilegeResourceDefinition = new PrivilegeResourceDefinition(Resource.Type.AmbariPrivilege);    Assert.assertEquals("privileges", privilegeResourceDefinition.getPluralName());  }
@Test  public void testHasWarnings() throws Exception {    Warning firstWarning = new Warning(null, "Message 1", null, null);    firstWarning.file = new File("File1.java");    firstWarning.line = 8;    Warning secondWarning = new Warning(null, "Message 2", null, null);    secondWarning.file = new File("File2.xml");    secondWarning.line = 14;    List<Warning> lintResult = Arrays.asList(firstWarning, secondWarning);    WarningAssert.assertThat(lintResult)        .hasWarnings(2)        .in("File1.java", "File2.xml")        .atLine(8, 14)        .withMessage("Message 1", "Message 2");  }
@Test    public void getScenarioGridPanelByGridWidget() {        assertEquals(scenarioGridPanelMock, scenarioSimulationContextLocal.getScenarioGridPanelByGridWidget(GridWidget.SIMULATION));        assertEquals(backgroundGridPanelMock, scenarioSimulationContextLocal.getScenarioGridPanelByGridWidget(GridWidget.BACKGROUND));    }
@Test    public void testHasTestMethodKeywordEmptyModifiersChildrenList() {        AstNode parentNode = mock(AstNode.class);        when(parentNode.getChildren(MODIFIERS)).thenReturn(new LinkedList<>());        assertFalse(MethodChecksUtils.hasTestMethodKeyword(parentNode));    }
@Test(description = "Testing getting device location when unable to retrieve location")    public void testGetDeviceLocationException() throws DeviceDetailsMgtException {        DeviceInformationManager deviceInformationManager = Mockito                .mock(DeviceInformationManagerImpl.class, Mockito.RETURNS_MOCKS);        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceInformationManagerService")).                toReturn(deviceInformationManager);        Mockito.when(deviceInformationManager.getDeviceLocation(Mockito.any(DeviceIdentifier.class)))                .thenThrow(new DeviceDetailsMgtException());        Response response = this.deviceManagementService                .getDeviceLocation(TEST_DEVICE_TYPE, UUID.randomUUID().toString(), null);        Assert.assertEquals(response.getStatus(), Response.Status.INTERNAL_SERVER_ERROR.getStatusCode());    }
@Test    public void testTrackingTrue() {        assertTrue(LookAndFeelAddons.isTrackingLookAndFeelChanges());    }
@Test  public void testSupportsVideographerToken() {    BaseAuthenticationToken baseAuthenticationToken =        new VideographerAuthenticationToken("127.0.0.1", mock(SecurityLogger.class));    boolean supports = videographerRealm.supports(baseAuthenticationToken);    assertTrue(supports);  }
@Test	public void testValidLoginUser(){		when(userRepository.findByEmailAndPassword(user.getEmail(), user.getPassword())).thenReturn(user);		assertEquals(user, userService.loginUser(user));	}
@Test(description = "This test case tests the behaviour of the Service Component when there is a possible "            + "exception")    public void testActivateWithException() {        DeviceTypeExtensionServiceComponent deviceTypeExtensionServiceComponent = new                DeviceTypeExtensionServiceComponent();        deviceTypeExtensionServiceComponent.activate(null);    }
@Test	public void fromV3_00ToV3_10() {		XfsVersionRange range = new XfsVersionRange(XfsVersion.V3_00, XfsVersion.V3_10);		Assert.assertFalse(range.contains(XfsVersion.V2_00));		Assert.assertTrue(range.contains(XfsVersion.V3_00));		Assert.assertTrue(range.contains(XfsVersion.V3_10));		Assert.assertFalse(range.contains(XfsVersion.V3_20));	}
@Test  public void testEncode2() {    scrambledPasswordHexStr = "cc93fb6f68af2e9446dafc0a1667d015b0a49550";    challenge = new byte[]{      // part1      0x42, 0x0f, 0x34, 0x68, 0x6f, 0x77, 0x67, 0x18,      // part2      0x14, 0x57, 0x3d, 0x04, 0x39, 0x70, 0x1f, 0x46, 0x58, 0x51, 0x49, 0x31};    assertEquals(scrambledPasswordHexStr, StringUtil.toHexString(Native41Authenticator.encode(PASSWORD, challenge)));  }
@Test  public void testGetResources() throws Exception{    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());    Set<String> propertyIds = new HashSet<String>();    propertyIds.add(PropertyHelper.getPropertyId("c1", "p1"));    propertyIds.add(PropertyHelper.getPropertyId("c1", "p3"));    Request request = PropertyHelper.getReadRequest(propertyIds);    Iterable<Resource> iterable = controller.getResourceIterable(Resource.Type.Host, request, null);    int cnt = 0;    for (Resource resource : iterable) {      Assert.assertEquals(Resource.Type.Host, resource.getType());      ++cnt;    }    Assert.assertEquals(4, cnt);  }
@Test    void get13Test() {        assertEquals(13, (int) instance.get13().orElseThrow(NoSuchElementException::new));    }
@Test    void constructor() {        final LicenseTerm licenseTerm = new LicenseTermImpl(TEXT);        assertEquals(TEXT, licenseTerm.getText());    }
@Test    void shouldExtractServerVersion()    {        Map<String,Value> metadata = singletonMap( "server", value( "Neo4j/3.5.0" ) );        ServerVersion version = extractNeo4jServerVersion( metadata );        assertEquals( ServerVersion.v3_5_0, version );    }
@Test  public void testOozieConfigClusterUpdateHAEnabledSpecifyingHostNamesDirectly() throws Exception {    final String expectedHostName = "c6401.apache.ambari.org";    final String expectedHostNameTwo = "c6402.ambari.apache.org";    final String expectedExternalHost = "c6408.ambari.apache.org";    final String expectedHostGroupName = "host_group_1";    final String expectedHostGroupNameTwo = "host_group_2";    Map<String, Map<String, String>> configProperties = new HashMap<String, Map<String, String>>();    Map<String, String> oozieSiteProperties = new HashMap<String, String>();    Map<String, String> oozieEnvProperties = new HashMap<String, String>();    Map<String, String> coreSiteProperties = new HashMap<String, String>();    configProperties.put("oozie-site", oozieSiteProperties);    configProperties.put("oozie-env", oozieEnvProperties);    configProperties.put("hive-env", oozieEnvProperties);    configProperties.put("core-site", coreSiteProperties);    oozieSiteProperties.put("oozie.base.url", expectedHostName);    oozieSiteProperties.put("oozie.authentication.kerberos.principal", expectedHostName);    oozieSiteProperties.put("oozie.service.HadoopAccessorService.kerberos.principal", expectedHostName);    oozieSiteProperties.put("oozie.service.JPAService.jdbc.url", "jdbc:mysql://" + expectedExternalHost + "/ooziedb");    // simulate the Oozie HA configuration    oozieSiteProperties.put("oozie.services.ext",        "org.apache.oozie.service.ZKLocksService,org.apache.oozie.service.ZKXLogStreamingService,org.apache.oozie.service.ZKJobsConcurrencyService,org.apache.oozie.service.ZKUUIDService");    oozieEnvProperties.put("oozie_existing_mysql_host", expectedExternalHost);    coreSiteProperties.put("hadoop.proxyuser.oozie.hosts", expectedHostName + "," + expectedHostNameTwo);    Configuration clusterConfig = new Configuration(configProperties, Collections.<String, Map<String, Map<String, String>>>emptyMap());    Collection<String> hgComponents = new HashSet<String>();    hgComponents.add("OOZIE_SERVER");    TestHostGroup group1 = new TestHostGroup(expectedHostGroupName, hgComponents, Collections.singleton("host1"));    Collection<String> hgComponents2 = new HashSet<String>();    hgComponents2.add("OOZIE_SERVER");    TestHostGroup group2 = new TestHostGroup(expectedHostGroupNameTwo, hgComponents2, Collections.singleton("host2"));    Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>();    hostGroups.add(group1);    hostGroups.add(group2);    expect(stack.getCardinality("OOZIE_SERVER")).andReturn(new Cardinality("1+")).anyTimes();    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor updater = new BlueprintConfigurationProcessor(topology);    updater.doUpdateForClusterCreate();    assertEquals("oozie property not updated correctly",        expectedHostName, oozieSiteProperties.get("oozie.base.url"));    assertEquals("oozie property not updated correctly",        expectedHostName, oozieSiteProperties.get("oozie.authentication.kerberos.principal"));    assertEquals("oozie property not updated correctly",        expectedHostName, oozieSiteProperties.get("oozie.service.HadoopAccessorService.kerberos.principal"));    assertEquals("oozie property not updated correctly",        expectedHostName + "," + expectedHostNameTwo, coreSiteProperties.get("hadoop.proxyuser.oozie.hosts"));  }
@Test  public void testGetResourcesFromCommonServices() throws Exception {    Resource.Type type = Resource.Type.ClientConfig;    AmbariManagementController managementController = createNiceMock(AmbariManagementController.class);    Clusters clusters = createNiceMock(Clusters.class);    Cluster cluster = createNiceMock(Cluster.class);    AmbariMetaInfo ambariMetaInfo = createNiceMock(AmbariMetaInfo.class);    StackId stackId = createNiceMock(StackId.class);    ComponentInfo componentInfo = createNiceMock(ComponentInfo.class);    ServiceInfo serviceInfo = createNiceMock(ServiceInfo.class);    CommandScriptDefinition commandScriptDefinition = createNiceMock(CommandScriptDefinition.class);    Config clusterConfig = createNiceMock(Config.class);    DesiredConfig desiredConfig = createNiceMock(DesiredConfig.class);    Host host = createNiceMock(Host.class);    Service service = createNiceMock(Service.class);    ServiceComponent serviceComponent = createNiceMock(ServiceComponent.class);    ServiceComponentHost serviceComponentHost = createNiceMock(ServiceComponentHost.class);    ServiceOsSpecific serviceOsSpecific = createNiceMock(ServiceOsSpecific.class);    ConfigHelper configHelper = createNiceMock(ConfigHelper.class);    Configuration configuration = PowerMock.createStrictMockAndExpectNew(Configuration.class);    Map<String, String> configMap = createNiceMock(Map.class);    File mockFile = PowerMock.createNiceMock(File.class);    Runtime runtime = createMock(Runtime.class);    Process process = createNiceMock(Process.class);    Map<String, DesiredConfig> desiredConfigMap = new HashMap<String, DesiredConfig>();    desiredConfigMap.put("hive-site", desiredConfig);    Map<String, Map<String, String>> allConfigTags = new HashMap<String, Map<String, String>>();    Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();    Map<String, Map<String, String>> configTags = new HashMap<String,            Map<String, String>>();    Map<String, Map<String, Map<String, String>>> attributes = new HashMap<String,            Map<String, Map<String, String>>>();    ClientConfigFileDefinition clientConfigFileDefinition = new ClientConfigFileDefinition();    clientConfigFileDefinition.setDictionaryName("pig-env");    clientConfigFileDefinition.setFileName("pig-env.sh");    clientConfigFileDefinition.setType("env");    List <ClientConfigFileDefinition> clientConfigFileDefinitionList = new LinkedList<ClientConfigFileDefinition>();    clientConfigFileDefinitionList.add(clientConfigFileDefinition);    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(        type,        PropertyHelper.getPropertyIds(type),        PropertyHelper.getKeyPropertyIds(type),        managementController);    // create the request    Request request = PropertyHelper.getReadRequest(ClientConfigResourceProvider.COMPONENT_CLUSTER_NAME_PROPERTY_ID, "c1",        ClientConfigResourceProvider.COMPONENT_COMPONENT_NAME_PROPERTY_ID,        ClientConfigResourceProvider.COMPONENT_SERVICE_NAME_PROPERTY_ID);    Predicate predicate = new PredicateBuilder().property(ClientConfigResourceProvider.COMPONENT_CLUSTER_NAME_PROPERTY_ID).      equals("c1").and().property(ClientConfigResourceProvider.COMPONENT_COMPONENT_NAME_PROPERTY_ID).equals("PIG").      and().property(ClientConfigResourceProvider.COMPONENT_SERVICE_NAME_PROPERTY_ID).equals("PIG").      toPredicate();    String clusterName = "C1";    String serviceName = "PIG";    String componentName = "PIG";    String displayName = "Pig Client";    String hostName = "Host100";    String publicHostName = "Host100";    String desiredState = "INSTALLED";    String stackName = "S1";    String stackVersion = "V1";    String stackRoot="/tmp/stacks/S1/V1";    String packageFolder= StackManager.COMMON_SERVICES + "/PIG/package";    String commonServicesPath = "/var/lib/ambari-server/src/main/resources" + File.separator + "common-services";    if (System.getProperty("os.name").contains("Windows")) {      stackRoot = "C:\\tmp\\stacks\\S1\\V1";      packageFolder = StackManager.COMMON_SERVICES + "\\PIG\\package";    }    HashMap<String, Host> hosts = new HashMap<String, Host>();    hosts.put(hostName, host);    HashMap<String, Service> services = new HashMap<String, Service>();    services.put(serviceName,service);    HashMap<String, ServiceComponent> serviceComponentMap = new HashMap<String, ServiceComponent>();    serviceComponentMap.put(componentName,serviceComponent);    HashMap<String, ServiceComponentHost> serviceComponentHosts = new HashMap<String, ServiceComponentHost>();    serviceComponentHosts.put(componentName, serviceComponentHost);    HashMap<String, ServiceOsSpecific> serviceOsSpecificHashMap = new HashMap<String, ServiceOsSpecific>();    serviceOsSpecificHashMap.put("key",serviceOsSpecific);    ServiceComponentHostResponse shr1 = new ServiceComponentHostResponse(clusterName, serviceName, componentName, displayName, hostName, publicHostName, desiredState, "", null, null, null);    Set<ServiceComponentHostResponse> responses = new LinkedHashSet<ServiceComponentHostResponse>();    responses.add(shr1);    Map<String, String> returnConfigMap = new HashMap<String, String>();    returnConfigMap.put(Configuration.SERVER_TMP_DIR.getKey(), Configuration.SERVER_TMP_DIR.getDefaultValue());    returnConfigMap.put(Configuration.AMBARI_PYTHON_WRAP.getKey(), Configuration.AMBARI_PYTHON_WRAP.getDefaultValue());    // set expectations    expect(managementController.getConfigHelper()).andReturn(configHelper);    expect(managementController.getAmbariMetaInfo()).andReturn(ambariMetaInfo).anyTimes();    expect(managementController.getClusters()).andReturn(clusters).anyTimes();    expect(clusters.getCluster(clusterName)).andReturn(cluster).anyTimes();    expect(configHelper.getEffectiveConfigProperties(cluster, configTags)).andReturn(properties);    expect(configHelper.getEffectiveConfigAttributes(cluster, configTags)).andReturn(attributes);    expect(configMap.get(Configuration.SERVER_TMP_DIR.getKey())).andReturn(Configuration.SERVER_TMP_DIR.getDefaultValue());    expect(configMap.get(Configuration.AMBARI_PYTHON_WRAP.getKey())).andReturn(Configuration.AMBARI_PYTHON_WRAP.getDefaultValue());    expect(configuration.getConfigsMap()).andReturn(returnConfigMap);    expect(configuration.getResourceDirPath()).andReturn("/var/lib/ambari-server/src/main/resources");    expect(configuration.getJavaVersion()).andReturn(8);    expect(configuration.areHostsSysPrepped()).andReturn("false");    expect(configuration.isAgentStackRetryOnInstallEnabled()).andReturn("false");    expect(configuration.getAgentStackRetryOnInstallCount()).andReturn("5");    expect(configuration.getExternalScriptThreadPoolSize()).andReturn(Configuration.THREAD_POOL_SIZE_FOR_EXTERNAL_SCRIPT.getDefaultValue());    expect(configuration.getExternalScriptTimeout()).andReturn(Configuration.EXTERNAL_SCRIPT_TIMEOUT.getDefaultValue());    Map<String,String> props = new HashMap<String, String>();    props.put("key","value");    expect(clusterConfig.getProperties()).andReturn(props);    expect(configHelper.getEffectiveDesiredTags(cluster, null)).andReturn(allConfigTags);    expect(cluster.getClusterName()).andReturn(clusterName);    expect(managementController.getHostComponents(EasyMock.<Set<ServiceComponentHostRequest>>anyObject())).andReturn(responses).anyTimes();    expect(cluster.getCurrentStackVersion()).andReturn(stackId);    PowerMock.mockStaticPartial(StageUtils.class, "getClusterHostInfo");    Map<String, Set<String>> clusterHostInfo = new HashMap<String, Set<String>>();    Set<String> all_hosts = new HashSet<String>(Arrays.asList("Host100","Host101","Host102"));    Set<String> some_hosts = new HashSet<String>(Arrays.asList("0-1","2"));    Set<String> ohter_hosts = new HashSet<String>(Arrays.asList("0,1"));    Set<String> clusterHostTypes = new HashSet<String>(Arrays.asList("nm_hosts", "hs_host",            "namenode_host", "rm_host", "snamenode_host", "slave_hosts", "zookeeper_hosts"));    for (String hostTypes: clusterHostTypes) {      if (hostTypes.equals("slave_hosts")) {        clusterHostInfo.put(hostTypes, ohter_hosts);      } else {        clusterHostInfo.put(hostTypes, some_hosts);      }    }    Map<String, Host> stringHostMap = new HashMap<String, Host>();    stringHostMap.put(hostName, host);    clusterHostInfo.put("all_hosts",all_hosts);    expect(StageUtils.getClusterHostInfo(cluster)).andReturn(clusterHostInfo);    expect(stackId.getStackName()).andReturn(stackName).anyTimes();    expect(stackId.getStackVersion()).andReturn(stackVersion).anyTimes();    expect(ambariMetaInfo.getComponent(stackName, stackVersion, serviceName, componentName)).andReturn(componentInfo);    expect(ambariMetaInfo.getService(stackName, stackVersion, serviceName)).andReturn(serviceInfo);    expect(serviceInfo.getServicePackageFolder()).andReturn(packageFolder);    expect(ambariMetaInfo.getComponent((String) anyObject(), (String) anyObject(),            (String) anyObject(), (String) anyObject())).andReturn(componentInfo).anyTimes();    expect(componentInfo.getCommandScript()).andReturn(commandScriptDefinition);    expect(componentInfo.getClientConfigFiles()).andReturn(clientConfigFileDefinitionList);    expect(cluster.getConfig("hive-site", null)).andReturn(clusterConfig);    expect(clusterConfig.getType()).andReturn("hive-site").anyTimes();    expect(cluster.getDesiredConfigs()).andReturn(desiredConfigMap);    expect(clusters.getHost(hostName)).andReturn(host);    HashMap<String, String> rcaParams = new HashMap<String, String>();    rcaParams.put("key","value");    expect(managementController.getRcaParameters()).andReturn(rcaParams).anyTimes();    expect(ambariMetaInfo.getService(stackName, stackVersion, serviceName)).andReturn(serviceInfo);    expect(serviceInfo.getOsSpecifics()).andReturn(new HashMap<String, ServiceOsSpecific>()).anyTimes();    Set<String> userSet = new HashSet<String>();    userSet.add("hdfs");    expect(configHelper.getPropertyValuesWithPropertyType(stackId, PropertyInfo.PropertyType.USER, cluster, desiredConfigMap)).andReturn(userSet);    PowerMock.expectNew(File.class, new Class<?>[]{String.class}, anyObject(String.class)).andReturn(mockFile).anyTimes();    PowerMock.createNiceMockAndExpectNew(PrintWriter.class, anyObject());    expect(mockFile.getParent()).andReturn("");    PowerMock.mockStatic(Runtime.class);    expect(mockFile.exists()).andReturn(true);    String commandLine = "ambari-python-wrap " + commonServicesPath + "/PIG/package/null generate_configs null " +            commonServicesPath + "/PIG/package /var/lib/ambari-server/tmp/structured-out.json " +            "INFO /var/lib/ambari-server/tmp";    if (System.getProperty("os.name").contains("Windows")) {      commandLine = "ambari-python-wrap " + commonServicesPath +              "\\PIG\\package\\null generate_configs null " +              commonServicesPath + "\\PIG\\package /var/lib/ambari-server/tmp\\structured-out.json " +              "INFO /var/lib/ambari-server/tmp";    }    ProcessBuilder processBuilder = PowerMock.createNiceMock(ProcessBuilder.class);    PowerMock.expectNew(ProcessBuilder.class,Arrays.asList(commandLine.split("\\s+"))).andReturn(processBuilder).once();    expect(processBuilder.start()).andReturn(process).once();    InputStream inputStream = new ByteArrayInputStream("some logging info".getBytes());    expect(process.getInputStream()).andReturn(inputStream);    // replay    replay(managementController, clusters, cluster, ambariMetaInfo, stackId, componentInfo, commandScriptDefinition,            clusterConfig, host, service, serviceComponent, serviceComponentHost, serviceInfo, configHelper,            runtime, process, configMap);    PowerMock.replayAll();    Set<Resource> resources = provider.getResources(request, predicate);    assertFalse(resources.isEmpty());    // verify    verify(managementController, clusters, cluster, ambariMetaInfo, stackId, componentInfo,commandScriptDefinition,            clusterConfig, host, service, serviceComponent, serviceComponentHost, serviceInfo, configHelper,            runtime, process);    PowerMock.verifyAll();  }
@Test  public void testToMap() {    ContextTransformer transformer = createStrictMock(ContextTransformer.class);    expect(transformer.getKey()).andReturn("data").times(1);    replayAll();    ContainsPredicate predicate = new ContainsPredicate(transformer, "ONE");    Map<String, Object> actualMap = predicate.toMap();    verifyAll();    Map<String, Object> expectedMap = new HashMap<String, Object>();    expectedMap.put("contains", new ArrayList<String>(Arrays.asList("data", "ONE")));    Assert.assertEquals(expectedMap, actualMap);  }
@Test	    public void TC_getXMLFil2e()	    {	        try	        {	            OKW_XmlReader myXlReader = new OKW_XmlReader("/xml/OKW_Ini.xml");	            String Actuell = myXlReader.getXMLFile();	            assertEquals("Ein Wert wird erwartet:", "/xml/OKW_Ini.xml", Actuell);	        }	        catch (JAXBException | ParserConfigurationException | SAXException | IOException e)	        {	            fail(e.getMessage());	        }	    }
@Test  public void testGetStagingMode() throws Exception {    assertEquals( stagingMode, handler.getStagingMode() );  }
@Test  public void testUpdate() throws AmbariException {    KerberosDescriptor descriptor = createFromJSON();    KerberosDescriptor updatedDescriptor = createFromMap();    Assert.assertNotNull(descriptor);    Assert.assertNotNull(updatedDescriptor);    descriptor.update(updatedDescriptor);    validateUpdatedData(descriptor);  }
@Test    public void testGetServletUrl() {        assertEquals("dtablexls/file?clientId=123", handler.getServletUrl());    }
@Test    public void testReadUpdateWfs200MixedTransaction()                            throws Exception {        XMLStreamReader xmlStream = getXMLStreamReader( MIXED_200 );        Transaction ta = reader.read( xmlStream );        Iterator<TransactionAction> taIter = ta.getActions().iterator();        // 1. action: Native        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Native" );        Native nativeAction = (Native) taIter.next();        skipElement( nativeAction.getVendorSpecificData() );        xmlStream.require( XMLStreamReader.END_ELEMENT, WFS_200_NS, "Native" );        // 2. action: Insert        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Insert" );        Insert insert = (Insert) taIter.next();        XMLStreamReader features = insert.getFeatures();        features.require( XMLStreamReader.START_ELEMENT, "http://www.someserver.com/myns", "ElevP_1M" );        skipElement( features );        nextElement( features );        // 3. action: Insert        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Insert" );        insert = (Insert) taIter.next();        features = insert.getFeatures();        features.require( XMLStreamReader.START_ELEMENT, "http://www.someserver.com/myns", "RoadL_1M" );        skipElement( features );        nextElement( features );        // 4. action: Update        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Update" );        Update update = (Update) taIter.next();        Iterator<PropertyReplacement> propIter = update.getReplacementProps();        assertTrue( propIter.hasNext() );        PropertyReplacement property = propIter.next();        XMLStreamReader replacementValue = property.getReplacementValue();        skipElement( replacementValue );        nextElement( replacementValue );        nextElement( replacementValue );        assertFalse( propIter.hasNext() );        assertNotNull( update.getFilter() );        // 5. action: Insert        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Insert" );        insert = (Insert) taIter.next();        features = insert.getFeatures();        features.require( XMLStreamReader.START_ELEMENT, "http://www.someserver.com/myns", "BuiltUpA_1M" );        skipElement( features );        nextElement( features );        skipElement( features );        nextElement( features );        // 6. action: Update        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Update" );        update = (Update) taIter.next();        propIter = update.getReplacementProps();        assertTrue( propIter.hasNext() );        property = propIter.next();        replacementValue = property.getReplacementValue();        skipElement( replacementValue );        nextElement( replacementValue );        nextElement( replacementValue );        assertFalse( propIter.hasNext() );        assertNotNull( update.getFilter() );        // 7. action: Update        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Update" );        update = (Update) taIter.next();        propIter = update.getReplacementProps();        assertTrue( propIter.hasNext() );        property = propIter.next();        replacementValue = property.getReplacementValue();        skipElement( replacementValue );        nextElement( replacementValue );        nextElement( replacementValue );        assertFalse( propIter.hasNext() );        assertNotNull( update.getFilter() );        // 8. action: Delete        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Delete" );        Delete delete = (Delete) taIter.next();        assertNotNull( delete );        // 9. action: Delete        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Delete" );        delete = (Delete) taIter.next();        assertNotNull( delete );        // 10. action: Replace        assertTrue( taIter.hasNext() );        xmlStream.require( XMLStreamReader.START_ELEMENT, WFS_200_NS, "Replace" );        Replace replace = (Replace) taIter.next();        skipElement( replace.getReplacementFeatureStream() );        assertNotNull( replace.getFilter() );        assertFalse( taIter.hasNext() );    }
@Test	public void testCovertCausedExecutionException() throws Exception {		_futureTask.run();		final Exception exception = new Exception();		Future<Object> future = new FutureConverter<Object, Object>(			_futureTask) {			@Override			protected Object convert(Object v) throws Exception {				throw exception;			}		};		try {			future.get();			Assert.fail();		}		catch (ExecutionException executionException) {			Assert.assertSame(exception, executionException.getCause());		}		try {			future.get(1, TimeUnit.SECONDS);			Assert.fail();		}		catch (ExecutionException executionException) {			Assert.assertSame(exception, executionException.getCause());		}	}
@Test    public void should_set_number_given_correct_phone_number() {        String phoneNumber = "15023157777";        Phone phone = new Phone(phoneNumber);        assertThat(phone.number()).isEqualTo(phoneNumber);    }
@Test    public void testKeySet() {        Set<String> keys = new HashSet<String>();        for (int i = 0; i < Random.getScaleCount(); i++) {            String key = Random.getSimpleString();            keys.add(key);            map.put(key, randomValueSet());        }        for (String key : map.keySet()) {            Assert.assertTrue(keys.contains(key));        }        Assert.assertTrue(keys.size() == map.keySet().size());    }
@Test    public void test200Example7()                            throws Exception {        Map<String, String> kvpParams = readFileIntoMap( GetPropertyValueKVPAdapterTest.class.getResource( "wfs200/example7.kvp" ) );        GetPropertyValue request = GetPropertyValueKVPAdapter.parse( kvpParams );        assertEquals( VERSION_200, request.getVersion() );        assertEquals( "myns:phone[2]", request.getValueReference().getAsText() );        FilterQuery query = (FilterQuery) request.getQuery();        assertEquals( 1, query.getTypeNames().length );        assertEquals( QName.valueOf( "Person" ), query.getTypeNames()[0].getFeatureTypeName() );        OperatorFilter filter = (OperatorFilter) query.getFilter();        Assert.assertTrue( filter.getOperator() instanceof And );    }
@Test	public void testBuildPOSTEndpointMetadataKeys() {		MetadataKeysBuilder metadataKeysBuilder = new MetadataKeysBuilder();		Set<String> metadataKeyIds = toMetadataKeyIdSet(			metadataKeysBuilder.getMetadataKeys(				openAPISpecJsonNode, OASConstants.OPERATION_POST));		Assert.assertTrue(			metadataKeyIds.contains("/endpoint/with/get/and/post/operation"));	}
@ThreadLeakLingering(linger=1000)  @Test  public void testTrain() {    Random gen = RandomUtils.getRandom();    Exponential exp = new Exponential(0.5, gen);    Vector beta = new DenseVector(200);    for (Vector.Element element : beta.all()) {      int sign = 1;      if (gen.nextDouble() < 0.5) {        sign = -1;      }      element.set(sign * exp.nextDouble());    }    AdaptiveLogisticRegression.Wrapper cl = new AdaptiveLogisticRegression.Wrapper(2, 200, new L1());    cl.update(new double[]{1.0e-5, 1});    for (int i = 0; i < 10000; i++) {      AdaptiveLogisticRegression.TrainingExample r = getExample(i, gen, beta);      cl.train(r);      if (i % 1000 == 0) {        System.out.printf("%10d %10.3f\n", i, cl.getLearner().auc());      }    }    assertEquals(1, cl.getLearner().auc(), 0.1);    AdaptiveLogisticRegression adaptiveLogisticRegression = new AdaptiveLogisticRegression(2, 200, new L1());    adaptiveLogisticRegression.setInterval(1000);    for (int i = 0; i < 20000; i++) {      AdaptiveLogisticRegression.TrainingExample r = getExample(i, gen, beta);      adaptiveLogisticRegression.train(r.getKey(), r.getActual(), r.getInstance());      if (i % 1000 == 0 && adaptiveLogisticRegression.getBest() != null) {        System.out.printf("%10d %10.4f %10.8f %.3f\n",                          i, adaptiveLogisticRegression.auc(),                          Math.log10(adaptiveLogisticRegression.getBest().getMappedParams()[0]), adaptiveLogisticRegression.getBest().getMappedParams()[1]);      }    }    assertEquals(1, adaptiveLogisticRegression.auc(), 0.1);    adaptiveLogisticRegression.close();  }
@Test	public void testValidateConfigurationValidFieldTextComplete()		throws Exception {		_fragmentEntryValidatorImpl.validateConfiguration(			_read("configuration_valid_field_text_complete.json"));	}
@Test  public void testSetterString() throws Exception  {    String string = innerObj.stringVal.concat("test");    createSetter(fqcn, "innerObj.stringVal", String.class).set(testObj, string);    assertSame(string, innerObj.stringVal);    createSetter(innerObjClass, "stringVal", String.class).set(innerObj, string = string.concat("more test"));    assertEquals(string, innerObj.stringVal);    createSetter(innerObjClass, "protectedStringVal", String.class).set(innerObj, string = string.concat("and more test"));    assertSame(string, innerObj.protectedStringVal);    createSetter(innerObjClass, "privateStringVal", String.class).set(innerObj, string = string.concat("and even more test"));    assertSame(string, innerObj.getPrivateStringVal());  }
@Test    public void enableCreateButtonForDMNScenarioWithPath() {        scenarioSimulationCreationPopupViewSpy.selectedPath = "Path";        scenarioSimulationCreationPopupViewSpy.enableCreateButtonForDMNScenario();        verify(okButtonMock, times(1)).setEnabled(eq(true));    }
@Test    public void contentImplTest() {        ContentImpl content = new ContentImpl("value");        Assert.assertEquals(content.value, "value");    }
@Test    public void pingExtraData() {        ByteBuffer buffer = ByteBuffer.wrap(TestMessages.PING_EXTRA_DATA_BUFFER);        Http2PingFrame frame = (Http2PingFrame) decoder.decode(buffer, context);        assertNotNull(frame);        assertEquals(9, frame.getLength());        assertEquals(6, frame.getType());        assertEquals(0x00, frame.getFlags());        assertEquals(32, frame.getStreamID());        assertArrayEquals(new byte[] {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}, frame.getData());    }
@Test	public void testProcessDDMFormInstanceReportWithEmptyData()		throws Exception {		DDMFormFieldValue ddmFormFieldValue = _mockDDMFormFieldValue(			"field1", "1");		long formInstanceRecordId = 1;		_mockDDMFormInstanceRecord(formInstanceRecordId);		JSONObject processedFieldJSONObject =			_numericDDMFormFieldTypeReportProcessor.process(				ddmFormFieldValue,				JSONUtil.put(					"type", DDMFormFieldType.NUMERIC				).put(					"values", JSONFactoryUtil.createJSONObject()				),				formInstanceRecordId,				DDMFormInstanceReportConstants.EVENT_ADD_RECORD_VERSION);		JSONObject summaryJSONObject = processedFieldJSONObject.getJSONObject(			"summary");		Assert.assertEquals("1", summaryJSONObject.getString("average"));		Assert.assertEquals("1", summaryJSONObject.getString("max"));		Assert.assertEquals("1", summaryJSONObject.getString("min"));		Assert.assertEquals("1", summaryJSONObject.getString("sum"));	}
@Test  public void testRangerEnvBlueprintExport() throws Exception {    // Given    List<String> configTypesWithRangerHdfsAuditDir = ImmutableList.of(      "ranger-env",      "ranger-yarn-audit",      "ranger-hdfs-audit",      "ranger-hbase-audit",      "ranger-hive-audit",      "ranger-knox-audit",      "ranger-kafka-audit",      "ranger-storm-audit",      "ranger-atlas-audit"    );    Map<String, Map<String, String>> clusterConfigProperties = new HashMap<>();    for (String configType: configTypesWithRangerHdfsAuditDir) {      Map<String, String> configProperties = new HashMap<>();      configProperties.put("xasecure.audit.destination.hdfs.dir", "hdfs://nn_host:100");      clusterConfigProperties.put(configType, configProperties);    }    Map<String, Map<String, String>> parentProperties = new HashMap<>();    Configuration parentClusterConfig = new Configuration(parentProperties, new HashMap<String, Map<String, Map<String, String>>>());    Configuration clusterConfig = new Configuration(clusterConfigProperties, new HashMap<String, Map<String, Map<String, String>>>(), parentClusterConfig);    Collection<String> rangerComponents = new HashSet<>();    rangerComponents.add("RANGER_ADMIN");    rangerComponents.add("RANGER_USERSYNC");    Collection<String> hdfsComponents = new HashSet<String>();    hdfsComponents.add("NAMENODE");    hdfsComponents.add("DATANODE");    TestHostGroup group1 = new TestHostGroup("group1", rangerComponents, Collections.singleton("host1"));    group1.components.add("DATANODE");    TestHostGroup group2 = new TestHostGroup("group2", hdfsComponents, Collections.singleton("nn_host"));    Collection<TestHostGroup> hostGroups = Lists.newArrayList(group1, group2);    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor configProcessor = new BlueprintConfigurationProcessor(topology);    // When    configProcessor.doUpdateForBlueprintExport();    // Then    String expectedAuditHdfsDir = "hdfs://%HOSTGROUP::group2%:100";    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-env", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-yarn-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-hdfs-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-hbase-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-hive-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-knox-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-kafka-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-storm-audit", "xasecure.audit.destination.hdfs.dir"));    assertEquals(expectedAuditHdfsDir, clusterConfig.getPropertyValue("ranger-atlas-audit", "xasecure.audit.destination.hdfs.dir"));  }
@Test    public void testDeepEqualsEmpty() {        ColumnStore<Node> store1 = new ColumnStore<Node>(Node.class, false);        Assert.assertTrue(store1.deepEquals(store1));        ColumnStore<Node> store2 = new ColumnStore<Node>(Node.class, false);        Assert.assertTrue(store1.deepEquals(store2));    }
@Test  public void testHdfsSiteUpdateConfigs2() throws Exception{    Map<String, String> oldPropertiesHdfsSite = new HashMap<String, String>() {      {        put("dfs.client.retry.policy.enabled", "true");      }    };    Map<String, String> newPropertiesHdfsSite = new HashMap<String, String>() {      {        put("dfs.client.retry.policy.enabled", "false");      }    };    EasyMockSupport easyMockSupport = new EasyMockSupport();    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);    final Service service = createStrictMock(Service.class);    final Map<String, Service> services = Collections.singletonMap("HDFS", service);    Config mockHdfsSite = easyMockSupport.createNiceMock(Config.class);    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{      put("normal", cluster);    }}).anyTimes();    expect(cluster.getDesiredConfigByType("hdfs-site")).andReturn(mockHdfsSite).atLeastOnce();    expect(mockHdfsSite.getProperties()).andReturn(oldPropertiesHdfsSite).anyTimes();    expect(cluster.getServices()).andReturn(services).once();    Injector injector = easyMockSupport.createNiceMock(Injector.class);    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();    replay(injector, clusters, mockHdfsSite, cluster);    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)        .addMockedMethod("createConfiguration")        .addMockedMethod("getClusters", new Class[] { })        .addMockedMethod("createConfig")        .withConstructor(createNiceMock(ActionManager.class), clusters, injector)        .createNiceMock();    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);    Capture<Map<String, String>> propertiesCapture = EasyMock.newCapture();    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();    expect(controller.getClusters()).andReturn(clusters).anyTimes();    expect(controller.createConfig(anyObject(Cluster.class), anyString(), capture(propertiesCapture), anyString(),                                   EasyMock.<Map<String, Map<String, String>>>anyObject())).andReturn(createNiceMock(Config.class)).once();    replay(controller, injector2);    new UpgradeCatalog240(injector2).updateHDFSConfigs();    easyMockSupport.verifyAll();    Map<String, String> updatedProperties = propertiesCapture.getValue();    assertTrue(Maps.difference(newPropertiesHdfsSite, updatedProperties).areEqual());  }
@Test    void shouldUseTraceLevelForActivation() {        final HttpLogWriter unit = new DefaultHttpLogWriter();        logger.setEnabledLevels(TRACE);        assertTrue(unit.isActive());        logger.setEnabledLevels(INFO);        assertFalse(unit.isActive());    }
@Test    void get11() {        assertEquals(m11, instance.get11());    }
@SuppressWarnings({ "rawtypes", "unchecked" })  @Test  public void testNodeProcessing()  {    FilteredLineToTokenHashMap oper = new FilteredLineToTokenHashMap();    HashTestSink tokenSink = new HashTestSink();    oper.setSplitBy(";");    oper.setSplitTokenBy(",");    oper.tokens.setSink(tokenSink);    String[] filters = new String[2];    filters[0] = "a";    filters[1] = "c";    oper.setFilterBy(filters);    oper.beginWindow(0); //    String input1 = "a,2,3;b,1,2;c,4,5,6";    String input2 = "d";    String input3 = "";    int numTuples = 1000;    for (int i = 0; i < numTuples; i++) {      oper.data.process(input1);      oper.data.process(input2);      oper.data.process(input3);    }    oper.endWindow(); //    Assert.assertEquals("number emitted tuples", 2, tokenSink.map.size());    HashMap<HashMap<String, ArrayList<String>>, Object> smap = tokenSink.map;    for (Map.Entry<HashMap<String, ArrayList<String>>, Object> e : smap        .entrySet()) {      for (Map.Entry<String, ArrayList<String>> l : e.getKey().entrySet()) {        String key = l.getKey();        ArrayList<String> list = l.getValue();        Assert.assertTrue(!key.equals("b"));        Assert.assertTrue(!key.equals("d"));        if (key.equals("a")) {          Assert              .assertEquals("number emitted values for \"a\"", 2, list.size());          Assert.assertEquals("first value for \"a\"", "2", list.get(0));          Assert.assertEquals("second value for \"a\"", "3", list.get(1));        } else if (key.equals("c")) {          Assert              .assertEquals("number emitted values for \"c\"", 3, list.size());          Assert.assertEquals("first value for \"c\"", "4", list.get(0));          Assert.assertEquals("second value for \"c\"", "5", list.get(1));          Assert.assertEquals("second value for \"c\"", "6", list.get(2));        }      }    }  }
@Test  public void testToBuilder() {    CloudBigtableTableConfiguration underTest =        buildConfiguration().toBuilder().withConfiguration("somekey", "somevalue").build();    CloudBigtableTableConfiguration copy = underTest.toBuilder().build();    Assert.assertNotSame(underTest, copy);    Assert.assertEquals(underTest, copy);  }
@Test  public void testLength() throws Exception {    module.length(callback);    verify(callback,times(1)).invoke(any());  }
@Test    public void checkUnaryConstructorHasNoFilter() {        Composite composite = mock(Composite.class);        FilterComposite fc = new FilterComposite(composite);        assertThat(fc.getFilter(), is(nullValue()));    }
@Test	public void testParseWithGeBinaryExpression()		throws ExpressionVisitException {		Expression expression = _filterParserImpl.parse(			"fieldExternal ge 'value'");		Assert.assertNotNull(expression);		BinaryExpression binaryExpression = (BinaryExpression)expression;		Assert.assertEquals(			BinaryExpression.Operation.GE, binaryExpression.getOperation());		MemberExpression memberExpression =			(MemberExpression)binaryExpression.getLeftOperationExpression();		PrimitivePropertyExpression primitivePropertyExpression =			(PrimitivePropertyExpression)memberExpression.getExpression();		Assert.assertEquals(			"fieldExternal", primitivePropertyExpression.getName());		LiteralExpression literalExpression =			(LiteralExpression)binaryExpression.getRightOperationExpression();		Assert.assertEquals("'value'", literalExpression.getText());		Assert.assertEquals(			LiteralExpression.Type.STRING, literalExpression.getType());	}
@Test    public void showAddItemButton() {        collectionEditorViewImplSpy.showAddItemButton(false);        checkStyleDisplay(addItemButtonStyleMock, false);        collectionEditorViewImplSpy.showAddItemButton(true);        checkStyleDisplay(addItemButtonStyleMock, true);    }
@Test    public void testEthSyncing() throws Exception {        web3j.platonSyncing().send();        verifyResult("{\"jsonrpc\":\"2.0\",\"method\":\"platon_syncing\",\"params\":[],\"id\":1}");    }
@Test  public void testValidateIdEquality() {    Vertex vertex1 = createVertex();    Vertex vertex2 = createVertex();    assertEquals(vertex1.id(), vertex1.id());    assertEquals(vertex2.id(), vertex2.id());    assertNotEquals(vertex1.id(), vertex2.id());  }
@Test  public void testPopulateAmbariServerProperties() throws Exception {    File file = mock(File.class);    String recommendationsArtifactsLifetime = "1w";    StackAdvisorRunner stackAdvisorRunner = mock(StackAdvisorRunner.class);    AmbariMetaInfo ambariMetaInfo = mock(AmbariMetaInfo.class);    StackAdvisorCommand<TestResource> cmd = new TestStackAdvisorCommand(file, recommendationsArtifactsLifetime, "test", 1,      stackAdvisorRunner, ambariMetaInfo);    ObjectNode objectNode = (ObjectNode) cmd.mapper.readTree("{\"Versions\": " +      "{\"stack_name\": \"stack\", \"stack_version\":\"1.0.0\"}}");    Map<String, String> props = Collections.singletonMap("a", "b");    doReturn(props).when(ambariMetaInfo).getAmbariServerProperties();    cmd.populateAmbariServerInfo(objectNode);    JsonNode serverProperties = objectNode.get("ambari-server-properties");    assertNotNull(serverProperties);    assertEquals("b", serverProperties.iterator().next().getTextValue());  }
@Test	public void testWildcardQuery() throws Exception {		SearchContext searchContext = getSearchContext();		searchContext.setKeywords("test*.jpg");		String cmisQuery = buildQuery(searchContext);		assertQueryEquals(			"(cmis:name LIKE 'test%.jpg' OR cmis:createdBy LIKE 'test%.jpg')",			cmisQuery);	}
@Test    public void copyToDirectory() throws Exception {        final Path folder = mock(Path.class);        service.copy(path,                     "newName.scesim",                     folder,                     "comment");        verify(copyServiceMock).copy(path,                                     "newName.scesim",                                     folder,                                     "comment");    }
@Test    public void shouldHaveStatusWarningIfDetailsContainWarnings() {        // given        final ApplicationStatus applicationStatus = applicationStatus(mock(ApplicationInfo.class), null, mock(SystemInfo.class), mock(VersionInfo.class), mock(TeamInfo.class), asList(                statusDetail("bar", OK, "a message"),                statusDetail("foobar", WARNING, "another message"))        );        // then        assertThat(applicationStatus.status, is(WARNING));    }
@Test  public void testStageSorting() throws Exception {    List<SortRequestProperty> sortProperties = new ArrayList<SortRequestProperty>();    SortRequest sortRequest = new SortRequestImpl(sortProperties);    Predicate predicate = new PredicateBuilder().property(        StageResourceProvider.STAGE_CLUSTER_NAME).equals("c1").toPredicate();    sortProperties.add(new SortRequestProperty(        StageResourceProvider.STAGE_LOG_INFO, SortRequest.Order.ASC));    Request request = PropertyHelper.getReadRequest(new HashSet<String>(Arrays.<String>asList()),        null, null, null, sortRequest);    // get back all 5    List<StageEntity> entities = stageDao.findAll(request, predicate);    assertEquals(5, entities.size());    // assert sorting ASC    String lastInfo = null;    for (StageEntity entity : entities) {      if (lastInfo == null) {        lastInfo = entity.getLogInfo();        continue;      }      String currentInfo = entity.getLogInfo();      assertTrue(lastInfo.compareTo(currentInfo) <= 0);      lastInfo = currentInfo;    }    // clear and do DESC    sortProperties.clear();    sortProperties.add(new SortRequestProperty(        StageResourceProvider.STAGE_LOG_INFO, SortRequest.Order.DESC));    // get back all 5    entities = stageDao.findAll(request, predicate);    assertEquals(5, entities.size());    // assert sorting DESC    lastInfo = null;    for (StageEntity entity : entities) {      if (null == lastInfo) {        lastInfo = entity.getLogInfo();        continue;      }      String currentInfo = entity.getLogInfo();      assertTrue(lastInfo.compareTo(currentInfo) >= 0);      lastInfo = currentInfo;    }  }
@Test public void testLoadContent() {		// Arrange:		final WebFragment fragment = new WebFragment();		// Act + Assert:		assertThat(fragment.loadContent("http://www.google.com"), is(false));		assertThat(fragment.getContent(), is("http://www.google.com"));		assertThat(fragment.getContentType(), is(WebFragment.CONTENT_URL));	}
@Test    public void testMultipleAnnotatedSettersClass()    {        TestMonitor monitor = new TestMonitor();        ConfigurationMetadata<?> metadata = ConfigurationMetadata.getConfigurationMetadata(MultipleAnnotatedSettersClass.class, monitor);        // Not validating metadata, since the actual setter it picks is not deterministic        monitor.assertNumberOfErrors(1);        monitor.assertNumberOfWarnings(0);        monitor.assertMatchingErrorRecorded("Multiple methods are annotated", "Value");    }
@Test	public void testGetEditableEditableValues() throws Exception {		String editableValues = _read(			"fragment_entry_link_editable_editable_values.json");		Assert.assertEquals(			_objectMapper.readTree(				_read(					"fragment_entry_link_editable_editable_values_segments_" +						"experience_0.json")),			_objectMapper.readTree(				EditableValuesTransformerUtil.getEditableValues(					editableValues, 0)));		Assert.assertEquals(			_objectMapper.readTree(				_read(					"fragment_entry_link_editable_editable_values_segments_" +						"experience_1.json")),			_objectMapper.readTree(				EditableValuesTransformerUtil.getEditableValues(					editableValues, 1)));		Assert.assertEquals(			_objectMapper.readTree(				_read(					"fragment_entry_link_editable_editable_values_segments_" +						"experience_2.json")),			_objectMapper.readTree(				EditableValuesTransformerUtil.getEditableValues(					editableValues, 2)));	}
@Test  public void testToEntityWithNullRecord() {    assertNull(converter.toEntity(null));  }
@Test  public void testGetId() throws Exception {    LdapSyncEventEntity event = new LdapSyncEventEntity(1L);    Assert.assertEquals(1L, event.getId());  }
@Test  public void mkdirTest() throws IOException, AlluxioException {    String qualifiedPath =            "tachyon://" + mLocalAlluxioCluster.getMasterHostname() + ":"                    + mLocalAlluxioCluster.getMasterPort() + "/root/testFile1";    InterpreterResult output = alluxioInterpreter.interpret("mkdir " + qualifiedPath, null);    boolean existsDir = fs.exists(new AlluxioURI("/root/testFile1"));    Assert.assertEquals(            "Successfully created directory " + qualifiedPath + "\n\n",            output.message());    Assert.assertTrue(existsDir);  }
@Test  public void testGetLabel() throws Exception {    List<InstanceConfig> instances = getInstanceConfigs();    Assert.assertEquals(2, instances.size());    Assert.assertEquals("My Instance 1!", instances.get(0).getLabel());    Assert.assertEquals("My Instance 2!", instances.get(1).getLabel());  }
@Test    public void testLineEndingInRequireAndProvide() throws Exception {        final ClosureRequireDependencyManager.Node node = _depManager.addFile("xb", "goog.\nrequire('3a'); goog.\n\rprovide('xb');",            Collections.<String>emptySet());        Assert.assertEquals("xb", node.id);        assertTrue(node.dependencyIds.contains("3a"));    }
@Test    public void testNoConfigMethodsClass()            throws Exception    {        TestMonitor monitor = new TestMonitor();        ConfigurationMetadata<?> metadata = ConfigurationMetadata.getConfigurationMetadata(NoConfigMethodsClass.class, monitor);        Map<String, Set<String>> expectedAttributes = new HashMap<>();        verifyMetaData(metadata, NoConfigMethodsClass.class, null, false, expectedAttributes);        monitor.assertNumberOfErrors(1);        monitor.assertNumberOfWarnings(0);        monitor.assertMatchingErrorRecorded("does not have any @Config annotations", NoConfigMethodsClass.class.getName());    }
@Test    void get16Test() {        assertEquals(16, (int) instance.get16());    }
@Test    void shouldThrowWhenNegativeLinkedHashMapSizeGiven()    {        assertThrows( IllegalArgumentException.class, () -> Iterables.newLinkedHashMapWithSize( -42 ) );    }
@Test  public void testServiceCheckDowngradeStages() throws Exception {    Map<String, UpgradePack> upgrades = ambariMetaInfo.getUpgradePacks("HDP", "2.1.1");    assertTrue(upgrades.containsKey("upgrade_test_checks"));    UpgradePack upgrade = upgrades.get("upgrade_test_checks");    assertNotNull(upgrade);    Cluster cluster = makeCluster();    UpgradeContext context = m_upgradeContextFactory.create(cluster, UpgradeType.ROLLING,        Direction.DOWNGRADE, DOWNGRADE_VERSION, new HashMap<String, Object>());    context.setResolver(m_masterHostResolver);    List<UpgradeGroupHolder> groups = m_upgradeHelper.createSequence(upgrade, context);    assertEquals(5, groups.size());    // grab the manual task out of ZK which has placeholder text    UpgradeGroupHolder zookeeperGroup = groups.get(3);    assertEquals("ZOOKEEPER", zookeeperGroup.name);    ManualTask manualTask = (ManualTask) zookeeperGroup.items.get(0).getTasks().get(        0).getTasks().get(0);    assertEquals(1, manualTask.messages.size());    assertEquals(        "This is a manual task with a placeholder of placeholder-rendered-properly",        manualTask.messages.get(0));  }
@Test  public void testSetTextAvailable() throws Exception {    assertTrue( roh.isTextAvailable() );    roh.setTextAvailable( false );    assertFalse( roh.isTextAvailable() );  }
@Test(expected = InvalidUsernamePasswordCombinationException.class)  public void testAuthWithoutPass() {    Users users = createMock(Users.class);    UserDAO userDAO = createMock(UserDAO.class);    Authentication authentication = createMock(Authentication.class);    UserEntity userEntity = combineUserEntity();    expect(authentication.getName()).andReturn(TEST_USER_NAME);    expect(userDAO.findLocalUserByName(TEST_USER_NAME)).andReturn(userEntity);    expect(authentication.getCredentials()).andReturn(null);    replay(users, userDAO, authentication);    AmbariLocalUserProvider ambariLocalUserProvider = new AmbariLocalUserProvider(userDAO, users, passwordEncoder);    ambariLocalUserProvider.authenticate(authentication);  }
@Test  public void testParseTransportStreamWithKLVCallback() throws Exception {    final Stanag4609TransportStreamParser parser = getParser();    // Mockito can't spy anonymous classes.    final BiConsumer<Integer, DecodedKLVMetadataPacket> callback =        new BiConsumer<Integer, DecodedKLVMetadataPacket>() {          @Override          public void accept(Integer integer, DecodedKLVMetadataPacket decodedKLVMetadataPacket) {}        };    final BiConsumer<Integer, DecodedKLVMetadataPacket> callbackSpy = spy(callback);    parser.parse(callbackSpy);    final ArgumentCaptor<DecodedKLVMetadataPacket> decodedPacketCaptor =        ArgumentCaptor.forClass(DecodedKLVMetadataPacket.class);    // The packet ID of the metadata stream in this file is 497.    verify(callbackSpy, times(1)).accept(eq(497), decodedPacketCaptor.capture());    verifyDecodedMetadataPacket(decodedPacketCaptor.getValue());  }
@Test  public void testPrimaryFilterNumericStringWithQuotes() {    WebResource r = resource();    ClientResponse response = r.path("ws").path("v1").path("timeline")        .path("type_1").queryParam("primaryFilter", "other:\"123abc\"")        .accept(MediaType.APPLICATION_JSON)        .get(ClientResponse.class);    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());    verifyEntities(response.getEntity(TimelineEntities.class));  }
@Test    public void testSetMetadata() throws Exception {        final String metaData = "metaData";        page.setMetadata(metaData);        verify(plugin).setMetaData(metaData);    }
@Test(expected = AmbariException.class)  public void shouldThrowExceptionWhenOldTezViewUrlIsInvalid() throws Exception {    upgradeCatalog250.getUpdatedTezHistoryUrlBase("Invalid URL");  }
@Test  public void testToPredicate() {    assertEquals(new NotPredicate(new EqualsPredicate<String>("prop", "val")),        new NotEqualsOperator().toPredicate("prop", "val"));  }
@Test	public void testNotCalledJumpPageAction() throws Exception {		DDMForm ddmForm = new DDMForm();		DDMFormField ddmFormField = createDDMFormField(			"field0", "text", FieldConstants.NUMBER);		ddmForm.addDDMFormField(ddmFormField);		ddmForm.addDDMFormRule(			new DDMFormRule(				Arrays.asList("jumpPage(1, 3)"), "getValue(\"field0\") > 1"));		DDMFormValues ddmFormValues = DDMFormValuesTestUtil.createDDMFormValues(			ddmForm);		ddmFormValues.addDDMFormFieldValue(			DDMFormValuesTestUtil.createDDMFormFieldValue(				"field0_instanceId", "field0", new UnlocalizedValue("1")));		DDMFormEvaluatorEvaluateResponse ddmFormEvaluatorEvaluateResponse =			doEvaluate(ddmForm, ddmFormValues);		Set<Integer> disabledPagesIndexes =			ddmFormEvaluatorEvaluateResponse.getDisabledPagesIndexes();		Assert.assertTrue(			disabledPagesIndexes.toString(), disabledPagesIndexes.isEmpty());	}
@Test	public void testArray() {		IsEmptyFunction isEmptyFunction = new IsEmptyFunction();		Boolean result = isEmptyFunction.apply(			new String[] {"  ", "not empty "});		Assert.assertFalse(result);	}
@Test	public void testReplaceAliasPastWeek() {		Calendar calendar = new GregorianCalendar(			2018, Calendar.MAY, 15, 23, 59, 59);		Assert.assertEquals(			"[20180508235959 TO 20180514235959]",			_dateRangeFactory.replaceAliases(				"[past-week TO past-24-hours]", calendar));	}
@Test    public void givenATeamEntityListFromLocalApi() {        given(teamsLocalDataSource.teamEntityList()).willReturn(Observable.just(FakeTeamLocalAPI.getFakeTeamEntityList()));        teamsRepository.getTeamList();        verify(teamsLocalDataSource).teamEntityList();    }
@Test  public void testIsGangliaSSL() throws Exception {    ComponentSSLConfiguration sslConfiguration = getConfiguration("tspath",        "tspass", "tstype", true);    Assert.assertTrue(sslConfiguration.isHttpsEnabled());  }
@Test	public void testReturnsTheClosestMatchByWidthIfNoExactMatchPresentAndRunsTheProcess()		throws Exception {		AMImageConfigurationEntry getConfigurationEntryFilter =			_createAMImageConfigurationEntry(				_fileVersion.getCompanyId(), 200, 500);		AMImageConfigurationEntry closestAMImageConfigurationEntry =			_createAMImageConfigurationEntry(				_fileVersion.getCompanyId(), 201, 501);		AMImageConfigurationEntry fartherAMImageConfigurationEntry =			_createAMImageConfigurationEntry(				_fileVersion.getCompanyId(), 301, 501);		AMImageConfigurationEntry farthestAMImageConfigurationEntry =			_createAMImageConfigurationEntry(				_fileVersion.getCompanyId(), 401, 501);		AdaptiveMedia<AMImageProcessor> closestAdaptiveMedia =			_createAdaptiveMedia(				_fileVersion, closestAMImageConfigurationEntry);		AdaptiveMedia<AMImageProcessor> fartherAdaptiveMedia =			_createAdaptiveMedia(				_fileVersion, fartherAMImageConfigurationEntry);		AdaptiveMedia<AMImageProcessor> farthestAdaptiveMedia =			_createAdaptiveMedia(				_fileVersion, farthestAMImageConfigurationEntry);		_mockClosestMatch(			_fileVersion, getConfigurationEntryFilter,			Arrays.asList(				farthestAdaptiveMedia, closestAdaptiveMedia,				fartherAdaptiveMedia));		HttpServletRequest httpServletRequest = _createRequestFor(			_fileVersion, getConfigurationEntryFilter);		Assert.assertEquals(			Optional.of(closestAdaptiveMedia),			_amImageRequestHandler.handleRequest(httpServletRequest));		Mockito.verify(			_amAsyncProcessor		).triggerProcess(			_fileVersion, String.valueOf(_fileVersion.getFileVersionId())		);	}
@Test	public void testGetViewInPanelURL() {		MockLiferayPortletRenderRequest mockLiferayPortletRenderRequest =			new MockLiferayPortletRenderRequest();		MockLiferayPortletURL mockLiferayPortletURL =			new MockLiferayPortletURL();		mockLiferayPortletRenderRequest.setAttribute(			"null" + StringPool.DASH + WebKeys.CURRENT_PORTLET_URL,			mockLiferayPortletURL);		mockLiferayPortletRenderRequest.setAttribute(			WebKeys.LOCALE, LocaleUtil.US);		ContentDashboardDropdownItemsProvider			contentDashboardDropdownItemsProvider =				new ContentDashboardDropdownItemsProvider(					_http, _language, mockLiferayPortletRenderRequest,					new MockLiferayPortletRenderResponse(), new PortalImpl());		ContentDashboardItem contentDashboardItem = _getContentDashboardItem(			Collections.singletonList(				_getContentDashboardItemAction(					"viewInPanel",					ContentDashboardItemAction.Type.VIEW_IN_PANEL,					"validURL")));		List<DropdownItem> dropdownItems =			contentDashboardDropdownItemsProvider.getDropdownItems(				contentDashboardItem);		Stream<DropdownItem> stream = dropdownItems.stream();		DropdownItem viewInPanelDropdownItem = stream.filter(			dropdownItem -> Objects.equals(				String.valueOf(dropdownItem.get("label")), "viewInPanel")		).findFirst(		).orElseThrow(			() -> new AssertionError()		);		Map<String, Object> data =			(Map<String, Object>)viewInPanelDropdownItem.get("data");		Assert.assertEquals("showMetrics", String.valueOf(data.get("action")));		Assert.assertEquals("validURL", String.valueOf(data.get("fetchURL")));	}
@Test  public void testGetResources_many() throws Exception {    @SuppressWarnings("unchecked")    ResourceProvider provider = init(        new HashMap<String,String>() {{          put("status", "RUNNING");          put("name", "a");        }},        new HashMap<String,String>() {{          put("status", "RUNNING");          put("name", "b");        }},        new HashMap<String,String>() {{          put("status", "NOT_RUNNING");          put("name", "c");        }});            PredicateBuilder pb = new PredicateBuilder().property(        HostComponentProcessResourceProvider.HC_PROCESS_CLUSTER_NAME_ID).equals("c1").and();    pb = pb.property(        HostComponentProcessResourceProvider.HC_PROCESS_HOST_NAME_ID).equals("h1").and();    Predicate predicate = pb.property(        HostComponentProcessResourceProvider.HC_PROCESS_COMPONENT_NAME_ID).equals("comp1").toPredicate();        Request request = PropertyHelper.getReadRequest(Collections.<String>emptySet());        Set<Resource> resources = provider.getResources(request, predicate);        Assert.assertEquals(Integer.valueOf(3), Integer.valueOf(resources.size()));        for (Resource r : resources) {      Assert.assertNotNull(r.getPropertyValue(HostComponentProcessResourceProvider.HC_PROCESS_NAME_ID));      Assert.assertNotNull(r.getPropertyValue(HostComponentProcessResourceProvider.HC_PROCESS_STATUS_ID));    }  }
@Test  public void testInsert() {    // TODO: 11/2/17  }
@Test    public void testPlay_Basic() {        int numCards = 12;        int maxCard = numCards;        List<Player> players = new ArrayList<>();                Hand h1 = new Hand(Arrays.asList(new Integer[]{1,5,9}));        Player p1 = new Player("p1", strategy, maxCard, h1);        Hand h2 = new Hand(Arrays.asList(new Integer[]{4,8,6}));        Player p2 = new Player("p2", strategy, maxCard, h2);        Hand h3 = new Hand(Arrays.asList(new Integer[]{7,2,3}));        Player p3 = new Player("p3", strategy, maxCard, h3);                players.add(p1);        players.add(p2);        players.add(p3);                Hand kitty = new Hand(Arrays.asList(new Integer[]{10,11,12}));                // test        List<Player> newPlayers = new Game(numCards, false).play(kitty, players.stream()).collect(toList());                assertEquals(3, newPlayers.size());        assertEquals(0, newPlayers.get(0).getNumCardsInHand());        assertEquals(0, newPlayers.get(1).getNumCardsInHand());        assertEquals(0, newPlayers.get(2).getNumCardsInHand());        assertEquals(3, newPlayers.stream().filter(p -> p.getPlayerStats().getNumRoundsWon() == 1).count());        assertEquals(1, newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 10).count());        assertEquals(1, newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 11).count());        assertEquals(1, newPlayers.stream().filter(p -> p.getPlayerStats().getTotal() == 12).count());    }
@Test	public void testAsterisk() throws Exception {		CSSRTLConverter cssRTLConverter = new CSSRTLConverter();		Assert.assertEquals(			"p{*right:50%}", cssRTLConverter.process("p{*left:50%}"));		Assert.assertEquals(			"p{*text-align:left}",			cssRTLConverter.process("p{*text-align:right}"));	}
@Test	public void testAroundWritePageWithExtensionContextWithNoExtendedType()		throws IOException {		Page<Object> page = Page.of(Collections.singleton(new Object()));		Mockito.when(			_writerInterceptorContext.getEntity()		).thenReturn(			page		);		Mockito.when(			_writerInterceptorContext.getGenericType()		).thenReturn(			new GenericType<Page<Object>>() {			}.getType()		);		Mockito.when(			_writerInterceptorContext.getType()		).thenReturn(			(Class)Object.class		);		_pageEntityExtensionWriterInterceptor.aroundWriteTo(			_writerInterceptorContext);		Mockito.verify(			_writerInterceptorContext, Mockito.never()		).setEntity(			any()		);		Mockito.verify(			_writerInterceptorContext, Mockito.never()		).setGenericType(			any()		);		Mockito.verify(			_writerInterceptorContext		).proceed();	}
@Test    public void testParseNestedInvokedBlacklistedMethod() {        Set<String> methods = SyntaxTools                .parseShortInvokedMethods("foo(time(x, y))");        Assert.assertEquals(methods, Sets.newHashSet("foo"));    }
@Test    void shouldWriteAndFlushSingleMessage()    {        EmbeddedChannel channel = newChannel();        NetworkConnection connection = newConnection( channel );        connection.writeAndFlush( PULL_ALL, NO_OP_HANDLER );        channel.runPendingTasks(); // writeAndFlush is scheduled to execute in the event loop thread, trigger its execution        assertEquals( 1, channel.outboundMessages().size() );        assertEquals( PULL_ALL, single( channel.outboundMessages() ) );    }
@Test    public void testValid() throws Exception {    	    	CustomValidationConfiguration validationSpec = new CustomValidationConfiguration();        validationSpec.setStopSeverity(Severity.Info);        validationSpec.setRejectSeverity(Severity.Info);                MessageValidatorConfiguration validator = new MessageValidatorConfiguration();        validator.setFactory(ValidatorMock.Factory.class.getName());        validator.addSetting(ValidatorMock.SEVERITY, "");                validationSpec.addValidator(validator);                ValidationResult result = new DefaultValidationExecutor().validate(new UserMessage(), validationSpec);                       assertTrue(result.executedAllValidators());        assertTrue(Utils.isNullOrEmpty(result.getValidationErrors()));    }
@Test    @SuppressWarnings("unchecked")    public void testConsumer()                            throws Exception {        BlockingQueue<ProducerMessage> producerQueue = mock( BlockingQueue.class );        BlockingQueue<ConsumerMessage> consumerQueue = mock( BlockingQueue.class );        Feature[] features = new Feature[] { mock( Feature.class ), mock( Feature.class ) };        when( producerQueue.take() ).thenReturn( new ProducerFeatureMessage( features[0] ),                                                 new ProducerFeatureMessage( features[1] ),                                                 new ProducerFinishedMessage() );        Consumer consumer = new Consumer( producerQueue, consumerQueue );        assertTrue( consumer.hasNext() );        assertEquals( features[0], consumer.next() );        assertTrue( consumer.hasNext() );        assertEquals( features[1], consumer.next() );        assertFalse( consumer.hasNext() );        consumer.close();        verify( consumerQueue, never() ).put( new ConsumerClosingMessage() );    }
@Test    public void checkCanCreateWhenFeatureDisabled() {        when(authorizationManager.authorize(any(ResourceRef.class),                                            eq(ResourceAction.READ),                                            eq(user))).thenReturn(false);        assertFalse(handler.canCreate());        assertResourceRef();    }
@Test    @SuppressWarnings("unchecked")    public void testContextMenuCellIsSelectedCell() {        final GuidedDecisionTableView.Presenter dtPresenter = makeDecisionTable();        final GridData uiModel = dtPresenter.getView().getModel();        final GridColumn uiColumn = new RowNumberColumn();        uiModel.appendColumn(uiColumn);        //Cell associated with Mock onContextMenu Event has indices (0,0)        uiModel.selectCells(0, 0, 1, 1);        when(columnInformation.getColumn()).thenReturn(uiColumn);        when(modellerPresenter.getAvailableDecisionTables()).thenReturn(new HashSet<GuidedDecisionTableView.Presenter>() {            {                add(dtPresenter);            }        });        final ContextMenuHandler handler = contextMenuSupport.getContextMenuHandler(modellerPresenter);        handler.onContextMenu(event);        // this method is called if the handler does a selectCell, which should not occur for this test case        verify(cellSelectionStrategy,               never()).handleSelection(any(GridData.class),                                        any(Integer.class),                                        any(Integer.class),                                        any(Boolean.class),                                        any(Boolean.class));        verify(rowContextMenu,               times(1)).show(any(Integer.class),                              any(Integer.class));        verify(cellContextMenu,               never()).show(any(Integer.class),                             any(Integer.class));    }
@Test	public void testHasViewPermissionReturnsTrueWhenUserHasPermission()		throws Exception {		Mockito.when(			_modelResourcePermission.contains(				Mockito.any(PermissionChecker.class),				Mockito.any(BookmarksEntry.class), Mockito.anyString())		).thenReturn(			true		);		AssetRenderer<BookmarksEntry> assetRenderer =			new BookmarksEntryAssetRenderer(				_bookmarksEntry, _modelResourcePermission);		Assert.assertTrue(assetRenderer.hasViewPermission(_permissionChecker));	}
@Test  public void qualifierOffsetIsPartiallySupported() throws IOException {    Scan scan = new Scan().addFamily(Bytes.toBytes("f1"));    Filters.Filter adaptedFilter =        adapter.adapt(            new FilterAdapterContext(scan, null),            new ColumnPaginationFilter(10, Bytes.toBytes("q1")));    Filters.Filter expected =        FILTERS            .chain()            .filter(FILTERS.limit().cellsPerColumn(1))            .filter(                FILTERS                    .qualifier()                    .rangeWithinFamily("f1")                    .startClosed(ByteString.copyFromUtf8("q1")))            .filter(FILTERS.limit().cellsPerRow(10));    Assert.assertEquals(expected.toProto(), adaptedFilter.toProto());  }
@Test    @SuppressWarnings("unchecked")    public void knownColumnType_ConditionCol52() {        final Pattern52 p = new Pattern52();        final ConditionCol52 column = new ConditionCol52();        p.getChildColumns().add(column);        model.getConditions().add(p);        final Callback<String> callback = mock(Callback.class);        columnDefinitionFactory.generateColumnDefinition(dtPresenter,                                                         column,                                                         callback);        verify(conditionCol52DefinitionBuilder,               times(1)).generateDefinition(eq(dtPresenter),                                            eq(column),                                            any(Callback.class));        verify(callback,               times(1)).callback(any(String.class));    }
@Test        public void tcRemoveBeginEndQuotations()        {            assertEquals("", OKW_Helper.removeBeginEndQuotations("\"\""));            assertEquals("A", OKW_Helper.removeBeginEndQuotations("\"A\""));            assertEquals("ABC", OKW_Helper.removeBeginEndQuotations("\"ABC\""));        }
@Test    public void testDeepHashCodeEmpty() {        ColumnStore<Node> store1 = new ColumnStore<Node>(Node.class, false);        Assert.assertEquals(store1.deepHashCode(), store1.deepHashCode());        ColumnStore<Node> store2 = new ColumnStore<Node>(Node.class, false);        Assert.assertEquals(store1.deepHashCode(), store2.deepHashCode());        ColumnStore<Edge> store3 = new ColumnStore<Edge>(Edge.class, false);        Assert.assertNotEquals(store1.deepHashCode(), store3.deepHashCode());    }
@Test    public void doesNotFilterInvalidJson() throws Exception {        String valid = getResource("/cars-array.json").trim();        String invalid = valid.substring(0, valid.length() - 1);        String filtered = getFilter("cars").filter(invalid);        assertThat(filtered, containsString("Ford"));    }
@Test    public void testDateEditorValueAsDate() throws ParseException  {        DatePickerCellEditor editor = new DatePickerCellEditor();        Date input = new Date();        assertEquals("the input date must be unchanged", input, editor.getValueAsDate(input));        assertEquals("input as long must be same", input, editor.getValueAsDate(input.getTime()));        // PENDING: fails on server, moved out off the way into visual check for now//        String dateString = editor.getFormats()[0].format(input);//        Date fullCycle = editor.getFormats()[0].parse(dateString);//        assertEquals("the formatted input date string must be same", fullCycle, editor.getValueAsDate(dateString));        String nonsenseString = "invalid";        assertNull("invalid string maps to null", editor.getValueAsDate(nonsenseString));        assertNull("empty String maps to null", editor.getValueAsDate(""));        // same with date/string wrapped into TreeNode        DefaultMutableTreeNode node = new DefaultMutableTreeNode(input);        assertEquals("date must be user-object", input, editor.getValueAsDate(node));        // same with date/string wrapped into a TreeTableNode        DefaultMutableTreeTableNode tableNode = new DefaultMutableTreeTableNode(input);        assertEquals("date must be user-object", input, editor.getValueAsDate(tableNode));    }
@Test	public void testFlip() {		Log.d(tag, ""+L4 );		L4.flip();		Log.d(tag, ""+L4 );	}
@Test  public void testSetFilenameGenerator() {    FilenameGenerator filenameGenerator = mock(FilenameGenerator.class);    udpStreamMonitor.setFilenameGenerator(filenameGenerator);    verify(udpStreamProcessor).setFilenameGenerator(filenameGenerator);  }
@Test  public void testGetMaxAmbariVersion() throws Exception {    ViewConfig config = getConfig();    Assert.assertNull(config.getMaxAmbariVersion());    config = getConfig(with_ambari_versions);    Assert.assertEquals("2.0.0", config.getMaxAmbariVersion());  }
@Test    void shouldLogRequestWithoutHeaders() throws IOException {        final String correlationId = "b7e7a488-682a-11e5-b527-10ddb1ee7671";        final HttpRequest request = MockHttpRequest.create()                .withPath("/test")                .withBodyAsString("Hello, world!");        final String format = unit.format(correlation(correlationId), request);        assertThat(format, not(containsString("headers")));    }
@Test    public void testDeepHashCode() {        ColumnStore<Node> store1 = new ColumnStore<Node>(Node.class, false);        ColumnImpl col1 = new ColumnImpl("0", Integer.class, null, null, Origin.DATA, false, false);        store1.addColumn(col1);        ColumnStore<Node> store2 = new ColumnStore<Node>(Node.class, false);        ColumnImpl col2 = new ColumnImpl("0", Integer.class, null, null, Origin.DATA, false, false);        store2.addColumn(col2);        Assert.assertEquals(store1.deepHashCode(), store2.deepHashCode());        ColumnStore<Node> store3 = new ColumnStore<Node>(Node.class, false);        ColumnImpl col3 = new ColumnImpl("0", String.class, null, null, Origin.DATA, false, false);        store3.addColumn(col3);        Assert.assertNotEquals(store1.deepHashCode(), store3.deepHashCode());    }
@Test    public void testGetActive_userToTV() throws Exception {        DateTimeFormatter dtf = DateTimeUtils.PARAMETER_WITH_DAY_DTF.withZone(dtZone);        String startTimeStr = dtf.print(mentionTime.minusDays(1));        String endTimeStr = dtf.print(mentionTime.plusDays(1));        Map<String, Double> scores = underTest.getActive(startTimeStr, endTimeStr,                                                         DimensionType.USER.toString(),                                                         ActiveMethod.ToTV.toString(), "10",                                                         "true");        assertFalse(scores.isEmpty());    }
@Test  public void testGetCreateDirectives() throws Exception {    final RepositoryResourceDefinition resourceDefinition = new RepositoryResourceDefinition();    final Collection<String> createDirectives = resourceDefinition.getCreateDirectives();    Assert.assertEquals(1, createDirectives.size());    Assert.assertEquals(RepositoryResourceDefinition.VALIDATE_ONLY_DIRECTIVE, createDirectives.iterator().next());  }
@Test  public void testReadRowsAsyncWithStreamOb() {    final Exception readException = new Exception();    Query request = Query.create(TABLE_ID).rowKey(ROW_KEY);    StreamObserver<Result> resultStreamOb =        new StreamObserver<Result>() {          @Override          public void onNext(Result result) {            assertResult(EXPECTED_RESULT, result);          }          @Override          public void onError(Throwable throwable) {            assertEquals(readException, throwable);          }          @Override          public void onCompleted() {}        };    when(mockDataClient.readRowsCallable(Mockito.<RowResultAdapter>any()))        .thenReturn(mockStreamingCallable);    doAnswer(            new Answer() {              int count = 0;              @Override              public Object answer(InvocationOnMock invocationOnMock) {                ResponseObserver<Result> resObserver = invocationOnMock.getArgument(1);                resObserver.onStart(null);                resObserver.onResponse(EXPECTED_RESULT);                if (count == 0) {                  resObserver.onComplete();                } else {                  resObserver.onError(readException);                }                count++;                return null;              }            })        .when(mockStreamingCallable)        .call(Mockito.<Query>any(), Mockito.<ResponseObserver<Result>>any());    dataClientWrapper.readRowsAsync(request, resultStreamOb);    dataClientWrapper.readRowsAsync(request, resultStreamOb);    verify(mockDataClient, times(2)).readRowsCallable(Mockito.<RowResultAdapter>any());    verify(mockStreamingCallable, times(2))        .call(Mockito.<Query>any(), Mockito.<ResponseObserver<Result>>any());  }
@Test    void mapToDouble() {        assertEquals(1, instance.mapToDouble(String::length).sum(), EPSILON);    }
@Test  public void testStartWebVtt() throws Exception {    EasyMock.expect(captionService.convert(EasyMock.anyObject(Attachment.class), EasyMock.anyObject(String.class),            EasyMock.anyObject(String.class), EasyMock.anyObject(String.class))).andReturn(job2);    EasyMock.replay(captionService);    operation.setConfiguration(AttachTranscriptionOperationHandler.TRANSCRIPTION_JOB_ID, "transcriptionJob");    // operation.setConfiguration(AttachTranscriptionOperationHandler.TARGET_FLAVOR, "captions/timedtext");    operation.setConfiguration(AttachTranscriptionOperationHandler.TARGET_TAG, "tag1,tag2");    operation.setConfiguration(AttachTranscriptionOperationHandler.TARGET_CAPTION_FORMAT, "vtt");    WorkflowOperationResult result = operationHandler.start(workflowInstance, null);    Assert.assertEquals(Action.CONTINUE, result.getAction());    MediaPackage updatedMp = result.getMediaPackage();    Attachment[] attachments = updatedMp.getAttachments(MediaPackageElementFlavor.parseFlavor("captions/vtt+en"));    Assert.assertNotNull(attachments);    Assert.assertEquals(1, attachments.length);    Assert.assertNotNull(attachments[0].getTags());    Assert.assertEquals(3, attachments[0].getTags().length);    Assert.assertEquals("lang:en", attachments[0].getTags()[0]);    Assert.assertEquals("tag1", attachments[0].getTags()[1]);    Assert.assertEquals("tag2", attachments[0].getTags()[2]);  }
@Test    void create21() {        final MutableTuple21<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> tuple = MutableTuples.create21();        test(tuple);        final MutableTuple21<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> defaultTuple = new MutableTuple21<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>()         {            private Integer t0;            private Integer t1;            private Integer t2;            private Integer t3;            private Integer t4;            private Integer t5;            private Integer t6;            private Integer t7;            private Integer t8;            private Integer t9;            private Integer t10;            private Integer t11;            private Integer t12;            private Integer t13;            private Integer t14;            private Integer t15;            private Integer t16;            private Integer t17;            private Integer t18;            private Integer t19;            private Integer t20;            @Override            public Optional<Integer> get0() {                return Optional.of(0);            }            @Override            public void set0(Integer val) {                t0 = val;            }            @Override            public Optional<Integer> get1() {                return Optional.of(1);            }            @Override            public void set1(Integer val) {                t1 = val;            }            @Override            public Optional<Integer> get2() {                return Optional.of(2);            }            @Override            public void set2(Integer val) {                t2 = val;            }            @Override            public Optional<Integer> get3() {                return Optional.of(3);            }            @Override            public void set3(Integer val) {                t3 = val;            }            @Override            public Optional<Integer> get4() {                return Optional.of(4);            }            @Override            public void set4(Integer val) {                t4 = val;            }            @Override            public Optional<Integer> get5() {                return Optional.of(5);            }            @Override            public void set5(Integer val) {                t5 = val;            }            @Override            public Optional<Integer> get6() {                return Optional.of(6);            }            @Override            public void set6(Integer val) {                t6 = val;            }            @Override            public Optional<Integer> get7() {                return Optional.of(7);            }            @Override            public void set7(Integer val) {                t7 = val;            }            @Override            public Optional<Integer> get8() {                return Optional.of(8);            }            @Override            public void set8(Integer val) {                t8 = val;            }            @Override            public Optional<Integer> get9() {                return Optional.of(9);            }            @Override            public void set9(Integer val) {                t9 = val;            }            @Override            public Optional<Integer> get10() {                return Optional.of(10);            }            @Override            public void set10(Integer val) {                t10 = val;            }            @Override            public Optional<Integer> get11() {                return Optional.of(11);            }            @Override            public void set11(Integer val) {                t11 = val;            }            @Override            public Optional<Integer> get12() {                return Optional.of(12);            }            @Override            public void set12(Integer val) {                t12 = val;            }            @Override            public Optional<Integer> get13() {                return Optional.of(13);            }            @Override            public void set13(Integer val) {                t13 = val;            }            @Override            public Optional<Integer> get14() {                return Optional.of(14);            }            @Override            public void set14(Integer val) {                t14 = val;            }            @Override            public Optional<Integer> get15() {                return Optional.of(15);            }            @Override            public void set15(Integer val) {                t15 = val;            }            @Override            public Optional<Integer> get16() {                return Optional.of(16);            }            @Override            public void set16(Integer val) {                t16 = val;            }            @Override            public Optional<Integer> get17() {                return Optional.of(17);            }            @Override            public void set17(Integer val) {                t17 = val;            }            @Override            public Optional<Integer> get18() {                return Optional.of(18);            }            @Override            public void set18(Integer val) {                t18 = val;            }            @Override            public Optional<Integer> get19() {                return Optional.of(19);            }            @Override            public void set19(Integer val) {                t19 = val;            }            @Override            public Optional<Integer> get20() {                return Optional.of(20);            }            @Override            public void set20(Integer val) {                t20 = val;            }        };        test(defaultTuple);    }
@Test  public void testClose() throws Exception {    List<String> listOfOneElement = ImmutableList.of(TEST_VALUE, TEST_VALUE);    when(stream.iterator()).thenReturn(listOfOneElement.iterator());    doNothing().when(stream).cancel();    try (ResultScanner<String> closedScanner = new RowResultScanner<>(stream, TEST_ARRAY)) {      assertEquals(TEST_VALUE, closedScanner.next());    }    verify(stream).iterator();    // verifying call the RowResultScanner#close.    verify(stream).cancel();  }
@Test  public void testApplyEmptyValue() {    Resource resource = new ResourceImpl(Resource.Type.HostComponent);    String propertyId = PropertyHelper.getPropertyId("category1", "foo");    Predicate predicate = new FilterPredicate(propertyId, "");    resource.setProperty(propertyId, "monkey");    Assert.assertFalse(predicate.evaluate(resource));    predicate = new FilterPredicate(propertyId, "monkey");    Assert.assertTrue(predicate.evaluate(resource));  }
@Test    public void testEthEstimateGasContractCreation() throws Exception {        web3j.platonEstimateGas(                Transaction.createContractTransaction(                        "0x52b93c80364dc2dd4444c146d73b9836bbbb2b3f", BigInteger.ONE,                        BigInteger.TEN, "")).send();        verifyResult("{\"jsonrpc\":\"2.0\",\"method\":\"platon_estimateGas\","                + "\"params\":[{\"from\":\"0x52b93c80364dc2dd4444c146d73b9836bbbb2b3f\","                + "\"gasPrice\":\"0xa\",\"data\":\"0x\",\"nonce\":\"0x1\"}],\"id\":1}");    }
@Test    void cleanup() {        cacheStore.put("key1", new TestCache(), Duration.ZERO, null);        cacheStore.put("key2", new TestCache(), Duration.ofMinutes(1), null);        cacheStore.cleanup();        assertThat(cacheStore.caches).hasSize(1);    }
@Test(description = "This method tests the behaviour of getGroups under valid conditions")    public void testGetGroups() throws GroupManagementException {        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getGroupManagementProviderService"))                .toReturn(groupManagementProviderService);        PowerMockito.stub(PowerMockito.method(PrivilegedCarbonContext.class, "getThreadLocalCarbonContext"))                .toReturn(context);        PaginationResult paginationResult = new PaginationResult();        Mockito.doReturn(paginationResult).when(groupManagementProviderService)                .getGroups(Mockito.anyString(), Mockito.any(GroupPaginationRequest.class));        Response response = groupManagementService.getGroups("test", "admin", 0, 10);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode(),                "GetGroups request failed with valid parameters");        Mockito.reset(groupManagementProviderService);        List<DeviceGroup> deviceGroupList = new ArrayList<>();        deviceGroupList.add(new DeviceGroup("test"));        paginationResult.setData(deviceGroupList);        paginationResult.setRecordsTotal(1);        Mockito.doReturn(paginationResult).when(groupManagementProviderService)                .getGroups(Mockito.anyString(), Mockito.any(GroupPaginationRequest.class));        response = groupManagementService.getGroups("test", "admin", 0, 10);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode(),                "GetGroups request failed with valid parameters");    }
@Test  public void testToCompletableFuture_exception() throws Exception {    ListeningExecutorService service =        MoreExecutors.listeningDecorator(            BigtableSessionSharedThreadPools.getInstance().getBatchThreadPool());    ListenableFuture<String> listenableFuture =        service.submit(            new Callable<String>() {              public String call() throws Exception {                throw new IllegalStateException("Test failed feature");              }            });    CompletableFuture<String> completableFuture = FutureUtils.toCompletableFuture(listenableFuture);    thrown.expect(ExecutionException.class);    thrown.expectCause(IsInstanceOf.<Throwable>instanceOf(IllegalStateException.class));    thrown.expectMessage(containsString("Test failed feature"));    completableFuture.get();  }
@Test  public void testResolveUserSearchFilterPlaceHolders() throws Exception {    String ldapUserSearchFilter = "{usernameAttribute}={0}  {userObjectClass}={1}";    String filter = ldapServerProperties.resolveUserSearchFilterPlaceHolders(ldapUserSearchFilter);    assertEquals("uid={0}  dummyObjectClass={1}", filter);  }
@Test	public void getResponseOkTest() {		CacheControl cc;		cc = new CacheControl();		cc.setNoCache(true);		cc.setNoTransform(true);		cc.setPrivate(true);		assertEquals(RestApiResponseHandler.getResponseOk().getStatus(), 200);		assertEquals(RestApiResponseHandler.getResponseOk("String for Test").getStatus() , (Response.ok("String for test").cacheControl(cc).build().getStatus()));		JSONObject jo = new JSONObject();		jo.put("status", 200);		assertEquals(RestApiResponseHandler.getResponseOk(jo).getStatus() , Response.ok(jo.toString()).cacheControl(cc).build().getStatus());	}
@Test  public void testTemporalStart()      throws RolloverActionException, SourceUnavailableException, IngestException {    catalogRolloverAction.doAction(tempFile);    ArgumentCaptor<UpdateRequest> argumentCaptor = ArgumentCaptor.forClass(UpdateRequest.class);    verify(catalogFramework, times(2)).update(argumentCaptor.capture());    ArgumentCaptor<Attribute> attributeCaptor = ArgumentCaptor.forClass(Attribute.class);    verify(createdParentMetacard, atLeastOnce()).setAttribute(attributeCaptor.capture());    List<Attribute> geoAttributeList =        attributeCaptor.getAllValues().stream()            .filter(attr -> attr.getName().equals(AttributeNameConstants.TEMPORAL_START))            .collect(Collectors.toList());    assertThat(geoAttributeList, hasSize(1));    assertThat(geoAttributeList.get(0).getValue(), is(TEMPORAL_START_DATE));  }
@Test    void testForEach() {        final Set<Map.Entry<String, Integer>> entries = new HashSet<>();        instance            .forEach((k, v) -> entries.add(entry(k, v)));        assertEquals(refStream().collect(Collectors.toSet()), entries);    }
@Test	public void testToJSONObject() {		AssetCategoryMetric childAssetCategoryMetric = new AssetCategoryMetric(			RandomTestUtil.randomString(), RandomTestUtil.randomString(),			RandomTestUtil.randomLong());		AssetVocabularyMetric assetVocabularyMetric = new AssetVocabularyMetric(			RandomTestUtil.randomString(), RandomTestUtil.randomString(),			Collections.singletonList(childAssetCategoryMetric));		AssetCategoryMetric assetCategoryMetric = new AssetCategoryMetric(			assetVocabularyMetric, RandomTestUtil.randomString(),			RandomTestUtil.randomString(), RandomTestUtil.randomLong());		String vocabularyName = RandomTestUtil.randomString();		Assert.assertEquals(			JSONUtil.put(				"categories",				JSONUtil.put(					JSONUtil.put(						"key", childAssetCategoryMetric.getKey()					).put(						"name", childAssetCategoryMetric.getName()					).put(						"value", childAssetCategoryMetric.getValue()					).put(						"vocabularyName", assetVocabularyMetric.getName()					))			).put(				"key", assetCategoryMetric.getKey()			).put(				"name", assetCategoryMetric.getName()			).put(				"value", assetCategoryMetric.getValue()			).put(				"vocabularyName", vocabularyName			).toString(),			String.valueOf(assetCategoryMetric.toJSONObject(vocabularyName)));	}
@Test  public void testNoAutoSkipFailure() throws Exception {    Map<String, UpgradePack> upgrades = ambariMetaInfo.getUpgradePacks("HDP", "2.2.0");    UpgradePack upgradePack = upgrades.get("upgrade_test_skip_failures");    List<Grouping> groups = upgradePack.getGroups(Direction.UPGRADE);    for (Grouping grouping : groups) {      if (grouping.name.equals("SKIPPABLE_BUT_NOT_AUTO_SKIPPABLE")) {        Assert.assertFalse(grouping.supportsAutoSkipOnFailure);      } else {        Assert.assertTrue(grouping.supportsAutoSkipOnFailure);      }    }  }
@Test	public void testCompareWhenServiceReferencesAreNull() {		PropertyServiceReferenceComparator<Object>			propertyServiceReferenceComparator =				new PropertyServiceReferenceComparator<>("ranking");		ServiceReference<Object> serviceReference1 = new TestServiceReference<>(			"ranking", 1);		Assert.assertEquals(			0, propertyServiceReferenceComparator.compare(null, null));		int compare = propertyServiceReferenceComparator.compare(			serviceReference1, null);		Assert.assertTrue(compare < 0);		Assert.assertEquals(			propertyServiceReferenceComparator.compare(serviceReference1, null),			-propertyServiceReferenceComparator.compare(				null, serviceReference1));	}
@Test	public void testThrowException() throws Exception {		DDMDataProviderRequest.Builder builder =			DDMDataProviderRequest.Builder.newBuilder();		DDMDataProviderRequest ddmDataProviderRequest = builder.withParameter(			"dataProviderInstanceId", "1"		).build();		when(			_ddmDataProviderInstanceService.getDataProviderInstance(1)		).thenThrow(			Exception.class		);		DDMDataProviderResponse ddmDataProviderResponse =			_ddmDataProviderInstanceOutputParametersDataProvider.getData(				ddmDataProviderRequest);		Optional<List<KeyValuePair>> optional =			ddmDataProviderResponse.getOutputOptional(				"outputParameterNames", List.class);		Assert.assertTrue(optional.isPresent());		List<KeyValuePair> keyValuePairs = optional.get();		Assert.assertEquals(keyValuePairs.toString(), 0, keyValuePairs.size());	}
@Test  public void testIsAliasString() {    String test = "cassablanca";    Assert.assertFalse(CredentialProvider.isAliasString(test));    test = "${}";    Assert.assertFalse(CredentialProvider.isAliasString(test));    test = "{}";    Assert.assertFalse(CredentialProvider.isAliasString(test));    test = "{cassablanca}";    Assert.assertFalse(CredentialProvider.isAliasString(test));    test = "${cassablanca}";    Assert.assertFalse(CredentialProvider.isAliasString(test));    test = "${alias=cassablanca}";    Assert.assertTrue(CredentialProvider.isAliasString(test));  }
@Test  public void testHasRepo() throws Exception {    given().pathParam("repoId", "UNKNOWN")            .expect()            .statusCode(HttpStatus.SC_OK)            .body(equalTo("false"))            .when().get(env.host("/hasrepo/{repoId}"));    given().pathParam("repoId", "default")            .expect()            .statusCode(HttpStatus.SC_OK)            .body(equalTo("true"))            .when().get(env.host("/hasrepo/{repoId}"));  }
@Test  public void testRetryableCheckAndMutateRowAsync() {    CheckAndMutateRowRequest request =        CheckAndMutateRowRequest.newBuilder().setTableName(TABLE_NAME).build();    defaultClient.checkAndMutateRowAsync(request);    verifyRequestCalled(request);  }
@Test    public void testEqualValueQuantityAscendingSort() {        Map<Long, Map<String, Set<TObject>>> records = Maps.newLinkedHashMap();        List<String> keys = Lists.newArrayList("name", "company", "age");        Map<String, Set<TObject>> entry = TMaps                .newLinkedHashMapWithCapacity(keys.size());        Set<TObject> values = Sets.newHashSet(Convert.javaToThrift("jeff"));        entry.put("name", values);        values = Sets.newHashSet(Convert.javaToThrift("Cinchapi"));        entry.put("company", values);        values = Sets.newHashSet(Convert.javaToThrift(50));        entry.put("age", values);        TMaps.putResultDatasetOptimized(records, Integer.toUnsignedLong(1),                entry);        entry = TMaps.newLinkedHashMapWithCapacity(keys.size());        values = Sets.newHashSet(Convert.javaToThrift("ashleah"));        entry.put("name", values);        values = Sets.newHashSet(Convert.javaToThrift("ARMN Inc."));        entry.put("company", values);        values = Sets.newHashSet(Convert.javaToThrift(100),                Convert.javaToThrift(20));        entry.put("age", values);        TMaps.putResultDatasetOptimized(records, Integer.toUnsignedLong(2),                entry);        entry = TMaps.newLinkedHashMapWithCapacity(keys.size());        values = Sets.newHashSet(Convert.javaToThrift("mark"));        entry.put("name", values);        values = Sets.newHashSet(Convert.javaToThrift("Cinchapi"));        entry.put("company", values);        values = Sets.newHashSet(Convert.javaToThrift(100),                Convert.javaToThrift(25));        entry.put("age", values);        TMaps.putResultDatasetOptimized(records, Integer.toUnsignedLong(3),                entry);        Order order = Order.by("age").ascending().build();        Store store = new Queue(1);        Map<Long, Map<String, Set<TObject>>> result = Sorting                .byValues(order, store).sort(records);        List<Long> expectedSort = Lists.newArrayList();        expectedSort.add(Integer.toUnsignedLong(1));        expectedSort.add(Integer.toUnsignedLong(2));        expectedSort.add(Integer.toUnsignedLong(3));        List<Long> sort = Lists.newArrayList(result.keySet());        Assert.assertEquals(expectedSort, sort);    }
@Test	public void testUninstall(){		ch.install(tf);		ch.uninstall(tf);		tf.updateUI();		Assert.assertFalse(changed);	}
@Test    public void getScenarioGridColumnLocal() {        String columnId = factMappingDescription.getExpressionIdentifier().getName();        String instanceTitle = factMappingDescription.getFactIdentifier().getName();        String propertyTitle = "PROPERTY TITLE";        final FactMappingType type = factMappingDescription.getExpressionIdentifier().getType();        String columnGroup = type.name();        scenarioGridSpy.getScenarioGridColumnLocal(instanceTitle, propertyTitle, columnId, columnGroup, type, ScenarioSimulationEditorConstants.INSTANCE.insertValue());        verify(scenarioGridSpy, times(1)).getHeaderBuilderLocal(eq(instanceTitle),                                                                eq(propertyTitle),                                                                eq(columnId),                                                                eq(columnGroup),                                                                eq(type));    }
@Test  public void testPerformMixTwo() throws Exception {    final Cluster cluster = Mockito.mock(Cluster.class);    Mockito.when(cluster.getClusterId()).thenReturn(1L);    Mockito.when(m_clusters.getCluster("cluster")).thenReturn(cluster);    Map<String, Service> services = new HashMap<String, Service>();    services.put("OLDSERVICE", Mockito.mock(Service.class));    Mockito.when(cluster.getServices()).thenReturn(services);    Map<String, String> checkProperties = new HashMap<String, String>();    checkProperties.put(ServicePresenceCheck.NO_UPGRADE_SUPPORT_SERVICES_PROPERTY_NAME,"Atlas, MyService");    checkProperties.put(ServicePresenceCheck.REMOVED_SERVICES_PROPERTY_NAME,"OldService");    checkProperties.put(ServicePresenceCheck.NEW_SERVICES_PROPERTY_NAME,"NewService");    PrerequisiteCheckConfig prerequisiteCheckConfig = Mockito.mock(PrerequisiteCheckConfig.class);    Mockito.when(prerequisiteCheckConfig.getCheckProperties(        m_check.getClass().getName())).thenReturn(checkProperties);    PrerequisiteCheck check = new PrerequisiteCheck(null, null);    PrereqCheckRequest request = new PrereqCheckRequest("cluster");    request.setPrerequisiteCheckConfig(prerequisiteCheckConfig);    m_check.perform(check, request);    Assert.assertEquals(PrereqCheckStatus.FAIL, check.getStatus());  }
@Test  public void testFromEntityWithBindingOfCardinalityTwoAndSameDirectionFactIsDestination() {    FactEntity.FactObjectBinding binding = new FactEntity.FactObjectBinding()            .setObjectID(UUID.randomUUID())            .setDirection(Direction.FactIsDestination);    FactEntity entity = new FactEntity().addBinding(binding).addBinding(binding);    FactRecord record = converter.fromEntity(entity);    assertNull(record.getSourceObject());    assertNull(record.getDestinationObject());  }
@Test  public void testAttachExtendedOnly() throws Exception {    WorkflowInstanceImpl instance = new WorkflowInstanceImpl();    List<WorkflowOperationInstance> ops = new ArrayList<WorkflowOperationInstance>();    WorkflowOperationInstanceImpl operation = new WorkflowOperationInstanceImpl("test", OperationState.INSTANTIATED);    ops.add(operation);    instance.setOperations(ops);    instance.setMediaPackage(mp);    MediaPackage clone = (MediaPackage) mp.clone();    operation.setConfiguration(SeriesWorkflowOperationHandler.SERIES_PROPERTY, "series1");    operation.setConfiguration(SeriesWorkflowOperationHandler.ATTACH_PROPERTY, "creativecommons/*");    operation.setConfiguration(SeriesWorkflowOperationHandler.APPLY_ACL_PROPERTY, "false");    WorkflowOperationResult result = operationHandler.start(instance, null);    Assert.assertEquals(Action.CONTINUE, result.getAction());    MediaPackage resultingMediapackage = result.getMediaPackage();    Assert.assertEquals("series1", resultingMediapackage.getSeries());    Assert.assertEquals("Series 1", resultingMediapackage.getSeriesTitle());    Assert.assertEquals(clone.getElements().length + 1, resultingMediapackage.getElements().length);  }
@Test  public void testProjectIdIsRequired() throws IOException {    Configuration configuration = new Configuration(false);    configuration.unset(BigtableOptionsFactory.PROJECT_ID_KEY);    expectedException.expect(IllegalArgumentException.class);    BigtableOptionsFactory.fromConfiguration(configuration);  }
@Test    void get6() {        assertEquals(m6, instance.get6());    }
@Test    public void testAnnotationType()    {        assertEquals(ServiceTypes.serviceType("apple").annotationType(), ServiceType.class);        assertEquals(ServiceTypes.serviceType("apple").annotationType(), appleServiceType.annotationType());    }
@Test  public void testBuildNegativeStateQuery() throws Exception {    WorkflowQuery q = new WorkflowQuery().withSeriesId("series1").withoutState(WorkflowState.RUNNING);    String solrQuery = dao.createQuery(q, Permissions.Action.READ.toString(), true);    String expected = "oc_org:mh_default_org AND seriesid:series1 AND (-state:running AND *:*)";    assertEquals(expected, solrQuery);  }
@Test    public void testWMSCapabilitiesLanguages()                            throws XMLStreamException {        WMSCapabilitiesAdapter capabilities = createCapabilities();        List<String> languages = capabilities.parseLanguages();        assertNull( languages );    }
@Test(expected = InvalidUsernamePasswordCombinationException.class)  public void testBadCredentialsForMissingLoginAlias() throws Exception {    // Given    assertNull("User already exists in DB", userDAO.findLdapUserByName("allowedUser"));    Authentication authentication = new UsernamePasswordAuthenticationToken("missingloginalias@ambari.apache.org", "password");    configuration.setProperty(Configuration.LDAP_ALT_USER_SEARCH_ENABLED.getKey(), "true");    // When    authenticationProvider.authenticate(authentication);    // Then    // InvalidUsernamePasswordCombinationException should be thrown due to no user with 'missingloginalias@ambari.apache.org'  is found in ldap  }
@Test    public void checkPerformanceWithSelectedCell() {        uiModel.selectCell(0,                           1);        handler.perform(gridWidget,                        true,                        true);        verify(gridWidget,               times(1)).selectCell(eq(0),                                    eq(0),                                    eq(false),                                    eq(false));    }
@Test  public void testResponseWithError() throws Exception {    ProxyService ps = new ProxyService();    URLStreamProvider streamProviderMock = PowerMock.createNiceMock(URLStreamProvider.class);    HttpURLConnection urlConnectionMock = createMock(HttpURLConnection.class);    Response.ResponseBuilder responseBuilderMock = PowerMock.createMock(ResponseBuilderImpl.class);    URI uriMock = PowerMock.createMock(URI.class);    Response responseMock = createMock(ResponseImpl.class);    InputStream es = new ByteArrayInputStream("error".getBytes());    MultivaluedMap<String, String> queryParams = new MultivaluedMapImpl();    MultivaluedMap<String, String> headerParams = new MultivaluedMapImpl();    Map<String, List<String>> headerParamsToForward = new HashMap<String, List<String>>();    headerParams.add("AmbariProxy-User-Remote","testuser");    headerParams.add("Content-Type","testtype");    List<String> userRemoteParams = new LinkedList<String>();    userRemoteParams.add("testuser");    headerParamsToForward.put("User-Remote", userRemoteParams);    PowerMock.mockStatic(Response.class);    expect(getHttpHeaders().getRequestHeaders()).andReturn(headerParams);    expect(getHttpHeaders().getRequestHeader("AmbariProxy-User-Remote")).andReturn(userRemoteParams);    expect(getUriInfo().getRequestUri()).andReturn(uriMock);    expect(getUriInfo().getQueryParameters()).andReturn(queryParams);    expect(uriMock.getQuery()).andReturn("url=testurl");    expect(streamProviderMock.processURL("testurl", "GET", (InputStream) null, headerParamsToForward)).andReturn(urlConnectionMock);    expect(urlConnectionMock.getResponseCode()).andReturn(400).times(2);    expect(urlConnectionMock.getContentType()).andReturn("text/plain");    expect(urlConnectionMock.getErrorStream()).andReturn(es);    expect(Response.status(400)).andReturn(responseBuilderMock);    expect(responseBuilderMock.entity(es)).andReturn(responseBuilderMock);    expect(responseBuilderMock.type("text/plain")).andReturn(responseBuilderMock);    expect(responseBuilderMock.build()).andReturn(responseMock);    PowerMock.expectNew(URLStreamProvider.class, 20000, 15000, null, null, null).andReturn(streamProviderMock);    PowerMock.replay(streamProviderMock, URLStreamProvider.class, uriMock, URI.class, Response.class, responseBuilderMock);    replay(getUriInfo(), urlConnectionMock, getHttpHeaders());    Response resultForErrorRequest = ps.processGetRequestForwarding(getHttpHeaders(),getUriInfo());    assertSame(resultForErrorRequest, responseMock);  }
@Test    public void testGetIndexWithDefaultSelectSecondOption() throws Exception {        assertEquals(2,                     DecisionTableColumnViewUtils.getCurrentIndexFromList(SECOND_OPTION,                                                                          listBox));    }
@Test public void testOnViewCreatedWithBackgroundResource() {		// Arrange:		final BaseFragment fragment = new TestFragmentWithContentViewWithBackgroundResource();		final View mockView = mock(FrameLayout.class);		// Act:		fragment.onViewCreated(mockView, null);		// Assert:		verify(mockView).setBackgroundResource(TestFragmentWithContentViewWithBackgroundResource.BACKGROUND_RESOURCE);		verifyNoMoreInteractions(mockView);	}
@Test	public void testFileVersionPath() throws Exception {		Mockito.when(			_dlAppService.getFileVersion(1)		).thenReturn(			_fileVersion		);		Mockito.when(			_amImageConfigurationHelper.getAMImageConfigurationEntry(				Mockito.anyLong(), Mockito.eq("x"))		).thenReturn(			Optional.of(_amImageConfigurationEntry)		);		_pathInterpreter.interpretPath("/image/0/1/x/foo.jpg");		Mockito.verify(			_dlAppService		).getFileEntry(			0		);		Mockito.verify(			_dlAppService		).getFileVersion(			1		);		Mockito.verify(			_fileVersion		).getCompanyId();		Mockito.verify(			_amImageConfigurationEntry		).getProperties();		Mockito.verify(			_amImageConfigurationEntry		).getUUID();	}
@Test  public void shouldAnalyzeInlineResourceAndReturnWarnings() throws Exception {    TestFile[] files = {        xml("file1", "<xml></xml>"),        java("file2", "public class Class{}") };    Detector detector = Helper.dummyDetector();    Issue[] issues = { Helper.dummyIssue() };    Lint lint = new Lint(detector, issues);    List<Warning> warnings = lint.project(files);    assertThat(warnings).isEqualTo(Helper.dummyWarnings());  }
@Test    void shouldNotFailAsyncResultEvenWhenRunFailed() throws Throwable    {        // Given        Connection connection = mock( Connection.class );        Throwable error = new RuntimeException( "Hi there" );        ResultCursorFactory cursorFactory = newResultCursorFactory( connection, failedFuture( error ), false );        // When        CompletionStage<AsyncResultCursor> cursorFuture = cursorFactory.asyncResult();        // Then        verifyRunCompleted( connection, cursorFuture );    }
@Test    public void canFactoryProcessViewsShouldBeRobustWithWeirdInput() {        Dictionary<String, String> headers = new Hashtable<>(2);        headers.put(BundleScriptingConfigurationConstants.JAHIA_MODULE_SCRIPTING_VIEWS, ",,,");        assertFalse(ScriptEngineUtils.canFactoryProcessViews(new TestScriptEngineFactory(), headers));        headers.put(BundleScriptingConfigurationConstants.JAHIA_MODULE_SCRIPTING_VIEWS, ",     foo  \t\n,,");        assertTrue(ScriptEngineUtils.canFactoryProcessViews(new TestScriptEngineFactory(), headers));        headers.put(BundleScriptingConfigurationConstants.JAHIA_MODULE_SCRIPTING_VIEWS, ",     js  \t\n,,    bar,");        assertTrue(ScriptEngineUtils.canFactoryProcessViews(new TestScriptEngineFactory(), headers));    }
@Test  public void missingClusterVersionShouldNotCauseException() throws Exception {    init(false);    activeRepoUpdater.process();  }
@Test    void shouldFailToHandleRecord()    {        assertThrows( UnsupportedOperationException.class, () -> handler.onRecord( new Value[]{value( 42 )} ) );    }
@Test    public void testConvertJsonFloat() {        float value = Random.getFloat();        String json = "{\"elt\": " + value + "}";        Multimap<String, Object> data = Convert.jsonToJava(json);        Assert.assertEquals(value, Iterables.getOnlyElement(data.get("elt")));    }
@Test	public void testCompareIsTransitiveWhenServiceReferencePropertiesAreNull() {		PropertyServiceReferenceComparator<Object>			propertyServiceReferenceComparator =				new PropertyServiceReferenceComparator<>("ranking");		ServiceReference<Object> serviceReference1 = new TestServiceReference<>(			"ranking", -1);		ServiceReference<Object> serviceReference2 = new TestServiceReference<>(			"ranking", 0);		ServiceReference<Object> serviceReference3 = new TestServiceReference<>(			"ranking", 1);		ServiceReference<Object> serviceReference4 =			new TestServiceReference<>();		int compare1 = propertyServiceReferenceComparator.compare(			serviceReference4, serviceReference1);		Assert.assertTrue(compare1 > 0);		int compare2 = propertyServiceReferenceComparator.compare(			serviceReference1, serviceReference2);		Assert.assertTrue(compare2 > 0);		int compare3 = propertyServiceReferenceComparator.compare(			serviceReference4, serviceReference2);		Assert.assertTrue(compare3 > 0);		int compare4 = propertyServiceReferenceComparator.compare(			serviceReference4, serviceReference2);		Assert.assertTrue(compare4 > 0);		int compare5 = propertyServiceReferenceComparator.compare(			serviceReference2, serviceReference3);		Assert.assertTrue(compare5 > 0);		int compare6 = propertyServiceReferenceComparator.compare(			serviceReference4, serviceReference3);		Assert.assertTrue(compare6 > 0);	}
@Test(expected=IllegalArgumentException.class)  public void testCreate_HostGroupWithNoComponents() throws Exception {    Map<String, Object> props = BlueprintResourceProviderTest.getBlueprintTestProperties().iterator().next();    // remove the components for one of the host groups    ((Set<Map<String, Object>>) props.get(BlueprintResourceProvider.HOST_GROUP_PROPERTY_ID)).        iterator().next().remove(BlueprintResourceProvider.COMPONENT_PROPERTY_ID);    replay(stack, dao, entity, configEntity);    testFactory.createBlueprint(props, null);  }
@Test	public void testProcessTemplate8() throws Exception {		Template template = new VelocityTemplate(			new MockTemplateResource(_TEMPLATE_FILE_NAME),			HashMapBuilder.<String, Object>put(				_TEST_KEY, _TEST_VALUE			).build(),			_velocityEngine, _templateContextHelper, _templateResourceCache,			false);		UnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter();		template.processTemplate(unsyncStringWriter);		String result = unsyncStringWriter.toString();		Assert.assertEquals(_TEST_VALUE, result);	}
@Test    public void testWMSCapabilitiesOperationsMetadata()                            throws XMLStreamException {        WMSCapabilitiesAdapter capabilities = createCapabilities();        OperationsMetadata operationsMetadata = capabilities.parseOperationsMetadata();        List<Operation> operations = operationsMetadata.getOperation();        assertEquals( 4, operations.size() );        Operation getMapOperation = operationsMetadata.getOperation( "GetMap" );        List<URL> getUrls = getMapOperation.getGetUrls();        assertEquals( 1, getUrls.size() );        assertEquals( getGetGetMapUrl(), getUrls.get( 0 ).toExternalForm() );        List<URL> postUrls = getMapOperation.getPostUrls();        assertEquals( 1, postUrls.size() );        assertEquals( getPostGetMapUrl(), postUrls.get( 0 ).toExternalForm() );        List<DCP> dcps = getMapOperation.getDCPs();        assertEquals( 1, dcps.size() );        DCP dcp = dcps.get( 0 );        List<Pair<URL, List<Domain>>> getEndpoints = dcp.getGetEndpoints();        assertEquals( 1, getEndpoints.size() );        assertEquals( getGetGetMapUrl(), getEndpoints.get( 0 ).getFirst().toExternalForm() );        List<Pair<URL, List<Domain>>> postEndpoints = dcp.getPostEndpoints();        assertEquals( 1, postEndpoints.size() );        assertEquals( getPostGetMapUrl(), postEndpoints.get( 0 ).getFirst().toExternalForm() );    }
@Test  public void testStatusFromStages() throws Exception {    Collection<Stage> stages;    CalculatedStatus status;    // completed request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.COMPLETED, status.getStatus());    assertEquals(100.0, status.getPercent(), 0.1);    // in progress request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.IN_PROGRESS, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.IN_PROGRESS, status.getStatus());    assertEquals(48.3, status.getPercent(), 0.1);    // pending request    stages = getStages(        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.PENDING, status.getStatus());    assertEquals(0.0, status.getPercent(), 0.1);    // failed request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.FAILED, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.FAILED, status.getStatus());    assertEquals(55.55, status.getPercent(), 0.1);    // timed out request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.TIMEDOUT),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.TIMEDOUT, status.getStatus());    assertEquals(66.66, status.getPercent(), 0.1);    // holding request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.HOLDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.HOLDING, status.getStatus());    assertEquals(47.5, status.getPercent(), 0.1);    // holding failed request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.HOLDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.HOLDING, status.getStatus());    assertEquals(47.5, status.getPercent(), 0.1);    // holding timed out request    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.HOLDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.HOLDING, status.getStatus());    assertNull(status.getDisplayStatus());    assertEquals(47.5, status.getPercent(), 0.1);    // aborted    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.ABORTED),        getTaskEntities(HostRoleStatus.ABORTED, HostRoleStatus.ABORTED, HostRoleStatus.ABORTED),        getTaskEntities(HostRoleStatus.ABORTED, HostRoleStatus.ABORTED, HostRoleStatus.ABORTED)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.ABORTED, status.getStatus());    assertNull(status.getDisplayStatus());    assertEquals(100.0, status.getPercent(), 0.1);    // in-progress even though there are aborted tasks in the middle    stages = getStages(        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED, HostRoleStatus.COMPLETED),        getTaskEntities(HostRoleStatus.ABORTED, HostRoleStatus.ABORTED, HostRoleStatus.PENDING),        getTaskEntities(HostRoleStatus.PENDING, HostRoleStatus.PENDING, HostRoleStatus.PENDING)    );    status = CalculatedStatus.statusFromStages(stages);    assertEquals(HostRoleStatus.IN_PROGRESS, status.getStatus());    assertNull(status.getDisplayStatus());    assertEquals(66.6, status.getPercent(), 0.1);  }
@Test  @SuppressWarnings("unchecked")  public void testVerbListIdentifiersAll() throws Exception {    final OaiPmhRepository repo = repo(            oaiPmhPersistenceMock(searchResultItem("id-1", new Date(), false),                                  searchResultItem("id-2", utcDate(2011, 6, 1), false)), Granularity.DAY);    runChecks(OaiPmhConstants.VERB_LIST_IDENTIFIERS,              repo.selectVerb(params("ListIdentifiers", null, "oai_dc", null, null, null)),              some(IsValid),              list(hasXPath("//oai20:ListIdentifiers/oai20:header[oai20:identifier='id-1']", NS_CTX),                   hasXPath("//oai20:ListIdentifiers/oai20:header[oai20:identifier='id-2']", NS_CTX),                   hasXPath("//oai20:ListIdentifiers/oai20:header[oai20:datestamp='2011-06-01']", NS_CTX),                   hasXPath("count(//oai20:ListIdentifiers/oai20:header)", NS_CTX, returningANumber(), equalTo(2.0))));  }
@Test    public void testDefaultConfig() {    	try {    		PModeManager manager = new PModeManager(config);    		    		Field pmodeStorage = PModeManager.class.getDeclaredField("deployedPModes");    		pmodeStorage.setAccessible(true);    		assertTrue(pmodeStorage.get(manager) instanceof InMemoryPModeSet);    	} catch (Throwable t) {    		t.printStackTrace();    		fail();    	}    }
@Test public void testOnBackPress() {		// Arrange:		final ActionMode mockActionMode = mock(ActionMode.class);		final ActionBarFragment fragment = new TestFragment();		fragment.onActionModeStarted(mockActionMode);		// Act + Assert:		assertThat(fragment.onBackPress(), is(true));		verify(mockActionMode).finish();		verifyNoMoreInteractions(mockActionMode);	}
@Test    void appendWithNullArguments() {        var builder = new StringBuilder();        filter.append(builder, "message", (Object[]) null);        assertThat(builder.toString()).isEqualTo("message");    }
@SuppressWarnings("unchecked")	@Test	public void testVisitBinaryExpressionOperationWithLowerEqualOperation() {		Map<String, EntityField> entityFieldsMap =			_entityModel.getEntityFieldsMap();		EntityField entityField = entityFieldsMap.get("title");		String value = "title1";		RangeTermFilter rangeTermFilter =			(RangeTermFilter)				_expressionVisitorImpl.visitBinaryExpressionOperation(					BinaryExpression.Operation.LE, entityField, value);		Assert.assertEquals(entityField.getName(), rangeTermFilter.getField());		Assert.assertNull(rangeTermFilter.getLowerBound());		Assert.assertFalse(rangeTermFilter.isIncludesLower());		Assert.assertEquals(value, rangeTermFilter.getUpperBound());		Assert.assertTrue(rangeTermFilter.isIncludesUpper());	}
@Test(expectedExceptions = UnsupportedOperationException.class)    public void testMaxValueNoNumber() {        IndexImpl<Node> index = generateEmptyIndex();        index.getMaxValue(index.columnStore.getColumn("foo"));    }
@Test    public void testWriteInt() throws Exception {        //given        final int i0 = 0x45678901;        final int i1 = 0x12345678;        //when        final Pointer<Integer> integerPointer = Pointer.nref(i0,                                                             i1);        //then        assertThat(JNITestUtil.getByte(integerPointer.address)).isEqualTo((byte) 0x01);        assertThat(JNITestUtil.getByte(integerPointer.address + 1)).isEqualTo((byte) 0x89);        assertThat(JNITestUtil.getByte(integerPointer.address + 2)).isEqualTo((byte) 0x67);        assertThat(JNITestUtil.getByte(integerPointer.address + 3)).isEqualTo((byte) 0x45);        assertThat(JNITestUtil.getByte(integerPointer.address + 4)).isEqualTo((byte) 0x78);        assertThat(JNITestUtil.getByte(integerPointer.address + 5)).isEqualTo((byte) 0x56);        assertThat(JNITestUtil.getByte(integerPointer.address + 6)).isEqualTo((byte) 0x34);        assertThat(JNITestUtil.getByte(integerPointer.address + 7)).isEqualTo((byte) 0x12);    }
@Test(expected = IllegalArgumentException.class)  public void testSerializePrivilegesByRoleWithNull() throws Exception {    AccessInformationUtil.serializePrivilegesByRole(null);  }
@Test	public void testGetPortletEditableValues() throws Exception {		String editableValues = _read(			"fragment_entry_link_portlet_editable_values.json");		Assert.assertEquals(			_objectMapper.readTree(				_read(					"fragment_entry_link_portlet_editable_values_segments_" +						"experience_0.json")),			_objectMapper.readTree(				EditableValuesTransformerUtil.getEditableValues(					editableValues, 0)));	}
@Test  public void getDataPointsTest()  {    DimensionalTable<Integer> table = createTestTable();    //Select on publisher    Set<Integer> expectedDataPoints = Sets.newHashSet(3, 4, 5);    Map<String, String> selectionKeys = Maps.newHashMap();    selectionKeys.put("publisher", "twitter");    Set<Integer> dataPoints = Sets.newHashSet(table.getDataPoints(selectionKeys));    Assert.assertEquals(expectedDataPoints, dataPoints);    //Select on advertiser    expectedDataPoints = Sets.newHashSet(8, 9);    selectionKeys.clear();    selectionKeys.put("advertiser", "microsoft");    dataPoints = Sets.newHashSet(table.getDataPoints(selectionKeys));    Assert.assertEquals(expectedDataPoints, dataPoints);    //Select on location    expectedDataPoints = Sets.newHashSet(2, 10);    selectionKeys.clear();    selectionKeys.put("location", "NY");    dataPoints = Sets.newHashSet(table.getDataPoints(selectionKeys));    Assert.assertEquals(expectedDataPoints, dataPoints);  }
@Test  public void testCreanupWOHwithoutPreservedFlavorAndWithoutDeleteExternal() throws WorkflowOperationException,          MediaPackageException {    Map<String, String> wfInstConfig = new Hashtable<>();    MediaPackageBuilder mpBuilder = MediaPackageBuilderFactory.newInstance().newMediaPackageBuilder();    MediaPackage mp = mpBuilder.createNew();    MediaPackageElement track1 = addElementToMediaPackage(mp, MediaPackageElement.Type.Track,            "presenter", "source", null);    track1.setURI(UrlSupport.uri(HOSTNAME_NODE1, WFR_URL_PREFIX, WorkingFileRepository.COLLECTION_PATH_PREFIX,            "asset", mp.getIdentifier().toString(), track1.getIdentifier(), "track.mp4"));    cleanupWOH.start(createWorkflowInstance(wfInstConfig, mp), null);    Assert.assertEquals("Media package shouldn't contain any elements", 0, mp.getElements().length);    Assert.assertEquals("Delete on remote repository not allowed", 0, deletedFilesURIs.size());  }
@Test    public void testGetDownloadUrl() throws Exception {        assertEquals(SERVLET_URL + "&attachmentPath=",                     view.getDownloadUrl(path()));    }
@Test	public void testReadTypedCollection() throws IOException {		Assert.assertEquals(			new ArrayList<Integer>() {				{					add(1);					add(2);				}			},			ConfigurationHandler.read(				"I( \\\r\n  \"1\", \\\r\n  \"2\", \\\r\n)"));	}
@Test  public void testGetNonExistingFactTypeIdsBasedOnNames() {    assertEquals(new HashSet<>(), resolver.factTypeNamesToIds(new HashSet<>()));    assertEquals(new HashSet<>(), resolver.factTypeNamesToIds(null));  }
@Test  public void testAuthName() throws Exception {    String user = AuthorizationHelper.getAuthenticatedName();    Assert.assertNull(user);    Authentication auth = new UsernamePasswordAuthenticationToken("admin", null);    SecurityContextHolder.getContext().setAuthentication(auth);    user = AuthorizationHelper.getAuthenticatedName();    Assert.assertEquals("admin", user);  }
@Test  public void testOneLeggedFactsAsPropsFilterRetracted() {    UUID objectId = UUID.randomUUID();    ObjectRecord objectRecord = new ObjectRecord().setId(objectId);    FactTypeStruct factType = mockFactType("factType");    FactRecord retractedFact = new FactRecord().setTypeID(factType.getId()).setValue("factValue1");    FactRecord fact = new FactRecord().setTypeID(factType.getId()).setValue("factValue2");    when(securityContext.hasReadPermission(any(FactRecord.class))).thenReturn(true);    when(objectFactDao.searchFacts(argThat(x -> Objects.equals(x.getObjectID(), set(objectId))))).thenAnswer(x ->            ResultContainer.<FactRecord>builder().setValues(ListUtils.list(retractedFact, fact).iterator()).build()    );    when(factRetractionHandler.isRetracted(retractedFact)).thenReturn(true);    when(factRetractionHandler.isRetracted(fact)).thenReturn(false);    assertEquals(2, helper.getOneLeggedFactsAsProperties(objectRecord, TraverseParams.builder().setIncludeRetracted(true).build()).size());    assertEquals(1, helper.getOneLeggedFactsAsProperties(objectRecord, TraverseParams.builder().setIncludeRetracted(false).build()).size());  }
@Test    public void testUseForwardedForInternal()    {        when(request.getRemoteAddr()).thenReturn("10.10.10.10");        when(request.getHeaders("X-FORWARDED-FOR")).thenReturn(Collections.enumeration(ImmutableList.of("10.11.12.13")));        assertEquals(new ClientAddressExtractor().clientAddressFor(request), "10.11.12.13");    }
@Test    public void queryEventsByTriggerId() throws Exception {        int numTenants = 2;        int numTriggers = 5;        int numEvents = 5;        createTestEvents(numTenants, numTriggers, numEvents);        Set<String> tenantIds = new HashSet<>();        tenantIds.add("tenant0");        tenantIds.add("tenant1");        EventsCriteria criteria = new EventsCriteria();        criteria.setTriggerId("trigger0");        List<Event> trigger0Events = alerts.getEvents(tenantIds, criteria, null);        assertEquals(10, trigger0Events.size());        criteria.setTriggerIds(Arrays.asList("trigger0", "trigger1", "trigger2"));        List<Event> trigger012Events = alerts.getEvents(tenantIds, criteria, null);        assertEquals(30, trigger012Events.size());        deleteTestEvents(numTenants);    }
@Test  public void testGetSettingWithoutSetOfProperties() {    SettingFactory settingFactory = new SettingFactory();    Map<String, Set<HashMap<String, String>>> properties;    Setting setting = settingFactory.getSetting(createSettingWithoutSetOfProperties());    Set<HashMap<String, String>> propertyValues = setting.getSettingValue(Setting.SETTING_NAME_RECOVERY_SETTINGS);    assertEquals(propertyValues.size(), 1);    assertEquals(propertyValues.iterator().next().get(Setting.SETTING_NAME_RECOVERY_ENABLED), "true");  }
@Test	public void testGetInterestTermsWithEmptyAcClientUserId() {		Assert.assertArrayEquals(			new String[0],			_asahInterestTermProvider.getInterestTerms(				RandomTestUtil.randomLong(), StringPool.BLANK));	}
@Test    public void shouldReturnExpectedArtifactGroups()            throws IOException    {        RepositoryPath path = new RepositoryPath(REPOSITORY_BASEDIR, repositoryFileSystem).resolve("org")                                                                                          .resolve("carlspring")                                                                                          .resolve("abs-lay-prov-test")                                                                                          .resolve("1.8")                                                                                          .resolve("abs-lay-prov-test-1.8.jar");        Set<ArtifactGroupEntry> artifactGroups = layoutProvider.getArtifactGroups(path);        assertThat(artifactGroups).isNotNull();        assertThat(artifactGroups).isEmpty();        RepositoryArtifactIdGroupEntry repositoryArtifactIdGroup = artifactGroupService.findOneOrCreate("storage0",                                                                                                        "releases",                                                                                                        "abs-lay-prov-test");        artifactGroups = layoutProvider.getArtifactGroups(path);        assertThat(artifactGroups).isNotNull();        assertThat(artifactGroups).hasSize((1));        assertThat(artifactGroups.iterator().next()).isEqualTo(repositoryArtifactIdGroup);        assertThat(repositoryArtifactIdGroup).isInstanceOf(RepositoryArtifactIdGroupEntry.class);        assertThat(repositoryArtifactIdGroup.getArtifactId()).isEqualTo(("abs-lay-prov-test"));        assertThat(repositoryArtifactIdGroup.getRepositoryId()).isEqualTo(("releases"));        assertThat(repositoryArtifactIdGroup.getStorageId()).isEqualTo(("storage0"));        assertThat(repositoryArtifactIdGroup.getClass()).isEqualTo((RepositoryArtifactIdGroupEntry.class));    }
@Test    public void testIntegerAliases() {        column.setFactField(FIELD_NAME);        column.setFieldType(DataType.TYPE_NUMERIC_INTEGER);        column.setValueList("1=One,2=Two");        final String[] valueList = utilities.getValueList(column);        Assertions.assertThat(valueList).containsExactly("1=One", "2=Two");    }
@Test    void getFieldQuoteStart() {        assertNotNull(DATABASE_NAMING_CONVENTION.getFieldQuoteStart());    }
@Test    void getJavadoc() {        assertFalse(instance().getJavadoc().isPresent());    }
@Test    public void getFactModelTreeEnumClass() {        final ModelField[] modelFields = {};        Map<String, String> superTypesMap = new HashMap<>();        superTypesMap.put(FACT_NAME, Enum.class.getCanonicalName());        final FactModelTree retrieved = abstractDMODataManagementStrategySpy.getFactModelTree(FACT_NAME, superTypesMap, modelFields);        assertNotNull(retrieved);        assertEquals(FACT_NAME, retrieved.getFactName());        assertEquals(FULL_PACKAGE, retrieved.getFullPackage());        assertTrue(retrieved.getSimpleProperties().containsKey(TestProperties.LOWER_CASE_VALUE));        assertEquals(FULL_CLASS_NAME, retrieved.getSimpleProperties().get(TestProperties.LOWER_CASE_VALUE).getTypeName());        assertEquals(FULL_CLASS_NAME, retrieved.getSimpleProperties().get(TestProperties.LOWER_CASE_VALUE).getPropertyTypeNameToVisualize());        assertFalse(retrieved.getSimpleProperties().get(TestProperties.LOWER_CASE_VALUE).getBaseTypeName().isPresent());        assertEquals(FULL_CLASS_NAME, retrieved.getSimpleProperties().get(TestProperties.LOWER_CASE_VALUE).getPropertyTypeNameToVisualize());    }
@Test  public void testAssignRow() {    double[] data = {2.1, 3.2};    test.assignRow(1, new DenseVector(data));    assertEquals("test[1][0]", 2.1, test.getQuick(1, 0), EPSILON);    assertEquals("test[1][1]", 3.2, test.getQuick(1, 1), EPSILON);  }
@Test    void next() {        assertEquals(ELEMENT, instance.next());    }
@Test  public void startUploadTest() throws IOException {    CloseableHttpResponse response = EasyMock.createNiceMock(CloseableHttpResponse.class);    StatusLine status = EasyMock.createNiceMock(StatusLine.class);    EasyMock.expect(response.getStatusLine()).andReturn(status).anyTimes();    EasyMock.expect(status.getStatusCode()).andReturn(HttpStatus.SC_OK).anyTimes();    EasyMock.replay(response, status);    Capture<HttpPost> capturedPost = Capture.newInstance();    EasyMock.expect(httpClient.execute(EasyMock.capture(capturedPost))).andReturn(response).anyTimes();    EasyMock.replay(httpClient);    // Check if correct url was invoked    service.startUpload(httpClient, bucket, mpId, fileExtension, file, size, contentType, token);    Assert.assertEquals("https://www.googleapis.com/upload/storage/v1/b/bucket/o?uploadType=resumable&name=mpId.flac",            capturedPost.getValue().getURI().toString());  }
@Test  public void testBagging() {    Data bag = classifierData.bagging(rng);    // the bag should have the same size as the data    assertEquals(classifierData.size(), bag.size());    // at least one element from the data should not be in the bag    boolean found = false;    for (int index = 0; index < classifierData.size() && !found; index++) {      found = !bag.contains(classifierData.get(index));    }        assertTrue("some instances from data should not be in the bag", found);    // regression    bag = regressionData.bagging(rng);    // the bag should have the same size as the data    assertEquals(regressionData.size(), bag.size());    // at least one element from the data should not be in the bag    found = false;    for (int index = 0; index < regressionData.size() && !found; index++) {      found = !bag.contains(regressionData.get(index));    }        assertTrue("some instances from data should not be in the bag", found);}
@Test    void testInfo3() {        instance.info(FORMATTING_MESSAGE, MESSAGE);        assertTrue(output.contains(FORMATTING_MESSAGE_PREFIX + "|" + MESSAGE));    }
@Test(expected = IllegalArgumentException.class)    public void ofBytesTooFew() {        DataLength.of(NULL_BYTE, NULL_BYTE, NULL_BYTE);    }
@Test    public void testInstall() {    	wrapper.install(txt, false);    	mustBeInstalled();	}
@Test  public void getAppWindowDurationMSTest()  {    OperatorContext context = createOperatorContext(500, 10);    long appWindowDuration = WindowUtils.getAppWindowDurationMs(context);    Assert.assertEquals(5000L, appWindowDuration);  }
@Test    public void fourCo() throws Exception {        Assert.assertEquals((long)RxComprehensions.doCompose(zero(0), intIncrementToString(), stringToInt(), intIncrementToString(), stringToInt()).toBlocking().first(), 2);    }
@Test    void invoke() throws InvocationTargetException, IllegalAccessException {        final Foo foo = new Foo(0);        final Execution.ClassMapper classMapper = new Execution.ClassMapper() {            @Override            public <T> T apply(Class<T> type) {                return null;            }        };        assertTrue(instance.invoke(foo, classMapper));        assertEquals(1, foo.value);    }
@Test	public void testGetUpgradePathWithIllegalArguments() {		UpgradeInfo upgradeInfo1 = createUpgradeInfo("0.0.0", "0.1.0");		UpgradeInfo upgradeInfo2 = createUpgradeInfo("0.1.0", "0.2.0");		UpgradeInfo upgradeInfo3 = createUpgradeInfo("0.2.0", "1.0.0");		UpgradeInfo upgradeInfo4 = createUpgradeInfo("1.0.0", "2.0.0");		ReleaseGraphManager releaseGraphManager = new ReleaseGraphManager(			Arrays.asList(				upgradeInfo4, upgradeInfo2, upgradeInfo1, upgradeInfo3));		List<UpgradeInfo> upgradeInfos = releaseGraphManager.getUpgradeInfos(			"0.0.0", "2.0.1");		Assert.assertEquals(upgradeInfos.toString(), 0, upgradeInfos.size());	}
@Test  public void testCreateObjectType() throws Exception {    UUID id = UUID.randomUUID();    when(getTiService().createObjectType(any(), isA(CreateObjectTypeRequest.class))).then(i -> ObjectType.builder().setId(id).build());    Response response = target("/v1/objectType").request().post(Entity.json(createCreateObjectTypeRequest()));    assertEquals(201, response.getStatus());    assertEquals(id.toString(), getPayload(response).get("id").textValue());    verify(getTiService(), times(1)).createObjectType(notNull(), isA(CreateObjectTypeRequest.class));  }
@Test(description = "This test case tests handling ProfileManagerDAOException when adding new profile feature",          dependsOnMethods = "testAddProfileFeatures")    public void testAddProfileFeaturesThrowingProfileManagerDAOException() throws Exception {        Profile profile = ProfileCreator.getProfile(FeatureCreator.getFeatureList(), DEVICE_TYPE_D);        profile1 = profileManager.addProfile(profile);        ProfileDAO profileDAO = mock(ProfileDAO.class);        when(profileDAO.getProfile(anyInt())).thenThrow(new ProfileManagerDAOException());        List<ProfileFeature> profileFeaturesList = profile.getProfileFeaturesList();        testThrowingException(featureManager,                              profileFeaturesList,                              p -> featureManager.addProfileFeatures((List<ProfileFeature>) p, profile1.getProfileId()),                              "profileDAO", profileDAO,                              ProfileManagerDAOException.class);    }
@Test    void get3() {        assertEquals(m3, instance.get3());    }
@Test  public void testRequestValidationSucceeds() {    assertTrue(getValidator().validate(new DeleteOriginRequest().setId(UUID.randomUUID())).isEmpty());  }
@Test    public void testJsonEncode()    {        assertJsonEncode(createPerson("alice@example.com", "Alice"),                ImmutableMap.of(                        "name", "Alice",                        "email", "alice@example.com"                ));    }
@SuppressWarnings("unchecked")    @Test    public void serialize() {        ConfigSerializer serializer = new ConfigSerializer();        Map<String, Object> map = new HashMap<>();        serializer.serialize(map, config);        assertEquals("123456abcdeabcde", map.get("apiKey"));        assertTrue((Boolean) map.get("autoDetectErrors"));        assertTrue((Boolean) map.get("autoTrackSessions"));        assertEquals("ALWAYS", map.get("sendThreads"));        assertEquals(Collections.singleton("com.example.DiscardClass"), map.get("discardClasses"));        assertEquals(Collections.singleton("production"), map.get("enabledReleaseStages"));        assertEquals(Collections.singleton("com.example"), map.get("projectPackages"));        assertEquals("production", map.get("releaseStage"));        assertEquals("builduuid-123", map.get("buildUuid"));        assertEquals("1.4.3", map.get("appVersion"));        assertEquals(55, map.get("versionCode"));        assertEquals("android", map.get("type"));        assertTrue((Boolean) map.get("persistUser"));        assertEquals(55, map.get("launchCrashThresholdMs"));        assertEquals(22, map.get("maxBreadcrumbs"));        assertEquals(Collections.singleton("manual"), map.get("enabledBreadcrumbTypes"));        Map<String, Object> errorTypes = (Map<String, Object>) map.get("enabledErrorTypes");        assertTrue((Boolean) errorTypes.get("anrs"));        assertTrue((Boolean) errorTypes.get("ndkCrashes"));        assertTrue((Boolean) errorTypes.get("unhandledExceptions"));        assertTrue((Boolean) errorTypes.get("unhandledRejections"));        Map<String, Object> endpoints = (Map<String, Object>) map.get("endpoints");        assertEquals("https://notify.bugsnag.com", endpoints.get("notify"));        assertEquals("https://sessions.bugsnag.com", endpoints.get("sessions"));    }
@Test    void keys() {        assertThat(job.keys(Map.of())).isEqualTo(0);    }
@Test    public void testIsFreeCode() throws Exception {        Query<KeywordBean> query = QueryBuilder.keywordQueryBuilder(isoLangMapper, "eng").limit(1).build();        assertFalse(query.execute(thesaurus).isEmpty());        KeywordBean keyword = query.execute(thesaurus).get(0);        assertFalse(thesaurus.isFreeCode(keyword.getNameSpaceCode(), keyword.getRelativeCode()));        assertTrue(writableThesaurus.isFreeCode(keyword.getNameSpaceCode(), keyword.getRelativeCode()));    }
@Test  public void testGetKerberosDescriptor() throws AmbariException {    KerberosDescriptor descriptor = metaInfo.getKerberosDescriptor(STACK_NAME_HDP, "2.0.8");    Assert.assertNotNull(descriptor);    Assert.assertNotNull(descriptor.getProperties());    Assert.assertEquals(3, descriptor.getProperties().size());    Assert.assertNotNull(descriptor.getIdentities());    Assert.assertEquals(1, descriptor.getIdentities().size());    Assert.assertEquals("spnego", descriptor.getIdentities().get(0).getName());    Assert.assertNotNull(descriptor.getConfigurations());    Assert.assertEquals(1, descriptor.getConfigurations().size());    Assert.assertNotNull(descriptor.getConfigurations().get("core-site"));    Assert.assertNotNull(descriptor.getConfiguration("core-site"));    Assert.assertNotNull(descriptor.getServices());    Assert.assertEquals(1, descriptor.getServices().size());    Assert.assertNotNull(descriptor.getServices().get("HDFS"));    Assert.assertNotNull(descriptor.getService("HDFS"));  }
@Test    public void wordMatch() {        char[][] charArray = {{'a', 'e', 'f'}, {'d', 'x', 'j'}, {'m', 'q', 'h'}};        int arrayWidth = 3;        String testStr1 = "adx";        String testStr2 = "fjh";        String testStr3 = "ada";        String testStr4 = "axh";        assert StringRelated.wordMatch(charArray, arrayWidth, testStr1);        assert StringRelated.wordMatch(charArray, arrayWidth, testStr2);        assert StringRelated.wordMatch(charArray, arrayWidth, testStr3);        assert !StringRelated.wordMatch(charArray, arrayWidth, testStr4);    }
@Test    public void testClear() {        IntervalSet set = new IntervalSet();        set.add(new Interval(1.0, 2.0));        set.clear();        Assert.assertTrue(set.isEmpty());        Assert.assertFalse(set.contains(new Interval(1.0, 2.0)));    }
@Test( expected = ArgumentNullException.class )  public void acquireNullSession() throws Exception {    final JobIdGenerator jobIdGenerator = new JobIdGenerator();    jobIdGenerator.acquire( null, UUID.randomUUID() );  }
@Test    public void testMultipleConcurrentReaders() {        List<Thread> threads = Lists.newArrayList();        final AtomicBoolean success = new AtomicBoolean(true);        Runnable runnable = new Runnable() {            @Override            public void run() {                if(!lock.readLock().tryLock()) {                    success.set(false);                }            }        };        for (int i = 0; i < TestData.getScaleCount(); i++) {            threads.add(new Thread(runnable));        }        for (Thread thread : threads) {            thread.start();        }        Assert.assertTrue(success.get());    }
@Test    public void testSinglePathToString() {        List<String> list = new ArrayList<String>();        list.add("a");        assertEquals("a", writer.pathToString(list));    }
@Test  public void testAddDependencies() throws IOException {    RoleCommandOrder rco = injector.getInstance(RoleCommandOrder.class);    InputStream testJsonIS = getClass().getClassLoader().            getResourceAsStream(TEST_RCO_DATA_FILE);    ObjectMapper mapper = new ObjectMapper();    Map<String,Object> testData = mapper.readValue(testJsonIS,        new TypeReference<Map<String,Object>>() {});    rco.addDependencies(testData);    mapper.setVisibility(JsonMethod.ALL, JsonAutoDetect.Visibility.ANY);    String dump = mapper.writeValueAsString(rco.getDependencies());    // Depends on hashing, string representation can be different    // We need a sophisticated comparison    List<String> parts = Arrays.asList(dump.substring(1, 522).split(Pattern.quote("],")));    assertEquals(3, parts.size());    assertTrue(parts.contains("\"RoleCommandPair{role=SECONDARY_NAMENODE, cmd=UPGRADE}\":[{\"role\":{\"name\":\"NAMENODE\"},\"cmd\":\"UPGRADE\"}"));    assertTrue(parts.contains("\"RoleCommandPair{role=SECONDARY_NAMENODE, cmd=START}\":[{\"role\":{\"name\":\"NAMENODE\"},\"cmd\":\"START\"}"));    boolean datanodeCommandExists = false;    for (String part : parts) {      if (part.contains("RoleCommandPair{role=DATANODE, cmd=STOP}")) {        datanodeCommandExists = true;        String[] parts2 = part.split(Pattern.quote(":["));        assertEquals(2, parts2.length);        assertEquals("\"RoleCommandPair{role=DATANODE, cmd=STOP}\"", parts2[0]);        List<String> components = Arrays.asList(new String[]{"\"role\":{\"name\":\"HBASE_MASTER\"},\"cmd\":\"STOP\"",                                                             "\"role\":{\"name\":\"RESOURCEMANAGER\"},\"cmd\":\"STOP\"",                                                             "\"role\":{\"name\":\"TASKTRACKER\"},\"cmd\":\"STOP\"",                                                             "\"role\":{\"name\":\"NODEMANAGER\"},\"cmd\":\"STOP\"",                                                             "\"role\":{\"name\":\"HISTORYSERVER\"},\"cmd\":\"STOP\"",                                                             "\"role\":{\"name\":\"JOBTRACKER\"},\"cmd\":\"STOP\""});        Assert.assertTrue(CollectionPresentationUtils.isStringPermutationOfCollection(parts2[1], components, "},{", 1, 1));      }    }    assertTrue(datanodeCommandExists);  }
@Test  public void moveWasApplied() {    // mock a unfinished result for when a move was applied to the current round    CoincheGameRound currentRound = coincheGame.getCurrentRound();    CoincheGameRound spyRound = spy(currentRound);    coincheGame.setCurrentRound(spyRound);    GameResult<Team> roundResult = GameResult.unfinishedResult();    doReturn(roundResult).when(spyRound).moveWasApplied();    GameResult<Team> gameResult = coincheGame.moveWasApplied();    assertThat(gameResult.isFinished())        .as("UNFINISHED ROUND - Check game hasn't finished yet")        .isFalse();    // check that the round has stayed the same    assertThat(coincheGame.getCurrentPlayerIndex())        .as("UNFINISHED ROUND - Check player index is still 0")        .isEqualTo(0);    assertThat(coincheGame.getCurrentRound())        .as("UNFINISHED ROUND - Check round is still the same")        .isEqualTo(spyRound);    // mock a finished result but not a finished game    roundResult = GameResult.finishedResult(Map.of(t1, 0, t2, 0));    doReturn(roundResult).when(spyRound).moveWasApplied();    gameResult = coincheGame.moveWasApplied();    assertThat(gameResult.isFinished())        .as("FINISHED ROUND - Check that the game hasn't finished yet")        .isFalse();    // check that a new round was created with the next player    assertThat(coincheGame.getCurrentPlayerIndex())        .as("FINISHED ROUND - Check new player index is 1")        .isEqualTo(1);    assertThat(coincheGame.getCurrentRound())        .as("FINISHED ROUND - Check new round isn't null")        .isNotNull();    assertThat(coincheGame.getCurrentRound())        .as("FINISHED ROUND - Check round has changed")        .isNotEqualTo(spyRound);    assertThat(coincheGame.getCurrentRound().getState())        .as("FINISHED ROUND - Check new state isn't null")        .isNotNull();    assertThat(coincheGame.getCurrentRound().getState().getCurrentPlayer())        .as("FINISHED ROUND - Check first player of new state is p2")        .isEqualTo(p2);    // mock a finished game now    currentRound = coincheGame.getCurrentRound();    spyRound = spy(currentRound);    coincheGame.setCurrentRound(spyRound);    roundResult = GameResult.finishedResult(Map.of(t1, 42000, t2, 0));    doReturn(roundResult).when(spyRound).moveWasApplied();    gameResult = coincheGame.moveWasApplied();    assertThat(gameResult.isFinished())        .as("FINISHED GAME - Check that the game has finished")        .isTrue();  }
@Test  public void testConsumeIndexesFacts() {    when(factConverter.apply(any())).thenReturn(new FactDocument());    factConsumer.consume(SetUtils.set(FactSEB.builder().build(), FactSEB.builder().build(), FactSEB.builder().build()));    verify(factConverter, times(3)).apply(notNull());    verify(factSearchManager, times(3)).indexFact(notNull());  }
@Test(expected = InvalidQueryException.class)  public void testTokens_matchesRegexpInvalidQuery2() throws InvalidQueryException {    QueryLexer lexer = new QueryLexer();    lexer.tokens("StackConfigurations/property_type.matches((.*USER.*)|(.*GROUP.*)|StackConfigurations/property_type.matches(.*GROUP.*)");  }
@Test    void send() {        var record = new ProducerRecord<byte[], byte[]>("topic", Strings.bytes("{}"));        when(uri.resolveURI()).thenReturn(Boolean.FALSE);        assertThatThrownBy(() -> producer.send(record))                .isInstanceOf(KafkaException.class)                .hasMessageContaining("kafka uri is not resolvable");    }
@Test  public void testGetResourcesNoPredicate() throws Exception {    WidgetLayoutResourceProvider provider = createProvider(null);    Request request = PropertyHelper.getReadRequest("WidgetLayouts/id");    Set<Resource> results = provider.getResources(request, null);    assertEquals(0, results.size());  }
@Test    public void getScenarioExpressionCellTextAreaSingletonDOMElementFactory() {        assertEquals(scenarioExpressionCellTextAreaSingletonDOMElementFactorySpy,                     scenarioSimulationContextLocal.getScenarioExpressionCellTextAreaSingletonDOMElementFactory(GridWidget.SIMULATION));    }
@Test  public void testGetHealthStatus() throws Exception {    HostEntity hostEntity = createNiceMock(HostEntity.class);    HostStateEntity hostStateEntity = createNiceMock(HostStateEntity.class);    HostDAO hostDAO  = createNiceMock(HostDAO.class);    HostStateDAO hostStateDAO  = createNiceMock(HostStateDAO.class);    Gson gson = new Gson();    expect(hostEntity.getHostAttributes()).andReturn("{\"foo\": \"aaa\", \"bar\":\"bbb\"}").anyTimes();    expect(hostEntity.getHostName()).andReturn("host1").anyTimes();    expect(hostEntity.getHostId()).andReturn(1L).anyTimes();    expect(hostEntity.getHostStateEntity()).andReturn(hostStateEntity).anyTimes();    expect(hostDAO.findById(1L)).andReturn(hostEntity).anyTimes();    expect(hostStateDAO.findByHostId(1L)).andReturn(hostStateEntity).atLeastOnce();    replayAll();    HostImpl host = new HostImpl(hostEntity, gson, hostDAO, hostStateDAO);    host.getHealthStatus();    host = new HostImpl(hostEntity, gson, hostDAO, hostStateDAO);    host.getHealthStatus();    verifyAll();  }
@Test    public void testAddColumnsTab() {        final MultiPageEditor pageEditor = mock(MultiPageEditor.class);        doReturn(pageEditor).when(presenter).getKieEditorWrapperMultiPage();        presenter.addColumnsTab();        verify(columnsPage).init(modeller);        verify(presenter).addEditorPage(COLUMNS_TAB_INDEX, columnsPage);    }
@Test    public void testTempDownInstance() throws Exception    {        final AtomicInteger checkMs = new AtomicInteger(10000);        InstanceConfig config = new InstanceConfig()        {            @Override            public String getString(StringConfigs config)            {                switch ( config )                {                case SERVERS_SPEC:                {                    return "1:foo,2:bar";                }                case ZOOKEEPER_DATA_DIRECTORY:                case ZOOKEEPER_INSTALL_DIRECTORY:                {                    return "/";                }                }                return null;            }            @Override            public int getInt(IntConfigs config)            {                switch ( config )                {                case CHECK_MS:                {                    return checkMs.get();                }                }                return 0;            }        };        Exhibitor mockExhibitor = makeMockExhibitor(config, "foo");        final Semaphore semaphore = new Semaphore(0);        MonitorRunningInstance monitor = new MonitorRunningInstance(mockExhibitor)        {            @Override            protected void restartZooKeeper(InstanceState currentInstanceState) throws Exception            {                semaphore.release();            }        };        monitor.doWork();        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        monitor.doWork();        Assert.assertFalse(semaphore.tryAcquire(3, TimeUnit.SECONDS));  // no instance state change, should not try restart        checkMs.set(1);        monitor.doWork();   // should do restart now as 10 times checkMs has elapsed        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));    }
@Test	public void testWriteInt() {		Serializer serializer = new Serializer();		ByteBuffer byteBuffer = ByteBuffer.allocate(_COUNT * 4);		byteBuffer.order(ByteOrder.BIG_ENDIAN);		IntBuffer intBuffer = byteBuffer.asIntBuffer();		int[] ints = new int[_COUNT];		for (int i = 0; i < _COUNT; i++) {			ints[i] = _random.nextInt();			serializer.writeInt(ints[i]);			intBuffer.put(ints[i]);		}		ByteBuffer serializerByteBuffer = serializer.toByteBuffer();		Assert.assertArrayEquals(			byteBuffer.array(), serializerByteBuffer.array());	}
@Test	public void getResponseErrorTest() {		assertEquals(RestApiResponseHandler.getResponseError(new Exception("Internal Server error")).getEntity().toString(), "{\"error\" : \""+"Internal Server error"+"\"}");	}
@Test    public void testRightConfigurationValue() {        Response response = configurationService.getConfigurationValue("ranger-yarn-plugin-properties", "ranger-yarn-plugin-enabled");        JSONObject jsonObject = (JSONObject) response.getEntity();        JSONArray arr = (JSONArray) jsonObject.get("configs");        Assert.assertEquals(arr.size(), 1);        JSONObject obj = (JSONObject) arr.get(0);        Assert.assertEquals(obj.get("siteName"), "ranger-yarn-plugin-properties");        Assert.assertEquals(obj.get("configName"), "ranger-yarn-plugin-enabled");        Assert.assertEquals(obj.get("configValue"), "Yes"); // because I set it myself.    }
@Test  public void canBeCommittedIfUnknownExceptionThrown() {    Transactional transactional = createNiceMock(Transactional.class);    EntityTransaction transaction = createStrictMock(EntityTransaction.class);    expect(transaction.getRollbackOnly()).andReturn(false);    expect(transactional.rollbackOn()).andReturn(asArray(IllegalArgumentException.class));    replayAll();    boolean canCommit = rollbackIfNecessary(transactional, new RuntimeException(), transaction);    Assert.assertTrue("Should be allowed to commit, exception thrown does not match rollbackOn clause", canCommit);    verifyAll();  }
@Test  public void testRemoveSessionAttribute() throws Exception {    Map<String, Object> attributes = new HashMap<String, Object>();    attributes.put("foo", "bar");    attributes.put("foo2", "bar2");    Map<String, Object> trimmedAttributes = new HashMap<String, Object>(attributes);    trimmedAttributes.remove("foo2");    AmbariSessionManager sessionManager = createMock(AmbariSessionManager.class);    ClusterImpl cluster =      createMockBuilder(ClusterImpl.class).        addMockedMethod("getSessionManager").        addMockedMethod("getClusterName").        addMockedMethod("getSessionAttributes").        createMock();    expect(cluster.getSessionManager()).andReturn(sessionManager);    expect(cluster.getClusterName()).andReturn("c1");    expect(cluster.getSessionAttributes()).andReturn(attributes);    sessionManager.setAttribute("cluster_session_attributes:c1", trimmedAttributes);    expectLastCall().once();    replay(sessionManager, cluster);    cluster.removeSessionAttribute("foo2");    verify(sessionManager, cluster);  }
@Test    void RequireInRange() {        final long first = -1;        final long lastExclusive = 4;        testHelper(l -> l >= first && l < lastExclusive, l -> LongRangeUtil.requireInRange(l, first, lastExclusive));    }
@Test	public void testSendAnalytics() throws Exception {		AnalyticsEventsMessage.Builder analyticsEventsMessageBuilder =			AnalyticsEventsMessage.builder("ApplicationKey", "UserId");		analyticsEventsMessageBuilder.contextProperty("languageId", "en_US");		analyticsEventsMessageBuilder.contextProperty(			"url", "http://www.liferay.com");		AnalyticsEventsMessage.Event.Builder eventBuilder =			AnalyticsEventsMessage.Event.builder("ApplicationId", "View");		eventBuilder.property("elementId", "banner1");		analyticsEventsMessageBuilder.event(eventBuilder.build());		analyticsEventsMessageBuilder.protocolVersion("1.0");		String response = _analyticsClientImpl.sendAnalytics(			analyticsEventsMessageBuilder.build());		Assert.assertNull(response);	}
@Test    void shouldPrepareToCloseChannel()    {        protocol.prepareToCloseChannel( channel );        assertThat( channel.outboundMessages(), hasSize( 1 ) );        assertThat( channel.outboundMessages().poll(), instanceOf( GoodbyeMessage.class ) );        assertEquals( 1, messageDispatcher.queuedHandlersCount() );    }
@Test	public void testImagePath() {		Assert.assertNotNull(			_liferayConnectionWizardDefinition.getImagePath(				DefinitionImageType.TREE_ICON_16X16));		Assert.assertNotNull(			_liferayConnectionWizardDefinition.getImagePath(				DefinitionImageType.WIZARD_BANNER_75X66));		Assert.assertNull(			_liferayConnectionWizardDefinition.getImagePath(				DefinitionImageType.SVG_ICON));	}
@Test    public void parseMultiSolid()                            throws XMLStreamException, FactoryConfigurationError, IOException, XMLParsingException,                            UnknownCRSException {        GMLStreamReader gmlReader = getParser( "MultiSolid.gml" );        XMLStreamReader xmlReader = gmlReader.getXMLReader();        Assert.assertEquals( XMLStreamConstants.START_ELEMENT, xmlReader.getEventType() );        Assert.assertEquals( new QName( "http://www.opengis.net/gml", "MultiSolid" ), xmlReader.getName() );        MultiSolid aggregate = (MultiSolid) gmlReader.readGeometry();        Assert.assertEquals( XMLStreamConstants.END_ELEMENT, xmlReader.getEventType() );        Assert.assertEquals( new QName( "http://www.opengis.net/gml", "MultiSolid" ), xmlReader.getName() );        Assert.assertEquals( 2, aggregate.size() );        Assert.assertEquals( SolidType.Solid, aggregate.get( 0 ).getSolidType() );        Assert.assertEquals( SolidType.CompositeSolid, aggregate.get( 1 ).getSolidType() );    }
@Test	public void testApply3() {		ConcatFunction concatFunction = new ConcatFunction();		String actualString = concatFunction.apply(			new String[] {"liferay", null});		Assert.assertEquals("liferay", actualString);	}
@Test  public void testGetDescription() throws Exception {    List<InstanceConfig> instances = getInstanceConfigs();    Assert.assertEquals(2, instances.size());    Assert.assertEquals("This is a description.", instances.get(0).getDescription());    Assert.assertNull(instances.get(1).getDescription());  }
@Test	public void testOnAfterUpdate() throws PortalException {		when(			_ddmFormInstanceReportLocalService.				getFormInstanceReportByFormInstanceId(Mockito.anyLong())		).thenThrow(			new NoSuchFormInstanceReportException()		);		DDMFormInstanceRecordVersion ddmFormInstanceRecordVersion = mock(			DDMFormInstanceRecordVersion.class);		when(			ddmFormInstanceRecordVersion.getFormInstanceId()		).thenReturn(			0L		);		when(			ddmFormInstanceRecordVersion.getStatus()		).thenReturn(			WorkflowConstants.STATUS_APPROVED		);		_ddmFormInstanceRecordVersionModelListener.onAfterUpdate(			ddmFormInstanceRecordVersion);	}
@Test  public void testMapperDate_noDatePattern() {    LOG.info("testMapperDate_noDatePattern()");    Map<String, Object> mapConfigs = new HashMap<>();    mapConfigs.put("some_param", "some_value");    MapperDate mapperDate = new MapperDate();    assertFalse("Was able to initialize!", mapperDate.init(null, "someField", null, mapConfigs));  }
@Test  public void testGetRoundCornerStart() throws Exception {    PointF topLeft = createBorderCorner(TOP_LEFT, 25, 10, 50, borderBox)        .getRoundCornerStart();    assertThat(topLeft.x, is(5f));    assertThat(topLeft.y, is(25f));    PointF topRight = createBorderCorner(TOP_RIGHT, 25, 10, 50, borderBox)        .getRoundCornerStart();    assertThat(topRight.x, is(375f));    assertThat(topRight.y, is(5f));    PointF bottomRight = createBorderCorner(BOTTOM_RIGHT, 25, 10, 50, borderBox)        .getRoundCornerStart();    assertThat(bottomRight.x, is(395f));    assertThat(bottomRight.y, is(375f));    PointF bottomLeft = createBorderCorner(BOTTOM_LEFT, 25, 10, 50, borderBox)        .getRoundCornerStart();    assertThat(bottomLeft.x, is(25f));    assertThat(bottomLeft.y, is(395f));  }
@Test    void permutation2() {        assertEquals(Arrays.asList(2, 1, 3), Permutation.permutation(2, LIST));    }
@Test    public void testValuesToArray() {        IncrementalSortMap<Integer, String> map = map5();        Collection v = map.values();        Object[] ar = v.toArray();        ArrayList s = new ArrayList(Arrays.asList(ar));        assertEquals(5, ar.length);        assertTrue(s.contains("A"));        assertTrue(s.contains("B"));        assertTrue(s.contains("C"));        assertTrue(s.contains("D"));        assertTrue(s.contains("E"));    }
@Test(expected = WorkflowOperationException.class)  public void testNoMediaPackage() throws Exception {    operationHandler.start(workflowInstance, null);  }
@Test  public void testGetItem() throws Exception {    module.getItem("",callback);    verify(callback,times(1)).invoke(any());  }
@Test    void shouldProtocolErrorWhenNoRouters()    {        // Given        MultiDatabasesRoutingProcedureRunner mockedRunner = newMultiDBProcedureRunnerMock();        Connection connection = mock( Connection.class );        Clock mockedClock = mock( Clock.class );        ClusterCompositionProvider provider =                newClusterCompositionProvider( mockedRunner, connection, mockedClock );        Record record = new InternalRecord( asList( "ttl", "servers" ), new Value[]{                value( 100 ), value( asList(                serverInfo( "READ", "one:1337", "two:1337" ),                serverInfo( "WRITE", "one:1337" ) ) )        } );        RoutingProcedureResponse routingResponse = newRoutingResponse( record );        when( mockedRunner.run( eq( connection ), any( DatabaseName.class ), any(InternalBookmark.class ) ) ).thenReturn( completedFuture( routingResponse ) );        when( mockedClock.millis() ).thenReturn( 12345L );        // When        ProtocolException error = assertThrows( ProtocolException.class,                () -> await( provider.getClusterComposition( connection, defaultDatabase(), empty() ) ) );        assertThat( error.getMessage(), containsString( "no router or reader found in response." ) );    }
@Test    public void testGetContentSupplier() {        final GuidedDecisionTableView.Presenter presenter = mock(GuidedDecisionTableView.Presenter.class);        final GuidedDecisionTable52 expected = mock(GuidedDecisionTable52.class);        doReturn(expected).when(presenter).getModel();        doReturn(presenter).when(this.presenter).getActiveDocument();        final GuidedDecisionTable52 actual = this.presenter.getContentSupplier().get();        assertEquals(expected, actual);    }
@Test  public void testUpdateResourcesWithUnsupportedPropertyRequest() throws Exception{    TestProviderModule providerModule = new TestProviderModule();    ClusterController controller = new ClusterControllerImpl(providerModule);    Map<String, Object> propertyMap = new HashMap<String, Object>();    propertyMap.put(PropertyHelper.getPropertyId("c1", "p1"), 99);    propertyMap.put(UNSUPPORTED_PROPERTY, 2);    Request request = PropertyHelper.getUpdateRequest(propertyMap, null);    Predicate predicate = new PredicateBuilder().property("c1/p2").equals(1).toPredicate();    try {      controller.updateResources(Resource.Type.Host, request, predicate);      Assert.fail("Expected an UnsupportedPropertyException for the unsupported properties.");    } catch (UnsupportedPropertyException e) {      // Expected    }  }
@Test  public void getTargetSchemaEmptyTest() {    when( teraDataBulkLoaderMetaMock.getSchemaName() ).thenReturn( "" );    when( teraDataBulkLoaderMetaMock.getDbName() ).thenReturn( "dbName" );    assertEquals( "dbName", teraDataBulkLoaderRoutines.getTargetSchema( true ) );  }
@Test    void thread() {        Response response = controller.thread(request);        assertThat(response.contentType()).get().isEqualTo(ContentType.TEXT_PLAIN);    }
@Test	public void testSupportsImageTagsWithNewLineCharacters() throws Exception {		Assert.assertEquals(			_CONTENT_PREFIX + "[REPLACED]" + _CONTENT_SUFFIX,			_contentTransformer.transform(_CONTENT_WITH_IMAGE_AND_NEWLINES));	}
@Test    public void testStringToOperatorGreaterThanOrEquals() {        String symbol = ">=";        Assert.assertEquals(Convert.stringToOperator(symbol),                Operator.GREATER_THAN_OR_EQUALS);    }
@Test	public void testProcessDocumentURLWithThumbnailParameter()		throws Exception {		DocumentHTMLProcessor documentHTMLProcessor =			new DocumentHTMLProcessor();		String originalHTML = StringBundler.concat(			"<html><head><title>test-title</title></head><body><img src=\"",			"/documents/29543/100903188/how-long/4e69-b2cc-e6ef21c10?t=1513212",			"&imageThumbnail=1\"/></body></html>");		InputStream originalInputStream = new ByteArrayInputStream(			originalHTML.getBytes());		InputStream processedInputStream = documentHTMLProcessor.process(			originalInputStream);		String processedHTML = IOUtils.toString(processedInputStream, "UTF-8");		String expectedHTML = StringBundler.concat(			"<html><head><title>test-title</title></head><body><img src=\"",			"/documents/29543/100903188/how-long/4e69-b2cc-e6ef21c10?t=1513212",			"&imageThumbnail=1&auth_token=authtoken\"/></body></html>");		Assert.assertEquals(expectedHTML, processedHTML);	}
@Test    void filterKey() {        final Map<String, Integer> expected = refStream().filter(KEY_STARTS_WITH_D).collect(TO_MAP);        final Map<String, Integer> actual = instance.filterKey(k -> k.startsWith("d")).toMap();        assertEquals(expected, actual);    }
@Test	public void testGetClassPK() {		ClassPKInfoItemIdentifier classPKInfoItemIdentifier =			new ClassPKInfoItemIdentifier(12345L);		Assert.assertEquals(12345L, classPKInfoItemIdentifier.getClassPK());	}
@Test    public void testJsonDecode()    {        PersonRepresentation personRepresentation = assertValidates(decodeJson(codec, jsonStructure));        assertThat(personRepresentation.toPerson()).isEqualTo(createPerson("foo@example.com", "Mr Foo"));    }
@Test(dataProvider = "matchProvider")    public void test(String s, String p, boolean expected) {        assertEquals(new Matches().match(s, p), expected);    }
@Test    public void shouldReturnCriticalityAndExpectations() throws Exception {        when(externalDependencies.getDependencies()).thenReturn(asList(                mongoDependency(singletonList(datasource("foo:42/bar"))).build(),                restServiceDependency("foobar:4711")                        .withCriticality(criticality(HIGH, "Bad. Really bad."))                        .withExpectations(lowExpectations())                        .build()        ));        mockMvc.perform(get("/internal/dependencies").accept(APPLICATION_JSON))                .andExpect(                        jsonPath("@.dependencies[0].criticality.level").value("NOT_SPECIFIED")                )                .andExpect(                        jsonPath("@.dependencies[0].criticality.disasterImpact").value("Not Specified")                )                .andExpect(                        jsonPath("@.dependencies[0].expectations.availability").value("NOT_SPECIFIED")                )                .andExpect(                        jsonPath("@.dependencies[0].expectations.performance").value("NOT_SPECIFIED")                )                .andExpect(                        jsonPath("@.dependencies[1].criticality.level").value("HIGH")                )                .andExpect(                        jsonPath("@.dependencies[1].criticality.disasterImpact").value("Bad. Really bad.")                )                .andExpect(                        jsonPath("@.dependencies[1].expectations.availability").value("LOW")                )                .andExpect(                        jsonPath("@.dependencies[1].expectations.performance").value("LOW")                );    }
@Test    public void save() {        editingBoxPresenter.save();        verify(propertyPresenterMock, times(1)).updateProperties(LOWER_CASE_VALUE);        verify(collectionPresenterMock, times(1)).addListItem(anyMap(), anyMap());    }
@Test    public void test_V100_EXAMPLE_1()                            throws Exception {        URL exampleURL = this.getClass().getResource( V100_EXAMPLE_1 );        Map<String, String> kvpMap = KVPUtils.readFileIntoMap( exampleURL );        GetFeature getFeature = GetFeatureKVPAdapter.parse( kvpMap, null );        assertEquals( new QName( "INWATERA_1M" ),                      ( (AdHocQuery) getFeature.getQueries().get( 0 ) ).getTypeNames()[0].getFeatureTypeName() );    }
@Test	public void testRemovesTemporalAttributeAndSetsFinalSrc() throws Exception {		String originalImgTag = String.format(			"<img data-image-id=\"%s\" src=\"%s\" />", _IMAGE_FILE_ENTRY_ID,			StringUtil.randomString());		String expectedImgTag = String.format(			"<img src=\"%s\" />", _FILE_ENTRY_IMAGE_URL);		String actualTag = _htmlImageAttachmentElementReplacer.replace(			originalImgTag, _fileEntry);		Assert.assertEquals(expectedImgTag, actualTag);	}
@Test  public void testCreateResource() throws Exception {    Capture<ArtifactEntity> createEntityCapture = newCapture();    Map<String, Object> outerMap = new TreeMap<String, Object>();    Map<String, Object> childMap = new TreeMap<String, Object>();    outerMap.put("child", childMap);    childMap.put("childKey", "childValue");    Map<String, Object> child2Map = new TreeMap<String, Object>();    childMap.put("child2", child2Map);    child2Map.put("child2Key", "child2Value");    Map<String, Object> child3Map = new TreeMap<String, Object>();    child2Map.put("child3", child3Map);    Map<String, Object> child4Map = new TreeMap<String, Object>();    child3Map.put("child4", child4Map);    child4Map.put("child4Key", "child4Value");    Set<Map<String, Object>> propertySet = new HashSet<Map<String, Object>>();    propertySet.add(outerMap);    propertySet.add(child4Map);    Map<String, Object> artifact_data = new TreeMap<String, Object>();    artifact_data.put("foo", "bar");    artifact_data.put("child", childMap);    artifact_data.put("collection", propertySet);    TreeMap<String, String> foreignKeys = new TreeMap<String, String>();    foreignKeys.put("cluster", "500");    Map<String, String> requestInfoProps = new HashMap<String, String>();    requestInfoProps.put(Request.REQUEST_INFO_BODY_PROPERTY, bodyJson);    // map with flattened properties    Map<String, Object> properties = new HashMap<String, Object>();    properties.put("Artifacts/artifact_name", "test-artifact");    properties.put("Artifacts/cluster_name", "test-cluster");    properties.put("artifact_data/foo", "bar");    properties.put("artifact_data/child/childKey", "childValue");    properties.put("artifact_data/child/child2/child2Key", "child2Value");    properties.put("artifact_data/child/child2/child3/child4/child4Key", "child4Value");    Collection<Object> collectionProperties = new HashSet<Object>();    properties.put("artifact_data/collection", collectionProperties);    // collection with maps of flattened properties    Map<String, Object> map1 = new TreeMap<String, Object>();    collectionProperties.add(map1);    map1.put("foo", "bar");    map1.put("child/childKey", "childValue");    map1.put("child/child2/child2Key", "child2Value");    map1.put("child/child2/child3/child4/child4Key", "child4Value");    Map<String, Object> map2 = new TreeMap<String, Object>();    collectionProperties.add(map2);    map2.put("child4Key", "child4Value");    Set<Map<String, Object>> requestProperties = Collections.singleton(properties);    // expectations    expect(request.getRequestInfoProperties()).andReturn(requestInfoProps).anyTimes();    expect(request.getProperties()).andReturn(requestProperties).anyTimes();    expect(controller.getClusters()).andReturn(clusters).anyTimes();    expect(clusters.getCluster("test-cluster")).andReturn(cluster).anyTimes();    expect(clusters.getClusterById(500L)).andReturn(cluster).anyTimes();    expect(cluster.getClusterId()).andReturn(500L).anyTimes();    expect(cluster.getClusterName()).andReturn("test-cluster").anyTimes();    // check to see if entity already exists    expect(dao.findByNameAndForeignKeys(eq("test-artifact"), eq(foreignKeys))).andReturn(null).once();    // create    dao.create(capture(createEntityCapture));    // end of expectation setting    replay(dao, em, controller, request, clusters, cluster, entity, entity2);    resourceProvider.createResources(request);    ArtifactEntity createEntity = createEntityCapture.getValue();    assertEquals("test-artifact", createEntity.getArtifactName());    Map<String, Object> actualArtifactData = createEntity.getArtifactData();    // need to decompose actualArtifactData because actualArtifactData.get("collection") returns a set    // implementation that does not equal an identical(same elements) HashSet instance    assertEquals(artifact_data.size(), actualArtifactData.size());    assertEquals(artifact_data.get("foo"), actualArtifactData.get("foo"));    assertEquals(artifact_data.get("child"), actualArtifactData.get("child"));    assertEquals(artifact_data.get("collection"), new HashSet(((Collection) actualArtifactData.get("collection"))));    assertEquals(foreignKeys, createEntity.getForeignKeys());  }
@Test    public void testEquivalence()    {        equivalenceTester()                .addEquivalentGroup(appleServiceType, ServiceTypes.serviceType("apple"))                .addEquivalentGroup(bananaServiceType, ServiceTypes.serviceType("banana"))                .check();    }
@Test	public void testGetAutoUpgradePath() {		UpgradeInfo upgradeInfo1 = createUpgradeInfo("0.0.0", "0.1.0");		UpgradeInfo upgradeInfo2 = createUpgradeInfo("0.1.0", "0.2.0");		UpgradeInfo upgradeInfo3 = createUpgradeInfo("0.2.0", "1.0.0");		UpgradeInfo upgradeInfo4 = createUpgradeInfo("1.0.0", "2.0.0");		ReleaseGraphManager releaseGraphManager = new ReleaseGraphManager(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4));		List<List<UpgradeInfo>> upgradeInfosList =			releaseGraphManager.getUpgradeInfosList("0.0.0");		Assert.assertEquals(			upgradeInfosList.toString(), 1, upgradeInfosList.size());		Assert.assertEquals(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4),			upgradeInfosList.get(0));	}
@Test  public void testSynchronizeLdapUsersAndGroups() throws Exception {    Set<String> userSet = new HashSet<String>();    userSet.add("user1");    Set<String> groupSet = new HashSet<String>();    groupSet.add("group1");    Injector injector = Guice.createInjector(Modules.override(new InMemoryDefaultTestModule()).with(new MockModule()));    // create mocks    LdapBatchDto ldapBatchDto = createNiceMock(LdapBatchDto.class);    Capture<LdapBatchDto> ldapBatchDtoCapture = EasyMock.newCapture();    // set expectations    expect(ldapDataPopulator.synchronizeAllLdapUsers(capture(ldapBatchDtoCapture))).andReturn(ldapBatchDto);    expect(ldapDataPopulator.synchronizeAllLdapGroups(capture(ldapBatchDtoCapture))).andReturn(ldapBatchDto);    expect(ldapDataPopulator.synchronizeExistingLdapUsers(capture(ldapBatchDtoCapture))).andReturn(ldapBatchDto);    expect(ldapDataPopulator.synchronizeExistingLdapGroups(capture(ldapBatchDtoCapture))).andReturn(ldapBatchDto);    expect(ldapDataPopulator.synchronizeLdapUsers(eq(userSet), capture(ldapBatchDtoCapture))).andReturn(ldapBatchDto);    expect(ldapDataPopulator.synchronizeLdapGroups(eq(groupSet), capture(ldapBatchDtoCapture))).andReturn(ldapBatchDto);    users.processLdapSync(capture(ldapBatchDtoCapture));    expectLastCall().anyTimes();    //replay    replay(ldapDataPopulator, clusters, actionDBAccessor, ambariMetaInfo, users, ldapBatchDto);    AmbariManagementControllerImpl controller = injector.getInstance(AmbariManagementControllerImpl.class);    LdapSyncRequest userRequest = new LdapSyncRequest(LdapSyncSpecEntity.SyncType.ALL);    LdapSyncRequest groupRequest = new LdapSyncRequest(LdapSyncSpecEntity.SyncType.ALL);    controller.synchronizeLdapUsersAndGroups(userRequest, groupRequest);    userRequest = new LdapSyncRequest(LdapSyncSpecEntity.SyncType.EXISTING);    groupRequest = new LdapSyncRequest(LdapSyncSpecEntity.SyncType.EXISTING);    controller.synchronizeLdapUsersAndGroups(userRequest, groupRequest);    userRequest = new LdapSyncRequest(LdapSyncSpecEntity.SyncType.SPECIFIC, userSet);    groupRequest = new LdapSyncRequest(LdapSyncSpecEntity.SyncType.SPECIFIC, groupSet);    controller.synchronizeLdapUsersAndGroups(userRequest, groupRequest);    verify(ldapDataPopulator, clusters, users, ldapBatchDto);  }
@Test    public void shouldHavePackageName() {        assertThat(Utils.hasPackageName(null)).isFalse();        assertThat(Utils.hasPackageName("NoPackage")).isFalse();        assertThat(Utils.hasPackageName("com.package.MyClass")).isTrue();    }
@Test  public void testExecuteDDLUpdates() throws Exception {    final DBAccessor dbAccessor = createNiceMock(DBAccessor.class);    Configuration configuration = createNiceMock(Configuration.class);    Connection connection = createNiceMock(Connection.class);    Statement statement = createNiceMock(Statement.class);    ResultSet resultSet = createNiceMock(ResultSet.class);    expect(configuration.getDatabaseUrl()).andReturn(Configuration.JDBC_IN_MEMORY_URL).anyTimes();    Capture<DBAccessor.DBColumnInfo> alertDefinitionIgnoreColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> alertDefinitionDescriptionColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> alertTargetGlobalColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> hostComponentStateColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> hostComponentVersionColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> clustersSecurityTypeColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> hostComponentStateSecurityStateColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> hostComponentDesiredStateSecurityStateColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> hostRoleCommandRetryColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> stageSkippableColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> viewparameterLabelColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> viewparameterPlaceholderColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> viewparameterDefaultValueColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> serviceDesiredStateSecurityStateColumnCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> clusterVersionCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> hostVersionCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> valueColumnCapture = EasyMock.newCapture();    Capture<DBAccessor.DBColumnInfo> dataValueColumnCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> alertTargetStatesCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> artifactCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> kerberosPrincipalCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> kerberosPrincipalHostCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> upgradeCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> upgradeGroupCapture = EasyMock.newCapture();    Capture<List<DBAccessor.DBColumnInfo>> upgradeItemCapture = EasyMock.newCapture();    // Alert Definition    dbAccessor.addColumn(eq("alert_definition"),                          capture(alertDefinitionIgnoreColumnCapture));    dbAccessor.addColumn(eq("alert_definition"),        capture(alertDefinitionDescriptionColumnCapture));    dbAccessor.createTable(eq("alert_target_states"),        capture(alertTargetStatesCapture));    // alert target    dbAccessor.addColumn(eq("alert_target"),        capture(alertTargetGlobalColumnCapture));    // Host Component State    dbAccessor.addColumn(eq("hostcomponentstate"),        capture(hostComponentStateColumnCapture));    // Host Component Version    dbAccessor.addColumn(eq("hostcomponentstate"),        capture(hostComponentVersionColumnCapture));    // Host Role Command retry allowed    dbAccessor.addColumn(eq("host_role_command"),        capture(hostRoleCommandRetryColumnCapture));    // Stage skippable    dbAccessor.addColumn(eq("stage"),        capture(stageSkippableColumnCapture));    // Clusters: security type    dbAccessor.addColumn(eq("clusters"),        capture(clustersSecurityTypeColumnCapture));    // Host Component State: security State    dbAccessor.addColumn(eq("hostcomponentstate"),        capture(hostComponentStateSecurityStateColumnCapture));    // Host Component Desired State: security State    dbAccessor.addColumn(eq("hostcomponentdesiredstate"),        capture(hostComponentDesiredStateSecurityStateColumnCapture));    dbAccessor.addColumn(eq("viewparameter"), capture(viewparameterLabelColumnCapture));    dbAccessor.addColumn(eq("viewparameter"), capture(viewparameterPlaceholderColumnCapture));    dbAccessor.addColumn(eq("viewparameter"), capture(viewparameterDefaultValueColumnCapture));    // Service Desired State: security State    dbAccessor.addColumn(eq("servicedesiredstate"),        capture(serviceDesiredStateSecurityStateColumnCapture));    // Cluster Version    dbAccessor.createTable(eq("cluster_version"),        capture(clusterVersionCapture), eq("id"));    // Host Version    dbAccessor.createTable(eq("host_version"),        capture(hostVersionCapture), eq("id"));    // Upgrade    dbAccessor.createTable(eq("upgrade"), capture(upgradeCapture), eq("upgrade_id"));    // Upgrade Group item    dbAccessor.createTable(eq("upgrade_group"), capture(upgradeGroupCapture), eq("upgrade_group_id"));    // Upgrade item    dbAccessor.createTable(eq("upgrade_item"), capture(upgradeItemCapture), eq("upgrade_item_id"));    // artifact    dbAccessor.createTable(eq("artifact"), capture(artifactCapture),        eq("artifact_name"), eq("foreign_keys"));    // kerberos_principal    dbAccessor.createTable(eq("kerberos_principal"), capture(kerberosPrincipalCapture),        eq("principal_name"));    // kerberos_principal_host    dbAccessor.createTable(eq("kerberos_principal_host"), capture(kerberosPrincipalHostCapture),        eq("principal_name"), eq("host_name"));    expect(dbAccessor.tableHasColumn("kerberos_principal_host", "host_name")).andReturn(true).atLeastOnce();    dbAccessor.addFKConstraint(eq("kerberos_principal_host"), eq("FK_krb_pr_host_hostname"),        eq("host_name"), eq("hosts"), eq("host_name"), eq(true), eq(false));    dbAccessor.addFKConstraint(eq("kerberos_principal_host"), eq("FK_krb_pr_host_principalname"),        eq("principal_name"), eq("kerberos_principal"), eq("principal_name"), eq(true), eq(false));    setViewInstancePropertyExpectations(dbAccessor, valueColumnCapture);    setViewInstanceDataExpectations(dbAccessor, dataValueColumnCapture);    // AbstractUpgradeCatalog.addSequence()    dbAccessor.getConnection();    expectLastCall().andReturn(connection).anyTimes();    connection.createStatement();    expectLastCall().andReturn(statement).anyTimes();    statement.executeQuery(anyObject(String.class));    expectLastCall().andReturn(resultSet).anyTimes();    replay(dbAccessor, configuration, resultSet, statement, connection);    AbstractUpgradeCatalog upgradeCatalog = getUpgradeCatalog(dbAccessor);    Class<?> c = AbstractUpgradeCatalog.class;    Field f = c.getDeclaredField("configuration");    f.setAccessible(true);    f.set(upgradeCatalog, configuration);    upgradeCatalog.executeDDLUpdates();    verify(dbAccessor, configuration, resultSet, statement, connection);    // verify columns for alert_definition    verifyAlertDefinitionIgnoreColumn(alertDefinitionIgnoreColumnCapture);    verifyAlertDefinitionDescriptionColumn(alertDefinitionDescriptionColumnCapture);    // verify alert target column for is_global    verifyAlertTargetGlobal(alertTargetGlobalColumnCapture);    // verify new table for alert target states    verifyAlertTargetStatesTable(alertTargetStatesCapture);    // Verify added column in hostcomponentstate table    DBAccessor.DBColumnInfo upgradeStateColumn = hostComponentStateColumnCapture.getValue();    assertEquals("upgrade_state", upgradeStateColumn.getName());    assertEquals(32, (int) upgradeStateColumn.getLength());    assertEquals(String.class, upgradeStateColumn.getType());    assertEquals("NONE", upgradeStateColumn.getDefaultValue());    assertFalse(upgradeStateColumn.isNullable());    // Verify added column in hostcomponentstate table    DBAccessor.DBColumnInfo upgradeVersionColumn = hostComponentVersionColumnCapture.getValue();    assertEquals("version", upgradeVersionColumn.getName());    assertEquals(32, (int) upgradeVersionColumn.getLength());    assertEquals(String.class, upgradeVersionColumn.getType());    assertEquals("UNKNOWN", upgradeVersionColumn.getDefaultValue());    assertFalse(upgradeVersionColumn.isNullable());    // Verify added column in host_role_command table    DBAccessor.DBColumnInfo upgradeRetryColumn = hostRoleCommandRetryColumnCapture.getValue();    assertEquals("retry_allowed", upgradeRetryColumn.getName());    assertEquals(1, (int) upgradeRetryColumn.getLength());    assertEquals(Integer.class, upgradeRetryColumn.getType());    assertEquals(0, upgradeRetryColumn.getDefaultValue());    assertFalse(upgradeRetryColumn.isNullable());    // Verify added column in host_role_command table    DBAccessor.DBColumnInfo upgradeSkippableColumn = stageSkippableColumnCapture.getValue();    assertEquals("skippable", upgradeSkippableColumn.getName());    assertEquals(1, (int) upgradeSkippableColumn.getLength());    assertEquals(Integer.class, upgradeSkippableColumn.getType());    assertEquals(0, upgradeSkippableColumn.getDefaultValue());    assertFalse(upgradeSkippableColumn.isNullable());    // verify security_type column    verifyClustersSecurityType(clustersSecurityTypeColumnCapture);    // verify security_state columns    verifyComponentSecurityStateColumn(hostComponentStateSecurityStateColumnCapture);    verifyComponentSecurityStateColumn(hostComponentDesiredStateSecurityStateColumnCapture);    verifyServiceSecurityStateColumn(serviceDesiredStateSecurityStateColumnCapture);    verifyViewParameterColumns(viewparameterLabelColumnCapture, viewparameterPlaceholderColumnCapture,        viewparameterDefaultValueColumnCapture);    // verify artifact columns    List<DBAccessor.DBColumnInfo> artifactColumns = artifactCapture.getValue();    testCreateArtifactTable(artifactColumns);    // verify kerberos_principal columns    testCreateKerberosPrincipalTable(kerberosPrincipalCapture.getValue());    // verify kerberos_principal_host columns    testCreateKerberosPrincipalHostTable(kerberosPrincipalHostCapture.getValue());    // Verify capture group sizes    assertEquals(7, clusterVersionCapture.getValue().size());    assertEquals(4, hostVersionCapture.getValue().size());    assertViewInstancePropertyColumns(valueColumnCapture);    assertViewInstanceDataColumns(dataValueColumnCapture);    assertEquals(6, upgradeCapture.getValue().size());    assertEquals(4, upgradeGroupCapture.getValue().size());    assertEquals(7, upgradeItemCapture.getValue().size());  }
@Test  public void testSerializeDateRange() {    Date startDate = newDate(1999, 3, 21, 14, 0, 0);    Date endDate = newDate(1999, 3, 21, 14, 30, 10);    String serializedStartDate = dateFormatUTC().format(startDate);    String serializedEndDate = dateFormatUTC().format(endDate);    String day = "[" + serializedStartDate + " TO " + serializedEndDate + "]";    assertEquals(day, SolrUtils.serializeDateRange(some(startDate), some(endDate)));    assertEquals("[* TO " + serializedEndDate + "]", SolrUtils.serializeDateRange(Option.<Date>none(), some(endDate)));    assertEquals("[" + serializedStartDate + " TO *]", SolrUtils.serializeDateRange(some(startDate), Option.<Date>none()));  }
@Test    public void parseTriangle()                            throws XMLStreamException, FactoryConfigurationError, IOException, XMLParsingException,                            UnknownCRSException {        XMLStreamReaderWrapper parser = getParser( "Triangle.gml" );        Triangle patch = (Triangle) getPatchParser().parseSurfacePatch( parser, CRSManager.getCRSRef( "EPSG:4326" ) );        Assert.assertEquals( 4, patch.getExteriorRing().getControlPoints().size() );    }
@Test	public void testEndpointsWithoutTargetRefsAllNamespaces() {		EndpointsList endpoints = createSingleEndpointEndpointListByPodName("api-pod");		endpoints.getItems().get(0).getSubsets().get(0).getAddresses().get(0).setTargetRef(null);		when(this.endpointsOperation.list()).thenReturn(endpoints);		when(this.kubernetesClient.endpoints()).thenReturn(this.endpointsOperation);		when(this.kubernetesClient.endpoints().inAnyNamespace()).thenReturn(this.endpointsOperation);		when(this.kubernetesClient.endpoints().inAnyNamespace().withLabels(anyMap()))				.thenReturn(this.endpointsOperation);		this.underTest.catalogServicesWatch();		// second execution on shuffleServices		this.underTest.catalogServicesWatch();		verify(this.applicationEventPublisher).publishEvent(any(HeartbeatEvent.class));	}
@Test	public void testGetThumbnailFileSizeDoesNotTriggerAMProcessorWhenAMImageExists()		throws Exception {		Mockito.when(			_adaptiveMedia.getValueOptional(Mockito.any())		).thenReturn(			Optional.empty()		);		Mockito.when(			_amImageFinder.getAdaptiveMediaStream(Mockito.any(Function.class))		).thenAnswer(			invocation -> Stream.of(_adaptiveMedia)		);		_amImageEntryProcessor.getThumbnailFileSize(_fileVersion, 0);		Mockito.verify(			_amAsyncProcessor, Mockito.never()		).triggerProcess(			Mockito.any(FileVersion.class), Mockito.anyString()		);	}
@Test    public void testColumnVisibilityActionOnHideable() {        JXTable table = new JXTable(10, 3);        table.setColumnControlVisible(true);        ColumnControlButton columnControl = (ColumnControlButton) table.getColumnControl();        ColumnVisibilityAction action = columnControl.getColumnVisibilityActions().get(0);        TableColumnExt columnExt = table.getColumnExt(0);        // visible property is false        columnExt.setVisible(false);        columnExt.setHideable(false);        assertTrue("visibility action must be selected if not hideable", action.isSelected());        assertFalse("action must be disabled", action.isEnabled());        columnExt.setHideable(true);        assertFalse("visibility action must be unselected if hideable", action.isSelected());    }
@Test	public void testColumnMappingWitUndefinedTargetColumn() throws Exception {		try (XLSBatchEngineImportTaskItemReader				xlsBatchEngineImportTaskItemReader =					_getXLSBatchEngineImportTaskItemReader(						new String[] {							"createDate1", "description1", "id1", "name1_en",							"name1_hr"						},						new Object[][] {							{								createDateString, "sample description", 1,								"sample name", "naziv"							}						})) {			validate(				createDateString, "sample description", 1L,				new HashMap<String, String>() {					{						put("createDate1", "createDate");						put("description1", "description");						put("id1", "id");						put("name1", null);					}				},				xlsBatchEngineImportTaskItemReader.read(), null);		}	}
@Test    public void testGetText() throws Exception {        assertEquals("5", mDay.getText());    }
@Test    void composeToInt() {        final ToInt<String> toInt = String::length;        final ComposeToInt<String, String, ToInt<String>> composeToInt =                (ComposeToInt<String, String, ToInt<String>>)                        ComposedUtil.composeToInt(Function.identity(), toInt);        assertNotNull(composeToInt.firstStep());        assertNotNull(composeToInt.secondStep());        assertNull(composeToInt.apply(null));        assertNotNull(composeToInt.apply("test"));    }
@Test    public void shouldNotBePossibleToResolveSiblingPathOutsideTheRepositoryRoot()    {        assertThatExceptionOfType(PathExceededRootRepositoryPathException.class)             .isThrownBy(() -> {                 RepositoryPath path = new RepositoryPath(REPOSITORY_BASEDIR, repositoryFileSystem);                 path.resolveSibling(Paths.get("relative"));        });    }
@Test  public void testOozieHAEnabledExport() throws Exception {    final String expectedHostName = "c6401.apache.ambari.org";    final String expectedHostNameTwo = "c6402.ambari.apache.org";    final String expectedExternalHost = "c6408.ambari.apache.org";    final String expectedHostGroupName = "host_group_1";    final String expectedHostGroupNameTwo = "host_group_2";    final String expectedPortNum = "80000";    Map<String, Map<String, String>> configProperties = new HashMap<String, Map<String, String>>();    Map<String, String> oozieSiteProperties = new HashMap<String, String>();    Map<String, String> oozieEnvProperties = new HashMap<String, String>();    Map<String, String> coreSiteProperties = new HashMap<String, String>();    configProperties.put("oozie-site", oozieSiteProperties);    configProperties.put("oozie-env", oozieEnvProperties);    configProperties.put("hive-env", oozieEnvProperties);    configProperties.put("core-site", coreSiteProperties);    oozieSiteProperties.put("oozie.base.url", expectedHostName + ":" + expectedPortNum);    oozieSiteProperties.put("oozie.authentication.kerberos.principal", expectedHostName);    oozieSiteProperties.put("oozie.service.HadoopAccessorService.kerberos.principal", expectedHostName);    oozieSiteProperties.put("oozie.service.JPAService.jdbc.url", "jdbc:mysql://" + expectedExternalHost + "/ooziedb");    // simulate the Oozie HA configuration    oozieSiteProperties.put("oozie.services.ext",      "org.apache.oozie.service.ZKLocksService,org.apache.oozie.service.ZKXLogStreamingService,org.apache.oozie.service.ZKJobsConcurrencyService,org.apache.oozie.service.ZKUUIDService");    oozieSiteProperties.put("oozie.zookeeper.connection.string", createHostAddress(expectedHostName, "2181") + "," + createHostAddress(expectedHostNameTwo, "2181"));    oozieEnvProperties.put("oozie_existing_mysql_host", expectedExternalHost);    coreSiteProperties.put("hadoop.proxyuser.oozie.hosts", expectedHostName + "," + expectedHostNameTwo);    Configuration clusterConfig = new Configuration(configProperties, Collections.<String, Map<String, Map<String, String>>>emptyMap());    Collection<String> hgComponents = new HashSet<String>();    hgComponents.add("OOZIE_SERVER");    hgComponents.add("ZOOKEEPER_SERVER");    TestHostGroup group1 = new TestHostGroup(expectedHostGroupName, hgComponents, Collections.singleton(expectedHostName));    Collection<String> hgComponents2 = new HashSet<String>();    hgComponents2.add("OOZIE_SERVER");    hgComponents2.add("ZOOKEEPER_SERVER");    TestHostGroup group2 = new TestHostGroup(expectedHostGroupNameTwo, hgComponents2, Collections.singleton(expectedHostNameTwo));    Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>();    hostGroups.add(group1);    hostGroups.add(group2);    expect(stack.getCardinality("OOZIE_SERVER")).andReturn(new Cardinality("1+")).anyTimes();    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor updater = new BlueprintConfigurationProcessor(topology);    updater.doUpdateForBlueprintExport();    assertEquals("oozie property not updated correctly",      createExportedHostName(expectedHostGroupName, expectedPortNum), oozieSiteProperties.get("oozie.base.url"));    assertEquals("oozie property not updated correctly",      createExportedHostName(expectedHostGroupName), oozieSiteProperties.get("oozie.authentication.kerberos.principal"));    assertEquals("oozie property not updated correctly",      createExportedHostName(expectedHostGroupName), oozieSiteProperties.get("oozie.service.HadoopAccessorService.kerberos.principal"));    assertEquals("oozie property not updated correctly",      createExportedHostName(expectedHostGroupName) + "," + createExportedHostName(expectedHostGroupNameTwo), coreSiteProperties.get("hadoop.proxyuser.oozie.hosts"));    assertEquals("oozie property not updated correctly",      createExportedAddress("2181", expectedHostGroupName) + "," + createExportedAddress("2181", expectedHostGroupNameTwo), oozieSiteProperties.get("oozie.zookeeper.connection.string"));  }
@Test(expected = WebApplicationException.class)        public void testGetBindingDetailJSON_NULL() {                System.out.println("getBindingDetailJSON_NULL");                String id = UUID.randomUUID().toString();                BindingTemplate expResult = null;                BindingTemplate result = instance.getBindingDetailJSON(id);        }
@Test(expected = UnsupportedOperationException.class)    public void testUpdateCodeByURI() throws Exception {        this.allThesaurus.updateCodeByURI("olduri", "newuri");    }
@Test    void trigger() {        FixedRateTask task = new FixedRateTask(null, null, Duration.ofSeconds(30));        assertThat(task.trigger()).isEqualTo("fixedRate@PT30S");    }
@SuppressWarnings("unchecked")  @Test  public void testUserBadResponse() throws Exception {    HttpURLConnection conn = EasyMock.createMock(HttpURLConnection.class);    expect(conn.getResponseCode()).andReturn(200);    expect(conn.getInputStream()).andReturn(new ByteArrayInputStream(GOOD_LOGIN_RESPONSE.getBytes())).once();    expect(conn.getResponseCode()).andReturn(200);    expect(conn.getInputStream()).andReturn(new ByteArrayInputStream(GOOD_USER_RESPONSE.getBytes())).once();    expect(conn.getResponseCode()).andReturn(500);    expect(m_streamProvider.processURL((String) anyObject(), (String) anyObject(),        (InputStream) anyObject(), (Map<String, List<String>>) anyObject())).andReturn(            conn).anyTimes();    replay(conn, m_streamProvider);    PrerequisiteCheck check = new PrerequisiteCheck(null, null);    m_rpc.perform(check, new PrereqCheckRequest("cluster"));    assertEquals(PrereqCheckStatus.WARNING, check.getStatus());    assertEquals("Could not verify credentials for user 'r_admin'.  Response code 500 received from " + RANGER_URL + "service/public/api/repository/count", check.getFailReason());    verify(conn, m_streamProvider);  }
@Test  public void testApply() {    Geometry geometry = mock(Geometry.class);    Geometry newGeometry = mock(Geometry.class);    GeometryOperator.Context context = new GeometryOperator.Context();    when(childGeometryFunction.apply(geometry, context)).thenReturn(newGeometry);    Geometry result = geometryOperatorList.apply(geometry, context);    assertThat(result, is(newGeometry));  }
@Test	public void testAdd() {		board.add(L4, 0, 1);	}
@Test    void slowOperationThreshold() {        var threshold = Duration.ofSeconds(5);        redis.slowOperationThreshold(threshold);        assertThat(redis.slowOperationThresholdInNanos).isEqualTo(threshold.toNanos());    }
@Test  public void testDeleteResources() throws Exception{    TestProviderModule providerModule = new TestProviderModule();    TestHostResourceProvider resourceProvider = (TestHostResourceProvider) providerModule.getResourceProvider(Resource.Type.Host);    ClusterController controller = new ClusterControllerImpl(providerModule);    Predicate predicate = new PredicateBuilder().property("c1/p2").equals(1).toPredicate();    controller.deleteResources(Resource.Type.Host, new RequestImpl(null, null, null, null), predicate);    Assert.assertEquals(TestHostResourceProvider.Action.Delete, resourceProvider.getLastAction());    Assert.assertNull(resourceProvider.getLastRequest());    Assert.assertSame(predicate, resourceProvider.getLastPredicate());  }
@Test	public void testDelete() throws Exception {		DDMStorageAdapterDeleteRequest.Builder builder =			DDMStorageAdapterDeleteRequest.Builder.newBuilder(1);		DDMStorageAdapterDeleteResponse expectedResponse =			_jsonDDMStorageAdapter.delete(builder.build());		Assert.assertTrue(expectedResponse.isDeleted());		Mockito.verify(			_ddmContentLocalService, Mockito.times(1)		).deleteDDMContent(			1		);	}
@Test    void testChecksum() throws URISyntaxException, IOException {        final Path checksumTestFile = Path.of(Objects.requireNonNull(Thread.currentThread().getContextClassLoader()                .getResource("checksum_test.txt")).toURI());        final Mono<String> result = sha256ChecksumProvider.checksum(                Files.newInputStream(checksumTestFile).readAllBytes());        StepVerifier.create(result)                .assertNext(resultValue -> assertThat(resultValue, is(                        "5be0888bbe2087f962fee5748d9cf52e37e4c6a24af79675ff7e1ca0a1b12739")))                .verifyComplete();    }
@Test	public void testGetClassName() {		InfoItemReference infoItemReference = new InfoItemReference(			"className", 12354L);		Assert.assertEquals("className", infoItemReference.getClassName());	}
@Test	public void testReturnsTheSameContentIfThereAreNoContentTransformers() {		Assert.assertSame(			_ORIGINAL_CONTENT,			_contentTransformerHandlerImpl.transform(				_contentTransformerContentType, _ORIGINAL_CONTENT));	}
@Test  public void testGrantFactAccessSubjectNotFound() throws Exception {    GrantFactAccessRequest request = createGrantAccessRequest();    when(factRequestResolver.resolveFact(request.getFact())).thenReturn(new FactRecord());    InvalidArgumentException ex = assertThrows(InvalidArgumentException.class, () -> delegate.handle(request));    assertEquals(set("subject.not.exist"), set(ex.getValidationErrors(), InvalidArgumentException.ValidationError::getMessageTemplate));    verify(subjectResolver).resolveSubject(request.getSubject());  }
@Test(expectedExceptions = RuntimeException.class)  public void testValidateTonyConfTooManyFooInstances() {    Configuration conf = new Configuration();    conf.setInt(TonyConfigurationKeys.getMaxInstancesKey("foo"), 1);    conf.setInt("tony.foo.instances", 2);    TonyClient.validateTonyConf(conf);  }
@Test    public void searchUsers_IOExceptionThenSuccess_SearchUsersRetried() {        //Given        when(githubUserRestService.searchGithubUsers(anyString()))                .thenReturn(getIOExceptionError(), Observable.just(githubUserList()));        when(githubUserRestService.getUser(anyString()))                .thenReturn(Observable.just(user1FullDetails()), Observable.just(user2FullDetails()));        //When        TestSubscriber<List<User>> subscriber = new TestSubscriber<>();        userRepository.searchUsers(USER_LOGIN_RIGGAROO).subscribe(subscriber);        //Then        subscriber.awaitTerminalEvent();        subscriber.assertNoErrors();        verify(githubUserRestService, times(2)).searchGithubUsers(USER_LOGIN_RIGGAROO);        verify(githubUserRestService).getUser(USER_LOGIN_RIGGAROO);        verify(githubUserRestService).getUser(USER_LOGIN_2_REBECCA);    }
@Test  public void testSearchObjectTypesCallsDelegate() throws Exception {    ObjectTypeSearchDelegate delegate = mock(ObjectTypeSearchDelegate.class);    when(delegateProvider.get(ObjectTypeSearchDelegate.class)).thenReturn(delegate);    SearchObjectTypeRequest request = new SearchObjectTypeRequest();    service.searchObjectTypes(RequestHeader.builder().build(), request);    verify(delegate).handle(request);  }
@Test    public void severalGroups() throws Exception {        User user = userRepo.findOneByUsername(username);        assertNull("User already exists", user);        String group = groupname + "1";        String profile = Profile.Reviewer.name();        for (int i = 2; i < 5; i++) {            group = group + config.getArraySeparator() + groupname + i;            profile = profile + config.getArraySeparator() + Profile.Editor.name();        }        MockHttpServletRequest request = new MockHttpServletRequest();        request.addHeader(this.config.getEmailKey(), email);        request.addHeader(this.config.getFirstnameKey(), firstname);        request.addHeader(this.config.getGroupKey(), group);        request.addHeader(this.config.getProfileKey(), profile);        request.addHeader(this.config.getSurnameKey(), surname);        request.addHeader(this.config.getUsernameKey(), username);        utils.setupUser(request, this.config);        // Checks        user = userRepo.findOneByUsername(username);        assertNotNull("User was not created", user);        assertSame("The profile should be the highest in the list", Profile.Reviewer, user.getProfile());        List<Integer> idGroups = userGroupRepo.findGroupIds(UserGroupSpecs.hasUserId(user.getId()));        assertSame("Groups size is wrong", idGroups.size(), 4);        List<UserGroup> groups = userGroupRepo.findAll(UserGroupSpecs.hasUserId(user.getId()));        for (UserGroup ug : groups) {            assertNotSame("No profile can be guest as we have defined a role for all groups.", Profile.Guest,                    ug.getProfile());        }    }
@Test    public void testOnRefreshMenusEvent() {        builder.onRefreshMenusEvent(new RefreshMenusEvent());        verify(builder).initialise();    }
@Test	public void testRaceConditionInLazyInit() {		LazyInitRace lazy = new LazyInitRace();		Thread th_1 = new Thread(() -> {			exObject_1 = lazy.getInstance();		});		Thread th_2 = new Thread(() -> {			exObject_2 = lazy.getInstance();		});		th_1.start();		th_2.start();		try {			th_1.join();			th_2.join();		}		catch (InterruptedException e) {			e.printStackTrace();		}		assertEquals(exObject_1, exObject_2);	}
@Test   public void testUpdateSettings_keysExist() {      WizardPage page = new TestWizardPage("Test Page","");            WizardSettings settings = new StackWizardSettings();      page.updateSettings(settings);            Assert.assertTrue("Key set did not contain needed key.",            settings.keySet().contains("test box"));      Assert.assertTrue("Key set did not contain needed key.",            settings.keySet().contains("test field"));      Assert.assertTrue("Key set did not contain needed key.",            settings.keySet().contains("custom comp"));      Assert.assertTrue("Key set did not contain needed key.",            settings.keySet().contains("formated field"));   }
@Test  public void testGetStackArtifactResourceProvider() {    AmbariManagementController managementController = createMock(AmbariManagementController.class);    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(        Resource.Type.StackArtifact, null, null, managementController);    assertEquals(StackArtifactResourceProvider.class, provider.getClass());  }
@Test	public void testEmpty() {		Assert.assertTrue(			_localizableTextDDMFormFieldValueAccessor.isEmpty(				DDMFormValuesTestUtil.createDDMFormFieldValue(					"localizableText", new UnlocalizedValue("{}")),				LocaleUtil.US));	}
@Test    void get0() {        assertEquals(m0, instance.get0());    }
@Test    public void format1() {        assertEquals( "3.1416", Utils.format(Math.PI));        assertEquals( "314.1593", Utils.format(Math.PI* 100));    }
@Test    void findInNotRequired() {        final Foo expected = InjectorUtil.findIn(Foo.class, injector, instances, false);        assertEquals(foo, expected);        assertNull(InjectorUtil.findIn(Integer.class, injector, instances, false));    }
@Test	public void testTextField() {		// Dynamic data mapping form		DDMForm ddmForm = DDMFormTestUtil.createDDMForm();		boolean required = true;		DDMFormField ddmFormField = DDMFormTestUtil.createTextDDMFormField(			"Field1", false, false, required);		ddmFormField.setLabel(			DDMFormValuesTestUtil.createLocalizedValue("Field 1", _LOCALE));		ddmFormField.setReadOnly(false);		ddmFormField.setTip(			DDMFormValuesTestUtil.createLocalizedValue(				"This is a tip.", _LOCALE));		ddmFormField.setProperty("displayStyle", "singleline");		ddmForm.addDDMFormField(ddmFormField);		// Dynamic data mapping form field evaluation		String instanceId = StringUtil.randomString();		Map<DDMFormEvaluatorFieldContextKey, Map<String, Object>>			ddmFormFieldsPropertyChanges =				HashMapBuilder.					<DDMFormEvaluatorFieldContextKey, Map<String, Object>>put(						new DDMFormEvaluatorFieldContextKey(							"Field1", instanceId),						HashMapBuilder.<String, Object>put(							"required", true						).put(							"valid", true						).put(							"visible", true						).build()					).build();		// Dynamic data mapping form values		List<DDMFormFieldValue> ddmFormFieldValues = new ArrayList<>();		DDMFormFieldValue ddmFormFieldValue =			DDMFormValuesTestUtil.createUnlocalizedDDMFormFieldValue(				"Field1", "Value 1");		ddmFormFieldValue.setInstanceId(instanceId);		ddmFormFieldValues.add(ddmFormFieldValue);		DDMFormFieldTemplateContextFactory ddmFormFieldTemplateContextFactory =			createDDMFormFieldTemplateContextFactory(				ddmForm, ddmFormField.getName(), ddmFormFieldsPropertyChanges,				ddmFormFieldValues, false, getTextDDMFormFieldRenderer(),				getTextDDMFormFieldTemplateContextContributor());		List<Object> fields = ddmFormFieldTemplateContextFactory.create();		Assert.assertEquals(fields.toString(), 1, fields.size());		Map<String, Object> fieldTemplateContext =			(Map<String, Object>)fields.get(0);		Assert.assertEquals(			"singleline",			MapUtil.getString(fieldTemplateContext, "displayStyle"));		Assert.assertEquals(			"Field 1", MapUtil.getString(fieldTemplateContext, "label"));		Assert.assertEquals(			false, MapUtil.getBoolean(fieldTemplateContext, "readOnly"));		Assert.assertEquals(			false, MapUtil.getBoolean(fieldTemplateContext, "repeatable"));		Assert.assertEquals(			true, MapUtil.getBoolean(fieldTemplateContext, "required"));		Assert.assertEquals(			"This is a tip.", MapUtil.getString(fieldTemplateContext, "tip"));		Assert.assertEquals(			true, MapUtil.getBoolean(fieldTemplateContext, "valid"));		Assert.assertEquals(			StringPool.BLANK,			MapUtil.getString(fieldTemplateContext, "validationErrorMessage"));		Assert.assertEquals(			"Value 1", MapUtil.getString(fieldTemplateContext, "value"));		Assert.assertEquals(			true, MapUtil.getBoolean(fieldTemplateContext, "visible"));		String expectedName = String.format(			_FIELD_NAME_FORMAT, "Field1", instanceId, 0, _LOCALE.toString());		Assert.assertEquals(			expectedName, MapUtil.getString(fieldTemplateContext, "name"));	}
@Test  public void testGetFactPropsInputValidation() {    assertThrows(IllegalArgumentException.class,            () -> helper.getFactProperties(null, TraverseParams.builder().build()));    assertThrows(IllegalArgumentException.class,            () -> helper.getFactProperties(new FactRecord(), null));  }
@Test  public void isInTransactionTest()  {    JdbcNonTransactionalStore jdbcNonTransactionalStore = new JdbcNonTransactionalStore();    try {      jdbcNonTransactionalStore.isInTransaction();    } catch (RuntimeException e) {      return;    }    Assert.fail("Exception should be thrown");  }
@Test(description = "Testing get devices when request exists both name and role.")    public void testGetDevicesWhenBothNameAndRoleAvailable() {        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceManagementService"))                .toReturn(this.deviceManagementProviderService);        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceAccessAuthorizationService"))                .toReturn(this.deviceAccessAuthorizationService);        Response response = this.deviceManagementService                .getDevices(TEST_DEVICE_NAME, TEST_DEVICE_TYPE, DEFAULT_USERNAME, null, DEFAULT_ROLE, DEFAULT_OWNERSHIP,                        DEFAULT_STATUS, 1, null, null, false, 10, 5);        Assert.assertEquals(response.getStatus(), Response.Status.BAD_REQUEST.getStatusCode());    }
@Test(expected = IOException.class)	public void testMapToResultsThrowsIOException() throws Exception {		_individualSegmentJSONObjectMapper.mapToResults("invalid json");	}
@Test    void invalidate() {        assertThatThrownBy(() -> sessionManager.invalidate(null, null))                .isInstanceOf(Error.class)                .hasMessageContaining("must not be null");    }
@Test    public void testIsCompleteWhenPatternIsNotSet() {        when(plugin.patternWrapper()).thenReturn(newPattern("",                                                            "",                                                            false));        page.isComplete(Assert::assertFalse);        verify(view,               never()).hidePatternWarning();        verify(view).showPatternWarning();        verify(plugin,               never()).isNewColumn();    }
@Test(description = "Handle request with device type URI with Mutual Auth Header",            dependsOnMethods = "testHandleSuccessRequestProxyMutualAuthHeader")    public void testHandleSuccessRequestMutualAuthHeader() throws Exception {        HashMap<String, String> transportHeaders = new HashMap<>();        transportHeaders.put(AuthConstants.MUTUAL_AUTH_HEADER, "Test Header");        setMockClient();        this.mockClient.setResponse(getAccessTokenReponse());        this.mockClient.setResponse(getValidationResponse());        MessageContext messageContext = createSynapseMessageContext("<empty/>", this.synapseConfiguration,                transportHeaders, "https://test.com/testservice/api/testdevice");        org.apache.axis2.context.MessageContext axisMC = ((Axis2MessageContext) messageContext).getAxis2MessageContext();        String certStr = getContent(TestUtils.getAbsolutePathOfConfig("ra_cert.pem"));        X509Certificate cert = X509Certificate.getInstance(new ByteArrayInputStream(certStr.                getBytes(StandardCharsets.UTF_8.name())));        axisMC.setProperty(AuthConstants.CLIENT_CERTIFICATE, new X509Certificate[]{cert});        boolean response = this.handler.handleRequest(messageContext);        Assert.assertTrue(response);        this.mockClient.reset();    }
@Test  public void testDeleteMapping() throws Exception {    StoragePath path = new StoragePath(ORG, MP_ID, new VersionImpl(1L), ASSET1_ID);    database.storeMapping(path, "archive_path/" + ASSET1_ID, AWS_VERSION_1);    AwsAssetMapping mapping = database.findMapping(path);    Assert.assertNotNull(mapping);    database.deleteMapping(path);    // Mapping row is not deleted, but findMapping should not find it    mapping = database.findMapping(path);    Assert.assertNull(mapping);    // Mapping should have its deletion date set    List<AwsAssetMapping> mappings = database.findAllByMediaPackage(MP_ID);    Assert.assertEquals(1, mappings.size());    Assert.assertNotNull(mappings.get(0).getDeletionDate());  }
@Test  public void testStoreFactCommentSavesEntity() {    FactRecord fact = new FactRecord().setId(UUID.randomUUID());    FactCommentRecord comment = new FactCommentRecord().setId(UUID.randomUUID());    when(factCommentRecordConverter.toEntity(comment, fact.getId())).thenReturn(new FactCommentEntity());    assertSame(comment, dao.storeFactComment(fact, comment));    verify(factManager).saveFactComment(notNull());    verify(factCommentRecordConverter).toEntity(argThat(r -> r.getId() == comment.getId()), eq(fact.getId()));  }
@Test	public void testParseDateRangeInvalidEnd() {		RangeTermQueryValue rangeTermQueryValue =			rangeTermQueryValueParser.parse("[now/d now+1d/d");		Assert.assertNull(rangeTermQueryValue);	}
@Test    public void unknownFrame() {        ByteBuffer buffer = ByteBuffer.wrap(TestMessages.UNKNOWN_PAYLOAD_BUFFER);        Http2UnknownFrame frame = (Http2UnknownFrame) decoder.decode(buffer, context);        assertNotNull(frame);        assertEquals(2, frame.getLength());        assertEquals(255, frame.getType() & 0x00FF);        assertEquals(0x00, frame.getFlags());        assertEquals(32, frame.getStreamID());        assertEquals(2, frame.getPayload().length);        assertArrayEquals(new byte[] {0x0E,  0x18}, frame.getPayload());    }
@Test public void testNewFragmentInstanceForAbstractFragment() {		// Arrange:		final FragmentItem item = new FragmentItem(1, TestAbstractFragment.class);		// Act + Assert:		assertThat(item.newFragmentInstance(new Bundle()), is(nullValue()));	}
@Test        public void testGetOpInfoXML() {                System.out.println("getOpInfoXML");                String id = UUID.randomUUID().toString();                OperationalInfo expResult = null;                OperationalInfo result = instance.getOpInfoXML(JUDDI_BIZ);                Assert.assertNotNull(result);                Assert.assertNotNull(result.getAuthorizedName());                Assert.assertNotNull(result.getEntityKey());                Assert.assertNotNull(result.getNodeID());        }
@Test    public void allowsTypingOfNonOptionArguments() {        OptionSpec<File> nonOptions = parser.nonOptions().ofType( File.class );        OptionSet options = parser.parse( "/opt", "/var" );        assertEquals( asList( new File( "/opt" ), new File( "/var" ) ), nonOptions.values( options ) );    }
@Test  public void testGetOriginByIdTwiceReturnsSameInstance() {    OriginEntity entity = createAndSaveOrigin();    OriginEntity origin1 = getOriginManager().getOrigin(entity.getId());    OriginEntity origin2 = getOriginManager().getOrigin(entity.getId());    assertSame(origin1, origin2);  }
@Test    public void testSqlThrowableLabel() throws Exception {        SQLException sqlException = new SQLException("My SQL exception", "Login failure", 400);        assertThat(Utils.getLabel(sqlException)).isEqualTo("java.sql.SQLException,ErrorCode=400,SQLState=Login failure");    }
@Test  public void testFromEntityWithEmptyObject() {    assertNotNull(converter.fromEntity(new ObjectEntity()));  }
@Test    public void testDoOriginMatch() {        Pair<String, String>[] matches = new Pair[]{            new Pair("*", "*"),            new Pair("file://", "*"),            new Pair("localhost", "http://localhost"),            new Pair("localhost:8080", "http://localhost:8080"),            new Pair("http://localhost", "http://localhost:80"),            new Pair("https://localhost", "http://localhost:443")        };        Pair<String, String>[] nonMatches = new Pair[]{            new Pair(null, null),            new Pair("*", null),            new Pair("file://", "http://localhost:8080"),            new Pair("http://localhost", "http://localhost:8080"),            new Pair("http://host", "http://localhost")        };        for (int i = 0; i < matches.length; i++) {            Pair<String, String> pair = matches[i];            System.out.println("asserting match: " + pair);            assertTrue(RpcUtils.doOriginsMatch(pair.getElement1(), pair.getElement2()));            assertTrue(RpcUtils.doOriginsMatch(pair.getElement2(), pair.getElement1()));        }        for (int i = 0; i < nonMatches.length; i++) {            Pair<String, String> pair = nonMatches[i];            System.out.println("asserting not match: " + pair);            assertFalse(RpcUtils.doOriginsMatch(pair.getElement1(), pair.getElement2()));            assertFalse(RpcUtils.doOriginsMatch(pair.getElement2(), pair.getElement1()));        }    }
@Test    void get7Test() {        assertEquals(7, (int) instance.get7().orElseThrow(NoSuchElementException::new));    }
@Test    void testFilter() {        Assertions.assertFalse(this.filter.isAllowGuestLogin());        Assertions.assertEquals(PrincipalFormat.FQN, this.filter.getPrincipalFormat());        Assertions.assertEquals(PrincipalFormat.BOTH, this.filter.getRoleFormat());        Assertions.assertNull(this.filter.getFilterConfig());        Assertions.assertNotNull(this.filter.getProvider());        Assertions.assertTrue(this.filter.getAccessDeniedHandler() instanceof CustomAccessDeniedHandler);    }
@Test  public void testBuildClusterForNonExistingBlueprint() {    when(client.doesBlueprintExist("id")).thenReturn(false);    String result = clusterCommands.buildCluster(new Blueprint("id"));    verify(client).doesBlueprintExist("id");    assertEquals("Not a valid blueprint id", result);  }
@Test  public void testDoUpdateForClusterCreate_MultiHostProperty__exportedValues___withPorts_UsingMinusSymbolInHostGroupName() throws Exception {    Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();    Map<String, String> typeProps = new HashMap<String, String>();    typeProps.put("ha.zookeeper.quorum", "%HOSTGROUP::os-amb-r6-secha-1427972156-hbaseha-3-6%:2181,%HOSTGROUP::os-amb-r6-secha-1427972156-hbaseha-3-5%:2181,%HOSTGROUP::os-amb-r6-secha-1427972156-hbaseha-3-7%:2181");    properties.put("core-site", typeProps);    Configuration clusterConfig = new Configuration(properties, Collections.<String, Map<String, Map<String, String>>>emptyMap());    Collection<String> hgComponents = new HashSet<String>();    hgComponents.add("NAMENODE");    hgComponents.add("SECONDARY_NAMENODE");    hgComponents.add("ZOOKEEPER_SERVER");    TestHostGroup group1 = new TestHostGroup("os-amb-r6-secha-1427972156-hbaseha-3-6", hgComponents, Collections.singleton("testhost"));    Collection<String> hgComponents2 = new HashSet<String>();    hgComponents2.add("DATANODE");    hgComponents2.add("HDFS_CLIENT");    hgComponents2.add("ZOOKEEPER_SERVER");    Set<String> hosts2 = new HashSet<String>();    hosts2.add("testhost2");    hosts2.add("testhost2a");    hosts2.add("testhost2b");    TestHostGroup group2 = new TestHostGroup("os-amb-r6-secha-1427972156-hbaseha-3-5", hgComponents2, hosts2);    Collection<String> hgComponents3 = new HashSet<String>();    hgComponents2.add("HDFS_CLIENT");    hgComponents2.add("ZOOKEEPER_CLIENT");    Set<String> hosts3 = new HashSet<String>();    hosts3.add("testhost3");    hosts3.add("testhost3a");    TestHostGroup group3 = new TestHostGroup("os-amb-r6-secha-1427972156-hbaseha-3-7", hgComponents3, hosts3);    Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>();    hostGroups.add(group1);    hostGroups.add(group2);    hostGroups.add(group3);    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor updater = new BlueprintConfigurationProcessor(topology);    updater.doUpdateForClusterCreate();    String updatedVal = topology.getConfiguration().getFullProperties().get("core-site").get("ha.zookeeper.quorum");    String[] hosts = updatedVal.split(",");    Collection<String> expectedHosts = new HashSet<String>();    expectedHosts.add("testhost:2181");    expectedHosts.add("testhost2:2181");    expectedHosts.add("testhost2a:2181");    expectedHosts.add("testhost2b:2181");    expectedHosts.add("testhost3:2181");    expectedHosts.add("testhost3a:2181");    assertEquals(6, hosts.length);    for (String host : hosts) {      assertTrue("Expected host :" + host + "was not included in the multi-server list in this property.", expectedHosts.contains(host));      expectedHosts.remove(host);    }  }
@Test  public void testUpdate() {    KerberosIdentityDescriptor identityDescriptor = createFromJSON();    KerberosIdentityDescriptor updatedIdentityDescriptor = createFromMap();    Assert.assertNotNull(identityDescriptor);    Assert.assertNotNull(updatedIdentityDescriptor);    identityDescriptor.update(updatedIdentityDescriptor);    validateUpdatedData(identityDescriptor);  }
@Test    public void outputTest() {        List<Map<String, Object>> stuff = ImmutableList.of(                ImmutableMap.of("a", "1", "b", 2),                ImmutableMap.of("b", 2, "c", 3, "d", 4),                ImmutableMap.of("a", ImmutableList.of(1, 2, 3)));        ByteArrayOutputStream out = new ByteArrayOutputStream();        PrintStream stream = new PrintStream(out);        Exporters.csv(stream).export(stuff);        StringBuilder expected = new StringBuilder();        expected.append("a,b,c,d").append(System.lineSeparator())                .append("1,2,null,null").append(System.lineSeparator())                .append("null,2,3,4").append(System.lineSeparator())                .append("\"1,2,3\",null,null,null");        Assert.assertEquals(expected.toString(), out.toString());    }
@Test    public void replaceColumnTest() {        abstractScesimGridModelSpy.replaceColumn(ROW_INDEX, gridColumnMock);        verify(gridColumnMock, times(COLUMN_NUMBER)).getWidth();        verify(gridColumnMock, times(COLUMN_NUMBER)).setWidth(anyDouble());        verify(abstractScesimGridModelSpy, times(1)).deleteColumn(eq(ROW_INDEX));        verify(abstractScesimGridModelSpy, times(1)).commonAddColumn(eq(ROW_INDEX), eq(gridColumnMock), isA(ExpressionIdentifier.class));    }
@Test public void testCheckIfEnabledOrThrowWhenEnabled() {		// Act:		FragmentAnnotations.checkIfEnabledOrThrow();	}
@Test	public void testCreateDDMFormValues() throws Exception {		String serializedDDMFormValues = read("ddm-form-values.json");		when(			_resourceRequest.getParameter("serializedDDMFormValues")		).thenReturn(			serializedDDMFormValues		);		when(			_language.getLanguageId(_resourceRequest)		).thenReturn(			"pt_BR"		);		when(			_language.isAvailableLocale(LocaleUtil.BRAZIL)		).thenReturn(			true		);		DDMForm ddmForm = DDMFormTestUtil.createDDMForm();		ddmForm.addDDMFormField(			DDMFormTestUtil.createTextDDMFormField(				"TextField1", true, false, false));		ddmForm.addDDMFormField(			DDMFormTestUtil.createTextDDMFormField(				"TextField2", true, false, false));		when(			_ddmStructure.getDDMForm()		).thenReturn(			ddmForm		);		LocalizedValue value1 = new LocalizedValue();		value1.addString(LocaleUtil.BRAZIL, "Texto 1");		DDMFormFieldValue ddmFormFieldValue1 =			DDMFormValuesTestUtil.createDDMFormFieldValue(				"eBvF8zup", "TextField1", value1);		LocalizedValue value2 = new LocalizedValue();		value2.addString(LocaleUtil.BRAZIL, "Texto 2");		DDMFormFieldValue ddmFormFieldValue2 =			DDMFormValuesTestUtil.createDDMFormFieldValue(				"6VYYLvfJ", "TextField2", value2);		DDMFormValues ddmFormValues1 =			DDMFormValuesTestUtil.createDDMFormValues(				ddmForm, SetUtil.fromArray(new Locale[] {LocaleUtil.BRAZIL}),				LocaleUtil.BRAZIL);		ddmFormValues1.addDDMFormFieldValue(ddmFormFieldValue1);		ddmFormValues1.addDDMFormFieldValue(ddmFormFieldValue2);		DDMFormValues ddmFormValues2 =			_addFormInstanceRecordMVCResourceCommand.createDDMFormValues(				_ddmFormInstance, _resourceRequest);		Assert.assertNotEquals(LocaleUtil.getSiteDefault(), LocaleUtil.BRAZIL);		Assert.assertTrue(Objects.equals(ddmFormValues1, ddmFormValues2));	}
@Test  public void testGetClusterKerberosDescriptorResourceProvider() {    AmbariManagementController managementController = createMock(AmbariManagementController.class);    replay(managementController);    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(        Resource.Type.ClusterKerberosDescriptor, null, null, managementController);    verify(managementController);    assertEquals(ClusterKerberosDescriptorResourceProvider.class, provider.getClass());  }
@Test  public void testIsRetractedCachesResult() {    FactRecord fact = new FactRecord().setId(UUID.randomUUID()).setFlags(set(FactRecord.Flag.RetractedHint));    FactDocument retraction = new FactDocument().setId(UUID.randomUUID());    when(factSearchManager.searchFacts(inReferenceTo(fact.getId()))).thenReturn(createSearchResult(retraction));    assertTrue(handler.isRetracted(fact));    verify(factSearchManager).searchFacts(inReferenceTo(fact.getId()));    verify(factSearchManager).searchFacts(inReferenceTo(retraction.getId()));    verifyNoMoreInteractions(factSearchManager);    assertTrue(handler.isRetracted(fact));    verifyNoMoreInteractions(factSearchManager);  }
@Test    public void testGetColumnKeys() {        ColumnStore<Node> store = new ColumnStore(Node.class, false);        ColumnImpl col = new ColumnImpl("0", Integer.class, null, null, Origin.DATA, false, false);        store.addColumn(col);        ObjectSet<String> set = new ObjectOpenHashSet<String>();        set.add("0");        Assert.assertEquals(store.getColumnKeys(), set);    }
@Test    public void testSynchAllOnEditorSetValue() {        JXDatePicker picker = new JXDatePicker();        Date date = XTestUtils.getStartOfToday(5);        picker.getEditor().setValue(date);        assertSynchAll(picker, date);    }
@Test    public void testFromConfigFile() throws Exception {        AutomonPropertiesLoader loader = new AutomonPropertiesLoader("automon.xml");        Properties properties = loader.getProperties();        assertThat(properties.getProperty(AutomonPropertiesLoader.CONFIGURED_OPEN_MON)).isEqualTo("org.mypackage.MyOpenMon");    }
@Test    public void givenBoolean$setDebugEnabled_whenQuery_thenShouldCallNativeApi() {        // given        PowerMockito.mockStatic(Instabug.class);        // when        rnModule.setDebugEnabled(true);        // then        PowerMockito.verifyStatic(VerificationModeFactory.times(1));        Instabug.setDebugEnabled(true);    }
@Test    void get10() {        assertEquals(m10, instance.get10());    }
@Test(expected = IllegalArgumentException.class)	public void testCreateFragmentForNotInstantiableFragment() {		// Arrange:		final TestFactory factory = new TestFactory();		// Act:		factory.createFragment(TestFactory.FRAGMENT_2);	}
@Test    public void commonUndoRedoPreexecutionDifferentGridCheckSwitch() {        // Test to verify there are not new, un-managed, GridWidget        for (GridWidget gridWidget : GridWidget.values()) {            when(scenarioGridWidgetSpy.isSelected()).thenReturn(GridWidget.BACKGROUND.equals(gridWidget));            when(backgroundGridWidgetSpy.isSelected()).thenReturn(GridWidget.SIMULATION.equals(gridWidget));            commandSpy.gridWidget = gridWidget;            commandSpy.commonUndoRedoPreexecution(scenarioSimulationContextLocal);        }    }
@Test    public void convertValueToString() {        assertEquals(null, helper.convertValueToString(null));        assertEquals("true", helper.convertValueToString(true));        assertEquals("false", helper.convertValueToString(false));        Date date = new Date();        assertEquals(format.format(date), helper.convertValueToString(date));        assertEquals(BigDecimal.ONE.toPlainString(), helper.convertValueToString(BigDecimal.ONE));        assertEquals(BigInteger.ONE.toString(), helper.convertValueToString(BigInteger.ONE));        Byte b = Byte.MAX_VALUE;        assertEquals(b.toString(), helper.convertValueToString(b));        Double d = 123.456;        assertEquals(d.toString(), helper.convertValueToString(d));        Float f = new Float(123.456);        assertEquals(f.toString(), helper.convertValueToString(f));        Integer i = 123;        assertEquals(i.toString(), helper.convertValueToString(i));        Long l = new Long(123);        assertEquals(l.toString(), helper.convertValueToString(l));        Short s = 123;        assertEquals(s.toString(), helper.convertValueToString(s));        assertEquals("surprise!", helper.convertValueToString("surprise!"));    }
@Test    public void testNoParameters()    {        TrackInstantiation.reset();        NoParameters noParameters = reportCollectionFactory.createReportCollection(NoParameters.class);        TrackInstantiation.assertInstantiated();        ArgumentCaptor<String> stringCaptor = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<TrackInstantiation> reportCaptor = ArgumentCaptor.forClass(TrackInstantiation.class);        verify(reportExporter).export(reportCaptor.capture(), eq(false), stringCaptor.capture(), tagCaptor.capture());        assertEquals(stringCaptor.getValue(), "NoParameters.Add");        assertEquals(tagCaptor.getValue(), ImmutableMap.of());        assertNotNull(reportCaptor.getValue());        assertNotNull(noParameters.add());    }
@Test(description = "Testing get devices with IF-Modified-Since")    public void testGetDevicesWithModifiedSince() {        String ifModifiedSince = new SimpleDateFormat(DEFAULT_DATE_FORMAT).format(new Date());        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceManagementService"))                .toReturn(this.deviceManagementProviderService);        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceAccessAuthorizationService"))                .toReturn(this.deviceAccessAuthorizationService);        PowerMockito.stub(PowerMockito.method(MultitenantUtils.class, "getTenantAwareUsername"))                .toReturn(TENANT_AWARE_USERNAME);        PowerMockito.stub(PowerMockito.method(CarbonContext.class, "getThreadLocalCarbonContext"))                .toReturn(Mockito.mock(CarbonContext.class, Mockito.RETURNS_MOCKS));        Response response = this.deviceManagementService                .getDevices(null, TEST_DEVICE_TYPE, DEFAULT_USERNAME, null, DEFAULT_ROLE, DEFAULT_OWNERSHIP,                        DEFAULT_STATUS, 1, null, ifModifiedSince, false, 10, 5);        Assert.assertEquals(response.getStatus(), Response.Status.NOT_MODIFIED.getStatusCode());        response = this.deviceManagementService                .getDevices(null, TEST_DEVICE_TYPE, DEFAULT_USERNAME, null, DEFAULT_ROLE, DEFAULT_OWNERSHIP,                        DEFAULT_STATUS, 1, null, ifModifiedSince, true, 10, 5);        Assert.assertEquals(response.getStatus(), Response.Status.NOT_MODIFIED.getStatusCode());        response = this.deviceManagementService                .getDevices(null, TEST_DEVICE_TYPE, DEFAULT_USERNAME, null, DEFAULT_ROLE, DEFAULT_OWNERSHIP,                        DEFAULT_STATUS, 1, null, "ErrorModifiedSince", false, 10, 5);        Assert.assertEquals(response.getStatus(), Response.Status.BAD_REQUEST.getStatusCode());    }
@Test    public void testParseEncodingsWithoutRequestTypesSpecificAndKvp() {        DeegreeWFS supportedRequests = prepareSupportedRequestsWithoutRequestTypesSpecificAndKvp();        SupportedEncodings unlimitedSupportedEncodings = webFeatureService.parseEncodings( supportedRequests );        assertThat( unlimitedSupportedEncodings, CoreMatchers.instanceOf( UnlimitedSupportedEncodings.class ) );    }
@Test	public void testGetNestedFieldsWithPagination() throws Exception {		Product product = _toProduct(1L, null);		Mockito.when(			_writerInterceptorContext.getEntity()		).thenReturn(			product		);		Mockito.doReturn(			new NestedFieldsHttpServletRequestWrapperTest.				MockHttpServletRequest(					"skus", "page", String.valueOf(1), "pageSize",					String.valueOf(2))		).when(			_nestedFieldServiceTrackerCustomizer		).getHttpServletRequest(			Mockito.any(Message.class)		);		NestedFieldsContextThreadLocal.setNestedFieldsContext(			new NestedFieldsContext(				Collections.singletonList("skus"), new MessageImpl(),				_getPathParameters(), "v1.0", new MultivaluedHashMap<>()));		_nestedFieldsWriterInterceptor.aroundWriteTo(_writerInterceptorContext);		Sku[] skus = product.getSkus();		Assert.assertEquals(Arrays.toString(skus), 2, skus.length);	}
@Test  public void testToEntityWithFullRecord() {    FactRecord record = new FactRecord()            .setId(UUID.randomUUID())            .setTypeID(UUID.randomUUID())            .setValue("value")            .setInReferenceToID(UUID.randomUUID())            .setOrganizationID(UUID.randomUUID())            .setOriginID(UUID.randomUUID())            .setAddedByID(UUID.randomUUID())            .setAccessMode(FactRecord.AccessMode.Explicit)            .setConfidence(0.1f)            .setTrust(0.2f)            .setTimestamp(123456789L)            .setLastSeenTimestamp(987654321L)            .addFlag(FactRecord.Flag.RetractedHint);    FactEntity entity = converter.toEntity(record);    assertEquals(record.getId(), entity.getId());    assertEquals(record.getTypeID(), entity.getTypeID());    assertEquals(record.getValue(), entity.getValue());    assertEquals(record.getInReferenceToID(), entity.getInReferenceToID());    assertEquals(record.getOrganizationID(), entity.getOrganizationID());    assertEquals(record.getOriginID(), entity.getOriginID());    assertEquals(record.getAddedByID(), entity.getAddedByID());    assertEquals(record.getAccessMode().name(), entity.getAccessMode().name());    assertEquals(record.getConfidence(), entity.getConfidence(), 0.0f);    assertEquals(record.getTrust(), entity.getTrust(), 0.0f);    assertEquals(record.getTimestamp(), entity.getTimestamp());    assertEquals(record.getLastSeenTimestamp(), entity.getLastSeenTimestamp());    assertEquals(SetUtils.set(FactEntity.Flag.RetractedHint), entity.getFlags());  }
@Test    public void testIsMethodWithParameterClass()            throws Exception    {        TestMonitor monitor = new TestMonitor();        ConfigurationMetadata<?> metadata = ConfigurationMetadata.getConfigurationMetadata(IsMethodWithParameterClass.class, monitor);        Map<String, Set<String>> expectedAttributes = new HashMap<>();        verifyMetaData(metadata, IsMethodWithParameterClass.class, null, false, expectedAttributes);        monitor.assertNumberOfErrors(1);        monitor.assertNumberOfWarnings(0);        monitor.assertMatchingErrorRecorded("No getter", "unusable", "isValue", "setValue");    }
@Test  public void testGetComponent() throws Exception {    ComponentInfo component = metaInfo.getComponent(STACK_NAME_HDP,        STACK_VERSION_HDP, SERVICE_NAME_HDFS, SERVICE_COMPONENT_NAME);    Assert.assertEquals(component.getName(), SERVICE_COMPONENT_NAME);    try {      metaInfo.getComponent(STACK_NAME_HDP,          STACK_VERSION_HDP, SERVICE_NAME_HDFS, NON_EXT_VALUE);    } catch (StackAccessException e) {    }  }
@Test    void testFlatMapToDouble() {        final double expected = refStream().flatMapToDouble(e -> LongStream.range(0, e.getValue()).mapToDouble(l -> l)).sum();        final double actual = instance.flatMapToDouble((k, v) -> LongStream.range(0, v).mapToDouble(l -> l)).sum();        assertEquals(expected, actual, EPSILON);    }
@Test    void toTuple6OfNullables() {        final Function<Integer, Tuple6OfNullables<Integer, Integer, Integer, Integer, Integer, Integer>> mapper = TuplesOfNullables.toTupleOfNullables(i -> i + 0, i -> i + 1, i -> i + 2, i -> i + 3, i -> i + 4, i -> i + 5);        assertTuple(mapper.apply(0), 6);    }
@Test	public void testValidateConfigurationValuesTextFieldTypeInvalidURL()		throws Exception {		expectedException.expect(FragmentEntryConfigurationException.class);		_fragmentEntryValidatorImpl.validateConfigurationValues(			_read("configuration_field_text_typeoptions_validation_url.json"),			JSONUtil.put("urlField", StringUtil.randomString()));	}
@Test    public void testSearch() throws Exception {        // reindex before searching        userManager.reindex();        bean.setQuery("admin");        assertEquals("success", bean.search());        assertTrue(bean.getUsers().size() == 1);    }
@Test  public void testGetType() {    assertSame(Operator.TYPE.NOT_EQUAL, new NotEqualsOperator().getType());  }
@Test  public void testFilterOutOfBandMetricData() throws Exception {    setUpCommonMocks();    TestStreamProvider streamProvider = new TestStreamProvider(SINGLE_HOST_METRICS_FILE_PATH);    injectCacheEntryFactoryWithStreamProvider(streamProvider);    TestMetricHostProvider metricHostProvider = new TestMetricHostProvider();    ComponentSSLConfiguration sslConfiguration = mock(ComponentSSLConfiguration.class);    TimelineMetricCacheProvider cacheProviderMock = EasyMock.createMock(TimelineMetricCacheProvider.class);    TimelineMetricCache cacheMock = EasyMock.createMock(TimelineMetricCache.class);    expect(cacheProviderMock.getTimelineMetricsCache()).andReturn(cacheMock).anyTimes();    Map<String, Map<String, PropertyInfo>> propertyIds = PropertyHelper.getMetricPropertyIds(Resource.Type.Host);    AMSPropertyProvider propertyProvider = new AMSHostPropertyProvider(      propertyIds,      streamProvider,      sslConfiguration,      cacheProviderMock,      metricHostProvider,      CLUSTER_NAME_PROPERTY_ID,      HOST_NAME_PROPERTY_ID    );    Resource resource = new ResourceImpl(Resource.Type.Host);    resource.setProperty(CLUSTER_NAME_PROPERTY_ID, "c1");    resource.setProperty(HOST_NAME_PROPERTY_ID, "h1");    Map<String, TemporalInfo> temporalInfoMap = new HashMap<String, TemporalInfo>();    // Chopped a section in the middle    temporalInfoMap.put(PROPERTY_ID1, new TemporalInfoImpl(1416446744801L, 1416447224801L, 1L));    Request request = PropertyHelper.getReadRequest(Collections.singleton(PROPERTY_ID1), temporalInfoMap);    Set<Resource> resources =      propertyProvider.populateResources(Collections.singleton(resource), request, null);    Assert.assertEquals(1, resources.size());    Resource res = resources.iterator().next();    Map<String, Object> properties = PropertyHelper.getProperties(resources.iterator().next());    Assert.assertNotNull(properties);    URIBuilder uriBuilder = AMSPropertyProvider.getAMSUriBuilder("localhost", 6188, false);    uriBuilder.addParameter("metricNames", "cpu_user");    uriBuilder.addParameter("hostname", "h1");    uriBuilder.addParameter("appId", "HOST");    uriBuilder.addParameter("startTime", "1416446744801");    uriBuilder.addParameter("endTime", "1416447224801");    Assert.assertEquals(uriBuilder.toString(), streamProvider.getLastSpec());    Number[][] val = (Number[][]) res.getPropertyValue(PROPERTY_ID1);    Assert.assertNotNull("No value for property " + PROPERTY_ID1, val);    // 4 entries fit into the default allowance limit    Assert.assertEquals(25, val.length);  }
@Test (description = "This test case tests whether the Pull Notification Subscriber is set correctly.")    public void testSetPullNotificationSubscriberConfig() throws InvocationTargetException, IllegalAccessException {        setPullNotificationSubscriber.invoke(androidDeviceTypeManagerService, androidDeviceConfiguration                .getPullNotificationSubscriberConfig());        Assert.assertEquals(androidDeviceTypeManagerService.getPullNotificationSubscriber() != null,                androidDeviceConfiguration.getPullNotificationSubscriberConfig() != null);        setPullNotificationSubscriber.invoke(rasberrypiDeviceTypeManagerService, rasberrypiDeviceConfiguration                .getPullNotificationSubscriberConfig());        Assert.assertEquals(rasberrypiDeviceTypeManagerService.getPullNotificationSubscriber() != null,                rasberrypiDeviceConfiguration.getPullNotificationSubscriberConfig() != null);    }
@Test    void loadProperties() {        final Properties properties = PropertiesUtil.loadProperties(LOGGER, file("test.properties"));        assertNotNull(properties);        assertEquals("1", properties.getProperty("a"));    }
@Test  public void testGetSettings_instance(){    Result result = new ResultImpl(true);    TreeNode<Resource> resultTree = createResultTreeSettingsObject(result.getResultTree());    ClusterBlueprintRenderer renderer = new TestBlueprintRenderer(topology);    Result blueprintResult = renderer.finalizeResult(result);    TreeNode<Resource> blueprintTree = blueprintResult.getResultTree();    TreeNode<Resource> blueprintNode = blueprintTree.getChildren().iterator().next();    Resource blueprintResource = blueprintNode.getObject();    Map<String, Map<String, Object>> propertiesMap = blueprintResource.getPropertiesMap();    Map<String,Object> children = propertiesMap.get("");    //Verify if required information is present in actual result    assertTrue(children.containsKey("settings"));    List<Map<String,Object>> settingValues = (ArrayList)children.get("settings");    Boolean isRecoverySettings = false;    Boolean isComponentSettings = false;    Boolean isServiceSettings = false;    //Verify actual values    for(Map<String,Object> settingProp : settingValues){      if(settingProp.containsKey("recovery_settings")){        isRecoverySettings = true;        HashSet<Map<String,String>> checkPropSize = (HashSet)settingProp.get("recovery_settings");        assertEquals(1,checkPropSize.size());        assertEquals("true",checkPropSize.iterator().next().get("recovery_enabled"));      }      if(settingProp.containsKey("component_settings")){        isComponentSettings = true;        HashSet<Map<String,String>> checkPropSize = (HashSet)settingProp.get("component_settings");        assertEquals(1,checkPropSize.size());        Map<String, String> finalProp = checkPropSize.iterator().next();        assertEquals("Component:1",finalProp.get("name"));        assertEquals("true",finalProp.get("recovery_enabled"));      }      if(settingProp.containsKey("service_settings")){        isServiceSettings = true;        HashSet<Map<String,String>> checkPropSize = (HashSet)settingProp.get("service_settings");        assertEquals(2,checkPropSize.size());        for(Map<String,String> finalProp : checkPropSize){          if(finalProp.containsKey("credential_store_enabled")){            assertEquals("Service:1",finalProp.get("name"));            assertEquals("true",finalProp.get("recovery_enabled"));          }          assertFalse(finalProp.get("name").equals("Service:3"));        }      }    }    //Verify if required information is present in actual result    assertTrue(isRecoverySettings);    assertTrue(isComponentSettings);    assertTrue(isServiceSettings);  }
@Test    public void testDeselectNotSelected() throws Exception {        mMonth.deselect(mToday);        assertFalse(mMonth.isSelected());    }
@Test    public void test_no_book() {        assertThat(calculator.price()).isEqualTo(0);    }
@Test    void testPartialRequestMismatch() {        SamplingRule rule = new SamplingRule()            .withAttributes(null)            .withHost("192.168.1.1")            .withServiceName("www.foo.com")            .withHTTPMethod("POST")            .withResourceARN("arn:aws:service:us-east-1:111111111111:resource")            .withURLPath("/bar/123")            .withServiceType("AWS::EC2::Instance");        SamplingRequest req = new SamplingRequest(            "role-arn",            "arn:aws:service:us-east-1:111111111111:resource",            "www.bar.com",            null,            "POST",            "/bar/123",            "AWS::EC2::Instance",            null        );        Matchers m = new Matchers(rule);        Assertions.assertFalse(m.match(req));    }
@Test    void get() {        final Holder<String> stringHolder = new Holder<>("value");        assertEquals("value", stringHolder.get());    }
@Test  public void testRevokeParentPrivilegeWithChildsExist() throws Exception {    String roleName = "r1";    /**     * grantor is admin, there is no need to check grant option     */    String grantor = ADMIN_USER;    PrivilegeObject updatePrivilege1 = new Builder()        .setComponent(SEARCH)        .setAction(SearchConstants.UPDATE)        .setService(SERVICE)        .setAuthorizables(Arrays.asList(new Collection(COLLECTION_NAME), new Field(FIELD_NAME)))        .build();    PrivilegeObject queryPrivilege1 = new Builder()        .setComponent(SEARCH)        .setAction(SearchConstants.QUERY)        .setService(SERVICE)        .setAuthorizables(Arrays.asList(new Collection(COLLECTION_NAME),new Field(FIELD_NAME)))        .build();    PrivilegeObject queryPrivilege2 = new Builder()        .setComponent(SEARCH)        .setAction(SearchConstants.QUERY)        .setService(SERVICE)        .setAuthorizables(Arrays.asList(new Collection(NOT_COLLECTION_NAME)))        .build();    sentryStore.createRole(SEARCH, roleName, grantor);    sentryStore.alterRoleGrantPrivilege(SEARCH, roleName, updatePrivilege1, grantor);    sentryStore.alterRoleGrantPrivilege(SEARCH, roleName, queryPrivilege1, grantor);    sentryStore.alterRoleGrantPrivilege(SEARCH, roleName, queryPrivilege2, grantor);    /**     * revoke all privilege with collection[COLLECTION_NAME=collection1] and its child privileges     */    PrivilegeObject allPrivilege = new Builder()        .setComponent(SEARCH)        .setAction(SearchConstants.ALL)        .setService(SERVICE)        .setAuthorizables(Arrays.asList(new Collection(COLLECTION_NAME)))        .build();    sentryStore.alterRoleRevokePrivilege(SEARCH, roleName, allPrivilege, grantor);    assertEquals(Sets.newHashSet(queryPrivilege2),        sentryStore.getPrivilegesByRole(SEARCH, Sets.newHashSet(roleName)));  }
@Test    public void givenThatActivityIsBoundToServce_whenActivityIsUnboundFromService_thenActivityIsUnbound() {        givenThatActivityIsAlreadyBoundtoService();        binder.unbindCustomTabsService(mockActivity);        verify(mockActivity).unbindService(any(ServiceConnection.class));    }
@Test    public void testPreparedStatementsAreReadOnlyModeAware() throws SQLException {        final ReadOnlyModeAwareConnection cnx = new ReadOnlyModeAwareConnection(mockedConnection, readOnlyModeStatus);        final String sql = "select * from whatever";        assertIsReadOnlyModeAware(cnx.prepareStatement(sql));        assertIsReadOnlyModeAware(cnx.prepareStatement(sql, 0));        assertIsReadOnlyModeAware(cnx.prepareStatement(sql, 0, 0));        assertIsReadOnlyModeAware(cnx.prepareStatement(sql, 0, 0, 0));        assertIsReadOnlyModeAware(cnx.prepareStatement(sql, new int[0]));        assertIsReadOnlyModeAware(cnx.prepareStatement(sql, new String[0]));    }
@Test	public void testFuzzyQuery() throws Exception {		SearchContext searchContext = getSearchContext();		searchContext.setKeywords("test~");		String cmisQuery = buildQuery(searchContext);		assertQueryEquals(			"(cmis:name LIKE 'test%' OR cmis:createdBy LIKE 'test%')",			cmisQuery);	}
@Test    public void testNamespacedEsriCollection()                            throws XMLStreamException {        InputStream in = FeatureInfoParserTest.class.getResourceAsStream( "esriwithnamespace.xml" );        XMLInputFactory fac = XMLInputFactory.newInstance();        XMLStreamReader xin = fac.createXMLStreamReader( in );        xin.next();        FeatureCollection fc = FeatureInfoParser.parseAsFeatureCollection( xin, "test" );        Assert.assertEquals( 8, fc.size() );    }
@Test    public void testEnumHasPriorityButSimpleOperatorDouble() throws Exception {        testEnumAndOperator(DataType.TYPE_NUMERIC_DOUBLE, "==");        verify(testedFactory).decoratedGridCellValueAdaptor(puddCaptor.capture());        assertTrue(puddCaptor.getValue() instanceof ProxyPopupNumericDoubleDropDownEditCell);    }
@Test	public void testOrderCustomWebFragments2() throws Exception {		List<WebXMLDefinition> webXMLDefinitions = new ArrayList<>();		webXMLDefinitions.add(			loadWebXMLDefinition("dependencies/custom-web-fragment-3.xml"));		webXMLDefinitions.add(			loadWebXMLDefinition("dependencies/custom-web-fragment-2.xml"));		webXMLDefinitions.add(			loadWebXMLDefinition("dependencies/custom-web-fragment-1.xml"));		WebXMLDefinition webXMLDefinition = loadWebXMLDefinition(			"dependencies/custom-web-absolute-ordering-2.xml");		List<WebXMLDefinition> orderedWebXMLDefinitions =			OrderUtil.getOrderedWebXMLDefinitions(				webXMLDefinitions, webXMLDefinition.getAbsoluteOrderingNames());		Assert.assertEquals(			orderedWebXMLDefinitions.toString(), 2,			orderedWebXMLDefinitions.size());		WebXMLDefinition firstWebXMLDefinition = orderedWebXMLDefinitions.get(			0);		Assert.assertEquals(			"fragment1", firstWebXMLDefinition.getFragmentName());		WebXMLDefinition secondWebXMLDefinition = orderedWebXMLDefinitions.get(			1);		Assert.assertEquals(			"fragment2", secondWebXMLDefinition.getFragmentName());	}
@Test    public void onEditTabSelected() {        scenarioSimulationEditorKogitoWrapperSpy.onEditTabSelected();        verify(scenarioSimulationEditorPresenterMock, times(1)).onEditTabSelected();    }
@Test	public void testProofCompleteness() throws Exception {		Assume.assumeFalse(TestUtils.ignore(manifest_.getInput(),				ElkTestUtils.TEST_INPUT_LOCATION, IGNORE_COMPLETENESS_LIST));		ProofTestUtils.proofCompletenessTest(prover_, query_,				adapter_.getGoal(), adapter_, new OwlInternalJustifier(), true);	}
@Test    public void given$show_whenQuery_thenShouldCallNativeApi() {        // given        PowerMockito.mockStatic(Instabug.class);        // when        rnModule.show();        // then        PowerMockito.verifyStatic(VerificationModeFactory.times(1));        Instabug.show();    }
@Test    public void testUpdate() throws VetoException {        final LimitedEntryBRLConditionColumn column = new LimitedEntryBRLConditionColumn();        column.setHeader("col1");        modelSynchronizer.appendColumn(column);        final LimitedEntryBRLConditionColumn edited = new LimitedEntryBRLConditionColumn();        edited.setHideColumn(true);        edited.setHeader("updated");        modelSynchronizer.updateColumn(column,                                       edited);        assertEquals(1,                     model.getConditions().size());        assertEquals(4,                     uiModel.getColumns().size());        assertTrue(uiModel.getColumns().get(3) instanceof BooleanUiColumn);        assertEquals("updated",                     uiModel.getColumns().get(3).getHeaderMetaData().get(0).getTitle());        assertEquals(false,                     uiModel.getColumns().get(3).isVisible());    }
@Test    public void testFileMd5SumEquals_SameFile() throws Exception {        Path path1 = Paths.get(FileDigestUtilTest.class.getResource("file1.txt").toURI());        Path path2 = Paths.get(FileDigestUtilTest.class.getResource("file1.txt").toURI());        byte[] digest1 = fileDigestUtil.getFileMd5Sum(path1);        byte[] digest2 = fileDigestUtil.getFileMd5Sum(path2);        assertTrue(Arrays.equals(digest1, digest2));    }
@Test    public void testSetSelectedValue() {        DefaultListModel model = new DefaultListModel();        model.addElement("One");        model.addElement("Two");        model.addElement("Three");        model.addElement("Four");        model.addElement("Five");        model.addElement("Six");        model.addElement("Seven");        JXList list = new JXList();        list.setAutoCreateRowSorter(true);        list.setModel(model);        list.setSelectedValue("Three", false);        assertEquals(2, list.getSelectedIndex());        list.setRowFilter(new RowFilter<ListModel, Integer>() {            @Override            public boolean include(Entry<? extends ListModel, ? extends Integer> entry) {                return entry.getStringValue(entry.getIdentifier()).contains("e");            }        });        assertEquals(1, list.getSelectedIndex());        list.setSelectedValue("Five", false);        assertEquals(2, list.getSelectedIndex());    }
@Test    void signByte() {        final ToByte<Byte> signByte = SignUtil.signByte(b -> b);        assertEquals(-1, signByte.applyAsByte((byte) -1));        assertEquals(0, signByte.applyAsByte((byte) 0));        assertEquals(1, signByte.applyAsByte((byte) 1));    }
@Test  public void testTokens_invalidLogicalOp() {    try {      new QueryLexer().tokens("foo=1<5=2");      fail("Expected InvalidQueryException due to invalid logical op");    } catch (InvalidQueryException e) {      //expected    }  }
@Test    public void test_parseLong_bytes() {        String str = "12345";        long result = NumberUtils.parseLong(str.getBytes(), 0L);        Assertions.assertEquals(12345L, result);    }
@Test  public void testGetPeriodsYearly() {    for (int i = 0; i < repetitions; i++) {      final Instant a = randomInstant();      final Instant b = randomInstant();      final Instant from = Ordering.natural().min(a, b);      final Instant to = Ordering.natural().max(a, b);      logger.info("from {} to {} {}", from, to, DataResolution.YEARLY.name());      final List<Tuple<Instant, Instant>> periods = InfluxStatisticsProvider.getPeriods(from, to, DataResolution.YEARLY,          ZoneId.of("Z"));      assertEquals(from, periods.get(0).getA());      if (periods.size() > 1) {        assertEquals(            LocalDateTime                .ofInstant(from, ZoneOffset.UTC)                .plusYears(1)                .withMonth(1)                .withDayOfMonth(1)                .withHour(0)                .withMinute(0)                .withSecond(0)                .withNano(0)                .minusNanos(1)                .toInstant(ZoneOffset.UTC),            periods.get(0).getB());      } else {        assertEquals(to, periods.get(0).getB());        continue;      }      assertEquals(to, periods.get(periods.size() - 1).getB());      assertEquals(LocalDateTime              .ofInstant(to, ZoneOffset.UTC)              .withMonth(1)              .withDayOfMonth(1)              .withHour(0)              .withMinute(0)              .withSecond(0)              .withNano(0)              .toInstant(ZoneOffset.UTC),          periods.get(periods.size() - 1).getA());    }  }
@Test	public void testCreateDDMExpression() throws Exception {		DDMExpressionFactoryImpl ddmExpressionFactoryImpl =			new DDMExpressionFactoryImpl();		ddmExpressionFactoryImpl.ddmExpressionFunctionTracker =			_ddmExpressionFunctionTracker;		when(			_ddmExpressionFunctionTracker.getDDMExpressionFunctionFactories(				Matchers.any())		).thenReturn(			HashMapBuilder.<String, DDMExpressionFunctionFactory>put(				"pow", () -> new PowFunction()			).build()		);		CreateExpressionRequest.Builder builder =			CreateExpressionRequest.Builder.newBuilder("pow(2,3)");		DDMExpression<BigDecimal> ddmExpression =			ddmExpressionFactoryImpl.createExpression(builder.build());		BigDecimal actual = ddmExpression.evaluate();		Assert.assertEquals(0, actual.compareTo(new BigDecimal(8)));	}
@Test	public void testAddFiles_1() throws Exception {		String jarDir = System.getProperty("user.home");		ClassPathHack.addFiles(jarDir);	}
@Test	public void testIsValidWithSameState() {		MockHttpServletRequest mockHttpServletRequest =			new MockHttpServletRequest();		String state = RandomTestUtil.randomString();		mockHttpServletRequest.setParameter("state", state);		OAuth2State oAuth2State = new OAuth2State(			RandomTestUtil.randomLong(), RandomTestUtil.randomString(),			RandomTestUtil.randomString(), state);		Assert.assertTrue(			OAuth2StateUtil.isValid(oAuth2State, mockHttpServletRequest));	}
@Test  public void testAddSessionAttributes() throws Exception {    Map<String, Object> attributes = new HashMap<String, Object>();    attributes.put("foo", "bar");    Cluster cluster = createMock(Cluster.class);    ClustersImpl clusters =        createMockBuilder(ClustersImpl.class).addMockedMethod("findCluster", String.class).createMock();    expect(clusters.findCluster("c1")).andReturn(cluster);    cluster.addSessionAttributes(attributes);    replay(clusters, cluster);    clusters.addSessionAttributes("c1", attributes);    verify(clusters, cluster);  }
@Test(expectedExceptions = NullPointerException.class)    public void testInTypeIteratorNull() {        EdgeStore edgeStore = new EdgeStore();        edgeStore.edgeInIterator(null, 0);    }
@Test	public void testComputeIfAbsent() {		try {			_concurrentMap.computeIfAbsent(null, null);			Assert.fail("Should throw NullPointerException");		}		catch (NullPointerException nullPointerException) {			Assert.assertEquals(				"Key is null", nullPointerException.getMessage());		}		try {			_concurrentMap.computeIfAbsent(_testKey, null);			Assert.fail("Should throw NullPointerException");		}		catch (NullPointerException nullPointerException) {			Assert.assertEquals(				"Mapping function is null", nullPointerException.getMessage());		}		Assert.assertNull(			_concurrentMap.computeIfAbsent(_testKey, key -> null));		_assertEventQueue(Event.MAP_KEY, Event.UNMAP_KEY);		Assert.assertSame(			_testValue1,			_concurrentMap.computeIfAbsent(_testKey, key -> _testValue1));		_assertEventQueue(Event.MAP_KEY, Event.MAP_VALUE);		Assert.assertSame(			_testValue1,			_concurrentMap.computeIfAbsent(_testKey, key -> _testValue2));		_assertEventQueue(			Event.MAP_KEY, Event.UNMAP_KEY, Event.UNMAP_VALUE_FOR_QUERY);		Assert.assertSame(_testValue1, _concurrentMap.get(_testKey));		_assertEventQueue(Event.MAP_KEY_FOR_QUERY, Event.UNMAP_VALUE_FOR_QUERY);		ConcurrentMap<KeyReference, ValueReference> innerConcurrentMap =			ReflectionTestUtil.getFieldValue(				_concurrentMap, "innerConcurrentMap");		Assert.assertEquals(			innerConcurrentMap.toString(), 1, innerConcurrentMap.size());		Collection<ValueReference> valueReferences =			innerConcurrentMap.values();		Iterator<ValueReference> iterator = valueReferences.iterator();		ValueReference valueReference = iterator.next();		ReflectionTestUtil.setFieldValue(valueReference, "_value", null);		Assert.assertSame(			_testValue2,			_concurrentMap.computeIfAbsent(_testKey, key -> _testValue2));		_assertEventQueue(			Event.MAP_KEY, Event.UNMAP_KEY, Event.UNMAP_VALUE_FOR_QUERY,			Event.MAP_KEY, Event.MAP_VALUE);	}
@Test	public void testWriteBlock() throws IOException {		byte[] expectedBytes = new byte[1];		AtomicBoolean writeCalled = new AtomicBoolean();		UnsyncFilterOutputStream unsyncFilterOutputStream =			new UnsyncFilterOutputStream(				new TestOutputStream() {					@Override					public void write(byte[] bytes, int offset, int length) {						Assert.assertSame(expectedBytes, bytes);						Assert.assertEquals(0, offset);						Assert.assertEquals(1, length);						writeCalled.set(true);					}				});		unsyncFilterOutputStream.write(expectedBytes);		Assert.assertTrue(writeCalled.get());	}
@Test    void get8() {        assertEquals(m8, instance.get8());    }
@Test  public void testSetterInt() throws Exception  {    int intVal = innerObj.intVal;    PojoUtils.createSetterInt(fqcn, "innerObj.intVal").set(testObj, ++intVal);    assertEquals(intVal, innerObj.intVal);    createSetterInt(innerObjClass, "intVal").set(innerObj, ++intVal);    assertEquals(intVal, innerObj.intVal);    createSetterInt(innerObjClass, "protectedIntVal").set(innerObj, ++intVal);    assertEquals(intVal, innerObj.protectedIntVal);    createSetterInt(innerObjClass, "privateIntVal").set(innerObj, ++intVal);    assertEquals(intVal, innerObj.getPrivateIntVal());  }
@Test  public void testParse_FilterOp_exception() throws Exception {    List<Token> listTokens = new ArrayList<Token>();    listTokens.add(new Token(Token.TYPE.RELATIONAL_OPERATOR_FUNC, ".matches("));    listTokens.add(new Token(Token.TYPE.PROPERTY_OPERAND, "foo"));    listTokens.add(new Token(Token.TYPE.BRACKET_CLOSE, ")"));    QueryParser parser = new QueryParser();    try {      Predicate p = parser.parse(listTokens.toArray(new Token[listTokens.size()]));      fail("Filter operator is missing a required right operand.");    } catch (InvalidQueryException e) {      // expected    }  }
@Test  public void testConvertRequestWithLimit() throws Exception {    FactSearchCriteria criteria = converter.apply(new SearchFactRequest().setLimit(123));    assertEquals(123, criteria.getLimit());  }
@Test  public void testRegularHandlerForCallDataElementHandlers() throws KlvDecodingException {    stanag4609Processor.callDataElementHandlers(        Collections.singletonMap(FIELD_NAME, klvHandler),        defaultKlvHandler,        klvIntegerEncodedFloatingPoint,        dataElements);    verify(klvHandler, atLeastOnce()).accept(klvIntegerEncodedFloatingPoint);  }
@Test	public void testSplitDefinitions() {		addWorkflowDefinition(true);		addWorkflowDefinition(false);		List<ResultRowSplitterEntry> resultRowSplitterEntryList =			_resultRowSplitter.split(_resultRows);		Assert.assertEquals(			resultRowSplitterEntryList.toString(), 2,			resultRowSplitterEntryList.size());		ResultRowSplitterEntry resultRowSplitterEntry =			resultRowSplitterEntryList.get(0);		Assert.assertEquals("published", resultRowSplitterEntry.getTitle());		List<ResultRow> resultRows = resultRowSplitterEntry.getResultRows();		Assert.assertEquals(resultRows.toString(), 1, resultRows.size());		resultRowSplitterEntry = resultRowSplitterEntryList.get(1);		Assert.assertEquals("not-published", resultRowSplitterEntry.getTitle());		resultRows = resultRowSplitterEntry.getResultRows();		Assert.assertEquals(resultRows.toString(), 1, resultRows.size());	}
@Test    public void testGetIndexWithDefaultSelectFirstOption() throws Exception {        assertEquals(1,                     DecisionTableColumnViewUtils.getCurrentIndexFromList(FIRST_OPTION,                                                                          listBox));    }
@Test	public void testInvalidExpression1() throws Exception {		Boolean result = (Boolean)_allFunction.apply("#invalid# > 10", 11);		Assert.assertFalse(result);	}
@Test    public void setRuleCheatSheetContent() {        cheatSheetView.setRuleCheatSheetContent();        verify(ruleCheatSheetStyleMock, times(1)).setDisplay(Style.Display.BLOCK);        verify(dmnCheatSheetStyleMock, times(1)).setDisplay(Style.Display.NONE);    }
@Test(expected = RuntimeException.class)    public void testLocalizedSamplingStrategyWithOneRuleMissingAttributesThrowsRuntimeException() {        URL emptySamplingRules = LocalizedSamplingStrategyTest.class.getResource(            "/com/amazonaws/xray/strategy/sampling/OneRuleMissingAttributesSamplingRules.json");        LocalizedSamplingStrategy localizedSamplingStrategy = new LocalizedSamplingStrategy(emptySamplingRules);        SamplingRequest samplingRequest = new SamplingRequest("", "test", "/test", "test", "");        SamplingResponse sr = localizedSamplingStrategy.shouldTrace(samplingRequest);        Assert.assertFalse(sr.isSampled());    }
@Test    public void testCanSetupDefaultValueWhenEditingPatternIsNull() throws Exception {        when(plugin.patternWrapper()).thenReturn(null);        assertFalse(page.canSetupDefaultValue());    }
@Test    public void moveStickLeftAscendant() {        for (MotionEvent me : mLeftAsc) {            mTranslator.handle(me);        }        assertTrue("Event is not null", mLastKeyEvent != null);        assertTrue("Event should be produced when moving in ascendant direction", mLastKeyEvent.getKeyCode() == KeyEvent.KEYCODE_DPAD_LEFT);    }
@Test    public void testTheNumberOfScannedFunctions() {        sourceFile = ApexAstScanner.scanFile(new File("src/test/resources/metrics/methods.cls"));        assertThat(sourceFile.getInt(ApexMetric.METHODS)).isEqualTo(2);    }
@Test	public void testWriteConfValue_2() throws Exception {		String propertyName = "0123456789";		String propertyValue = "0123456789";		boolean result = xmlManipulator.writeConfValue(filePath, propertyName,				propertyValue);		assertEquals(true, result);	}
@Test  public void testRequestAbortsOnlyWhenNoQueuedTaskAndSuccessFactorUnmet() throws Exception {    ActionQueue aq = new ActionQueue();    Clusters fsm = mock(Clusters.class);    Cluster oneClusterMock = mock(Cluster.class);    Service serviceObj = mock(Service.class);    ServiceComponent scomp = mock(ServiceComponent.class);    ServiceComponentHost sch = mock(ServiceComponentHost.class);    UnitOfWork unitOfWork = mock(UnitOfWork.class);    when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);    when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);    when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);    when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);    when(serviceObj.getCluster()).thenReturn(oneClusterMock);    String host1 = "host1";    String host2 = "host2";    Host host = mock(Host.class);    HashMap<String, ServiceComponentHost> hosts =            new HashMap<String, ServiceComponentHost>();    hosts.put(host1, sch);    hosts.put(host2, sch);    when(scomp.getServiceComponentHosts()).thenReturn(hosts);    when(fsm.getHost(anyString())).thenReturn(host);    when(host.getState()).thenReturn(HostState.HEALTHY);    when(host.getHostName()).thenReturn(host1);    HostEntity hostEntity1 = new HostEntity();    HostEntity hostEntity2 = new HostEntity();    hostEntity1.setHostName(host1);    hostEntity2.setHostName(host2);    hostDAO.create(hostEntity1);    hostDAO.create(hostEntity2);    final List<Stage> stages = new ArrayList<Stage>();    long now = System.currentTimeMillis();    Stage stage = stageFactory.createNew(1, "/tmp", "cluster1", 1L,        "testRequestFailureBasedOnSuccessFactor", CLUSTER_HOST_INFO, "", "");    stage.setStageId(1);    addHostRoleExecutionCommand(now, stage, Role.SQOOP, Service.Type.SQOOP,        RoleCommand.INSTALL, host1, "cluster1");    addHostRoleExecutionCommand(now, stage, Role.OOZIE_CLIENT, Service.Type.OOZIE,        RoleCommand.INSTALL, host1, "cluster1");    addHostRoleExecutionCommand(now, stage, Role.MAPREDUCE_CLIENT, Service.Type.MAPREDUCE,        RoleCommand.INSTALL, host1, "cluster1");    addHostRoleExecutionCommand(now, stage, Role.HBASE_CLIENT, Service.Type.HBASE,        RoleCommand.INSTALL, host1, "cluster1");    addHostRoleExecutionCommand(now, stage, Role.GANGLIA_MONITOR, Service.Type.GANGLIA,        RoleCommand.INSTALL, host1, "cluster1");    addHostRoleExecutionCommand(now, stage, Role.HBASE_CLIENT, Service.Type.HBASE,        RoleCommand.INSTALL, host2, "cluster1");    addHostRoleExecutionCommand(now, stage, Role.GANGLIA_MONITOR, Service.Type.GANGLIA,        RoleCommand.INSTALL, host2, "cluster1");    stages.add(stage);    HostRoleStatus[] statusesAtIterOne = {HostRoleStatus.QUEUED, HostRoleStatus.QUEUED,        HostRoleStatus.QUEUED, HostRoleStatus.QUEUED, HostRoleStatus.FAILED,        HostRoleStatus.FAILED, HostRoleStatus.QUEUED, HostRoleStatus.QUEUED};    for (int index = 0; index < stage.getOrderedHostRoleCommands().size(); index++) {      stage.getOrderedHostRoleCommands().get(index).setTaskId(index + 1);      stage.getOrderedHostRoleCommands().get(index).setStatus(statusesAtIterOne[index]);    }    stage.setLastAttemptTime(host1, Role.SQOOP.toString(), now);    stage.setLastAttemptTime(host1, Role.MAPREDUCE_CLIENT.toString(), now);    stage.setLastAttemptTime(host1, Role.OOZIE_CLIENT.toString(), now);    stage.setLastAttemptTime(host1, Role.GANGLIA_MONITOR.toString(), now);    stage.setLastAttemptTime(host1, Role.HBASE_CLIENT.toString(), now);    stage.setLastAttemptTime(host2, Role.GANGLIA_MONITOR.toString(), now);    stage.setLastAttemptTime(host2, Role.HBASE_CLIENT.toString(), now);    ActionDBAccessor db = mock(ActionDBAccessor.class);    HostRoleCommandDAO hostRoleCommandDAOMock = mock(HostRoleCommandDAO.class);    Mockito.doNothing().when(hostRoleCommandDAOMock).publishTaskCreateEvent(anyListOf(HostRoleCommand.class));    RequestEntity request = mock(RequestEntity.class);    when(request.isExclusive()).thenReturn(false);    when(db.getRequestEntity(anyLong())).thenReturn(request);    when(db.getCommandsInProgressCount()).thenReturn(stages.size());    when(db.getStagesInProgress()).thenReturn(stages);    doAnswer(new Answer<Void>() {      @Override      public Void answer(InvocationOnMock invocation) throws Throwable {        String host = (String) invocation.getArguments()[0];        Long requestId = (Long) invocation.getArguments()[1];        Long stageId = (Long) invocation.getArguments()[2];        String role = (String) invocation.getArguments()[3];        CommandReport commandReport = (CommandReport) invocation.getArguments()[4];        for (Stage stage : stages) {          if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {            HostRoleCommand command = stage.getHostRoleCommand(host, role);            command.setStatus(HostRoleStatus.valueOf(commandReport.getStatus()));          }        }        return null;      }    }).when(db).updateHostRoleState(anyString(), anyLong(), anyLong(), anyString(), any(CommandReport.class));    when(db.getTask(anyLong())).thenAnswer(new Answer<Object>() {      @Override      public Object answer(InvocationOnMock invocation) throws Throwable {        Long taskId = (Long) invocation.getArguments()[0];        for (Stage stage : stages) {          for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {            if (taskId.equals(command.getTaskId())) {              return command;            }          }        }        return null;      }    });    doAnswer(new Answer<Collection<HostRoleCommandEntity>>() {      @Override      public Collection<HostRoleCommandEntity> answer(InvocationOnMock invocation) throws Throwable {        Long requestId = (Long) invocation.getArguments()[0];        List<HostRoleCommandEntity> abortedCommands = Lists.newArrayList();        for (Stage stage : stages) {          if (requestId.equals(stage.getRequestId())) {            for (HostRoleCommand command : stage.getOrderedHostRoleCommands()) {              if (command.getStatus() == HostRoleStatus.QUEUED ||                  command.getStatus() == HostRoleStatus.IN_PROGRESS ||                  command.getStatus() == HostRoleStatus.PENDING) {                command.setStatus(HostRoleStatus.ABORTED);                HostRoleCommandEntity hostRoleCommandEntity = command.constructNewPersistenceEntity();                hostRoleCommandEntity.setStage(stage.constructNewPersistenceEntity());                abortedCommands.add(hostRoleCommandEntity);              }            }          }        }        return abortedCommands;      }    }).when(db).abortOperation(anyLong());    Properties properties = new Properties();    Configuration conf = new Configuration(properties);    ActionScheduler scheduler = new ActionScheduler(100, 10000, db, aq, fsm, 3,        new HostsMap((String) null),        unitOfWork, null, conf, entityManagerProviderMock,        hostRoleCommandDAOMock, (HostRoleCommandFactory)null);    scheduler.doWork();    // Request is not aborted because all roles are in progress    HostRoleStatus[] expectedStatusesAtIterOne = {HostRoleStatus.QUEUED, HostRoleStatus.QUEUED,        HostRoleStatus.QUEUED, HostRoleStatus.QUEUED, HostRoleStatus.FAILED,        HostRoleStatus.FAILED, HostRoleStatus.QUEUED, HostRoleStatus.QUEUED};    for (int index = 0; index < stage.getOrderedHostRoleCommands().size(); index++) {      log.info(stage.getOrderedHostRoleCommands().get(index).toString());      Assert.assertEquals(expectedStatusesAtIterOne[index],          stage.getOrderedHostRoleCommands().get(index).getStatus());    }    HostRoleStatus[] statusesAtIterTwo = {HostRoleStatus.QUEUED, HostRoleStatus.QUEUED,        HostRoleStatus.QUEUED, HostRoleStatus.QUEUED, HostRoleStatus.FAILED,        HostRoleStatus.FAILED, HostRoleStatus.QUEUED, HostRoleStatus.COMPLETED};    for (int index = 0; index < stage.getOrderedHostRoleCommands().size(); index++) {      stage.getOrderedHostRoleCommands().get(index).setStatus(statusesAtIterTwo[index]);    }    scheduler.doWork();    // Request is not aborted because GANGLIA_MONITOR's success factor (0.5) is met    HostRoleStatus[] expectedStatusesAtIterTwo = {HostRoleStatus.QUEUED, HostRoleStatus.QUEUED,        HostRoleStatus.QUEUED, HostRoleStatus.QUEUED, HostRoleStatus.FAILED,        HostRoleStatus.FAILED, HostRoleStatus.QUEUED, HostRoleStatus.COMPLETED};    for (int index = 0; index < stage.getOrderedHostRoleCommands().size(); index++) {      log.info(stage.getOrderedHostRoleCommands().get(index).toString());      Assert.assertEquals(expectedStatusesAtIterTwo[index],          stage.getOrderedHostRoleCommands().get(index).getStatus());    }    HostRoleStatus[] statusesAtIterThree = {HostRoleStatus.QUEUED, HostRoleStatus.QUEUED,        HostRoleStatus.QUEUED, HostRoleStatus.QUEUED, HostRoleStatus.FAILED,        HostRoleStatus.FAILED, HostRoleStatus.FAILED, HostRoleStatus.COMPLETED};    for (int index = 0; index < stage.getOrderedHostRoleCommands().size(); index++) {      stage.getOrderedHostRoleCommands().get(index).setStatus(statusesAtIterThree[index]);    }    // Fails becuse HostRoleCommand doesn't have a hostName    scheduler.doWork();    // Request is aborted because HBASE_CLIENT's success factor (1) is not met    HostRoleStatus[] expectedStatusesAtIterThree = {HostRoleStatus.ABORTED, HostRoleStatus.ABORTED,        HostRoleStatus.ABORTED, HostRoleStatus.ABORTED, HostRoleStatus.FAILED,        HostRoleStatus.FAILED, HostRoleStatus.FAILED, HostRoleStatus.COMPLETED};    for (int index = 0; index < stage.getOrderedHostRoleCommands().size(); index++) {      log.info(stage.getOrderedHostRoleCommands().get(index).toString());      Assert.assertEquals(expectedStatusesAtIterThree[index],          stage.getOrderedHostRoleCommands().get(index).getStatus());    }  }
@Test  public void testConvertFactObjectBindingDefinitionsWithoutBindings() {    assertNull(helper.convertFactObjectBindingDefinitions(null));    assertNull(helper.convertFactObjectBindingDefinitions(ListUtils.list()));  }
@Test  public void testValidateConfig() throws Exception {    ViewArchiveUtility utility = new ViewArchiveUtility();    InputStream configStream = getClass().getClassLoader().getResourceAsStream("test_view.xml");    utility.validateConfig(configStream);  }
@Test    public void testSetDelay() throws Exception {        float delay = 20;        mViewHolder.setDelay(delay);        assertEquals(delay, mViewHolder.getDelay(), 0);    }
@Test  public void testContribute() throws Exception {    Addon addon = new Addon();    LookAndFeelAddons.contribute(addon);    // a ComponentAddon is initialized when it is contributed    assertTrue(addon.initialized);    // and uninitialized when "uncontributed"    LookAndFeelAddons.uncontribute(addon);    assertTrue(addon.uninitialized);    // re-contribute the ComponentAddon    LookAndFeelAddons.contribute(addon);    // reset its state    addon.initialized = false;    addon.uninitialized = false;    // when addon is changed, the ComponentAddon is uninitialized with the    // previous addon, then initialized with the new    LookAndFeelAddons oldLFAddon = LookAndFeelAddons.getAddon();    LookAndFeelAddons.setAddon(MetalLookAndFeelAddons.class);    LookAndFeelAddons newLFAddon = LookAndFeelAddons.getAddon();    assertTrue(addon.uninitialized);    assertEquals(oldLFAddon, addon.uninitializedWith);    assertTrue(addon.initialized);    assertEquals(newLFAddon, addon.initializedWith);  }
@Test	public void testFilterAllIncludeInactive() {		WorkflowDefinitionActivePredicate predicate =			new WorkflowDefinitionActivePredicate(WorkflowConstants.STATUS_ANY);		WorkflowDefinition workflowDefinition = new WorkflowDefinitionImpl(			false);		boolean result = predicate.test(workflowDefinition);		Assert.assertTrue(result);	}
@Test    public void errorsWhenLowerGreaterThanUpper() {        this.thrown.expect(IllegalArgumentException.class);        final DecimalRandom rand = new DecimalRandom(            DecimalRandomTest.MIN, DecimalRandomTest.MAX        );        final Double value = DecimalRandomTest.random();        rand.between(value, value - 1);    }
@Test    public void testCreateElementWithRefTo() throws Exception {        // Receipt with RefToMessageId        Receipt receipt = new Receipt();        receipt.setMessageId(UUID.randomUUID().toString());        receipt.setTimestamp(new Date());        receipt.setRefToMessageId(UUID.randomUUID().toString());    	OMElement miElement = MessageInfoElement.createElement(createParent(), receipt);    	    	assertNotNull(miElement);    	assertEquals(MESSAGE_INFO_ELEMENT_NAME, miElement.getQName());    	    	Iterator<OMElement> msgIdElems = miElement.getChildrenWithName(MESSAGE_ID_ELEMENT_NAME);    	assertFalse(Utils.isNullOrEmpty(msgIdElems));    	assertEquals(receipt.getMessageId(), msgIdElems.next().getText());    	Iterator<OMElement> timestampElems = miElement.getChildrenWithName(TIMESTAMP_ELEMENT_NAME);    	assertFalse(Utils.isNullOrEmpty(timestampElems));    	    	assertEquals(Utils.toXMLDateTime(receipt.getTimestamp()), timestampElems.next().getText());    	Iterator<OMElement> refToElems = miElement.getChildrenWithName(REF_TO_MESSAGE_ID_ELEMENT_NAME);    	assertFalse(Utils.isNullOrEmpty(refToElems));    	    	assertEquals(receipt.getRefToMessageId(), refToElems.next().getText());    }
@Test    public void testContains() {        assertThat(new VersionRange(range).contains(testVersion), equalTo(contains));    }
@Test  public void testGetIcon64() throws Exception {    ViewConfig config = getConfig();    Assert.assertEquals("/this/is/the/icon/url/icon64.png", config.getIcon64());  }
@Test    public void testGetObjectByIdGeometry1() {        Object o = store.getObjectById( "MULTIPOLYGON_1" );        Assert.assertTrue( o instanceof Geometry );    }
@Test    void testRequireInRange2() {        assertThrows(RuntimeException.class, () -> IntRangeUtil.requireInRange(-1,0,1, RuntimeException::new));    }
@Test    public void testCastp() throws Exception {        //given        final byte b0 = (byte) 0x8F;        final byte b1 = 0x7F;        final byte b2 = (byte) 0xF7;        final byte b3 = 0x00;        final byte b4 = 0x01;        final long pointer = byteArrayAsPointer(b0,                                                b1,                                                b2,                                                b3,                                                b4);        try (final Pointer<Void> voidPointer = wrap(pointer)) {            //when            final Pointer<Integer> integerPointer = voidPointer.castp(int.class);            //then            assertThat(integerPointer.get()).isEqualTo(0x00F77F8F);//b3+b2+b1+b0 (little endian)        }    }
@Test  public void testFindByService() {    List<AlertDefinitionEntity> definitions = dao.findByService(clusterId,        "HDFS");    assertNotNull(definitions);    assertEquals(10, definitions.size());    definitions = dao.findByService(clusterId, "YARN");    assertNotNull(definitions);    assertEquals(0, definitions.size());  }
@Test	public void testEquals() {		GroupUrlTitleInfoItemIdentifier groupUrlTitleInfoItemIdentifier1 =			new GroupUrlTitleInfoItemIdentifier(12345L, "urlTitle");		GroupUrlTitleInfoItemIdentifier groupUrlTitleInfoItemIdentifier2 =			new GroupUrlTitleInfoItemIdentifier(12345L, "urlTitle");		Assert.assertEquals(			groupUrlTitleInfoItemIdentifier1, groupUrlTitleInfoItemIdentifier2);	}
@Test  public void testGetJobLoad() throws Exception {    assertEquals((Float) 1.5F, job.getJobLoad());  }
@Test    public void expandEndIndeterminatePeriodNormal() {        expectedException.expect( IllegalArgumentException.class );        expectedException.expectMessage( "ExpandEndIndeterminate requires a time instant or a time period with indeterminate end" );        ad.evaluate( period( "00:00:02", "00:00:03" ) );    }
@Test    void get16() {        assertEquals(m16, instance.get16());    }
@Test    void construct() {        final GenericImpl generic = new GenericImpl("T");        assertEquals("T", generic.getLowerBound().orElseThrow(NoSuchElementException::new));    }
@Test  public void testFindConflictingEvents() throws Exception {    final long currentTime = System.currentTimeMillis();    final MediaPackage mediaPackageA = generateEvent(Opt.<String> none());    final MediaPackage mediaPackageB = generateEvent(Opt.<String> none());    final MediaPackage mediaPackageC = generateEvent(Opt.<String> none());    final MediaPackage mediaPackageD = generateEvent(Opt.<String> none());    //    schedSvc.addEvent(new Date(currentTime + seconds(10)), new Date(currentTime + hours(1) + seconds(10)), "Device A",            Collections.<String> emptySet(), mediaPackageA, wfProperties, Collections.<String, String> emptyMap(),            Opt.<String> none());    schedSvc.addEvent(new Date(currentTime + hours(24)), new Date(currentTime + hours(25)), "Device A",            Collections.<String> emptySet(), mediaPackageB, wfProperties, Collections.<String, String> emptyMap(),            Opt.<String> none());    schedSvc.addEvent(new Date(currentTime - hours(1)), new Date(currentTime - minutes(10)), "Device C",            Collections.<String> emptySet(), mediaPackageC, wfProperties, Collections.<String, String> emptyMap(),            Opt.<String> none());    schedSvc.addEvent(new Date(currentTime + seconds(10)), new Date(currentTime + hours(1) + seconds(10)), "Device D",            Collections.<String> emptySet(), mediaPackageD, wfProperties, Collections.<String, String> emptyMap(),            Opt.<String> none());    {      List<MediaPackage> allEvents = schedSvc.search(Opt.<String> none(), Opt.<Date> none(), Opt.<Date> none(),              Opt.<Date> none(), Opt.<Date> none());      assertEquals(4, allEvents.size());    }    final Date start = new Date(currentTime);    final Date end = new Date(currentTime + hours(2));    {      List<MediaPackage> events = schedSvc.search(Opt.some("Some Other Device"), Opt.some(start), Opt.<Date> none(),              Opt.<Date> none(), Opt.some(end));      assertEquals(0, events.size());    }    {      List<MediaPackage> events = schedSvc.search(Opt.some("Device A"), Opt.some(start), Opt.<Date> none(),              Opt.<Date> none(), Opt.some(end));      assertEquals(1, events.size());    }    {      ZonedDateTime startZdt = ZonedDateTime.ofInstant(start.toInstant(), ZoneOffset.UTC);      List<MediaPackage> events = schedSvc.findConflictingEvents("Device A",              new RRule("FREQ=WEEKLY;BYDAY=SU,MO,TU,WE,TH,FR,SA;BYHOUR=" + startZdt.getHour() + ";BYMINUTE=" + startZdt.getMinute()), start, new Date(start.getTime() + hours(48)),              new Long(seconds(36)), TimeZone.getTimeZone("America/Chicago"));      assertEquals(2, events.size());    }    {      // No events are contained in the RRule and date range: 2019-02-16T16:00:00Z to 2019-02-16T16:55:00Z, FREQ=WEEKLY;BYDAY=WE;BYHOUR=16;BYMINUTE=0      List<MediaPackage> conflicts = schedSvc.findConflictingEvents("Device A",              new RRule("FREQ=WEEKLY;BYDAY=WE;BYHOUR=16;BYMINUTE=0"), new Date(1550332800000L), new Date(1550336100000L), 1000, TimeZone.getTimeZone("Africa/Johannesburg"));      assertEquals(0, conflicts.size());    }    {      //Event A starts before event B, and ends during event B      List<MediaPackage> conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(23) + minutes(30)), new Date(currentTime + hours(24) + minutes(30)));      assertEquals(1, conflicts.size());      //Event A starts during event B, and ends after event B      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(24) + minutes(30)), new Date(currentTime + hours(25) + minutes(30)));      assertEquals(1, conflicts.size());      //Event A starts at the same time as event B      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(24)), new Date(currentTime + hours(24) + minutes(30)));      assertEquals(1, conflicts.size());      //Event A ends at the same time as event B      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(24) + minutes(10)), new Date(currentTime + hours(25)));      assertEquals(1, conflicts.size());      //Event A is contained entirely within event B      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(24) + minutes(10)), new Date(currentTime + hours(24) + minutes(50)));      assertEquals(1, conflicts.size());      //Event A contains event B entirely      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(23)), new Date(currentTime + hours(26)));      assertEquals(1, conflicts.size());      //Event A ends with less than one minute before event B starts      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(23)), new Date(currentTime + hours(24) - seconds(1)));      assertEquals(1, conflicts.size());      //Event A begins than one minute after event B ends      conflicts = schedSvc.findConflictingEvents("Device A", new Date(currentTime + hours(25) + seconds(1)), new Date(currentTime + hours(27)));      assertEquals(1, conflicts.size());    }  }
@Test	public void testBuildPATCHEndpointMetadataKeys() {		MetadataKeysBuilder metadataKeysBuilder = new MetadataKeysBuilder();		Set<String> metadataKeyIds = toMetadataKeyIdSet(			metadataKeysBuilder.getMetadataKeys(				openAPISpecJsonNode, OASConstants.OPERATION_PATCH));		Assert.assertTrue(			metadataKeyIds.contains("/endpoint/with/get/and/patch/operation"));	}
@Test    void get5Test() {        assertEquals(5, (int) instance.get5());    }
@Test    public void testsetFloat() throws Exception {        //given        final float f0 = 0x45678901;        final float f1 = 0x12345678;        final Pointer<Float> floatPointer = Pointer.nref(f0,                                                         f1);        //then        assertThat(JNITestUtil.getFloat(floatPointer.address)).isEqualTo(f0);        assertThat(JNITestUtil.getFloat(floatPointer.address + 4)).isEqualTo(f1);    }
@Test    public void createSettings() {        final String dmnFilePath = "test";        final Path pathMock = mock(Path.class);        final Settings retrieved = dmnSimulationCreationStrategy.createSettings(pathMock, dmnFilePath);        assertNotNull(retrieved);        assertEquals(ScenarioSimulationModel.Type.DMN, retrieved.getType());        assertEquals(dmnFilePath, retrieved.getDmnFilePath());    }
@Test  public void testGetClientHostForRunningAction_componentMapIsEmpty() throws Exception {    Injector injector = createNiceMock(Injector.class);    Cluster cluster = createNiceMock(Cluster.class);    Service service = createNiceMock(Service.class);    ServiceComponent component = createNiceMock(ServiceComponent.class);    Map<String, ServiceComponentHost> hostMap = new HashMap<String, ServiceComponentHost>();    expect(component.getServiceComponentHosts()).andReturn(hostMap);    replay(cluster, service, component, injector);    AmbariManagementControllerImpl controller = new AmbariManagementControllerImpl(null, clusters, injector);    String host = controller.getClientHostForRunningAction(cluster, service, component);    verify(cluster, service, component, injector);    assertNull(host);  }
@Test    public void shouldValidateSuccessfully() throws Exception {        EnumListValidator enumListValidator = createAndInitializeValidator(false, false);        boolean valid = enumListValidator.isValid(Arrays.asList("foo", "bar"), createContext());        assertThat(valid, is(true));    }
@Test  public void testGetQuery() throws Exception {    String createTableQuery = "CREATE TABLE `d1`.`t2` (`col_name1` string COMMENT 'col_name1 comment'," +      "`col_name2` decimal(10,2) COMMENT 'col_name2 comment')  PARTITIONED BY ( `col_name4` char(1) COMMENT 'col_name4 comment'," +      "`col_name3` string COMMENT 'col_name3 comment') CLUSTERED BY (col_name1, col_name2) SORTED BY (col_name1 ASC,col_name2 DESC)" +      " INTO 5 BUCKETS  ROW FORMAT DELIMITED  FIELDS TERMINATED BY ',' ESCAPED BY '\\\\' STORED AS  INPUTFORMAT " +      "'org.apache.hadoop.mapred.SequenceFileInputFormat' OUTPUTFORMAT 'org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat' " +      "LOCATION 'hdfs://c6401.ambari.apache.org:8020/user/hive/tables/d1/t1' TBLPROPERTIES ('immutable'='false'," +      "'orc.compress'='SNAPPY','transient_lastDdlTime'='1481520077','NO_AUTO_COMPACTION'='true','comment'='table t1 comment'," +      "'SORTBUCKETCOLSPREFIX'='TRUE')";    String json = "{\n" +      "\t\"id\": \"d1/t2\",\n" +      "\t\"database\": \"d1\",\n" +      "\t\"table\": \"t2\",\n" +      "\t\"columns\": [{\n" +      "\t\t\"name\": \"col_name1\",\n" +      "\t\t\"type\": \"string\",\n" +      "\t\t\"comment\": \"col_name1 comment\"\n" +      "\t}, {\n" +      "\t\t\"name\": \"col_name2\",\n" +      "\t\t\"type\": \"decimal(10,2)\",\n" +      "\t\t\"comment\": \"col_name2 comment\"\n" +      "\t}],\n" +      "\t\"partitionInfo\": {\n" +      "\t\t\"columns\": [{\n" +      "\t\t\t\"name\": \"col_name4\",\n" +      "\t\t\t\"type\": \"char(1)\",\n" +      "\t\t\t\"comment\": \"col_name4 comment\"\n" +      "\t\t}, {\n" +      "\t\t\t\"name\": \"col_name3\",\n" +      "\t\t\t\"type\": \"string\",\n" +      "\t\t\t\"comment\": \"col_name3 comment\"\n" +      "\t\t}]\n" +      "\t},\n" +      "\t\"detailedInfo\": {\n" +      "\t\t\"dbName\": \"d1\",\n" +      "\t\t\"owner\": \"admin\",\n" +      "\t\t\"createTime\": \"Mon Dec 12 05:21:17 UTC 2016\",\n" +      "\t\t\"lastAccessTime\": \"UNKNOWN\",\n" +      "\t\t\"retention\": \"0\",\n" +      "\t\t\"tableType\": \"MANAGED_TABLE\",\n" +      "\t\t\"location\": \"hdfs://c6401.ambari.apache.org:8020/user/hive/tables/d1/t1\",\n" +      "\t\t\"parameters\": {\n" +      "\t\t\t\"immutable\": \"false\",\n" +      "\t\t\t\"orc.compress\": \"SNAPPY\",\n" +      "\t\t\t\"transient_lastDdlTime\": \"1481520077\",\n" +      "\t\t\t\"NO_AUTO_COMPACTION\": \"true\",\n" +      "\t\t\t\"comment\": \"table t1 comment\",\n" +      "\t\t\t\"SORTBUCKETCOLSPREFIX\": \"TRUE\"\n" +      "\t\t}\n" +      "\t},\n" +      "\t\"storageInfo\": {\n" +      "\t\t\"serdeLibrary\": \"org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\",\n" +      "\t\t\"inputFormat\": \"org.apache.hadoop.mapred.SequenceFileInputFormat\",\n" +      "\t\t\"outputFormat\": \"org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\",\n" +      "\t\t\"compressed\": \"No\",\n" +      "\t\t\"numBuckets\": \"5\",\n" +      "\t\t\"bucketCols\": [\"col_name1\", \" col_name2\"],\n" +      "\t\t\"sortCols\": [{\n" +      "\t\t\t\"columnName\": \"col_name1\",\n" +      "\t\t\t\"order\": \"ASC\"\n" +      "\t\t}, {\n" +      "\t\t\t\"columnName\": \"col_name2\",\n" +      "\t\t\t\"order\": \"DESC\"\n" +      "\t\t}],\n" +      "\t\t\"parameters\": {\n" +      "\t\t\t\"escape.delim\": \"\\\\\\\\\",\n" +      "\t\t\t\"field.delim\": \",\",\n" +      "\t\t\t\"serialization.format\": \",\"\n" +      "\t\t}\n" +      "\t}\n" +      "}";    TableMeta tableMeta = new Gson().fromJson(json, TableMeta.class);    Optional<String> createQuery = new CreateTableQueryGenerator(tableMeta).getQuery();    LOG.info("createQuery : {}", createQuery);    Assert.assertTrue(createQuery.isPresent());    Assert.assertEquals( "incorrect create table query.", createTableQuery, createQuery.get());  }
@Test	public void testThatEmbeddedLibsAreHandledProperly() throws Exception {		WabProcessor wabProcessor = new TestWabProcessor(			getFile("/tck-V3URLTests.wab.war"),			Collections.singletonMap(				"Web-ContextPath",				new String[] {"/portlet-V3-annotated-demo"}));		File processedFile = wabProcessor.getProcessedFile();		Assert.assertNotNull(processedFile);		try (Jar jar = new Jar(processedFile)) {			// Check if the basic metadata is correct			Assert.assertEquals("portlet-V3-annotated-demo", jar.getBsn());			Assert.assertEquals("1.0.0", jar.getVersion());			// Does this WAR have a beans.xml file that would trigger			// OSGi CDI Integration analysis?			Resource beansXMLFile = jar.getResource("WEB-INF/beans.xml");			Assert.assertNotNull(beansXMLFile);			// Did the beans.xml file have a discovery mode of none?			try (InputStream inputStream = beansXMLFile.openInputStream()) {				Document document = SAXReaderUtil.read(inputStream);				Node beanDiscoveryMode = document.selectSingleNode(					"/beans/@bean-discovery-mode");				String value = beanDiscoveryMode.getStringValue();				Assert.assertNotEquals("none", value);			}			// Finally, make sure the requirement on the OSGi CDI			// Integration extender was added to the manifest			Domain domain = Domain.domain(jar.getManifest());			Parameters requirements = domain.getRequireCapability();			Map.Entry<String, Attrs> entry = findRequirement(				requirements, "osgi.extender",				HashMapBuilder.<String, Object>put(					"osgi.extender", "osgi.cdi"				).put(					"version", new Version(1)				).build());			Assert.assertNotNull(entry);			// Assert the expected number of beans were discovered			Attrs attrs = entry.getValue();			List<String> beans = attrs.getTyped(Attrs.LIST_STRING, "beans");			Assert.assertEquals(beans.toString(), 5, beans.size());			List<String> expectedList = Arrays.asList(				"javax.portlet.tck.portlets.URLTests_ActionURL",				"javax.portlet.tck.portlets.URLTests_BaseURL",				"javax.portlet.tck.portlets.URLTests_RenderURL",				"javax.portlet.tck.portlets.URLTests_ResourceURL",				"javax.portlet.tck.util.ModuleTestCaseDetails");			Assert.assertEquals(expectedList.toString(), expectedList, beans);			// Make sure other CDI requirements were added			// The bean portlet extension			Assert.assertNotNull(				findRequirement(					requirements, "osgi.cdi.extension",					Collections.singletonMap(						"osgi.cdi.extension",						"com.liferay.bean.portlet.cdi.extension")));			// The http extension			Assert.assertNotNull(				findRequirement(					requirements, "osgi.cdi.extension",					Collections.singletonMap(						"osgi.cdi.extension", "aries.cdi.http")));			// The EL extension			Assert.assertNotNull(				findRequirement(					requirements, "osgi.cdi.extension",					Collections.singletonMap(						"osgi.cdi.extension", "aries.cdi.el.jsp")));		}	}
@Test    public void getDownloadUrl() {        final Path path = mock(Path.class);        when(path.toURI()).thenReturn("default://master@MySpace/Mortgages/src/main/resources/a & b.drl");        final String downloadUrl = URLHelper.getDownloadUrl(path, "clientId");        assertEquals("dtablexls/file?clientId=clientId&attachmentPath=default%3A%2F%2Fmaster%40MySpace%2FMortgages%2Fsrc%2Fmain%2Fresources%2Fa+%26+b.drl", downloadUrl);    }
@Test    void requireInRangeClosed() {        assertEquals(0.0, DoubleRangeUtil.requireInRangeClosed(0.0, -1.0,1.0));    }
@Test  public void testDefaultVisibilityServiceProperties() throws Exception {    // Given    String serviceInfoXml =      "<metainfo>" +        "  <schemaVersion>2.0</schemaVersion>" +        "  <services>" +        "    <service>" +        "      <name>WITH_PROPS</name>" +        "      <displayName>WITH_PROPS</displayName>" +        "      <properties>" +        "        <property>" +        "          <name>PROP1</name>" +        "          <value>VAL1</value>" +        "        </property>" +        "        <property>" +        "          <name>PROP2</name>" +        "          <value>VAL2</value>" +        "        </property>" +        "      </properties>" +        "    </service>" +        "  </services>" +        "</metainfo>";    // When    Map<String, ServiceInfo> serviceInfoMap = getServiceInfo(serviceInfoXml);    // Then    Map<String, String> serviceProperties = serviceInfoMap.get("WITH_PROPS").getServiceProperties();    assertTrue("true".equals(serviceProperties.get(ServiceInfo.DEFAULT_SERVICE_INSTALLABLE_PROPERTY.getKey())));    assertTrue("true".equals(serviceProperties.get(ServiceInfo.DEFAULT_SERVICE_MANAGED_PROPERTY.getKey())));    assertTrue("true".equals(serviceProperties.get(ServiceInfo.DEFAULT_SERVICE_MONITORED_PROPERTY.getKey())));  }
@Test    public void testArgNameValuePairs_ArgValueNoArgName_multiple() throws Exception {        JoinPoint jp = mock(JoinPoint.class);        when(jp.getArgs()).thenReturn(new Object[]{"Steve", 20});        assertThat(Utils.getArgNameValuePairs(jp)).containsExactly("0: Steve", "1: 20");    }
@Test(timeout = 2500)    public void testPolygonStylingSmallClipping()                            throws Exception {        BufferedImage img = new BufferedImage( 100, 100, TYPE_INT_ARGB );        long time = currentTimeMillis();        Graphics2D g = img.createGraphics();        GeometryFactory geomFac = new GeometryFactory();        Java2DRenderer r = new Java2DRenderer( g, img.getWidth(), img.getHeight(),                                               geomFac.createEnvelope( new double[] { 0, 0 }, new double[] { 50d, 50d },                                                                       mapcs ) );        Envelope envelope = new GeometryFactory().createEnvelope( 0, 0, 100000000, 100000000, null );        PolygonStyling styling = new PolygonStyling();        styling.stroke = new Stroke();        styling.stroke.color = red;        styling.stroke.width = 5;        styling.stroke.dasharray = new double[] { 15, 15, 17, 5 };        styling.fill = new Fill();        styling.fill.color = white;        r.render( styling, envelope );        g.dispose();        long time2 = currentTimeMillis();        List<String> texts = new LinkedList<String>();        texts.add( "line: default style line dashed with pattern 15, 15, 17, 5" );        validateImage( img, time2 - time, "polygonstylingsmallclipping" );    }
@Test  public void testRequestType() throws Exception {    Request r = new PostRequest(null, new RequestBody(), null, null);    assertSame(Request.Type.POST, r.getRequestType());  }
@Test    void execute() {        HTTPResponse response = new HTTPResponse(200, Map.of(), new byte[0]);        when(httpClient.execute(any())).thenReturn(response);        var request = new TestWebService.TestRequest();        request.stringField = "12345";        Object result = webServiceClient.execute(HTTPMethod.PUT, "/api", TestWebService.TestRequest.class, request, void.class);        assertThat(result).isNull();    }
@Test	public void testGetFocusBehavior() throws Exception {		assertEquals(FocusBehavior.HIDE_PROMPT, PromptSupport.getFocusBehavior(txt));	}
@SuppressWarnings("unchecked")    @Test    public void testRetainIntersection() {        List<Integer> common = Lists.newArrayList();        List<Integer>[] lists = new List[Random.getScaleCount()];        int max = Random.getScaleCount();        for (int i = 0; i < max; i++) {            common.add(i);        }        for (int i = 0; i < lists.length; i++) {            lists[i] = Lists.<Integer> newArrayList();            lists[i].addAll(common);            for (int j = 0; j < Random.getScaleCount(); j++) {                lists[i].add(Random.getScaleCount() + max);            }            lists[i] = Lists.newArrayList(lists[i]);        }        TLists.retainIntersection(lists);        for (List<Integer> list : lists) {            Assert.assertEquals(common, list);        }    }
@Test    void shouldFailConnectionInitializedPromiseWhenHandshakeFails()    {        ChannelPromise channelInitializedPromise = channel.newPromise();        HandshakeCompletedListener listener = new HandshakeCompletedListener( "user-agent", authToken(), RoutingContext.EMPTY,                channelInitializedPromise );        ChannelPromise handshakeCompletedPromise = channel.newPromise();        IOException cause = new IOException( "Bad handshake" );        handshakeCompletedPromise.setFailure( cause );        listener.operationComplete( handshakeCompletedPromise );        Exception error = assertThrows( Exception.class, () -> await( channelInitializedPromise ) );        assertEquals( cause, error );    }
@Test(expected = AuthenticationFailedException.class)  public void testCheckPermissionForOrganizationThrowsAuthenticationFailedException() throws Exception {    UUID organizationID = UUID.randomUUID();    when(identityResolver.resolveOrganizationIdentity(organizationID)).thenReturn(organization);    when(accessController.hasPermission(credentials, viewThreatIntelFact, organization)).thenThrow(InvalidCredentialsException.class);    context.checkPermission(viewThreatIntelFact, organizationID);  }
@Test    public void testSingleParameter_LHSFieldName() {        final String result = utilities.convertSingleParameterToTemplateKey( "$param != null",                                                                             ParameterizedValueBuilder.Part.LHS );        assertEquals( "@{param1} != null",                      result );    }
@Test    void shouldTreatNotNeo4jExceptionAsFatal()    {        assertTrue( isFatal( new IOException( "IO failed!" ) ) );    }
@Test    void shouldReplaceImageBodyEvenWithoutBody() throws IOException {        final ResponseFilter filter = ResponseFilters.defaultValue();        final HttpResponse response = filter.filter(MockHttpResponse.create()                .withContentType("image/png")                .withBodyAsString("this is an image"));        response.withoutBody();        assertThat(response.getContentType(), is("image/png"));        assertThat(response.getContentType(), is("image/png"));        assertThat(response.getBody(), is("<binary>".getBytes(UTF_8)));        assertThat(response.getBodyAsString(), is("<binary>"));    }
@Test    public void onNavigation_updateLanguageSwitchAnchors() {        PlaceRequest request = new PlaceRequest.Builder().nameToken(NameTokens.PRODUCT).build();        NavigationEvent event = new NavigationEvent(request);        presenter.onNavigation(event);        verify(view).updateNavigationHref();    }
@Test	public void testAddFile_4() throws Exception {		File f = File.createTempFile("0123456789", "0123456789", (File) null);		ClassPathHack.addFile(f);	}
@Test    public void testLayoutWithLAFDecoration() {        // This test will not work in a headless configuration.        if (GraphicsEnvironment.isHeadless()) {            LOG.fine("cannot run testLAFDecorationLayout - headless environment");            return;        }        if (!UIManager.getLookAndFeel().getSupportsWindowDecorations()) {            LOG.info("cannot run test - unsupported laf window decoration");            return;        }                JFrame.setDefaultLookAndFeelDecorated(true);        JXFrame frame = new JXFrame();        frame.add(new JXTable(new AncientSwingTeam()));        frame.pack();        Dimension dim = frame.getSize();        assertEquals(dim, frame.getPreferredSize());        JXStatusBar bar = new JXStatusBar();        bar.add(new JLabel("need some content"));        frame.setStatusBar(bar);        frame.pack();        try {            assertEquals(dim.height + bar.getPreferredSize().height, frame.getPreferredSize().height);        } finally {            JFrame.setDefaultLookAndFeelDecorated(false);        }    }
@Test  public void testOverview() {    final Metacard metacard = new MetacardImpl();    metacard.setAttribute(new AttributeImpl(Core.DERIVED_RESOURCE_URI, "content:abc123#overview"));    assertThat(predicate.test(metacard), is(true));  }
@Test  public void testMatchDefaultDCTerm() throws Exception {    // Match == Default Value    operation.setConfiguration(ConfigureByDublinCoreTermWOH.DCCATALOG_PROPERTY, "episode");    operation.setConfiguration(ConfigureByDublinCoreTermWOH.DCTERM_PROPERTY, "source");    operation.setConfiguration(ConfigureByDublinCoreTermWOH.DEFAULT_VALUE_PROPERTY, "Timbuktu");    operation.setConfiguration(ConfigureByDublinCoreTermWOH.MATCH_VALUE_PROPERTY, "Timbuktu");    operation.setConfiguration(ConfigureByDublinCoreTermWOH.COPY_PROPERTY, "false");    operation.setConfiguration("newConfigProperty", "true");    WorkflowOperationResult result = operationHandler.start(instance, null);    Map<String, String> properties = result.getProperties();    Assert.assertTrue(properties.containsKey("newConfigProperty"));    Assert.assertEquals("true", properties.get("newConfigProperty"));  }
@Test  public void testSubstituteArguments() throws Exception  {    //simple substitute    String newPropertyId = AbstractPropertyProvider.substituteArgument("category/name1/$1/name2/$2", "$1", "foo");    Assert.assertEquals("category/name1/foo/name2/$2", newPropertyId);    newPropertyId = AbstractPropertyProvider.substituteArgument("category/name1/$1/name2/$2", "$2", "bar");    Assert.assertEquals("category/name1/$1/name2/bar", newPropertyId);    //substitute with method    newPropertyId = AbstractPropertyProvider.substituteArgument(        "category/name1/$1.toLowerCase()/name2/$2.toUpperCase()", "$1", "FOO");    Assert.assertEquals("category/name1/foo/name2/$2.toUpperCase()", newPropertyId);    newPropertyId = AbstractPropertyProvider.substituteArgument(        "category/name1/$1.toLowerCase()/name2/$2.toUpperCase()", "$2", "bar");    Assert.assertEquals("category/name1/$1.toLowerCase()/name2/BAR", newPropertyId);    //substitute with chained methods    newPropertyId = AbstractPropertyProvider.substituteArgument(        "category/name1/$1.toLowerCase().substring(1)/name2", "$1", "FOO");    Assert.assertEquals("category/name1/oo/name2", newPropertyId);    newPropertyId = AbstractPropertyProvider.substituteArgument(        "category/name1/$1.toLowerCase().substring(1).concat(\"_post\")/name2/$2.concat(\"_post\")", "$1", "FOO");    newPropertyId = AbstractPropertyProvider.substituteArgument(newPropertyId, "$2", "bar");    Assert.assertEquals("category/name1/oo_post/name2/bar_post", newPropertyId);  }
@Test    public void test200Example8()                            throws Exception {        GetPropertyValueXMLAdapter parser = new GetPropertyValueXMLAdapter();        parser.load( GetPropertyValueXMLAdapterTest.class.getResource( "wfs200/example8.xml" ) );        GetPropertyValue request = parser.parse();        assertEquals( VERSION_200, request.getVersion() );        assertEquals( "myns:phone", request.getValueReference().getAsText() );        assertNull( request.getPresentationParams().getStartIndex() );        assertNull( request.getPresentationParams().getCount() );        assertEquals( "application/xml; subtype=gml/3.2", request.getPresentationParams().getOutputFormat() );        assertNull( request.getResolveParams().getMode() );        assertNull( request.getResolveParams().getDepth() );        assertNull( request.getResolveParams().getTimeout() );        FilterQuery query = (FilterQuery) request.getQuery();        OperatorFilter filter = (OperatorFilter) query.getFilter();        Assert.assertTrue( filter.getOperator() instanceof And );    }
@Test  public void simpleTest() throws QueryBuilderException {    // GIVEN    UiAnalysis analysis = createAnalysis("select a, count() group by a order by a asc", null, Arrays.asList());    // WHEN    String queryBuilderDiql = generateQueryBuilder(analysis).build();    ExecutionRequest queryBuilderRequest = parse(queryBuilderDiql);    // THEN    String expectedDiql = "select a, count() from " + TABLE + " group by a order by a asc";    ExecutionRequest expectedRequest = parse(expectedDiql);    Assert.assertEquals(queryBuilderRequest, expectedRequest,        "Built query found to be not equal to the genrated one. Expected: '" + expectedDiql + "' but was '"            + queryBuilderDiql + "'");  }
@Test	public void testCreateRESTBuilder() throws Exception {		String dependenciesPath = _getDependenciesPath();		RESTBuilder restBuilder = new RESTBuilder(			new File(dependenciesPath, "copyright.txt"),			new File(dependenciesPath), null);		restBuilder.build();		String filesPath = _getFilesPath();		File applicationFile = new File(			filesPath + "/sample-impl/src/main/java/com/example/sample" +				"/internal/jaxrs/application/SampleApplication.java");		Assert.assertTrue(applicationFile.exists());		_assertResourceFilesExist(filesPath, "Document");		_assertResourceFilesExist(filesPath, "Folder");		File sampleApiDir = new File(filesPath + "/sample-api");		FileUtils.deleteDirectory(sampleApiDir);		Assert.assertFalse(sampleApiDir.exists());		File sampleImplDir = new File(filesPath + "/sample-impl");		FileUtils.deleteDirectory(sampleImplDir);		Assert.assertFalse(sampleImplDir.exists());	}
@Test    void shouldCreateDatabaseException()    {        String code = "Neo.DatabaseError.Transaction.TransactionLogError";        String message = "Failed to write the transaction log";        Neo4jException error = newNeo4jError( code, message );        assertThat( error, instanceOf( DatabaseException.class ) );        assertEquals( code, error.code() );        assertEquals( message, error.getMessage() );    }
@Test  public void testResolveTypeFound() {    ObjectTypeEntity entity = new ObjectTypeEntity()            .setId(UUID.randomUUID())            .setName("name");    when(objectManager.getObjectType(isA(UUID.class))).thenReturn(entity);    ObjectTypeInfoSEB seb = resolver.apply(entity.getId());    assertNotNull(seb);    assertEquals(entity.getId(), seb.getId());    assertEquals(entity.getName(), seb.getName());    verify(objectManager).getObjectType(entity.getId());  }
@Test    public void testRemoveFromEmptyCompoundHighlighter() {        CompoundHighlighter pipeline = new CompoundHighlighter();        pipeline.removeHighlighter(new ColorHighlighter());    }
@Test    public void pipelineExpandOrderingTest() {        List<Map<String, String>> listWithEmptyMap = new LinkedList<>();        listWithEmptyMap.add(new HashMap<String, String>());        SetAssignExtension setAssign = new SetAssignExtension();        SetAssignExtension.SetAssignTag setAssignTag = new SetAssignExtension.SetAssignTag();        setAssignTag.setName("var_out_test");        setAssignTag.setSet("A,B,C");        List<Map<String, String>> processedList = setAssign.pipelinePossibleStates(setAssignTag, listWithEmptyMap);        Assert.assertEquals(3, processedList.size());        Map<String, String> resultMap = processedList.get(0);        Assert.assertEquals(1, resultMap.keySet().size());        Assert.assertEquals("A", resultMap.get("var_out_test"));        resultMap = processedList.get(1);        Assert.assertEquals(1, resultMap.keySet().size());        Assert.assertEquals("B", resultMap.get("var_out_test"));        resultMap = processedList.get(2);        Assert.assertEquals(1, resultMap.keySet().size());        Assert.assertEquals("C", resultMap.get("var_out_test"));    }
@Test 	public void testValidLogin(){		when(userService.loginUser(user)).thenReturn(user);		assertEquals(user, userController.login(user, response));	}
@Test  public void testByteIndexed()      throws MimeTypeParseException, NitfFormatException, IOException, NoSuchMethodException,          IllegalAccessException, InvocationTargetException, InstantiationException {    int originalWidth = 200;    int originalHeight = 100;    int chipWidth = 160;    int chipHeight = 80;    NitfSegmentsFlow nitfSegmentsFlow = createGenericNitfSegmentFlow(originalWidth, originalHeight);    BufferedImage chipImage =        new BufferedImage(chipWidth, chipHeight, BufferedImage.TYPE_BYTE_INDEXED);    BinaryContent binaryContent =        catalogOutputAdapter.getNitfBinaryContent(chipImage, nitfSegmentsFlow, 0, 0);    NitfSegmentsFlow chipNitfSegmentFlow =        new NitfParserInputFlowImpl().inputStream(binaryContent.getInputStream()).allData();    chipNitfSegmentFlow.forEachImageSegment(        imageSegment1 -> {          assertThat(imageSegment1.getPixelValueType(), is(PixelValueType.INTEGER));          assertThat(imageSegment1.getImageRepresentation(), is(ImageRepresentation.RGBLUT));          assertThat(imageSegment1.getActualBitsPerPixelPerBand(), is(8));          assertThat(imageSegment1.getNumberOfBitsPerPixelPerBand(), is(8));          assertThat(imageSegment1.getImageBand(1).getImageRepresentation(), is("LU"));        });  }
@Test  public void testGetColo() throws Exception {    Cluster cluster = new Cluster("Cluster1", "Colo", Collections.singleton(new Cluster.Interface("type", "endpoint", "version")),        Collections.singleton(new Cluster.Location("name", "path")), Collections.singletonMap("P1", "V1"));    Assert.assertEquals("Colo", cluster.getColo());  }
@Test    public void testFilterNumber() throws Exception {        String filtered = getFilter("id") .filter(getResource("/user.json"));        assertThat(filtered, not(containsString("18375")));    }
@Test public void testAllowReturnTransitionOverlap() {		// Arrange:		final FragmentRequest request = new FragmentRequest(mock(FragmentController.class), FragmentRequest.NO_ID);		// Act + Assert:		assertThat(request.allowReturnTransitionOverlap(false), is(request));		assertThat(request.allowReturnTransitionOverlap(), is(false));		assertThat(request.allowReturnTransitionOverlap(true), is(request));		assertThat(request.allowReturnTransitionOverlap(), is(true));    }
@Test    public void executeIfSelected() {        commandSpy.execute(scenarioSimulationContextLocal);        verify((AbstractSelectedColumnCommand) commandSpy, times(1)).executeIfSelectedColumn(scenarioSimulationContextLocal, gridColumnMock);    }
@Test    public void shouldReturnPreviousValueOnSetValue() {        //given        dynamoJobMetaRepository.setValue("myJobType", "someKey", "someOldValue");        //when        String previousValue = dynamoJobMetaRepository.setValue("myJobType", "someKey", "someNewValue");        //given        assertThat(previousValue, is("someOldValue"));    }
@Test    void closeResponseIfServiceUnavailable() throws IOException {        var request = new Request.Builder().url("http://localhost").build();        var source = mock(BufferedSource.class);        var serviceUnavailableResponse = new Response.Builder().request(request)                .protocol(Protocol.HTTP_2)                .code(HTTPStatus.SERVICE_UNAVAILABLE.code)                .message("service unavailable")                .body(ResponseBody.create(source, MediaType.get("application/json"), 0))                .build();        var okResponse = new Response.Builder().request(request)                .protocol(Protocol.HTTP_2)                .code(HTTPStatus.OK.code)                .message("ok")                .build();        var chain = mock(Interceptor.Chain.class);        when(chain.request()).thenReturn(request);        when(chain.proceed(request)).thenReturn(serviceUnavailableResponse).thenReturn(okResponse);        Response response = interceptor.intercept(chain);        assertThat(response).isSameAs(okResponse);        verify(source).close();    }
@Test    public void testMultipleSubscriptionsReceiveSameResult() throws Exception {        Observable<String> observable = Observable.just("1");        Action1<String> testAction = new Action1<String>() {            @Override            public void call(String s) {                assertEquals("1", s);            }        };        observable                .compose(mLifecycleHandler.<String>load(4))                .subscribe(testAction);        observable                .compose(mLifecycleHandler.<String>load(4))                .subscribe(testAction);    }
@Test  public void testCompleteUpgradeOrchestration() throws Exception {    Map<String, UpgradePack> upgrades = ambariMetaInfo.getUpgradePacks("foo", "bar");    assertTrue(upgrades.isEmpty());    upgrades = ambariMetaInfo.getUpgradePacks("HDP", "2.1.1");    ServiceInfo si = ambariMetaInfo.getService("HDP", "2.1.1", "ZOOKEEPER");    si.setDisplayName("Zk");    ComponentInfo ci = si.getComponentByName("ZOOKEEPER_SERVER");    ci.setDisplayName("ZooKeeper1 Server2");    assertTrue(upgrades.containsKey("upgrade_test_partial"));    UpgradePack upgrade = upgrades.get("upgrade_test_partial");    assertNotNull(upgrade);    Cluster cluster = makeCluster();    UpgradeContext context = m_upgradeContextFactory.create(cluster, UpgradeType.ROLLING,        Direction.UPGRADE, UPGRADE_VERSION, new HashMap<String, Object>());    context.setResolver(m_masterHostResolver);    context.setSupportedServices(Collections.singleton("ZOOKEEPER"));    context.setScope(UpgradeScope.COMPLETE);    List<Grouping> groupings = upgrade.getGroups(Direction.UPGRADE);    assertEquals(8, groupings.size());    assertEquals(UpgradeScope.COMPLETE, groupings.get(6).scope);    List<UpgradeGroupHolder> groups = m_upgradeHelper.createSequence(upgrade, context);    assertEquals(4, groups.size());    assertEquals("PRE_CLUSTER", groups.get(0).name);    assertEquals("ZOOKEEPER", groups.get(1).name);    assertEquals("ALL_HOSTS", groups.get(2).name);    assertEquals("POST_CLUSTER", groups.get(3).name);    UpgradeGroupHolder group = groups.get(1);    // check that the display name is being used    assertTrue(group.items.get(1).getText().contains("ZooKeeper1 Server2"));    assertEquals("Service Check Zk", group.items.get(5).getText());    UpgradeGroupHolder postGroup = groups.get(3);    assertEquals("POST_CLUSTER", postGroup.name);    assertEquals("Finalize Upgrade", postGroup.title);    assertEquals(2, postGroup.items.size());    assertEquals("Confirm Finalize", postGroup.items.get(0).getText());    assertEquals("Save Cluster State", postGroup.items.get(1).getText());    assertEquals(StageWrapper.Type.SERVER_SIDE_ACTION, postGroup.items.get(1).getType());    assertEquals(3, groups.get(0).items.size());    assertEquals(6, groups.get(1).items.size());    assertEquals(1, groups.get(2).items.size());    // Do stacks cleanup    stackManagerMock.invalidateCurrentPaths();    ambariMetaInfo.init();  }
@Test public void testFragmentId() {		// Arrange:		final FragmentRequest request = new FragmentRequest(mock(FragmentController.class), FragmentRequest.NO_ID);		// Act + Assert:		assertThat(request.fragmentId(100), is(request));    	assertThat(request.fragmentId(), is(100));	}
@Test(expected = NotConnectedException.class)    public void testOpen_withExceptionAndRetries() throws Exception {        chatConfig.sourceConnectionSleepIntervalMs = 1000;        chatConfig.sourceConnectionMaxMs = 1000;        stormConf.put(ConfigurationConstants.CHATALYTICS_CONFIG.txt, YamlUtils.writeYaml(config));        try {            underTest.open(stormConf, mockContext, mockCollector);            fail();        } catch (Exception e) {            throw (Exception) e.getCause();        }    }
@Test	public void testValidateConfigurationValidFieldColorPaletteComplete()		throws Exception {		_fragmentEntryValidatorImpl.validateConfiguration(			_read("configuration_valid_field_colorpalette_complete.json"));	}
@Test  public void testConstructor() {    VideographerAuthenticationToken token =        new VideographerAuthenticationToken("127.0.0.1", mock(SecurityLogger.class));    assertThat(token.getPrincipal(), is(instanceOf(VideographerPrincipal.class)));    assertThat(        token.getCredentials(), is(VideographerAuthenticationToken.VIDEOGRAPHER_CREDENTIALS));    assertThat(token.getIpAddress(), is("127.0.0.1"));  }
@Test  public void testEnvStringPattern() {    assertFalse(RemoteInterpreter.isEnvString(null));    assertFalse(RemoteInterpreter.isEnvString(""));    assertFalse(RemoteInterpreter.isEnvString("abcDEF"));    assertFalse(RemoteInterpreter.isEnvString("ABC-DEF"));    assertTrue(RemoteInterpreter.isEnvString("ABCDEF"));    assertTrue(RemoteInterpreter.isEnvString("ABC_DEF"));    assertTrue(RemoteInterpreter.isEnvString("ABC_DEF123"));  }
@Test	public void testCreateValue_1()		throws Exception {		ObjectFactory fixture = new ObjectFactory();		String value = "";		JAXBElement<String> result = fixture.createValue(value);		assertNotNull(result);		assertEquals("", result.getValue());		assertEquals(false, result.isNil());		assertEquals(true, result.isGlobalScope());		assertEquals(false, result.isTypeSubstituted());	}
@Test  public void testGetSingularName() throws Exception {    TaskAttemptResourceDefinition definition = new TaskAttemptResourceDefinition();    Assert.assertEquals("taskattempt", definition.getSingularName());  }
@Test  public void testDoNameNodeHighAvailabilityExportWithHAEnabledNameServicePropertiesIncluded() throws Exception {    final String expectedNameService = "mynameservice";    final String expectedHostName = "c6401.apache.ambari.org";    Map<String, Map<String, String>> configProperties = new HashMap<String, Map<String, String>>();    Map<String, String> coreSiteProperties = new HashMap<String, String>();    Map<String, String> hbaseSiteProperties = new HashMap<String, String>();    Map<String, String> accumuloSiteProperties = new HashMap<String, String>();    configProperties.put("core-site", coreSiteProperties);    configProperties.put("hbase-site", hbaseSiteProperties);    configProperties.put("accumulo-site", accumuloSiteProperties);    // configure fs.defaultFS to include a nameservice name, rather than a host name    coreSiteProperties.put("fs.defaultFS", "hdfs://" + expectedNameService);    // configure hbase.rootdir to include a nameservice name, rather than a host name    hbaseSiteProperties.put("hbase.rootdir", "hdfs://" + expectedNameService + "/apps/hbase/data");    // configure instance.volumes to include a nameservice name, rather than a host name    accumuloSiteProperties.put("instance.volumes", "hdfs://" + expectedNameService + "/apps/accumulo/data");    Configuration clusterConfig = new Configuration(configProperties,        Collections.<String, Map<String, Map<String, String>>>emptyMap());    // note: test hostgroups may not accurately reflect the required components for the config properties    // which are mapped to them.  Only the hostgroup name is used for hostgroup resolution an the components    // are not validated    Collection<String> groupComponents = new HashSet<String>();    groupComponents.add("RESOURCEMANAGER");    Collection<String> hosts = new ArrayList<String>();    hosts.add(expectedHostName);    hosts.add("serverTwo");    TestHostGroup group = new TestHostGroup("group1", groupComponents, hosts);    Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>();    hostGroups.add(group);    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor configProcessor = new BlueprintConfigurationProcessor(topology);    configProcessor.doUpdateForBlueprintExport();    // verify that any properties that include nameservices are not removed from the exported blueprint's configuration    assertEquals("Property containing an HA nameservice (fs.defaultFS), was not correctly exported by the processor",        "hdfs://" + expectedNameService, coreSiteProperties.get("fs.defaultFS"));    assertEquals("Property containing an HA nameservice (hbase.rootdir), was not correctly exported by the processor",        "hdfs://" + expectedNameService + "/apps/hbase/data", hbaseSiteProperties.get("hbase.rootdir"));    assertEquals("Property containing an HA nameservice (instance.volumes), was not correctly exported by the processor",        "hdfs://" + expectedNameService + "/apps/accumulo/data", accumuloSiteProperties.get("instance.volumes"));  }
@Test  public void testConvertRequestFilterByKeywords() throws Exception {    FactSearchCriteria criteria = converter.apply(new SearchObjectRequest().setKeywords("keyword"));    assertEquals("keyword", criteria.getKeywords());    assertEquals(SetUtils.set(FactSearchCriteria.KeywordFieldStrategy.all), criteria.getKeywordFieldStrategy());    assertEquals(FactSearchCriteria.MatchStrategy.any, criteria.getKeywordMatchStrategy());  }
@Test  public void testGetId() throws Exception {    assertEquals(3L, job.getId());  }
@Test    void of() {        final IntStream ss = SingletonIntStream.of(OTHER_ELEMENT);        final List<Integer> s = ss.boxed().collect(toList());        assertEquals(singletonList(OTHER_ELEMENT), s);    }
@Test(expected = IllegalArgumentException.class)	public void testValidateEmptyArguments() throws Exception {		Main.main(new String[0]);	}
@Test    public void testInit() throws Exception {        model.setTableFormat(GuidedDecisionTable52.TableFormat.LIMITED_ENTRY);        doReturn(model).when(presenter).getModel();        doReturn(presenter).when(wizard).getPresenter();        plugin.init(wizard);        verify(plugin).setupDefaultValues();    }
@Test  public void testMinus() {    Matrix value = test.minus(test);    for (int row = 0; row < test.rowSize(); row++) {      for (int col = 0; col < test.columnSize(); col++) {        assertEquals("value[" + row + "][" + col + ']', 0.0, value.getQuick(row, col), EPSILON);      }    }  }
@Test  public void testIsNotNoneString() throws Exception {    assertThat(Utilities.isNotStringNone(" "), is(true));    assertThat(Utilities.isNotStringNone("non"), is(true));    assertThat(Utilities.isNotStringNone("none"), is(false));    assertThat(Utilities.isNotStringNone("None"), is(false));    assertThat(Utilities.isNotStringNone("NONE"), is(false));    assertThat(Utilities.isNotStringNone("None "), is(false));  }
@Test  public void testFromXml() throws Exception {    assertNotNull(mediaSegments);    String xml = mediaSegments.toXml();    MediaSegments mediaSegments = MediaSegments.fromXml(xml);    assertNotNull(mediaSegments);    assertNotNull(mediaSegments.getMediaSegments());    assertTrue(mediaSegments.getMediaSegments().size() == 3);  }
@Test	public void testTN_FindTModelForProcessName() throws JAXBException {				QName processName = new QName("http://example.com/travelagent","ReservationAndBookingTickets");			FindTModel findTModel = bpel2UDDI.createFindTModelForProcessName(processName);				System.out.println("***** Find TModel For ProcessName: " + processName);                if (serialize)		System.out.println(pFindTModel.print(findTModel));				Assert.assertNotNull(findTModel.getCategoryBag());	}
@Test    public void testGetErrorFrameJWindow() {        if (GraphicsEnvironment.isHeadless()) {            LOG.fine("cannot run - headless environment");            return;        }        assertNotNull(ui.getErrorFrame(new JWindow()));    }
@Test    public void test_V110_EXAMPLE09()                            throws Exception {        URL exampleURL = this.getClass().getResource( V110_EXAMPLE09 );        XMLAdapter xmlAdapter = new XMLAdapter( exampleURL );        GetFeatureXMLAdapter getFeatureAdapter = new GetFeatureXMLAdapter();        getFeatureAdapter.setRootElement( xmlAdapter.getRootElement() );        GetFeature getFeature = getFeatureAdapter.parse();        List<Query> queries = getFeature.getQueries();        FilterQuery filterQuery = (FilterQuery) queries.get( 0 );        TypeName[] typeNames = filterQuery.getTypeNames();        assertEquals( typeNames.length, 1 );        assertEquals( new QName( "Person" ), typeNames[0].getFeatureTypeName() );        OperatorFilter opFilter = (OperatorFilter) filterQuery.getFilter();        assertEquals( opFilter.getOperator().getType(), LOGICAL );        LogicalOperator logOp = (LogicalOperator) opFilter.getOperator();        assertEquals( logOp.getSubType(), AND );        And andOp = (And) logOp;        Operator op1 = andOp.getParameter( 0 );        assertEquals( op1.getType(), LOGICAL );        LogicalOperator logOp1 = (LogicalOperator) op1;        assertEquals( logOp1.getSubType(), AND );        And andOp1 = (And) logOp1;        Operator op11 = andOp1.getParameter( 0 );        assertEquals( op11.getType(), COMPARISON );        BinaryComparisonOperator compOp11 = (BinaryComparisonOperator) op11;        assertTrue( compOp11 instanceof PropertyIsGreaterThanOrEqualTo );        assertTrue( ( (PropertyIsGreaterThanOrEqualTo) op11 ).getParameter1() instanceof ValueReference );        assertEquals( ( (ValueReference) ( (PropertyIsGreaterThanOrEqualTo) op11 ).getParameter1() ).getAsText(),                      "myns:Person/myns:mailAddress/myns:Address/myns:streetNumber" );        assertTrue( ( (PropertyIsGreaterThanOrEqualTo) op11 ).getParameter2() instanceof Literal<?> );        assertEquals( ( (Literal<?>) ( (PropertyIsGreaterThanOrEqualTo) op11 ).getParameter2() ).getValue().toString(),                      "10000" );        Operator op12 = andOp1.getParameter( 1 );        assertEquals( op12.getType(), COMPARISON );        BinaryComparisonOperator compOp12 = (BinaryComparisonOperator) op12;        assertTrue( compOp12 instanceof PropertyIsLessThanOrEqualTo );        assertTrue( ( (PropertyIsLessThanOrEqualTo) op12 ).getParameter1() instanceof ValueReference );        assertEquals( ( (ValueReference) ( (PropertyIsLessThanOrEqualTo) op12 ).getParameter1() ).getAsText(),                      "myns:Person/myns:mailAddress/myns:Address/myns:streetNumber" );        assertTrue( ( (PropertyIsLessThanOrEqualTo) op12 ).getParameter2() instanceof Literal<?> );        assertEquals( ( (Literal<?>) ( (PropertyIsLessThanOrEqualTo) op12 ).getParameter2() ).getValue().toString(),                      "10999" );        Operator op2 = andOp.getParameter( 1 );        assertEquals( op2.getType(), LOGICAL );        LogicalOperator logOp2 = (LogicalOperator) op2;        assertEquals( logOp2.getSubType(), AND );        And andOp2 = (And) logOp2;        Operator op21 = andOp2.getParameter( 0 );        assertEquals( op21.getType(), COMPARISON );        BinaryComparisonOperator compOp21 = (BinaryComparisonOperator) op21;        assertTrue( compOp21 instanceof PropertyIsEqualTo );        assertTrue( ( (PropertyIsEqualTo) op21 ).getParameter1() instanceof ValueReference );        assertEquals( ( (ValueReference) ( (PropertyIsEqualTo) op21 ).getParameter1() ).getAsText(),                      "myns:Person/myns:mailAddress/myns:Address/myns:streetName" );        assertTrue( ( (PropertyIsEqualTo) op21 ).getParameter2() instanceof Literal<?> );        assertEquals( ( (Literal<?>) ( (PropertyIsEqualTo) op21 ).getParameter2() ).getValue().toString(), "Main St." );        Operator op22 = andOp2.getParameter( 1 );        assertEquals( op22.getType(), COMPARISON );        BinaryComparisonOperator compOp22 = (BinaryComparisonOperator) op22;        assertTrue( compOp22 instanceof PropertyIsEqualTo );        assertTrue( ( (PropertyIsEqualTo) op22 ).getParameter1() instanceof ValueReference );        assertEquals( ( (ValueReference) ( (PropertyIsEqualTo) op22 ).getParameter1() ).getAsText(),                      "myns:Person/myns:mailAddress/myns:Address/myns:city" );        assertTrue( ( (PropertyIsEqualTo) op22 ).getParameter2() instanceof Literal<?> );        assertEquals( ( (Literal<?>) ( (PropertyIsEqualTo) op22 ).getParameter2() ).getValue().toString(), "SomeTown" );        Operator op23 = andOp2.getParameter( 2 );        assertEquals( op23.getType(), COMPARISON );        BinaryComparisonOperator compOp23 = (BinaryComparisonOperator) op23;        assertTrue( compOp23 instanceof PropertyIsEqualTo );        assertTrue( ( (PropertyIsEqualTo) op23 ).getParameter1() instanceof ValueReference );        assertEquals( ( (ValueReference) ( (PropertyIsEqualTo) op23 ).getParameter1() ).getAsText(),                      "myns:Person/myns:sex" );        assertTrue( ( (PropertyIsEqualTo) op23 ).getParameter2() instanceof Literal<?> );        assertEquals( ( (Literal<?>) ( (PropertyIsEqualTo) op23 ).getParameter2() ).getValue().toString(), "Female" );        Operator op24 = andOp2.getParameter( 3 );        assertEquals( op24.getType(), COMPARISON );        BinaryComparisonOperator compOp24 = (BinaryComparisonOperator) op24;        assertTrue( compOp24 instanceof PropertyIsGreaterThan );        assertTrue( ( (PropertyIsGreaterThan) op24 ).getParameter1() instanceof ValueReference );        assertEquals( ( (ValueReference) ( (PropertyIsGreaterThan) op24 ).getParameter1() ).getAsText(),                      "myns:Person/myns:salary" );        assertTrue( ( (PropertyIsGreaterThan) op24 ).getParameter2() instanceof Literal<?> );        assertEquals( ( (Literal<?>) ( (PropertyIsGreaterThan) op24 ).getParameter2() ).getValue().toString(), "35000" );    }
@Test  public void testHasPermissionForOrganizationWithoutAccessToOrganization() throws Exception {    String content = "" +            "subject.1.name = subject\n" +            "organization.1.name = organization1\n" +            "organization.2.name = organization2\n" +            "subject.1.permission.1 = function" +            "";    setup(content);    assertFalse(accessController.hasPermission(createCredentials(1), createFunctionIdentifier("function"), createOrganizationIdentifier(2)));    assertFalse(accessController.hasPermission(createCredentials(1), () -> "function", createOrganizationIdentifier(2)));  }
@Test  public void testAuthenticationNullUser() {    expect(mockAuthPropsConfig.isAuthExternalEnabled()).andReturn(true);        replay(mockAuthPropsConfig);        Authentication authentication = new TestingAuthenticationToken(null, "credentials");        try {      provider.authenticate(authentication);      assertTrue("Should have thrown BadCredentialsException", false);    } catch(BadCredentialsException e) {      assertEquals("Username can't be null or empty.", e.getMessage());    }        verify(mockAuthPropsConfig);  }
@Test  public void testResolveNoOriginFound() {    UUID id = UUID.randomUUID();    assertNull(resolver.apply(id));    verify(originManager).getOrigin(id);  }
@Test    public void getPlaceholder_InstanceNotAssigned() {        String placeholder = ScenarioSimulationUtils.getPlaceHolder(false, false, FactMappingValueType.NOT_EXPRESSION, "com.Test");        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.defineValidType(), placeholder);        placeholder = ScenarioSimulationUtils.getPlaceHolder(false, true, FactMappingValueType.NOT_EXPRESSION, "com.Test");        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.defineValidType(), placeholder);        placeholder = ScenarioSimulationUtils.getPlaceHolder(false, false, FactMappingValueType.EXPRESSION, "com.Test");        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.defineValidType(), placeholder);        placeholder = ScenarioSimulationUtils.getPlaceHolder(false, true, FactMappingValueType.EXPRESSION, "com.Test");        assertEquals(ScenarioSimulationEditorConstants.INSTANCE.defineValidType(), placeholder);    }
@Test	public void testYellowCane() throws Exception {		byte[] idFile = IOUtils.toByteArray(TlvParserTest.class.getResourceAsStream("/yellow-cane.tlv"));		Identity identity = TlvParser.parse(idFile, Identity.class);		LOG.debug("special status: " + identity.specialStatus);		assertEquals(SpecialStatus.YELLOW_CANE, identity.specialStatus);		assertTrue(identity.specialStatus.hasBadSight());		assertTrue(identity.specialStatus.hasYellowCane());		assertFalse(identity.specialStatus.hasWhiteCane());	}
@Test    public void rejectsNullDatePattern() {        thrown.expect( NullPointerException.class );        datePattern( null );    }
@Test public void testRequestPage() throws IOException {    final JobManager jobManager = new JobManager();    final Response response = jobManager.requestPage( uuid.toString(), 100 );    assertNotNull( response );    assertTrue( response.hasEntity() );    final String page = response.readEntity( String.class );    assertEquals( "100", page );  }
@Test	public void testGetSpellCheckSuggestionWithEmptySuggestion() {		setUpSearchedKeywords("q", "a b");		Assert.assertNull(buildSpellCheckSuggestion(""));	}
@Test    void shouldNotSupportPartitions() {        assertThat(new ChunkingSpliterator("", 1, 1).trySplit(), is(nullValue()));    }
@Test  public void testResponseIsPaginated() throws Exception {    expect(m_dao.findAll(EasyMock.anyObject(AlertCurrentRequest.class))).andReturn(        getClusterMockEntities()).atLeastOnce();    expect(m_dao.getCount(EasyMock.anyObject(Predicate.class))).andReturn(0).atLeastOnce();    replay(m_dao);    SecurityContextHolder.getContext().setAuthentication(TestAuthenticationFactory.createAdministrator());    Set<String> requestProperties = new HashSet<String>();    requestProperties.add(AlertResourceProvider.ALERT_ID);    requestProperties.add(AlertResourceProvider.ALERT_DEFINITION_NAME);    Request request = PropertyHelper.getReadRequest(requestProperties);    Predicate predicate = new PredicateBuilder().property(AlertResourceProvider.ALERT_CLUSTER_NAME).equals(        "c1").toPredicate();    AlertResourceProvider provider = createProvider();    QueryResponse response = provider.queryForResources(request, predicate);    // since the request didn't have paging, then this should be false    assertFalse(response.isPagedResponse());    // add a paged request    PageRequest pageRequest = new PageRequestImpl(StartingPoint.Beginning, 5, 10, predicate, null);    request = PropertyHelper.getReadRequest(requestProperties, null, null, pageRequest, null);    response = provider.queryForResources(request, predicate);    // now the request has paging    assertTrue(response.isPagedResponse());    verify(m_dao);  }
@Test  public void testGanglia134Dependencies() throws Exception {    ServiceInfo service = metaInfo.getService(STACK_NAME_HDP, "1.3.4", "GANGLIA");    List<ComponentInfo> componentList = service.getComponents();    Assert.assertEquals(2, componentList.size());    for (ComponentInfo component : componentList) {      String name = component.getName();      if (name.equals("GANGLIA_SERVER")) {        // dependencies        Assert.assertEquals(0, component.getDependencies().size());        // component auto deploy        Assert.assertNull(component.getAutoDeploy());        // cardinality        Assert.assertEquals("1", component.getCardinality());      }      if (name.equals("GANGLIA_MONITOR")) {        // dependencies        Assert.assertEquals(0, component.getDependencies().size());        // component auto deploy        Assert.assertTrue(component.getAutoDeploy().isEnabled());        // cardinality        Assert.assertEquals("ALL", component.getCardinality());      }    }  }
@Test	public void testValidationForRepeatableField() throws Exception {		DDMForm ddmForm = new DDMForm();		DDMFormField ddmFormField = createDDMFormField(			"field0", "text", FieldConstants.STRING);		DDMFormFieldValidation ddmFormFieldValidation =			new DDMFormFieldValidation();		ddmFormFieldValidation.setDDMFormFieldValidationExpression(			new DDMFormFieldValidationExpression() {				{					setName("contains");					setValue("NOT(contains(field0, \"{parameter}\"))");				}			});		ddmFormFieldValidation.setErrorMessageLocalizedValue(			DDMFormValuesTestUtil.createLocalizedValue(				"This field should not contain zero.", LocaleUtil.US));		ddmFormFieldValidation.setParameterLocalizedValue(			DDMFormValuesTestUtil.createLocalizedValue("0", LocaleUtil.US));		ddmFormField.setDDMFormFieldValidation(ddmFormFieldValidation);		ddmForm.addDDMFormField(ddmFormField);		DDMFormValues ddmFormValues = DDMFormValuesTestUtil.createDDMFormValues(			ddmForm);		ddmFormValues.addDDMFormFieldValue(			DDMFormValuesTestUtil.createDDMFormFieldValue(				"field0_0", "field0", new UnlocalizedValue("0")));		ddmFormValues.addDDMFormFieldValue(			DDMFormValuesTestUtil.createDDMFormFieldValue(				"field0_1", "field0", new UnlocalizedValue("1")));		DDMFormEvaluatorEvaluateResponse ddmFormEvaluatorEvaluateResponse =			doEvaluate(ddmForm, ddmFormValues);		Map<DDMFormEvaluatorFieldContextKey, Map<String, Object>>			ddmFormFieldsPropertyChanges =				ddmFormEvaluatorEvaluateResponse.					getDDMFormFieldsPropertyChanges();		Assert.assertEquals(			ddmFormFieldsPropertyChanges.toString(), 2,			ddmFormFieldsPropertyChanges.size());		Map<String, Object> ddmFormFieldPropertyChanges1 =			ddmFormFieldsPropertyChanges.get(				new DDMFormEvaluatorFieldContextKey("field0", "field0_0"));		Map<String, Object> ddmFormFieldPropertyChanges2 =			ddmFormFieldsPropertyChanges.get(				new DDMFormEvaluatorFieldContextKey("field0", "field0_1"));		Assert.assertEquals(			"This field should not contain zero.",			ddmFormFieldPropertyChanges1.get("errorMessage"));		Assert.assertNull(ddmFormFieldPropertyChanges2.get("errorMessage"));		Assert.assertFalse((boolean)ddmFormFieldPropertyChanges1.get("valid"));		Assert.assertTrue((boolean)ddmFormFieldPropertyChanges2.get("valid"));	}
@Test  public void testStateCommandsGeneration() throws AmbariException, InterruptedException,          InvalidStateTransitionException {    StackId stackId = new StackId("HDP-0.1");    Clusters clusters = injector.getInstance(Clusters.class);    clusters.addHost(hostname1);    setOsFamily(clusters.getHost(hostname1), "redhat", "6.3");    clusters.addHost(hostname2);    setOsFamily(clusters.getHost(hostname2), "redhat", "6.3");    clusters.addCluster(clusterName, stackId);    Cluster cluster = clusters.getCluster(clusterName);    helper.getOrCreateRepositoryVersion(stackId, stackId.getStackVersion());    cluster.createClusterVersion(stackId, stackId.getStackVersion(), "admin",        RepositoryVersionState.INSTALLING);    Set<String> hostNames = new HashSet<String>(){{      add(hostname1);      add(hostname2);    }};    ConfigFactory configFactory = injector.getInstance(ConfigFactory.class);    Config config = configFactory.createNew(cluster, "hadoop-env", "version1",        new HashMap<String,String>() {{ put("a", "b"); }}, new HashMap<String, Map<String,String>>());    cluster.addDesiredConfig("_test", Collections.singleton(config));    clusters.mapAndPublishHostsToCluster(hostNames, clusterName);    Service hdfs = cluster.addService(serviceName);    hdfs.addServiceComponent(Role.DATANODE.name());    hdfs.getServiceComponent(Role.DATANODE.name()).addServiceComponentHost(hostname1);    hdfs.addServiceComponent(Role.NAMENODE.name());    hdfs.getServiceComponent(Role.NAMENODE.name()).addServiceComponentHost(hostname1);    hdfs.addServiceComponent(Role.SECONDARY_NAMENODE.name());    hdfs.getServiceComponent(Role.SECONDARY_NAMENODE.name()).addServiceComponentHost(hostname1);    hdfs.getServiceComponent(Role.DATANODE.name()).getServiceComponentHost(hostname1).setState(State.INSTALLED);    hdfs.getServiceComponent(Role.NAMENODE.name()).getServiceComponentHost(hostname1).setState(State.INSTALLED);    hdfs.getServiceComponent(Role.SECONDARY_NAMENODE.name()).getServiceComponentHost(hostname1).setState(State.INSTALLED);    ActionQueue aq = new ActionQueue();    ActionManager am = mock(ActionManager.class);    HeartbeatMonitor hm = new HeartbeatMonitor(clusters, aq, am,      heartbeatMonitorWakeupIntervalMS, injector);    HeartBeatHandler handler = new HeartBeatHandler(clusters, aq, am, injector);    Register reg = new Register();    reg.setHostname(hostname1);    reg.setResponseId(12);    reg.setTimestamp(System.currentTimeMillis() - 300);    reg.setAgentVersion(ambariMetaInfo.getServerVersion());    HostInfo hi = new HostInfo();    hi.setOS("Centos5");    reg.setHardwareProfile(hi);    handler.handleRegistration(reg);    HeartBeat hb = new HeartBeat();    hb.setHostname(hostname1);    hb.setNodeStatus(new HostStatus(HostStatus.Status.HEALTHY, "cool"));    hb.setTimestamp(System.currentTimeMillis());    hb.setResponseId(12);    handler.handleHeartBeat(hb);    List<StatusCommand> cmds = hm.generateStatusCommands(hostname1);    assertTrue("HeartbeatMonitor should generate StatusCommands for host1", cmds.size() == 3);    assertEquals("HDFS", cmds.get(0).getServiceName());    boolean  containsDATANODEStatus = false;    boolean  containsNAMENODEStatus = false;    boolean  containsSECONDARY_NAMENODEStatus = false;    for (StatusCommand cmd : cmds) {      containsDATANODEStatus |= cmd.getComponentName().equals("DATANODE");      containsNAMENODEStatus |= cmd.getComponentName().equals("NAMENODE");      containsSECONDARY_NAMENODEStatus |= cmd.getComponentName().equals("SECONDARY_NAMENODE");      assertTrue(cmd.getConfigurations().size() > 0);    }    assertEquals(true, containsDATANODEStatus);    assertEquals(true, containsNAMENODEStatus);    assertEquals(true, containsSECONDARY_NAMENODEStatus);    cmds = hm.generateStatusCommands(hostname2);    assertTrue("HeartbeatMonitor should not generate StatusCommands for host2 because it has no services", cmds.isEmpty());  }
@Test  public void buildUseCaseShouldGetReposFromUser() throws Exception {    loadUserDetailsUseCase.buildUseCase(MockFactory.TEST_USERNAME);    verify(gitHubService).getRepositoriesFromUser(MockFactory.TEST_USERNAME);  }
@Test    public void showEmptyStateMessage() {        presenterSpy.showEmptyStateMessage();        verify(coverageReportViewMock, times(1)).setEmptyStatusText(anyString());        verify(coverageReportViewMock, times(1)).hide();    }
@Test  public void testWhenRetriesAreDisabled() throws IOException {    RetryOptions retryOptions = RetryOptions.builder().setEnableRetries(false).build();    BigtableOptions options =        BigtableOptions.builder()            .setProjectId(TEST_PROJECT_ID)            .setInstanceId(TEST_INSTANCE_ID)            .setRetryOptions(retryOptions)            .build();    expectException.expect(IllegalStateException.class);    expectException.expectMessage("Disabling retries is not currently supported.");    dataSettings = BigtableVeneerSettingsFactory.createBigtableDataSettings(options);  }
@Test    public void testOnRefreshMetaDataPanelEvent() {        final RefreshMetaDataPanelEvent event = mock(RefreshMetaDataPanelEvent.class);        final GuidedDecisionTableView.Presenter eventPresenter = mock(GuidedDecisionTableView.Presenter.class);        final List<MetadataCol52> columns = new ArrayList<>();        doReturn(eventPresenter).when(event).getPresenter();        doReturn(columns).when(event).getColumns();        doNothing().when(presenter).refreshMetaDataWidget(any());        doNothing().when(presenter).refreshColumnsNoteInfo(any());        presenter.onRefreshMetaDataPanelEvent(event);        verify(presenter).refreshMetaDataWidget(columns);        verify(presenter).refreshColumnsNoteInfo(eventPresenter);    }
@Test    void mapToDouble() {        final double actual = instance.mapToDouble(i -> i).findFirst().orElseThrow(NoSuchElementException::new);        assertEquals(ELEMENT, actual, EPSILON);    }
@Test public void testPaginate() throws Exception {    Assert.assertEquals( 0, fastStreamHtmlOutput.paginate( null, 0 ) );  }
@Test    public void initMenu() {        assertNull(abstractColumnMenuPresenter.columnContextLIElement);        assertNull(abstractColumnMenuPresenter.insertColumnLeftLIElement);        assertNull(abstractColumnMenuPresenter.insertColumnRightLIElement);        assertNull(abstractColumnMenuPresenter.deleteColumnInstanceLIElement);        assertNull(abstractColumnMenuPresenter.duplicateInstanceLIElement);        abstractColumnMenuPresenter.initMenu();        assertNotNull(abstractColumnMenuPresenter.columnContextLIElement);        assertNotNull(abstractColumnMenuPresenter.insertColumnLeftLIElement);        assertNotNull(abstractColumnMenuPresenter.insertColumnRightLIElement);        assertNotNull(abstractColumnMenuPresenter.deleteColumnInstanceLIElement);        assertNotNull(abstractColumnMenuPresenter.duplicateInstanceLIElement);    }
@Test    public void testHasColumn() {        ColumnStore<Node> columnStore = generateEmptyNodeStore();        IndexImpl<Node> index = columnStore.indexStore.mainIndex;        ColumnImpl col1 = new ColumnImpl("foo", String.class, "foo", null, Origin.DATA, true, false);        ColumnImpl col2 = new ColumnImpl("bar", String.class, "bar", null, Origin.DATA, false, false);        col1.setStoreId(0);        col2.setStoreId(1);        Assert.assertFalse(index.hasColumn(col1));        index.addColumn(col1);        index.addColumn(col2);        Assert.assertTrue(index.hasColumn(col1));        Assert.assertFalse(index.hasColumn(col2));    }
@Test    void supportsVeryLargeValues() throws IOException {        final byte[] bytes = Files.readAllBytes(                Paths.get("src/test/resources/huge-value.json"));        final String body = new String(bytes, UTF_8);        final BodyFilter unit = replaceJsonStringProperty(                singleton("password"), "XXX");        final String actual = unit.filter(contentType, body);        assertThat(actual, containsString("\"password\": \"XXX\""));    }
@Test    public void testPossibleThriftToJavaAlreadyJava() {        Object expected = Random.getObject();        Object actual = Convert.possibleThriftToJava(expected);        Assert.assertEquals(expected, actual);    }
@Test  public void testGenerateListener() throws Exception {    ClassicEngineBoot.getInstance().start();    pageableHTMLOutput.generate( new MasterReport(), 1, new ByteArrayOutputStream(), 1 );    verify( listener, times( 1 ) ).reportProcessingStarted( any( ReportProgressEvent.class ) );    verify( listener, times( 1 ) ).reportProcessingFinished( any( ReportProgressEvent.class ) );    verify( listener, atLeastOnce() ).reportProcessingUpdate( any( ReportProgressEvent.class ) );  }
@Test	public void testMark() throws IOException {		// byte[]		ByteArrayFileInputStream byteArrayFileInputStream =			new ByteArrayFileInputStream(_testFile, 2048);		Assert.assertTrue(byteArrayFileInputStream.markSupported());		for (int i = 0; i < 512; i++) {			Assert.assertEquals(i & 0xff, byteArrayFileInputStream.read());		}		byteArrayFileInputStream.mark(0);		for (int i = 512; i < 1024; i++) {			Assert.assertEquals(i & 0xff, byteArrayFileInputStream.read());		}		Assert.assertEquals(-1, byteArrayFileInputStream.read());		// In memory reset to index 512		byteArrayFileInputStream.reset();		for (int i = 512; i < 1024; i++) {			Assert.assertEquals(i & 0xff, byteArrayFileInputStream.read());		}		byteArrayFileInputStream.close();		// FileInputStream		byteArrayFileInputStream = new ByteArrayFileInputStream(_testFile, 512);		Assert.assertFalse(byteArrayFileInputStream.markSupported());		for (int i = 0; i < 1024; i++) {			Assert.assertEquals(i & 0xff, byteArrayFileInputStream.read());		}		Assert.assertEquals(-1, byteArrayFileInputStream.read());		// FileInputStream reset to index 0		byteArrayFileInputStream.reset();		// Calling reset twice does not cause a NullPointerException		byteArrayFileInputStream.reset();		for (int i = 0; i < 1024; i++) {			Assert.assertEquals(i & 0xff, byteArrayFileInputStream.read());		}		byteArrayFileInputStream.close();	}
@Test    public void testFileMd5SumEquals_OtherFile_SameContent() throws Exception {        Path path1 = Paths.get(FileDigestUtilTest.class.getResource("file1.txt").toURI());        Path path2 = Paths.get(FileDigestUtilTest.class.getResource("file2.txt").toURI());        byte[] digest1 = fileDigestUtil.getFileMd5Sum(path1);        byte[] digest2 = fileDigestUtil.getFileMd5Sum(path2);        assertTrue(Arrays.equals(digest1, digest2));    }
@Test	public void testMap() throws Exception {		Individual individual = _individualJSONObjectMapper.map(			_read("get-individual.json"));		Assert.assertNotNull(individual);		Assert.assertEquals("352412408151322817", individual.getId());		List<Individual.DataSourceIndividualPK> dataSourceIndividualPKs =			individual.getDataSourceIndividualPKs();		Assert.assertEquals(			dataSourceIndividualPKs.toString(), 1,			dataSourceIndividualPKs.size());		Individual.DataSourceIndividualPK dataSourceIndividualPK =			dataSourceIndividualPKs.get(0);		Assert.assertEquals(			"352371782732600843", dataSourceIndividualPK.getDataSourceId());		Assert.assertEquals(			"LIFERAY", dataSourceIndividualPK.getDataSourceType());		List<String> individualPKs = dataSourceIndividualPK.getIndividualPKs();		Assert.assertEquals(individualPKs.toString(), 4, individualPKs.size());		Assert.assertEquals(			"b44ed31a-baad-bb17-b0e2-c9baaa7ab65e", individualPKs.get(0));		Assert.assertEquals(			"2724f980-6a85-11e9-8b49-890d26f7ce31", individualPKs.get(1));		Assert.assertEquals(			"91918ae0-6a85-11e9-b959-a7d2bf7a2eec", individualPKs.get(2));		Assert.assertEquals(			"ba91b030-6a87-11e9-b8af-c12bc5a9fb8e", individualPKs.get(3));		List<String> individualSegmentIds =			individual.getIndividualSegmentIds();		Assert.assertEquals(			individualSegmentIds.toString(), 4, individualSegmentIds.size());		Assert.assertEquals("335470926072595570", individualSegmentIds.get(0));		Assert.assertEquals("352373609633549750", individualSegmentIds.get(1));		Assert.assertEquals("352374896208779109", individualSegmentIds.get(2));		Assert.assertEquals("352416809884371310", individualSegmentIds.get(3));	}
@Test(description = "Testing search devices when unable to search devices")    public void testSearchDevicesException() throws SearchMgtException {        SearchManagerService searchManagerService = Mockito.mock(SearchManagerServiceImpl.class, Mockito.RETURNS_MOCKS);        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getSearchManagerService"))                .toReturn(searchManagerService);        Mockito.when(searchManagerService.search(Mockito.any(SearchContext.class))).thenThrow(new SearchMgtException());        Response response = this.deviceManagementService                .searchDevices(10, 5, new SearchContext());        Assert.assertEquals(response.getStatus(), Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(),                "Expects HTTP 500 when an exception occurred while searching the device");    }
@Test    void testGetSpecificationVersion() {        final String result = instance.getSpecificationVersion();        assertNotNull(result);    }
@Test    void get10Test() {        assertEquals(10, (int) instance.get10());    }
@Test  public void testGetViewInstanceSubject() throws Exception {    EventImpl event = getEvent("MyEvent", Collections.<String, String>emptyMap(), view_xml);    Assert.assertNull(event.getViewInstanceSubject());    ViewInstanceEntity viewInstanceEntity = ViewInstanceEntityTest.getViewInstanceEntity();    event = getEvent("MyEvent", Collections.<String, String>emptyMap(), viewInstanceEntity);    Assert.assertEquals(viewInstanceEntity, event.getViewInstanceSubject());  }
@Test    public void checkColumnType() {        assertEquals(BRLActionVariableColumn.class,                     builder.getSupportedColumnType());    }
@Test  public void testExcludedConfigTypes() {    StackInfo stack = stackManager.getStack("HDP", "2.0.8");    ServiceInfo service = stack.getService("HBASE");    assertFalse(service.hasConfigType("global"));    Map<String, Map<String, Map<String, String>>> configTypes = service.getConfigTypeAttributes();    assertEquals(2, configTypes.size());    assertTrue(configTypes.containsKey("hbase-site"));    assertTrue(configTypes.containsKey("hbase-policy"));    // test version that inherits the service via version inheritance    stack = stackManager.getStack("HDP", "2.1.1");    service = stack.getService("HBASE");    assertFalse(service.hasConfigType("global"));    configTypes = service.getConfigTypeAttributes();    assertEquals(2, configTypes.size());    assertTrue(configTypes.containsKey("hbase-site"));    assertTrue(configTypes.containsKey("hbase-policy"));    assertFalse(configTypes.containsKey("global"));    // test version that inherits the service explicit service extension    // the new version also excludes hbase-policy    stack = stackManager.getStack("OTHER", "2.0");    service = stack.getService("HBASE");    assertFalse(service.hasConfigType("hbase-policy"));    assertFalse(service.hasConfigType("global"));    configTypes = service.getConfigTypeAttributes();    assertEquals(1, configTypes.size());    assertTrue(configTypes.containsKey("hbase-site"));  }
@Test    public void testCreateElement() throws Exception {    	Collection<IPayload> payloads = new ArrayList<>();    	Payload p = new Payload();    	p.setPayloadURI("cid:as_attachment");    	p.addProperty(new Property("p1", "v1"));    	payloads.add(p);    	    	OMElement piElement = PayloadInfoElement.createElement(createParent(), payloads);    	        assertNotNull(piElement);        assertEquals(PAYLOAD_INFO_ELEMENT_NAME, piElement.getQName());        Iterator it = piElement.getChildrenWithName(PART_INFO_ELEMENT_NAME);        assertTrue(it.hasNext());        it.next();        assertFalse(it.hasNext());            }
@Test  public void testGetSyncType() throws Exception {    LdapSyncSpecEntity entity = new LdapSyncSpecEntity(LdapSyncSpecEntity.PrincipalType.USERS,        LdapSyncSpecEntity.SyncType.ALL, Collections.<String>emptyList());    Assert.assertEquals(LdapSyncSpecEntity.SyncType.ALL, entity.getSyncType());    entity = new LdapSyncSpecEntity(LdapSyncSpecEntity.PrincipalType.USERS,        LdapSyncSpecEntity.SyncType.EXISTING, Collections.<String>emptyList());    Assert.assertEquals(LdapSyncSpecEntity.SyncType.EXISTING, entity.getSyncType());  }
@Test    void appendWithTruncation() {        Map<String, String> values = new LinkedHashMap<>(); // make map order deterministic for result        values.put("k1", "v1");        values.put("k2", "v2");        var param = new FieldMapLogParam(values);        var builder = new StringBuilder();        param.append(builder, Set.of(), 7);        assertThat(builder.toString())                .isEqualTo("{k1=v1,...(truncated)");    }
@Test    public void readCitations() throws Exception {                // given                doReturn(citationsWritable).when(sparkContext).sequenceFile("/path/to/citations/", Text.class, BytesWritable.class);        doReturn(citations).when(citationsWritable).mapToPair(any());                        // execute                JavaPairRDD<String, MatchableEntity> retCitations = inputReader.readCitations(sparkContext, "/path/to/citations/");                        // assert                assertTrue(retCitations == citations);                verify(sparkContext).sequenceFile("/path/to/citations/", Text.class, BytesWritable.class);        verify(citationsWritable).mapToPair(mapToEntityFunction.capture());        assertMapToEntityFunction(mapToEntityFunction.getValue());            }
@Test    void build_GetRequest() {        Request request = CoapRequestBuilder.build(CoapRequestBuilder.GET_METHOD);        assertEquals(CoAP.Code.GET, request.getCode());    }
@Test(expected = NullPointerException.class)  public void testSetElapsedTimeRolloverConditionNullArg() {    udpStreamMonitor.setElapsedTimeRolloverCondition(null);  }
@Test(expected = NumberFormatException.class)    public void noHex() {        AmsError error = AmsError.of("0xFF000000");    }
@Test  public void testToPredicate() throws InvalidQueryException {    String prop = "prop";    Predicate p = new CategoryIsEmptyPredicate(prop);    assertEquals(p, new IsEmptyOperator().toPredicate(prop, null));  }
@Test    void shouldOutputCorrectLongFormatForMajorVersionOnly()    {        BoltProtocolVersion version = new BoltProtocolVersion( 4, 0 );        assertEquals( 4L, version.toInt() );    }
@Test    public void testOnDecisionTableSelectedEventWithSelectionsWithClipboardPopulated() {        model.getMetadataCols().add(new MetadataCol52());        model.getData().add(new ArrayList<DTCellValue52>() {{            add(new DTCellValue52(1));            add(new DTCellValue52("descr"));            add(new DTCellValue52("md"));        }});        uiModel.selectCell(0,                           2);        clipboard.setData(new HashSet<Clipboard.ClipboardData>() {{            add(new DefaultClipboard.ClipboardDataImpl(0,                                                       2,                                                       model.getData().get(0).get(2)));        }});        menu.onDecisionTableSelectedEvent(new DecisionTableSelectedEvent(dtPresenter));        verify(view,               times(1)).enableCutMenuItem(eq(true));        verify(view,               times(1)).enableCopyMenuItem(eq(true));        verify(view,               times(1)).enablePasteMenuItem(eq(true));        verify(view,               times(1)).enableInsertRowAboveMenuItem(eq(true));        verify(view,               times(1)).enableInsertRowBelowMenuItem(eq(true));        verify(view,               times(1)).enableDeleteRowMenuItem(eq(true));    }
@Test	public void testParseWithContainsMethodAndDoubleType() {		AbstractThrowableAssert exception = Assertions.assertThatThrownBy(			() -> _filterParserImpl.parse("contains(doubleExternal, 7)")		).isInstanceOf(			ExpressionVisitException.class		);		exception.hasMessage("Incompatible types.");	}
@Test  public void testSetProperties() throws Exception {    ComponentTest.setProperty(component,PROPS,VALUES);  }
@Test  public void testMultipleAppends() {    byte[] rowKey = dataHelper.randomData("rk1-");    byte[] family1 = Bytes.toBytes("family1");    byte[] qualifier1 = Bytes.toBytes("qualifier1");    byte[] value1 = Bytes.toBytes("value1");    byte[] family2 = Bytes.toBytes("family2");    byte[] qualifier2 = Bytes.toBytes("qualifier2");    byte[] value2 = Bytes.toBytes("value2");    Append append = new Append(rowKey);    append.add(family1, qualifier1, value1);    append.add(family2, qualifier2, value2);    ReadModifyWriteRow readModifyWriteRow =        ReadModifyWriteRow.create(TABLE_ID, ByteString.copyFrom(rowKey));    appendAdapter.adapt(append, readModifyWriteRow);    ReadModifyWriteRowRequest request = readModifyWriteRow.toProto(requestContext);    List<ReadModifyWriteRule> rules = request.getRulesList();    Assert.assertEquals(2, rules.size());    Assert.assertEquals("family1", rules.get(0).getFamilyName());    Assert.assertEquals("qualifier1", rules.get(0).getColumnQualifier().toStringUtf8());    Assert.assertEquals("value1", rules.get(0).getAppendValue().toStringUtf8());    Assert.assertEquals("family2", rules.get(1).getFamilyName());    Assert.assertEquals("qualifier2", rules.get(1).getColumnQualifier().toStringUtf8());    Assert.assertEquals("value2", rules.get(1).getAppendValue().toStringUtf8());  }
@Test	public void testGetWhenIndexIsGreaterThanZero() {		KaleoTaskInstanceToken kaleoTaskInstanceToken =			_getKaleoTaskInstanceToken(				KaleoRuntimeTestUtil.mockKaleoTaskAssignmentInstance(					Role.class.getName(), 1),				KaleoRuntimeTestUtil.mockKaleoTaskAssignmentInstance(					User.class.getName(), 2));		LazyWorkflowTaskAssigneeList lazyWorkflowTaskAssigneeList =			new LazyWorkflowTaskAssigneeList(kaleoTaskInstanceToken, null);		KaleoRuntimeTestUtil.assertWorkflowTaskAssignee(			User.class.getName(), 2, lazyWorkflowTaskAssigneeList.get(1));		Assert.assertFalse(			_executedMethodsNames.contains(				"getFirstKaleoTaskAssignmentInstance"));		Assert.assertTrue(			_executedMethodsNames.contains("getKaleoTaskAssignmentInstances"));	}
@Test    void shouldSkipInvalidJsonLookingLikeAValidOne() {        final String invalidJson = "{invalid}";        final String filtered = unit.filter("application/custom+json", invalidJson);        assertThat(filtered, is(invalidJson));    }
@Test    public void pushPromiseNoPadding() {        Http2Frame frame = TestMessages.PUSH_PROMISE_NO_PADDING_FRAME;        assertArrayEquals(TestMessages.PUSH_PROMISE_NO_PADDING_BUFFER, toByteArray(encoder.encode(frame, null)));    }
@Test    void shouldCreateFailedFutureWithCheckedException() throws Exception    {        IOException error = new IOException( "Hello" );        CompletableFuture<Object> future = Futures.failedFuture( error ).toCompletableFuture();        assertTrue( future.isCompletedExceptionally() );        ExecutionException e = assertThrows( ExecutionException.class, future::get );        assertEquals( error, e.getCause() );    }
@Test  public void testExplicitCredentials() throws IOException, GeneralSecurityException {    Credentials credentials = Mockito.mock(Credentials.class);    configuration = new Configuration(false);    configuration.set(BigtableOptionsFactory.BIGTABLE_HOST_KEY, TEST_HOST);    configuration.set(BigtableOptionsFactory.PROJECT_ID_KEY, TEST_PROJECT_ID);    configuration.set(BigtableOptionsFactory.INSTANCE_ID_KEY, TEST_INSTANCE_ID);    configuration = BigtableConfiguration.withCredentials(configuration, credentials);    BigtableOptions options = BigtableOptionsFactory.fromConfiguration(configuration);    Credentials actualCreds = CredentialFactory.getCredentials(options.getCredentialOptions());    Assert.assertSame(credentials, actualCreds);  }
@Test  public void testRefreshAfterFailure() throws Exception {    underTest = new OAuthCredentialsCache(executorService, mockCredentials);    final AccessToken accessToken =        new AccessToken("hi", new Date(HeaderCacheElement.TOKEN_STALENESS_MS + 1));    //noinspection unchecked    Mockito.when(mockCredentials.refreshAccessToken())        // First call will throw Exception & bypass retries        .thenThrow(new IOException())        // Second call will succeed        .thenReturn(accessToken);    // First call    OAuthCredentialsCache.HeaderToken token1 =        underTest.getHeader(TIMEOUT_SECONDS, TimeUnit.SECONDS);    Assert.assertFalse(token1.getStatus().isOk());    // Now the second token should be available    OAuthCredentialsCache.HeaderToken token2 =        underTest.getHeader(TIMEOUT_SECONDS, TimeUnit.SECONDS);    Assert.assertTrue(token2.getStatus().isOk());    Assert.assertThat(token2.getHeader(), containsString("hi"));    // Make sure that the token was only requested twice: once for the first failure & second time    // for background recovery    Mockito.verify(mockCredentials, times(2)).refreshAccessToken();  }
@Test    public void testInitDatePickerByRuleAttribute() {        final DatePicker datePicker = mock(DatePicker.class);        final String attributeValue = "31-May-2018";        doReturn(attributeValue).when(ruleAttribute).getValue();        factory.initDatePickerByRuleAttribute(datePicker, ruleAttribute);        // not robust verifications because of Date formatting / parsing is mocked by GwtMockito        verify(datePicker).setFormat(any());        verify(datePicker).setValue(notNull(Date.class));    }
@Test    public void onShoppingCartQuantityUpdated_updatesViewWithNewQuantity_whenCartItemIsSameAsCurrentOne() {        ShoppingCartQuantityChangeEvent updateEvent =                new ShoppingCartQuantityChangeEvent(currentShoppingCartItem, NEW_QUANTITY);        presenter.onShoppingCartQuantityChanged(updateEvent);        verify(view).updateQuantity(NEW_QUANTITY);    }
@Test  public void testInstallInputOrgInPropertiesFileExpectsAddedToService() throws Exception {    Organization org1 = EasyMock.createMock(Organization.class);    EasyMock.expect(org1.getId()).andReturn("org1").anyTimes();    EasyMock.replay(org1);    Organization org2 = EasyMock.createMock(Organization.class);    EasyMock.expect(org2.getId()).andReturn("org2").anyTimes();    EasyMock.replay(org2);    EasyMock.expect(securityService.getOrganization()).andReturn(org1).anyTimes();    EasyMock.replay(securityService);    File file = getResourceFile("/ListProvidersScannerTest-WithOrg.properties");    listProvidersScanner.install(file);    ResourceListQuery query = new ResourceListQueryImpl();    assertEquals(1, listProvidersService.getAvailableProviders().size());    assertEquals(listName, listProvidersService.getAvailableProviders().get(0));    assertEquals("org1", org1.getId());    assertTrue("Provider is not registered", listProvidersService.hasProvider(listName, org1.getId()));    Map<String, String> dictionary = listProvidersService.getList(listName, query, false);    assertEquals(3, dictionary.size());    assertEquals("TEST.VALUE.1", dictionary.get("TEST.KEY.1"));    assertEquals("TEST.VALUE.2", dictionary.get("TEST.KEY.2"));    assertEquals("TEST.VALUE.3", dictionary.get("TEST.KEY.3"));  }
@Test    public void resolvesComplementaryAngle() {        final Degrees<Double> first = new Degrees.Default<>(Math.random());        final Degrees<Double> second = new Degrees.Default<>(Math.random());        final Degrees<Double> third = new Degrees.Default<>(Math.random());        final InnerProduct<Double> pdt = new MkProduct<>();        final double error = 1.e-6;        MatcherAssert.assertThat(            new Complementary<>(first).resolve(pdt).doubleValue()                + first.resolve(pdt).doubleValue(),            Matchers.closeTo(Math.PI / 2, error)        );        MatcherAssert.assertThat(            new Complementary<>(second).resolve(pdt).doubleValue()                + second.resolve(pdt).doubleValue(),            Matchers.closeTo(Math.PI / 2, error)        );        MatcherAssert.assertThat(            new Complementary<>(third).resolve(pdt).doubleValue()                + third.resolve(pdt).doubleValue(),            Matchers.closeTo(Math.PI / 2, error)        );    }
@Test    void testTrace4() {        instance.trace(FORMATTING_MESSAGE2, MESSAGE, MESSAGE2);        assertTrue(output.contains(FORMATTING_MESSAGE_PREFIX + "|" + MESSAGE + "|" + MESSAGE2));    }
@Test    public void convertToMatchableEntities() {                // given                ReferenceMetadata ref1 = createReference("XXX");        ReferenceMetadata ref2 = createReference("YYY");                String doc1 = "DOC!";        Tuple2<String, ReferenceMetadata> refTuple1 = new Tuple2<>(doc1, ref1);        Tuple2<String, ReferenceMetadata> refTuple2 = new Tuple2<>(doc1, ref2);                List<Tuple2<String, ReferenceMetadata>> references = Lists.newArrayList();        references.add(refTuple1);        references.add(refTuple2);                        MatchableEntity entity1 = Mockito.mock(MatchableEntity.class);        when(entity1.id()).thenReturn("1");                MatchableEntity entity2 = Mockito.mock(MatchableEntity.class);        when(entity2.id()).thenReturn("2");                when(rawReferenceToEntityConverter.convert(new CitEntityId(doc1, ref1.getPosition()), ref1.getRawCitationText())).thenReturn(entity1);        when(rawReferenceToEntityConverter.convert(new CitEntityId(doc1, ref2.getPosition()), ref2.getRawCitationText())).thenReturn(entity2);                        // execute                List<Tuple2<String, MatchableEntity>> docIdEntities = referenceMetadataConverter.convertToMatchableEntities(references.iterator());                // assert                assertEquals(2, docIdEntities.size());        assertTrue(docIdEntities.get(0)._2() == entity1);        assertEquals(docIdEntities.get(0)._1(), "1");        assertTrue(docIdEntities.get(1)._2() == entity2);        assertEquals(docIdEntities.get(1)._1(), "2");    }
@Test  public void testSearchObjectsNoResult() throws Exception {    when(objectFactDao.searchObjects(any())).thenReturn(ResultContainer.<ObjectRecord>builder().build());    ResultSet<Object> result = delegate.handle(new SearchObjectRequest());    assertEquals(25, result.getLimit());    assertEquals(0, result.getCount());    assertEquals(0, ListUtils.list(result.iterator()).size());    verify(requestConverter).apply(notNull());    verify(objectFactDao).searchObjects(notNull());    verifyNoMoreInteractions(objectFactDao);  }
@Test  public void testInOperator() throws Exception {    QueryLexer lexer = new QueryLexer();    Token[] tokens = lexer.tokens("foo.in(one, two, 3)");    List<Token> listTokens = new ArrayList<Token>();    listTokens.add(new Token(Token.TYPE.RELATIONAL_OPERATOR_FUNC, ".in("));    listTokens.add(new Token(Token.TYPE.PROPERTY_OPERAND, "foo"));    listTokens.add(new Token(Token.TYPE.VALUE_OPERAND, "one, two, 3"));    listTokens.add(new Token(Token.TYPE.BRACKET_CLOSE, ")"));    assertArrayEquals(listTokens.toArray(new Token[listTokens.size()]), tokens);  }
@Test  public void testFromEntityWithNullEntity() {    assertNull(converter.fromEntity(null));  }
@Test(expected = UnsupportedOperationException.class)    public void testSetRepository() throws Exception {        this.allThesaurus.setRepository(Mockito.mock(LocalRepository.class));    }
@Test  public void testDoUpdateForClusterCreate_DBHostProperty__exportedValue() throws Exception {    Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();    Map<String, String> hiveSiteProps = new HashMap<String, String>();    hiveSiteProps.put("javax.jdo.option.ConnectionURL", "jdbc:mysql://%HOSTGROUP::group1%/hive?createDatabaseIfNotExist=true");    Map<String, String> hiveEnvProps = new HashMap<String, String>();    hiveEnvProps.put("hive_database", "New MySQL Database");    properties.put("hive-site", hiveSiteProps);    properties.put("hive-env", hiveEnvProps);    Configuration clusterConfig = new Configuration(properties, Collections.<String, Map<String, Map<String, String>>>emptyMap());    Collection<String> hgComponents = new HashSet<String>();    hgComponents.add("NAMENODE");    hgComponents.add("SECONDARY_NAMENODE");    hgComponents.add("RESOURCEMANAGER");    hgComponents.add("MYSQL_SERVER");    TestHostGroup group1 = new TestHostGroup("group1", hgComponents, Collections.singleton("testhost"));    Collection<String> hgComponents2 = new HashSet<String>();    hgComponents2.add("DATANODE");    hgComponents2.add("HDFS_CLIENT");    TestHostGroup group2 = new TestHostGroup("group2", hgComponents2, Collections.singleton("testhost2"));    Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>();    hostGroups.add(group1);    hostGroups.add(group2);    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor updater = new BlueprintConfigurationProcessor(topology);    updater.doUpdateForClusterCreate();    String updatedVal = topology.getConfiguration().getFullProperties().get("hive-site").get("javax.jdo.option.ConnectionURL");    assertEquals("jdbc:mysql://testhost/hive?createDatabaseIfNotExist=true", updatedVal);  }
@Test  public void testDefaultInstall() throws Exception {    EasyMock.expect(securityService.getOrganization()).andReturn(defaultOrg).anyTimes();    EasyMock.expect(defaultOrg.getId()).andReturn("mh_default_org").anyTimes();    File file = getResourceFile("/ListProvidersScannerTest-GoodProperties.properties");    listProvidersScanner.install(file);    EasyMock.replay(securityService, defaultOrg);    assertTrue("Provider has not been registered", listProvidersService.hasProvider(listName));    assertEquals(1, listProvidersService.getAvailableProviders().size());    assertEquals(3, listProvidersService            .getList(listName, null, false).size()    );    assertEquals(listName, listProvidersService.getAvailableProviders().get(0));    assertEquals("TEST.VALUE.1", listProvidersService            .getList(listName, null, false)            .get("TEST.KEY.1")    );  }
@Test    public void onDeleteSelectedCellsWithoutSelections() {        dtPresenter.onDeleteSelectedCells();        verify(synchronizer,               never()).deleteCell(any(GridData.Range.class),                                   any(Integer.class));    }
