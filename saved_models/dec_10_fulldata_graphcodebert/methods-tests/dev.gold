@Test  public void testDoUpdateForClusterCreate_MultiHostProperty_exportedValues_withPorts_singleHostValue() throws Exception {    Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>();    Map<String, String> yarnSiteConfig = new HashMap<String, String>();    yarnSiteConfig.put("hadoop.registry.zk.quorum", "%HOSTGROUP::host_group_1%:2181");    properties.put("yarn-site", yarnSiteConfig);    Configuration clusterConfig = new Configuration(properties, Collections.<String, Map<String, Map<String, String>>>emptyMap());    Collection<String> hgComponents = new HashSet<String>();    hgComponents.add("NAMENODE");    hgComponents.add("SECONDARY_NAMENODE");    hgComponents.add("ZOOKEEPER_SERVER");    TestHostGroup group1 = new TestHostGroup("host_group_1", hgComponents, Collections.singleton("testhost"));    Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>();    hostGroups.add(group1);    ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups);    BlueprintConfigurationProcessor updater = new BlueprintConfigurationProcessor(topology);    updater.doUpdateForClusterCreate();    assertEquals("Multi-host property with single host value was not correctly updated for cluster create.",      "testhost:2181", topology.getConfiguration().getFullProperties().get("yarn-site").get("hadoop.registry.zk.quorum"));  }
@Test(expected = InvalidArgumentException.class)  public void testResolveFactTypeByIdThrowsException() throws Exception {    resolver.resolveFactType(UUID.randomUUID().toString());  }
@Test    void encode() {        final String hashed = TenantState.encode("The quick brown fox jumps over the lazy dog.");        assertThat(hashed).isEqualTo("e4d909c290d0fb1ca068ffaddf22cbd0");    }
@Test    public void setRightController_setHeightAndWidthWithOptions() {        SideMenuOptions options = new SideMenuOptions();        options.height = new Number(100);        options.width = new Number(200);        uut.options.sideMenuRootOptions.left = options;        SimpleComponentViewController componentViewController = new SimpleComponentViewController(activity, childRegistry, "left", new Options());        uut.setLeftController(componentViewController);        int heightInDp = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 100, Resources.getSystem().getDisplayMetrics());        int widthInDp = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 200, Resources.getSystem().getDisplayMetrics());        LayoutParams params = componentViewController.getView().getLayoutParams();        assertThat(params.width).isEqualTo(widthInDp);        assertThat(params.height).isEqualTo(heightInDp);    }
@Test    public void shouldResolveAccessPattern() throws Exception {        final Table table = createTable();        final AccessPattern accessPattern = table.addAccessPattern(getTransaction(), "accessPattern");        final KomodoObject kobject = new ObjectImpl(_repo, accessPattern.getAbsolutePath(), accessPattern.getIndex());        assertThat(this.wsMgr.resolve(getTransaction(), kobject, AccessPattern.class), is(instanceOf(AccessPattern.class)));    }
@Test    public void testTraceFormat()    {        inner.setLevel(Level.FINEST);        logger.trace("hello, %s", "you");        assertLog(Level.FINEST, "hello, you");    }
@Test    void writeBoth() throws IOException {        when(formatter.format(correlation, request)).thenReturn("request");        when(formatter.format(correlation, response)).thenReturn("response");        unit.writeBoth(correlation, request, response);        verify(writer).write((Precorrelation) correlation, "request");        verify(writer).write(correlation, "response");    }
@Test  public void shouldDeleteGCPKeysIfSecretAlreadyExists() throws IOException {    when(serviceAccountKeyManager.serviceAccountExists(SERVICE_ACCOUNT)).thenReturn(true);    ServiceAccountKey jsonKey = new ServiceAccountKey();    jsonKey.setName("key.json");    jsonKey.setPrivateKeyData("json-private-key-data");    ServiceAccountKey p12Key = new ServiceAccountKey();    p12Key.setName("key.p12");    p12Key.setPrivateKeyData("p12-private-key-data");    when(serviceAccountKeyManager.createJsonKey(any(String.class))).thenReturn(jsonKey);    when(serviceAccountKeyManager.createP12Key(any(String.class))).thenReturn(p12Key);    when(k8sClient.createSecret(any())).thenThrow(new KubernetesClientException(        "Already exists", 409, new Status()));    sut.ensureServiceAccountKeySecret(WORKFLOW_ID.toString(), SERVICE_ACCOUNT);    verify(serviceAccountKeyManager).createJsonKey(SERVICE_ACCOUNT);    verify(serviceAccountKeyManager).createP12Key(SERVICE_ACCOUNT);    verify(serviceAccountKeyManager).tryDeleteKey(jsonKey.getName());    verify(serviceAccountKeyManager).tryDeleteKey(p12Key.getName());  }
@Test    void logError() {        logManager.logError(new TestException());    }
@Test  public void testReadUnsignedShort_EOFforOneByte_BigEndian_EOFException() throws Exception {    assertThrows(EOFException.class, () -> asInputStream((byte) 1).readUnsignedShort(JBBPByteOrder.BIG_ENDIAN));  }
@Test    public void testAdd_MultipleDocumentsWithTheirOwnIds() {                String idA = DOCUMENT_ID + "A";        String idB = DOCUMENT_ID + "B";                IdAddingSolrUpdateWriter updateWriter = new IdAddingSolrUpdateWriter(                UNIQUE_KEY_FIELD, DOCUMENT_ID, null, TABLE_NAME, updateCollector);                SolrInputDocument docA = mock(SolrInputDocument.class);        SolrInputDocument docB = mock(SolrInputDocument.class);                SolrInputField keyFieldA = new SolrInputField(UNIQUE_KEY_FIELD);        keyFieldA.setValue(idA, 1.0f);        SolrInputField keyFieldB = new SolrInputField(UNIQUE_KEY_FIELD);        keyFieldB.setValue(idB, 1.0f);                        when(docA.getField(UNIQUE_KEY_FIELD)).thenReturn(keyFieldA);        when(docB.getField(UNIQUE_KEY_FIELD)).thenReturn(keyFieldB);        updateWriter.add(docA);        updateWriter.add(docB);        verify(updateCollector).add(idA, docA);        verify(updateCollector).add(idB, docB);    }
@Test(expected = ObjectNotFoundException.class)  public void testFetchObjectTypeNotFound() throws Exception {    UUID id = UUID.randomUUID();    when(objectTypeRequestResolver.fetchExistingObjectType(id)).thenThrow(ObjectNotFoundException.class);    delegate.handle(new GetObjectTypeByIdRequest().setId(id));  }
@Test  public void testConvertRequestFilterOnMinMax() throws Exception {    FactSearchCriteria criteria = converter.apply(new SearchObjectFactsRequest()            .setMinimum(0.1f)            .setMaximum(0.2f)            .setDimension(Dimension.trust)    );    assertEquals(0.1f, (Float) criteria.getMinNumber(), 0.0);    assertEquals(0.2f, (Float) criteria.getMaxNumber(), 0.0);    assertEquals(SetUtils.set(FactSearchCriteria.NumberFieldStrategy.trust), criteria.getNumberFieldStrategy());    assertEquals(FactSearchCriteria.MatchStrategy.any, criteria.getNumberMatchStrategy());  }
@Test    public void encode() throws Exception {        ArrayList<Object> out = new ArrayList<>();        SUT.encode(null, amsPacket, out);        assertEquals(1, out.size());        assertThat(out, hasSize(1));    }
@Test    public void sampleWithSamplerEmitAndTerminate() {        PublishSubject<Integer> source = PublishSubject.create();        PublishSubject<Integer> sampler = PublishSubject.create();        Observable<Integer> m = source.sample(sampler);        m.subscribe(observer2);        source.onNext(1);        source.onNext(2);        sampler.onNext(1);        source.onNext(3);        source.onCompleted();        sampler.onNext(2);        sampler.onCompleted();        InOrder inOrder = inOrder(observer2);        inOrder.verify(observer2, never()).onNext(1);        inOrder.verify(observer2, times(1)).onNext(2);        inOrder.verify(observer2, never()).onNext(3);        inOrder.verify(observer2, times(1)).onCompleted();        inOrder.verify(observer2, never()).onNext(any());        verify(observer, never()).onError(any(Throwable.class));    }
@Test(expected = NullPointerException.class)   public void shouldFailPoolingNullBuffer() {      pool.release(null);   }
@Test  public void getNumArs() {    assertEquals(3, new TypeConstructorExpr("foo", exprsList()).getNumArgs());  }
@Test  public void testGetFactTypeByNameTwiceReturnsSameInstance() {    FactTypeEntity entity = createAndSaveFactType();    FactTypeEntity type1 = getFactManager().getFactType(entity.getName());    FactTypeEntity type2 = getFactManager().getFactType(entity.getName());    assertSame(type1, type2);  }
@Ignore  @Test  public void testImportAtPoint4() throws Exception {    JavaAnalyzer analyzer = getAnalyzer();    JavaImportCompletion completion = new JavaImportCompletion(GradleTestBase::getProject);    String cp = getClasspath();    File file =        new File(project.getProjectRootPath(), "./src/test/resources/MissingImport5.java")            .getCanonicalFile();    assertTrue(file.exists());    Optional<Map<String, List<String>>> map =        completion.importAtPoint(file, 0, 0, "CASE_INSENSITIVE_ORDER");    assertTrue(map.isPresent());    System.out.println(map.get());  }
@Test	public void testFilterByAuthor() throws Exception, Throwable {		// Arrange		String expectedResponse = fileReader				.readFile("unitTestAdhocQueryResponseFiltered.xml");		AdhocQueryResponse responseMock = marshaller.unmarshalFromXml(				AdhocQueryResponse.class,				fileReader.readFile("unitTestAdhocQueryResponse.xml"));		// Act		AdhocQueryResponse actualResponse = sut.filterByAuthor(responseMock,				"1114252178");		String actualResponseXmlString = marshaller.marshal(actualResponse);		// Assert		assertXMLEqual("", expectedResponse, actualResponseXmlString);	}
@Test  public void shouldGetAllWorkflowsOfAComponent() throws Exception {    final List<Workflow> workflows = Arrays.asList(WORKFLOW_1, WORKFLOW_2);    when(client.send(any(Request.class)))        .thenReturn(CompletableFuture.completedFuture(response(HTTP_OK, workflows)));    final String componentId = WORKFLOW_1.componentId();    final CompletableFuture<List<Workflow>> r = styx.workflows(componentId).toCompletableFuture();    verify(client, timeout(30_000)).send(requestCaptor.capture());    assertThat(r.isDone(), is(true));    final Request request = requestCaptor.getValue();    final HttpUrl url = API_URL.newBuilder().addPathSegment("workflows")        .addPathSegment(componentId).build();    assertThat(request.url().toString(), is(url.uri().toString()));    assertThat(request.method(), is("GET"));    assertThat(r.join(), is(workflows));  }
@Test(dataProvider = "treeLevels")	public void crossover1(final int level1, final int level2) {		final Random random = new Random();		final TreeNode<Integer> tree1 = newTree(level1, random);		final TreeNode<Integer> tree2 = newTree(level2, random);		final int size1 = tree1.size();		final int size2 = tree2.size();		SingleNodeCrossover.swap(tree1, tree2);		Assert.assertEquals(tree1.size() + tree2.size(), size1 + size2);	}
@Test    public void exceptionsForConsumersAreConverted() {        thrown.expect(RuntimeException.class);        thrown.expectMessage("Duh, something went wrong");        Stream.of(true).forEach(toConsumer(this::consumerMethodWithChecked, logger));    }
@Test  public void resolve_missing_expression() {    BindingTuple bindingTuple =        ExprValueUtils.tupleValue(ImmutableMap.of("ip", "209.160.24.63")).bindingTuples();    assertEquals(ExprValueUtils.LITERAL_MISSING,        bindingTuple.resolve(DSL.ref("ip_missing", STRING)));  }
@Test  public void testGetElementAt() {    final int[] etalon = new int[] {-27834, 23423, 0, -2, 3};    final Serializable payload = new FakePayload();    test.setPayload(payload);    for (int i = 0; i < etalon.length; i++) {      final JBBPFieldShort f = test.getElementAt(i);      assertSame(payload, f.getPayload());      assertEquals(etalon[i], f.getAsInt());    }  }
@Test  public void testWithInjectOnlyDirectInject() {    prep(Inject.class);    TestClassWithInjectParams testObject = new TestClassWithInjectParams();    mRealObjectMaker.injectObject(        mDependencyProvider,        testObject,        TypeToken.of(TestClassWithInjectParams.class));    assertTestObjectNormal(testObject, TestClassWithInjectParams.class);    verifyDependencyProviderCalls(runnableKey, runnableProviderKey);    assertThat(testObject.mRunnable).isEqualTo(mRunnableMock);    assertThat(testObject.mRunnableProvider).isEqualTo(mRunnableProviderMock);  }
@Test  public void testNormalize() throws Exception {    Response response = restService.normalize(MediaPackageElementParser.getAsXml(audioTrack), -30f);    Assert.assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());    Assert.assertEquals(new JaxbJob(job), response.getEntity());  }
@Test    void get4Test() {        assertEquals(4, (int) instance.get4().orElseThrow(NoSuchElementException::new));    }
@Test    public void testIsApplicable_WrongColumnFamily() {        assertFalse(extractor.isApplicable(new KeyValue(ROW, Bytes.toBytes("wrong family"), Bytes.toBytes("AB"), Bytes.toBytes("value"))));    }
@Test public void find2()    {        TripleTable table = createTripleTableMem();        add(table, n1, n2, n3);        add(table, n1, n2, n4);        contains(table, n1, n2, n3);        contains(table, n1, n2, n4);    }
@Test    public void testIsDifferentRegions() {        Tier tier = new Tier("name1", new Integer(1), new Integer(5), new Integer(1), null);        tier.setRegion("region1");        Tier tier2 = new Tier("name2", new Integer(1), new Integer(5), new Integer(1), null);        tier.setRegion("region2");        Set<Tier> tiers = new HashSet<Tier>();        tiers.add(tier);        tiers.add(tier2);        Environment env = new Environment();        env.setName("environmentName");        env.addTier(tier);        env.addTier(tier2);        boolean result = env.isDifferentRegions();        assertEquals(result, true);    }
@Test    void get22() {        assertEquals(m22, instance.get22());    }
@Test    public void testCreateDM() {        DMCreateRequest req = DMCreateRequest.builder().recipientId(Snowflake.asString(user)).build();        userService.createDM(req).block();    }
@Test public void testBitsTest3()    {        int v = 0x76543210 ;        assertTrue(BitsInt.test(v, v, 0, 32)) ;    }
@Test    public void testDayGridPositionAtLocationFirstColumnRToLWithWeekNumber() {        // This test will not work in a headless configuration.        if (GraphicsEnvironment.isHeadless()) {            LOG.fine("cannot run test - headless environment");            return;        }        BasicMonthViewUI ui = getRealizedMonthViewUI(ComponentOrientation.RIGHT_TO_LEFT, true);        Point location = getLocationInColumn(ui, BasicMonthViewUI.DAYS_IN_WEEK - 1);        Point dayGridPosition = ui.getDayGridPositionAtLocation(location.x, location.y);         assertEquals("last logical column in RToL", BasicMonthViewUI.FIRST_DAY_COLUMN,                 dayGridPosition.x);     }
@Test    public void printBirthInfo() {//        FortuneConstellation.printBirthInfo("2018-02-04T22:30:30");//        FortuneConstellation.printBirthInfo("2019-03-12T22:30:30");        FortuneConstellation.printBirthInfo("1993-01-16T04:30:30");        FortuneConstellation.printBirthInfo("1994-02-04T11:15:30");    }
@Test    public void test_createRole_failure_400() throws TVaultValidationException {        String token = "5PDrOhsy4ig8L3EpsJZSLAMg";        UserDetails userDetails = getMockUser(false);        AWSLoginRole awsLoginRole = new AWSLoginRole("ec2", "mytestawsrole", "ami-fce3c696",                "1234567890123", "us-east-2", "vpc-2f09a348", "subnet-1122aabb",                "arn:aws:iam::8987887:role/test-role", "arn:aws:iam::877677878:instance-profile/exampleinstanceprofile",                "\"[prod, dev\"]");        String responseJson = "{\"errors\":[\"Invalid path specified\"]}";        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseJson);        when(ControllerUtil.isPathValid("shared/mysafe01")).thenReturn(false);        ResponseEntity<String> responseEntity = selfSupportService.createRole(userDetails, token, awsLoginRole,"shared/mysafe01");        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());        assertEquals(responseEntityExpected, responseEntity);    }
@Test  public void testRequestTimer() {    underTest.add(createEntry());    Assert.assertFalse(underTest.currentBatch.wasSent());    underTest.currentBatch.lastRpcSentTimeNanos = time.get();    Assert.assertFalse(underTest.currentBatch.isStale());    time.addAndGet(BulkMutation.MAX_RPC_WAIT_TIME_NANOS - 1);    Assert.assertFalse(underTest.currentBatch.isStale());    time.addAndGet(1);    Assert.assertTrue(underTest.currentBatch.isStale());  }
@Test	public void components_are_identified_by_name() {		Level level = new Level("dummy");		Component a = level.component("a");		Component b = level.component("b");		assertThat(a).isNotSameAs(b);		Component secondReferenceToA = level.component("a");		assertThat(a).isSameAs(secondReferenceToA);	}
@Test    public void testPermittedTopology_polygon_linestring() {        DimensionInfo sourceDimensionInfo = DimensionInfo.XY_POLYGON;        DimensionInfo targetDimensionInfo = DimensionInfo.XY_LINESTRING;        EhCoversFF instance = new EhCoversFF();        boolean expResult = true;        boolean result = instance.permittedTopology(sourceDimensionInfo, targetDimensionInfo);        assertEquals(expResult, result);    }
@Test  public void testUpdate() {    MultiNormal f = new MultiNormal(20);    Vector a = f.sample();    Vector b = f.sample();    Vector c = f.sample();    DenseVector x = new DenseVector(a);    Centroid x1 = new Centroid(1, x);    x1.update(new Centroid(2, new DenseVector(b)));    Centroid x2 = new Centroid(x1);    x1.update(c);    // check for correct value    Vector mean = a.plus(b).plus(c).assign(Functions.div(3));    assertEquals(0, x1.getVector().minus(mean).norm(1), 1.0e-8);    assertEquals(3, x1.getWeight(), 0);    assertEquals(0, x2.minus(a.plus(b).divide(2)).norm(1), 1.0e-8);    assertEquals(2, x2.getWeight(), 0);    assertEquals(0, new Centroid(x1.getIndex(), x1, x1.getWeight()).minus(x1).norm(1), 1.0e-8);    // and verify shared storage    assertEquals(0, x.minus(x1).norm(1), 0);    assertEquals(3, x1.getWeight(), 1.0e-8);    assertEquals(1, x1.getIndex());  }
@Test    public void onEditTabSelected() {        scenarioSimulationEditorKogitoWrapperSpy.onEditTabSelected();        verify(scenarioSimulationEditorPresenterMock, times(1)).onEditTabSelected();    }
@Test  public void testDefaulPolicyInterruption() throws IOException, InterruptedException, TimeoutException {    try {      Thread t = Thread.currentThread();      DefaultScheduler.INSTANCE.schedule(() -> t.interrupt(), 1, TimeUnit.SECONDS);      RetryPolicy.newBuilder()            .withRetryOnException(Exception.class, Integer.MAX_VALUE)            .build().run(() -> {        throw new IOException();      }, IOException.class);      Assert.fail();    } catch (InterruptedException ex) {      // expected    }  }
@Test	public void catalogoTablasTemporalesDBEntityTest() {		Assert.notNull(getManager(), "ArchidocManager es nulo");		ICatalogoTablasTemporalesDBEntity dbEntity = getManager()				.getCatalogoTablasTemporalesDBEntity();		Assert.notNull(dbEntity, "entity es nulo");		Assert.isTrue(ArchivoTables.ASGFCTLGTBLTMP_TABLE_NAME.equals(dbEntity				.getTableName()),"Las tablas no coinciden");		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount()));	}
@Test    public void addInverseDelegatesToFieldAddition() {        final MkAddition<Object> add = new MkAddition<>(new String());        final SpyField<Object> field = new SpyField<>(            new MkField<Object>(new Object(), add)        );        final Scalar<Object> scalar = new Scalar.Default<>(new Object());        new AddInverse<>(scalar).value(field);        MatcherAssert.assertThat(            add.inverted(), Matchers.is(true)        );        MatcherAssert.assertThat(            field.calls().additioned(), Matchers.is(true)        );    }
@Test    public void getMockLoginDetails_Test() {        CertManagerLogin certManagerLogin = nclmMockUtil.getMockLoginDetails();        assertNotNull(certManagerLogin);    }
@Test(expectedExceptions = LoadException.class)  public void unparsableJson() throws LoadException {    // GIVEN    String json = //        "[ { \"a\": 0,\"b\": " + Long.MAX_VALUE + "9 }]";    // WHEN    loader.load(0L, new BigByteBuffer(json.getBytes()), TABLE, colInfo);    // THEN: exception  }
@Test  public void wash() throws Exception {    WashingMachine washingMachine = new WashingMachine();    ExecutorService executorService = Executors.newFixedThreadPool(2);    executorService.execute(washingMachine::wash);    executorService.execute(() -> {      washingMachine.wash();      machineStateGlobal = washingMachine.getWashingMachineState();    });    executorService.shutdown();    try {      executorService.awaitTermination(10, TimeUnit.SECONDS);    } catch (InterruptedException ie) {      ie.printStackTrace();    }    assertEquals(WashingMachineState.WASHING, machineStateGlobal);  }
@Test    public void testCallMethodAll() {        Map<String, ZuulRoute> routes = new LinkedHashMap<>();        ZuulRoute route = new ZuulRoute("idFoo", "/v2/api/foo", null, "my.dns.com.br", true, null, Collections.newSetFromMap(new ConcurrentHashMap<>()));        routes.put("/v2/api/foo", route);        Credential opPost = new Credential(HttpMethod.POST.name(), "/api/foo/{id}", "/v2", "apiName", 10L, 88L, 10L, false);        Credential opDelete = new Credential(HttpMethod.DELETE.name(), "/api/foo/{id}", "/v2", "apiName", 11L, 88L, 10L, false);        Credential opAll = new Credential(HttpMethod.ALL.name(), "/api/foo/{id}", "/v2", "apiName", 12L, 88L, 10L, false);        Mockito.when(routeLocator.getAtomicRoutes()).thenReturn(new AtomicReference<>(routes));        Mockito.when(credentialRepository.findByPattern("/v2/api/foo")).thenReturn(Lists.newArrayList(opPost, opDelete, opAll));        HeimdallRoute heimdallRoute = this.filter.getMatchingHeimdallRoute("/v2/api/foo", HttpMethod.GET.name(), this.ctx);        assertNotNull(heimdallRoute);        assertEquals("/api/foo", heimdallRoute.getRoute().getPath());    }
@Test    public void followingEncodedEntitiesAreProperlyKept()    {        String content = "<p><textarea>&#123;&#123;velocity}}machin&#123;&#123;/velocity}}</textarea></p>";        Document document = this.cleaner.clean(new StringReader(content));        String textareaContent = document.getElementsByTagName("textarea").item(0).getTextContent();        assertEquals("&#123;&#123;velocity}}machin&#123;&#123;/velocity}}", textareaContent);        assertHTML("<p><textarea>&#123;&#123;velocity}}machin&#123;&#123;/velocity}}</textarea></p>", content);    }
@Test    public void testClearProgress() throws Exception {        Map<String, Object> contextMap = Maps.newHashMap();        ProgressControl control = new ProgressControl(UPLOAD_ID, 100);        control.setContextMap(contextMap);        assertNull(contextMap.get(ATTRIBUTE_NAME));        control.advance(50);        assertNotNull(contextMap.get(ATTRIBUTE_NAME));        control.clearProgress();        assertNull(contextMap.get(ATTRIBUTE_NAME));    }
@Test(expected = IllegalArgumentException.class)    public void notDateB() {        getHeight("2013-13-01-");    }
@Test	public void testReadInvalidRow() throws Exception {		try (CSVBatchEngineImportTaskItemReader				csvBatchEngineImportTaskItemReader =					_getCSVBatchEngineImportTaskItemReader(						FIELD_NAMES, StringPool.COMMA,						new Object[][] {							{								"", "sample description", 1, "sample name",								"naziv", "unknown column"							}						})) {			try {				csvBatchEngineImportTaskItemReader.read();				Assert.fail();			}			catch (ArrayIndexOutOfBoundsException						arrayIndexOutOfBoundsException) {			}		}	}
@Test    public void importScesimModel() throws IOException {        String raw = "";        importExportService.importScesimModel(ImportExportType.CSV, raw, simulationMock);        verify(scenarioCsvImportExportMock, times(1)).importData(eq(raw), eq(simulationMock));        when(scenarioCsvImportExportMock.importData(anyString(), any())).thenThrow(new IllegalStateException());        assertThatThrownBy(() -> importExportService                .importScesimModel(ImportExportType.CSV, raw, simulationMock))                .isInstanceOf(GenericPortableException.class);    }
@Test    public void testInvoke_DefaultHandlerExceptionResolver_responseCode_2xx() throws Throwable {        // do setup for test case.        NullPointerException occurException = new NullPointerException("null pointer exception.");        HttpServletResponse mockResponse = mock(HttpServletResponse.class);        DefaultHandlerExceptionResolver resolver = new DefaultHandlerExceptionResolver();        when(mockMethodInvocation.proceed()).thenReturn("viewname");        when(mockMethodInvocation.getThis()).thenReturn(resolver);        when(mockResponse.getStatus()).thenReturn(200);        when(mockMethodInvocation.getArguments()).thenReturn(new Object[] {                null, mockResponse, null, occurException });        // do test.        testTarget.invoke(mockMethodInvocation);        // do assert.        verify(mockExceptionLogger, times(1)).info((Exception) any());    }
@Test    public void testGetHostName() throws Exception    {        assertEquals( HOSTNAME, environmentContainer.getHostname() );    }
@Test    void shouldReturnZeroActiveCountForUnknownAddress()    {        assertEquals( 0, tracker.inUseChannelCount( address ) );    }
@Test   public void testTypedProperties() throws Exception {      SimpleString longKey = RandomUtil.randomSimpleString();      long longValue = RandomUtil.randomLong();      SimpleString simpleStringKey = RandomUtil.randomSimpleString();      SimpleString simpleStringValue = RandomUtil.randomSimpleString();      TypedProperties otherProps = new TypedProperties();      otherProps.putLongProperty(longKey, longValue);      otherProps.putSimpleStringProperty(simpleStringKey, simpleStringValue);      props.putTypedProperties(otherProps);      long ll = props.getLongProperty(longKey);      Assert.assertEquals(longValue, ll);      SimpleString ss = props.getSimpleStringProperty(simpleStringKey);      Assert.assertEquals(simpleStringValue, ss);   }
@Test	public void testRemove() throws Exception {		JButton button = new JButton();		BuddySupport.addLeft(button, tf);		BuddySupport.remove(button, tf);		Assert.assertSame(0, BuddySupport.getLeft(tf).size());		Assert.assertSame(0, tf.getComponentCount());	}
@Test    public void test_readAppRoleSecretId_successfully() {        String token = "5PDrOhsy4ig8L3EpsJZSLAMg";        String responseJson = "{\r\n" +         		"  \"data\": {\r\n" +         		"    \"secret_id\": \"generated-secret-id\",\r\n" +         		"    \"secret_id_accessor\": \"generated-accessor-id\"\r\n" +         		"  }\r\n" +         		"}";        Response response =getMockResponse(HttpStatus.OK, true, responseJson);        String appRoleName = "approle1";        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseJson);                when(reqProcessor.process("/auth/approle/secretid/lookup","{\"role_name\":\""+appRoleName+"\"}",token)).thenReturn(response);                ResponseEntity<String> responseEntityActual = appRoleService.readAppRoleSecretId(token, appRoleName);        assertEquals(HttpStatus.OK, responseEntityActual.getStatusCode());        assertEquals(responseEntityExpected, responseEntityActual);    }
@Test    public void shouldGetPublicRouterId() throws JSONException {        String response = "{\"routers\": [{\"status\": \"ACTIVE\", \"external_gateway_info\":"                + " {\"network_id\": \"e8892de7-38f9-4002-90f9-eedf0e72f5fc\"}, \"name\": "                + "\"router-1137229409\", \"admin_state_up\": false, "                + "\"tenant_id\": \"00000000000000000000000000000017\", \"routes\": [], "                + "\"id\": \"2fe38e4d-a4cb-4c0a-b1b9-e87e0d147f9c\"}, {\"status\": \"ACTIVE\", "                + "\"external_gateway_info\": {\"network_id\": \"e5892de7-38f9-4002-90f9-eedf0e72f5fc\","                + " \"enable_snat\": true}, \"name\": \"ext-rt\", \"admin_state_up\": "                + " true, \"tenant_id\": \"00000000000000000000000000000001\", \"routes\": [], \"id\":"                + "\"35da5189-03f8-4167-868d-932637d83105\"}]}";        String routerId = openStackUtil.getPublicRouterId(response, "00000000000000000000000000000001",                "e5892de7-38f9-4002-90f9-eedf0e72f5fc");        assertEquals(routerId, "35da5189-03f8-4167-868d-932637d83105");    }
@Test  public void testCustomSerialization_renamedProperty() throws Exception {    String apiConfigSource = g.generateConfig(SerializerTestEndpoint.class).get("myapi-v1.api");    ObjectNode root = objectMapper.readValue(apiConfigSource, ObjectNode.class);    JsonNode schemas = root.path("descriptor").path("schemas");    verifyObjectPropertySchema(schemas.path("SerializerTestBean"), "baz", "string");  }
@Test    public void testStream() throws Exception {        stream(readable, streamListener);    }
@Test    void toDatabaseType() throws Exception {        final byte[] expected = {            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,        };        final ByteBuffer test = ByteBuffer.wrap(expected);        final UUID original = new UUID(test.getLong(), test.getLong());        final Object actual = uuidMapper.toDatabaseType(original);        assertNotNull(actual);        assertEquals(byte[].class, actual.getClass(), "Result correct type: ");        assertArrayEquals(expected, (byte[]) actual, "Result correct values: ");    }
@Test    public void testNotifyChangedDeviceDelete() {        List<ChangeNotification> notifs = new ArrayList<>();        ModelNodeId nodeId = new ModelNodeId("/container=network-manager/container=" + MANAGED_DEVICES, NS);        EditContainmentNode editContainmentNode = new EditContainmentNode(QName.create(NS, DEVICE), EditConfigOperations.DELETE);        editContainmentNode.addMatchNode(QName.create(NS, DEVICE), new GenericConfigAttribute("device", NS, DEVICE_A));        ModelNodeChange change = new ModelNodeChange(ModelNodeChangeType.delete, editContainmentNode);        notifs.add(new EditConfigChangeNotification(nodeId, change, StandardDataStores.RUNNING, mock(ModelNode.class)));        m_deviceManagementSubsystem.notifyChanged(notifs);        verify(m_deviceManager).deviceRemoved(DEVICE_A);        verify(m_deviceManager, never()).deviceAdded(DEVICE_A);        verify(m_deviceManager, never()).devicePropertyChanged(DEVICE_A);    }
@Test    public void testCommitTransactions01() throws Exception {        // テスト入力データ設定        Map<String, PlatformTransactionManager> tranMap = new HashMap<String, PlatformTransactionManager>();        PlatformTransactionManager tran = new PlatformTransactionManagerStub();        tranMap.put("tran", tran);        Map<String, TransactionStatus> statMap = new HashMap<String, TransactionStatus>();        // テスト実施        try {            BatchUtil.commitTransactions(tranMap, statMap);        } catch (Exception e) {            e.printStackTrace();            fail();            return;        }        // 結果検証    }
@Test    public void connectionForDeprecatedGetRequest() throws Exception {        TestRequest.DeprecatedGet request = new TestRequest.DeprecatedGet();        assertEquals(request.getMethod(), Method.DEPRECATED_GET_OR_POST);        HurlStack.setConnectionParametersForRequest(mMockConnection, request);        verify(mMockConnection, never()).setRequestMethod(anyString());        verify(mMockConnection, never()).setDoOutput(true);    }
@Test    public void askUserToIdentifyShouldAddWaitingUserAndExposeAndGetTopic() {        wrapper.askUserToIdentify(100);        verify(waitingList).addWaitingUser(100);        verify(controller).sendExposeMessage();        verify(controller).sendGetTopicMessage();    }
@Test    public void testSelectCard() {        Strategy strategy = new NextCard();        int maxCard = 50;        int prizeCard = 10;        int handSize = 20;        IntStream hand = IntStream.range(1,handSize+1).boxed().mapToInt(i -> i);        // test        int result = strategy.selectCard(prizeCard, hand, maxCard);        assertEquals(1, result);    }
@Test    public void iteratingDownPids() {        assertThat(RBACDecorator.iterateDownPids(Arrays.asList("a.b", "c", "d")).toArray(new String[4]),            equalTo(new String[]{"jmx.acl.a.b.c.d", "jmx.acl.a.b.c", "jmx.acl.a.b", "jmx.acl"}));    }
@Test	public void shouldReuseTarget() {		final ArrayCreation arrayCreation = new ArrayCreation(new ConstantExpression(IntNode.valueOf(42)));		final IJsonNode result1 = arrayCreation.evaluate(IntNode.valueOf(42));		final IJsonNode result2 = arrayCreation.evaluate(IntNode.valueOf(42));		Assert.assertEquals(new ArrayNode<IJsonNode>(IntNode.valueOf(42)), result1);		Assert.assertSame(result1, result2);		Assert.assertEquals(new ArrayNode<IJsonNode>(IntNode.valueOf(42)), result2);	}
@Test    public void mergeOptions_AffectsOnlyComponentViewControllers() {        uut.mergeOptions("some unknown child id", new Options());    }
@Test    void toJavaTypeOutOfBounds() {        assertThrows(ArrayIndexOutOfBoundsException.class, () -> instance.toJavaType(column, User.class, 43));    }
@Test	public void splitString_caps() {		assertEquals(Arrays.asList("a","string","with","caps"), StringUtils.splitString("aStringWithCaps"));	}
@Test    public void test_updateSafe() throws Exception {        SafeBasicDetails safeBasicDetails = new SafeBasicDetails("mysafe01", "youremail@yourcompany.com", null, "My first safe");        Safe safe = new Safe("shared/mysafe01",safeBasicDetails);        String inputJson =new ObjectMapper().writeValueAsString(safe);        String responseJson = "{\"messages\":[\"Safe updated \"]}";        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseJson);        UserDetails userDetails = getMockUser(false);        when(selfSupportService.updateSafe(eq(userDetails),eq("5PDrOhsy4ig8L3EpsJZSLAMg"), Mockito.any(Safe.class))).thenReturn(responseEntityExpected);        mockMvc.perform(MockMvcRequestBuilders.put("/v2/ss/sdb").requestAttr("UserDetails", userDetails)                .header("vault-token", "5PDrOhsy4ig8L3EpsJZSLAMg")                .header("Content-Type", "application/json;charset=UTF-8")                .content(inputJson))                .andExpect(status().isOk())                .andExpect(content().string(containsString(responseJson)));    }
@Test  public void shouldThrowIllegalStateExceptionForIllegal() throws Exception {    thrown.expect(IllegalStateException.class);    thrown.expectMessage("don't do this dude");    Cases.illegal("don't do this dude");  }
@Test  public void testFieldDef() {    TerminalParserTest.assertResult(FIELD, "int f;", FieldDef.class, "int f;");    TerminalParserTest.assertResult(FIELD, "static final int f;", FieldDef.class, "static final int f;");    TerminalParserTest.assertResult(FIELD, "int f = foo;", FieldDef.class, "int f = foo;");    TerminalParserTest.assertResult(FIELD, "int[] a = {foo};", FieldDef.class, "int[] a = {foo};");  }
@Test    public void testSkipNothing() {        Observable<Integer> src = Observable.from(5, 3, 1);        Observable.create(skipWhile(src, LESS_THAN_FIVE)).subscribe(w);        InOrder inOrder = inOrder(w);        inOrder.verify(w, times(1)).onNext(5);        inOrder.verify(w, times(1)).onNext(3);        inOrder.verify(w, times(1)).onNext(1);        inOrder.verify(w, times(1)).onCompleted();        inOrder.verify(w, never()).onError(any(Throwable.class));    }
@Test(expected = KafkaException.class)	public void buildBadType() {		CustomPrincipal customPrincipal = customPrincipalBuilder.build(sslAuthenticationContext);	}
@Test	public void testMultiplication1() throws Exception {		DDMExpressionImpl<BigDecimal> ddmExpressionImpl = createDDMExpression(			"2.45 * 2");		BigDecimal bigDecimal = ddmExpressionImpl.evaluate();		Assert.assertEquals(0, bigDecimal.compareTo(new BigDecimal("4.9")));	}
@Test    public void testU_EncodingChar() {        assertThat(Functions.u("%"), is("%25"));        assertThat(Functions.u("あ"), is("%E3%81%82"));        assertThat(Functions.u("\n"), is("%0A"));    }
@Test  public void testFetchObjectsByIdWithUnknownId() {    assertEquals(0, ListUtils.list(getObjectManager().getObjects(null)).size());    assertEquals(0, ListUtils.list(getObjectManager().getObjects(ListUtils.list())).size());    assertEquals(0, ListUtils.list(getObjectManager().getObjects(ListUtils.list(UUID.randomUUID()))).size());  }
@Test	public void test() {		String[] args = {};		App.main(args);	}
@Test    public void testIsRelevant() throws Exception {        TestAction action = new TestAction("testName", null, "testHash");        Mockito.when(info.getStatus()).thenReturn(status);        Mockito.when(status.isExecuted(ctx, info, action)).thenReturn(false);        Assert.assertTrue(action.isRelevant(ctx, info));        Mockito.when(status.isExecuted(ctx, info, action)).thenReturn(true);        Assert.assertFalse(action.isRelevant(ctx, info));    }
@Test    public void userLogOffShouldDoNothingIfUserIsUnknown() {        setUpUnknownUser();        responder.userLogOff(100);        verifyZeroInteractions(messageController);        verify(controller, never()).removeUser(any(User.class), anyString());    }
@Test	public void testGetAssetCategoriesByAssetVocabulary() {		AssetCategory assetCategory = Mockito.mock(AssetCategory.class);		Mockito.when(			assetCategory.getVocabularyId()		).thenReturn(			RandomTestUtil.randomLong()		);		JournalArticle journalArticle = _getJournalArticle();		JournalArticleContentDashboardItem journalArticleContentDashboardItem =			new JournalArticleContentDashboardItem(				Collections.singletonList(assetCategory), null, null, null,				null, null, journalArticle, null, null);		Assert.assertEquals(			Collections.singletonList(assetCategory),			journalArticleContentDashboardItem.getAssetCategories(				assetCategory.getVocabularyId()));	}
@Test    public void buildVerificationScriptFromMultiplePublicKeys() {        final String key1 = "035fdb1d1f06759547020891ae97c729327853aeb1256b6fe0473bc2e9fa42ff50";        final String key2 = "03eda286d19f7ee0b472afd1163d803d620a961e1581a8f2704b52c0285f6e022d";        List<byte[]> keys = Arrays.asList(Numeric.hexStringToByteArray(key1), Numeric.hexStringToByteArray(key2));        byte[] script = ScriptBuilder.buildVerificationScript(keys, 2);        byte[] expected = Numeric.hexStringToByteArray(""                + OpCode.PUSH2.toString() // n = 2, signing threshold                + OpCode.PUSHDATA1.toString() + "21"  // PUSHDATA 33 bytes                + key1 // public key                + OpCode.PUSHDATA1.toString() + "21"  // PUSHDATA 33 bytes                + key2 // public key                + OpCode.PUSH2.toString() // m = 2, number of keys                + OpCode.PUSHNULL.toString()                + OpCode.SYSCALL.toString()                + InteropServiceCode.NEO_CRYPTO_CHECKMULTISIGWITHECDSASECP256R1.getHash()        );        assertArrayEquals(expected, script);    }
@Test    public void shouldOverrideValueForRequestInterceptor() throws Exception {        mockEndpoint();        TestRequestInterceptor mockTestRequestInterceptor = mock(TestRequestInterceptor.class);        mockStatic(ComponentFactory.class);        when(ComponentFactory.instantiate(TestRequestInterceptor.class, mockCRestConfig)).thenReturn(mockTestRequestInterceptor);        mockOverride(MethodConfig.METHOD_CONFIG_DEFAULT_REQUEST_INTERCEPTOR, TestRequestInterceptor.class);        DefaultMethodConfigBuilder toTest = newToTest();        MethodConfig actual = toTest.build();        assertCommons(actual);        assertSame(mockTestRequestInterceptor, actual.getRequestInterceptor());    }
@Test    public void isAuthorizedToRunContainerTests() {        TestSUser user = new TestSUser();        user.addProjectPermission("Foo", Permission.START_STOP_CLOUD_AGENT).                addProjectPermission("Foo", Permission.MANAGE_AGENT_CLOUDS);        assertThat(WebUtils.isAuthorizedToRunContainerTests(user)).isTrue();    }
@Test    public void testGetBestBlockHash() throws Exception {        neow3j.getBestBlockHash().send();        verifyResult(                "{\"jsonrpc\":\"2.0\",\"method\":\"getbestblockhash\",\"params\":[],\"id\":1}");    }
@Test    public void testWrapSingleLong() {        ByteBuf buffer = copyLong(42);        assertEquals(8, buffer.capacity());        assertEquals(42, buffer.readLong());        assertFalse(buffer.isReadable());        buffer.release();    }
@Test	public void testDeploy() throws Exception {		Assume.assumeTrue( isLinuxSystem());		copyResources( "/BashScript" );		File file = new File( OUTPUT_DIR, "BashScriptFile.deploy" );		Assert.assertFalse( file.exists());		this.plugin.deploy( this.inst );		assertTrue( file.exists());	}
@Test    public void otherDateHeader_rfc3339_dateTime_withOffset() {        // effectively 1996-12-20T00:39:57Z        Date date = HttpDateUtils.parse("other-date", "1996-12-19T16:39:57-08:00");        assertEquals(851042397000L, date.getTime());    }
@Test  public void testInitScriptsFramework() throws Exception {    getInstance().initScriptsFramework("");  }
@Test  public void testCompleteJobWithFiltering() throws Exception {     File inputFile = getTestTempFile("prefs.txt");     File userFile = getTestTempFile("users.txt");     File filterFile = getTestTempFile("filter.txt");     File outputDir = getTestTempDir("output");     outputDir.delete();     File tmpDir = getTestTempDir("tmp");     writeLines(inputFile,         "1,1,5",         "1,2,5",         "1,3,2",         "2,1,2",         "2,3,3",         "2,4,5",         "3,2,5",         "3,4,3",         "4,1,3",         "4,4,5");     /* only compute recommendations for the donkey */     writeLines(userFile, "4");     /* do not recommend the hotdog for the donkey */     writeLines(filterFile, "4,2");     RecommenderJob recommenderJob = new RecommenderJob();     Configuration conf = getConfiguration();     conf.set("mapred.input.dir", inputFile.getAbsolutePath());     conf.set("mapred.output.dir", outputDir.getAbsolutePath());     conf.setBoolean("mapred.output.compress", false);     recommenderJob.setConf(conf);     recommenderJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname",        TanimotoCoefficientSimilarity.class.getName(), "--numRecommendations", "1",        "--usersFile", userFile.getAbsolutePath(), "--filterFile", filterFile.getAbsolutePath() });     Map<Long,List<RecommendedItem>> recommendations = readRecommendations(new File(outputDir, "part-r-00000"));     assertEquals(1, recommendations.size());     assertTrue(recommendations.containsKey(4L));     assertEquals(1, recommendations.get(4L).size());     /* berries should have been recommended to the donkey */     RecommendedItem recommendedItem = recommendations.get(4L).get(0);     assertEquals(3L, recommendedItem.getItemID());     assertEquals(3.5, recommendedItem.getValue(), 0.05);   }
@Test    public void testSecuritySensitiveConfig()    {        Map<String, String> properties = new TreeMap<>();        properties.put("value", "some value");        inspect(properties, null, null, null, binder -> bindConfig(binder).bind(SetterSensitiveClass.class))                .component("ConfigurationMetadataTest$SetterSensitiveClass")                .value("Value", "value", "[REDACTED]", "[REDACTED]", "description")                .end();    }
@Test public void shouldLaunchSubscriptionPurchaseFlowWithoutExtraData() throws Exception {        shouldStartSetup_SuccessCase();        Bundle response = new Bundle();        response.putParcelable(RESPONSE_BUY_INTENT, PendingIntent.getActivity(Robolectric.application, 0, new Intent(), 0));        when(service.getBuyIntent(API_VERSION, Robolectric.application.getPackageName(), "sku", "subs", "")).thenReturn(response);        Activity activity = mock(Activity.class);        helper.launchPurchaseFlow(activity, "sku", SUBS, TEST_REQUEST_CODE, purchaseFinishedListener, "");        verify(activity).startIntentSenderForResult(any(IntentSender.class), eq(TEST_REQUEST_CODE), any(Intent.class), eq(0), eq(0), eq(0));    }
@Test  public void removeTypeArrayParameter3() throws Exception {    String name = "java.util.Map<Object[], Void>";    final String s = ClassNameUtils.removeTypeAndArray(name);    assertEquals("java.util.Map", s);  }
@Test    public void getSequences() {        //WorkProcessor size +1  -> StringEventWorkHandler ; there is 2        Sequence[] sequences = workerPoolInfo.getSequences();        Assert.assertTrue(sequences.length == 2);    }
@Test    void test_createAdBond3() throws Exception {        //given        String expectedNo = "no";        Customer customer = customerRepository.save(new Customer(expectedNo, "name", "bizNo", "ceo"));        shopRepository.save(new Shop(expectedNo, "name", customer));        LocalDate startDate = LocalDate.of(2020,8,11);        LocalDate endDate = LocalDate.of(2020,8,12);        String orderType1 = "a";        String orderType2 = "b";        adItemRepository.save(new AdItem(orderType1, startDate, "1", 1000L, customer));        adItemRepository.save(new AdItem(orderType2, endDate, "2", 2000L, customer));        //when        adItemService.createAdBond3(startDate, endDate, Arrays.asList(orderType1, orderType2));        //then        List<AdBond> adBonds = adBondRepository.findAll();        AdBond adBond1 = adBonds.get(0);        AdBond adBond2 = adBonds.get(1);        assertThat(adBonds).hasSize(2);        assertThat(adBond1.getCustomer().getCustomerNo()).isEqualTo(expectedNo);        assertThat(adBond2.getCustomer().getCustomerNo()).isEqualTo(expectedNo);        assertThat(adBond1.getCustomer().getShop().getShopNo()).isEqualTo(expectedNo);        assertThat(adBond2.getCustomer().getShop().getShopNo()).isEqualTo(expectedNo);    }
@Test    public void testGetAnalysisStepsReturnsListOfStepsAdded() {        List<AnalysisStep> steps = getAnalysisSteps();        Analysis.Builder builder = newBuilder();        steps.forEach(builder::addStep);        Analysis instance = builder.build();        assertThat(instance.getAnalysisSteps(), equalTo(steps));    }
@Test    @Ignore    public void testGetAllGroups() {        List<HadoopAuthorizationGroup> groups = rangerAuthorizationService.getAllGroups();        assertNotNull(groups);    }
@Test    public void testCreatePedigreeWithMoreThanOneFamilyInFile() {        Pedigree multiFamilyPed = Pedigree.of(                Individual.builder()                        .familyId("Adams")                        .id("Adam")                        .sex(Individual.Sex.MALE)                        .status(Individual.Status.UNAFFECTED)                        .build(),                Individual.builder()                        .familyId("Simpsons")                        .id("Homer")                        .sex(Individual.Sex.MALE)                        .status(Individual.Status.UNAFFECTED)                        .build()        );        assertThrows(RuntimeException.class, () ->                PedigreeSampleValidator.validate(multiFamilyPed, SampleIdentifier.of("Homer", 1), ImmutableList.of("Adam", "Homer"))        );    }
@Test  public void readMetadataBlock_updatesReadPositionAndAlignsPeekPosition() throws Exception {    ExtractorInput input = buildExtractorInput("flac/bear.flac");    input.skipFully(FlacConstants.STREAM_MARKER_SIZE);    // Advance peek position after metadata block.    input.advancePeekPosition(FlacConstants.STREAM_INFO_BLOCK_SIZE + 1);    FlacMetadataReader.readMetadataBlock(        input, new FlacStreamMetadataHolder(/* flacStreamMetadata= */ null));    assertThat(input.getPosition()).isNotEqualTo(0);    assertThat(input.getPeekPosition()).isEqualTo(input.getPosition());  }
@Test    void brokenV3CertificatePath() throws Exception    {        Collection<X509CertificateHolder> certs = new ArrayList<>();        certs.add(BcUtils.getX509CertificateHolder(v3CaCert));        CollectionStore store = new CollectionStore(certs);        CertificateProvider provider = componentManager.getInstance(CertificateProvider.class, "BCStoreX509");        ((BcStoreX509CertificateProvider) provider).setStore(store);        Collection<CertifiedPublicKey> chain = builder.build(v3Cert, provider);        assertThat(chain, contains(v3Cert));    }
@Test(expected = TestException.class)    public void testUsingWithResourceFactoryError() {        Func0<Subscription> resourceFactory = new Func0<Subscription>() {            @Override            public Subscription call() {                throw new TestException();            }        };        Func1<Subscription, Observable<Integer>> observableFactory = new Func1<Subscription, Observable<Integer>>() {            @Override            public Observable<Integer> call(Subscription subscription) {                return Observable.empty();            }        };        Observable.create(using(resourceFactory, observableFactory))                .toBlockingObservable().last();    }
@Test    public void testJUDDI_939() throws Exception {            UDDIClient uddiClient = new UDDIClient();            ServiceLocator serviceLocator = uddiClient.getServiceLocator("default");            Assert.assertNotNull(serviceLocator);            serviceLocator.setPolicy(PolicyRoundRobin.class.getName());            //serviceLocator.withCache(new URL("http", "0.0.0.0", 0, ""));    }
@Test  public void testParsePattern() throws Exception {    System.setProperty("config.file", "src/test/resources/test.conf");    ConfigFactory.invalidateCaches();    final Config config = ConfigFactory.load();    final String sessionId = "test";    String regexp = "(?![cdCD]\\z|qu\\z|jusqu\\z).+'.+";    TokenPattern tokenPattern = new TokenPattern(regexp, Tokeniser.getTokenSeparators(sessionId));    List<Pattern> patterns = tokenPattern.getParsedPattern();    Assert.assertEquals(3, patterns.size());    int i = 0;    for (Pattern pattern : patterns) {      if (i == 0) {        Assert.assertEquals("(?![cdCD]\\z|[qQ]u\\z|[jJ]usqu\\z).+", pattern.pattern());      } else if (i == 1) {        Assert.assertEquals("'", pattern.pattern());      } else if (i == 2) {        Assert.assertEquals(".+", pattern.pattern());      }      i++;    }    regexp = "être (de|d)";    tokenPattern = new TokenPattern(regexp, Tokeniser.getTokenSeparators(sessionId));    patterns = tokenPattern.getParsedPattern();    Assert.assertEquals(3, patterns.size());    i = 0;    for (Pattern pattern : patterns) {      if (i == 0) {        Assert.assertEquals("[êÊE]tre", pattern.pattern());      } else if (i == 1) {        Assert.assertEquals(" ", pattern.pattern());      } else if (i == 2) {        Assert.assertEquals("(de|d)", pattern.pattern());      }      i++;    }    regexp = ".+\\.\\p";    tokenPattern = new TokenPattern(regexp, Tokeniser.getTokenSeparators(sessionId));    patterns = tokenPattern.getParsedPattern();    Assert.assertEquals(3, patterns.size());    i = 0;    for (Pattern pattern : patterns) {      if (i == 0) {        Assert.assertEquals(".+", pattern.pattern());      } else if (i == 1) {        Assert.assertEquals("\\.", pattern.pattern());      } else if (i == 2) {        Assert.assertEquals(Tokeniser.getTokenSeparators(sessionId).pattern(), pattern.pattern());      }      i++;    }    regexp = ".+qu'";    tokenPattern = new TokenPattern(regexp, Tokeniser.getTokenSeparators(sessionId));    patterns = tokenPattern.getParsedPattern();    Assert.assertEquals(2, patterns.size());    i = 0;    for (Pattern pattern : patterns) {      if (i == 0) {        Assert.assertEquals(".+qu", pattern.pattern());      } else if (i == 1) {        Assert.assertEquals("'", pattern.pattern());      }      i++;    }    regexp = "\\D+\\.a[ \\)]c[abc]";    tokenPattern = new TokenPattern(regexp, Tokeniser.getTokenSeparators(sessionId));    patterns = tokenPattern.getParsedPattern();    LOG.debug(patterns.toString());    Assert.assertEquals(5, patterns.size());    i = 0;    for (Pattern pattern : patterns) {      if (i == 0) {        Assert.assertEquals("\\D+", pattern.pattern());      } else if (i == 1) {        Assert.assertEquals("\\.", pattern.pattern());      } else if (i == 2) {        Assert.assertEquals("a", pattern.pattern());      } else if (i == 3) {        Assert.assertEquals("[ \\)]", pattern.pattern());      } else if (i == 4) {        Assert.assertEquals("c[abc]", pattern.pattern());      }      i++;    }  }
@Test(expected = IllegalArgumentException.class)    public void unescapeCsvFieldsWithQuote2() {        unescapeCsvFields("\",a");    }
@Test	public void testOnePartition() {		PartitionIterator itr = PartitionIterators.range(ogclient, 1, 1);		Assert.assertTrue("hasNext", itr.hasNext());		Assert.assertEquals("next", 1, itr.next());		Assert.assertFalse("hasNext", itr.hasNext());	}
@Test    public void getKieAssetsDropdownItemFileWithoutPath() {        String fullPath = "filename.etc";        KieAssetsDropdownItem item = scenarioSimulationKogitoRuntimeCreationAssetsDropdownProviderImplSpy.getKieAssetsDropdownItem(fullPath);        assertNotNull(item);        assertEquals(fullPath, item.getValue());        assertEquals(fullPath, item.getSubText());        assertEquals(fullPath, item.getText());    }
@Test  public void testCreateResources() throws Exception {    IvoryService service = createMock(IvoryService.class);    Set<Map<String, Object>> propertySet = new HashSet<Map<String, Object>>();    Map<String, Object> properties = new HashMap<String, Object>();    properties.put(FeedResourceProvider.FEED_NAME_PROPERTY_ID, "Feed1");    properties.put(FeedResourceProvider.FEED_DESCRIPTION_PROPERTY_ID, "desc");    properties.put(FeedResourceProvider.FEED_SCHEDULE_PROPERTY_ID, "sched");    properties.put(FeedResourceProvider.FEED_STATUS_PROPERTY_ID, "SUBMITTED");    properties.put(FeedResourceProvider.FEED_SOURCE_CLUSTER_NAME_PROPERTY_ID, "source");    properties.put(FeedResourceProvider.FEED_TARGET_CLUSTER_NAME_PROPERTY_ID, "target");    // set expectations    service.submitFeed(FeedResourceProvider.getFeed("Feed1", properties));    // replay    replay(service);    propertySet.add(properties);    Request request = PropertyHelper.getCreateRequest(propertySet, Collections.<String,String>emptyMap());    FeedResourceProvider provider = new FeedResourceProvider(service,        PropertyHelper.getPropertyIds(Resource.Type.DRFeed),        PropertyHelper.getKeyPropertyIds(Resource.Type.DRFeed));    provider.createResources(request);    // verify    verify(service);  }
@Test    void get11() {        assertEquals(m11, instance.get11());    }
@Test    void get13() {        assertEquals(m13, instance.get13());    }
@Test    public void testMap() {        FieldDefinition fieldDefA = new FieldDefinition("fieldA", "cfA:qualifierA", ValueSource.VALUE, "int");        FieldDefinition fieldDefB = new FieldDefinition("fieldB", "cfB:qualifierB", ValueSource.VALUE,                DummyValueMapper.class.getName());        DefaultResultToSolrMapper resultMapper = new DefaultResultToSolrMapper("index-name", Lists.newArrayList(fieldDefA, fieldDefB),                Collections.<DocumentExtractDefinition> emptyList());        KeyValue kvA = new KeyValue(ROW, COLUMN_FAMILY_A, QUALIFIER_A, Bytes.toBytes(42));        KeyValue kvB = new KeyValue(ROW, COLUMN_FAMILY_B, QUALIFIER_B, Bytes.toBytes("dummy value"));        Result result = Result.create(Lists.<Cell>newArrayList(kvA, kvB));        resultMapper.map(result, solrUpdateWriter);        verify(solrUpdateWriter).add(solrInputDocCaptor.capture());                SolrInputDocument solrDocument = solrInputDocCaptor.getValue();        assertEquals(Sets.newHashSet("fieldA", "fieldB"), solrDocument.keySet());        SolrInputField fieldA = solrDocument.get("fieldA");        SolrInputField fieldB = solrDocument.get("fieldB");        assertEquals(Lists.newArrayList(42), fieldA.getValues());        assertEquals(Lists.newArrayList("A", "B", "C"), fieldB.getValues());    }
@Test	public void shouldThrowExceptionWhenUnableToParse() {		when(request.getAttribute("javax.servlet.jsp.jstl.fmt.locale.request")).thenReturn("pt_br");	try {		converter.convert("vr3.9", double.class, bundle);		fail("Should throw exception");	} catch (ConversionError e) {		assertThat(e.getMessage(), is(equalTo("vr3.9 is not a valid number.")));	}	}
@Test	public void testToJsonObjectWithTimeProperties() throws Exception {		JsonObjectIndexedRecordConverter jsonObjectIndexedRecordConverter =			getJsonObjectIndexedRecordConverter(				"/v1.0/timestamp/{code}", OASConstants.OPERATION_GET,				readObject("openapi_data_types.json"));		IndexedRecord indexedRecord =			jsonObjectIndexedRecordConverter.toIndexedRecord(				readObject("timestamp_content.json"));		IndexedRecordJsonObjectConverter indexedRecordJsonObjectConverter =			new IndexedRecordJsonObjectConverter(				true,				getSchema(					"/v1.0/timestamp/{code}", OASConstants.OPERATION_PATCH,					readObject("openapi_data_types.json")),				null, new Result());		JsonObject jsonObject = indexedRecordJsonObjectConverter.toJsonObject(			indexedRecord);		Assert.assertEquals(			"timestamp1 value", "2019-12-02T05:17:09Z",			jsonObject.getString("timestamp1"));		Assert.assertEquals(			"timestamp2 value", "2019-12-02T05:17:09Z",			jsonObject.getString("timestamp2"));		Assert.assertEquals(			"timestamp3 value", "2019-12-02T04:17:09Z",			jsonObject.getString("timestamp3"));	}
@Test    public void testUnsignedRightShift_issue417()    {        EncodedDoubleValue speedEncoder = new EncodedDoubleValue("Speed", 56, 8, 1, 30, 255);        Long flags = -72057594037927936L;        assertEquals(255, speedEncoder.getDoubleValue(flags), 0.01);    }
@Test    public void test_createSecretId_successfully() {        String responseJson = "{\"data\":{ \"secret_id\": \"5973a6de-38c1-0402-46a3-6d76e38b773c\", \"secret_id_accessor\": \"cda12712-9845-c271-aeb1-833681fac295\"}}";        Response response =getMockResponse(HttpStatus.NO_CONTENT, true, responseJson);        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body("{\"messages\":[\"Secret ID created for AppRole\"]}");        String token = "5PDrOhsy4ig8L3EpsJZSLAMg";        AppRoleSecretData appRoleSecretData = new AppRoleSecretData("approle1", new SecretData("dev", "appl"));        String jsonStr = "{\"role_name\":\"approle1\",\"data\":{\"env\":\"dev\",\"appname\":\"appl\"}}";                when(reqProcessor.process("/auth/approle/secretid/create", jsonStr,token)).thenReturn(response);        when(ControllerUtil.convertAppRoleSecretIdToLowerCase(Mockito.any())).thenReturn(jsonStr);        when(JSONUtil.getJSON(appRoleSecretData)).thenReturn(jsonStr);                ResponseEntity<String> responseEntityActual = appRoleService.createsecretId(token, appRoleSecretData);        assertEquals(HttpStatus.OK, responseEntityActual.getStatusCode());        assertEquals(responseEntityExpected, responseEntityActual);    }
@Test	public void shouldOptionallyIncludeChildField() {//		String expectedResult = "<order><client><name>guilherme silveira</name> </client>  <price>15.0</price><comments>pack it nicely, please</comments></order>";		Order order = new Order(new Client("guilherme silveira", new Address("R. Vergueiro")), 15.0, "pack it nicely, please");		serialization.from(order).include("client", "client.address").serialize();		assertThat(result(), containsString("\"street\": \"R. Vergueiro\""));	}
@Test	public void test3GetPopulatedViewObject() {		Mockito.when(daoMgr.getXXPortalUser()).thenReturn(XXPortalUserDao);		rangerTagResourceMapService.getPopulatedViewObject(xXTagResourceMap);	}
@Test  public void testStdoutLogging() {    assertTrue(fencer.tryFence(TEST_TARGET, "echo hello"));    Mockito.verify(ShellCommandFencer.LOG).info(        Mockito.endsWith("echo hello: hello"));  }
@Test    public void testIndexOf() throws Exception {        final byte COLON = (byte) ':';        final byte COMMA = (byte) ',';        final byte[] bytes = "name1: value1; name2: value2".getBytes(StandardCharsets.US_ASCII);        final int index1 = 5;        final int index2 = 20;        final ByteArrayBuffer buffer = new ByteArrayBuffer(16);        buffer.append(bytes, 0, bytes.length);        Assert.assertEquals(index1, buffer.indexOf(COLON));        Assert.assertEquals(-1, buffer.indexOf(COMMA));        Assert.assertEquals(index1, buffer.indexOf(COLON, -1, 11));        Assert.assertEquals(index1, buffer.indexOf(COLON, 0, 1000));        Assert.assertEquals(-1, buffer.indexOf(COLON, 2, 1));        Assert.assertEquals(index2, buffer.indexOf(COLON, index1 + 1, buffer.length()));    }
@Test    public void getIndexReturnFileIndex() {        Assert.assertEquals(1, offsetComputer.getIndex("123.index=1.12"));    }
@Test    public void dataPayloadNoPadding() {        Http2Frame frame = TestMessages.DATA_PAYLOAD_NO_PADDING_FRAME;        assertArrayEquals(TestMessages.DATA_PAYLOAD_NO_PADDING_BUFFER, toByteArray(encoder.encode(frame, null)));    }
@Test  public void testGetGrantedAuthorities() throws Exception {    String username = "user";    AmbariLdapAuthoritiesPopulator populator = createMockBuilder(AmbariLdapAuthoritiesPopulator.class)        .withConstructor(helper, userDAO, memberDAO, privilegeDAO, users).createMock();    expect(userEntity.getActive()).andReturn(true);    expect(users.getUserPrivileges(userEntity)).andReturn(Collections.singletonList(privilegeEntity));    expect(userDAO.findLdapUserByName(username)).andReturn(userEntity);    replayAll();    populator.getGrantedAuthorities(userData, username);    verifyAll();  }
@Test(expected = IllegalArgumentException.class)    public void aTableWithRowsBetween_butToIsLessZero_should_fail() {        aTable(ExampleTable.class).withRowsBetween(0, -1);    }
@Test    public void nickShouldShowSystemMessageIfNickChangeFails() throws CommandException {        doThrow(new CommandException("No!")).when(controller).changeMyNick(anyString());        parser.parse("/nick NewNick");        verify(messageController).showSystemMessage("No!");        verify(controller).changeMyNick("NewNick");    }
@Test //(expected=ExWarning.class)    public void checker05() { check("<urn:abc>") ; }
@Test  public void testRegistrationWithBadVersion() throws Exception,      InvalidStateTransitionException {    ActionManager am = actionManagerTestHelper.getMockActionManager();    replay(am);    Clusters fsm = clusters;    HeartBeatHandler handler = new HeartBeatHandler(fsm, new ActionQueue(), am,        injector);    clusters.addHost(DummyHostname1);    Host hostObject = clusters.getHost(DummyHostname1);    hostObject.setIPv4("ipv4");    hostObject.setIPv6("ipv6");    Register reg = new Register();    HostInfo hi = new HostInfo();    hi.setHostName(DummyHostname1);    hi.setOS(DummyOsType);    reg.setHostname(DummyHostname1);    reg.setHardwareProfile(hi);    reg.setAgentVersion(""); // Invalid agent version    reg.setPrefix(Configuration.PREFIX_DIR);    try {      handler.handleRegistration(reg);      fail ("Expected failure for non compatible agent version");    } catch (AmbariException e) {      log.debug("Error:" + e.getMessage());      Assert.assertTrue(e.getMessage().contains(          "Cannot register host with non compatible agent version"));    }    reg.setAgentVersion(null); // Invalid agent version    try {      handler.handleRegistration(reg);      fail ("Expected failure for non compatible agent version");    } catch (AmbariException e) {      log.debug("Error:" + e.getMessage());      Assert.assertTrue(e.getMessage().contains(          "Cannot register host with non compatible agent version"));    }  }
@Test    public void overlappingPlansApp1() {        this.request.addHeader(CLIENT_ID, clientId1);        Api api1 = new Api();        api1.setId(1L);        Api api2 = new Api();        api2.setId(2L);        Plan plan1 = new Plan();        plan1.setId(100L);        plan1.setApi(api1);        Plan plan2 = new Plan();        plan2.setId(200L);        plan2.setApi(api2);        App app1 = new App();        app1.setId(10L);        app1.setClientId(clientId1);        app1.setPlans(Collections.singletonList(plan1));        App app2 = new App();        app2.setId(20L);        app2.setClientId(clientId2);        app2.setPlans(Collections.singletonList(plan2));        Operation operation1 = new Operation(1111L, null, null,null, null);        Operation operation2 = new Operation(2222L, null, null,null, null);        Operation operation3 = new Operation(3333L, null, null,null, null);        List<Operation> operations1 = new ArrayList<>();        List<Operation> operations2 = new ArrayList<>();        operations1.add(operation1);        operations1.add(operation3);        operations2.add(operation2);        operations2.add(operation3);        Scope scope1 = new Scope(123L, null, null, null, new HashSet<>(operations1));        Scope scope2 = new Scope(321L, null, null, null, new HashSet<>(operations2));        plan1.setScopes(new HashSet<>(Collections.singletonList(scope1)));        plan2.setScopes(new HashSet<>(Collections.singletonList(scope2)));        context.set(OPERATION_ID, operation3.getId());        context.set(API_ID, api1.getId());        Mockito.when(appRepository.findByClientId(Mockito.anyString())).thenReturn(app1);        this.filter.run();        final FilterDetail filterDetail = TraceContextHolder.getInstance().getActualTrace().getFilters().get(SCOPES_FILTER);        assertEquals(HttpStatus.OK.value(), context.getResponseStatusCode());        assertEquals(Constants.SUCCESS, filterDetail.getStatus());    }
@Test(expected=IllegalArgumentException.class)    public void testBadOtherKey() {        TesseractOCRConfig config = new TesseractOCRConfig();        config.addOtherTesseractConfig("bad bad", "bad");    }
@Test    void testOfSingleton() {        final List<List<String>> actual = Combination.of("a")            .collect(toList());        assertEquals(            singletonList(                singletonList("a")            ),            actual        );    }
@Test  public void testGetOAuth2User() throws Exception {    when(config.getScopeExpression()).thenReturn(AuthScopeExpressions.interpret(SCOPES));    when(oauthService.getAuthorizedScopes(SCOPES)).thenReturn(SCOPES);    when(oauthService.getClientId(SCOPES)).thenReturn(CLIENT_ID);    when(config.getClientIds()).thenReturn(ImmutableList.of(CLIENT_ID));    when(oauthService.getCurrentUser(SCOPES)).thenReturn(APP_ENGINE_USER);    assertEquals(APP_ENGINE_USER, authenticator.getOAuth2User(request, config));  }
@Test    public void testParseZip() throws IOException {        Map<String, ClassReader> map = mAa.parseZip(mOsJarPath);        assertArrayEquals(new String[] {                "mock_android.dummy.InnerTest",                "mock_android.dummy.InnerTest$DerivingClass",                "mock_android.dummy.InnerTest$MyGenerics1",                "mock_android.dummy.InnerTest$MyIntEnum",                "mock_android.dummy.InnerTest$MyStaticInnerClass",                "mock_android.dummy.InnerTest$NotStaticInner1",                "mock_android.dummy.InnerTest$NotStaticInner2",                "mock_android.view.View",                "mock_android.view.ViewGroup",                "mock_android.view.ViewGroup$LayoutParams",                "mock_android.view.ViewGroup$MarginLayoutParams",                "mock_android.widget.LinearLayout",                "mock_android.widget.LinearLayout$LayoutParams",                "mock_android.widget.TableLayout",                "mock_android.widget.TableLayout$LayoutParams"            },            map.keySet().toArray());    }
@Test  public void index() throws Exception {    ctx.write(new IntWritable(0), instance);    EasyMock.replay(ctx);    IndexInstancesMapper indexInstances = new IndexInstancesMapper();    setField(indexInstances, "labelIndex", labelIndex);    indexInstances.map(new Text("/bird/"), instance, ctx);    EasyMock.verify(ctx);  }
@Test    public void containsStream_unregistersListenerOnUnsubscribe() {        final String testKey = "Test contains key";        when(mockSharedPreferences.contains(testKey)).thenReturn(true);        final TestObserver<Boolean> subscription = rxPreferences.containsStream(testKey).test();        subscriptions.add(subscription);        final ArgumentCaptor<SharedPreferences.OnSharedPreferenceChangeListener> listenerCaptor =                ArgumentCaptor.forClass(SharedPreferences.OnSharedPreferenceChangeListener.class);        verify(mockSharedPreferences).registerOnSharedPreferenceChangeListener(listenerCaptor.capture());        final SharedPreferences.OnSharedPreferenceChangeListener listener = listenerCaptor.getValue();        verify(mockSharedPreferences, never()).unregisterOnSharedPreferenceChangeListener(any());        subscription.dispose();        verify(mockSharedPreferences).unregisterOnSharedPreferenceChangeListener(listener);    }
@Test  public void testRemoveAll() {    LOG.info("Test remove all");    for (Integer i : list) {      assertTrue(set.add(i));    }    for (int i = 0; i < NUM; i++) {      assertTrue(set.remove(list.get(i)));    }    // the deleted elements should not be there    for (int i = 0; i < NUM; i++) {      assertFalse(set.contains(list.get(i)));    }    // iterator should not have next    Iterator<Integer> iter = set.iterator();    assertFalse(iter.hasNext());    assertTrue(set.isEmpty());    LOG.info("Test remove all - DONE");  }
@Test    public void testCreateFirstSnapshotWithLatestVersionWhenVersionExist() {        final VersionedFlowSnapshot snapshot = createSnapshot();        final BucketEntity existingBucket = new BucketEntity();        existingBucket.setId("b1");        existingBucket.setName("My Bucket");        existingBucket.setDescription("This is my bucket");        existingBucket.setCreated(new Date());        when(metadataService.getBucketById(existingBucket.getId())).thenReturn(existingBucket);        // return a flow with the existing snapshot when getFlowById is called        final FlowEntity existingFlow = new FlowEntity();        existingFlow.setId("flow1");        existingFlow.setName("My Flow");        existingFlow.setDescription("This is my flow.");        existingFlow.setCreated(new Date());        existingFlow.setModified(new Date());        existingFlow.setBucketId(existingBucket.getId());        when(metadataService.getFlowById(existingFlow.getId())).thenReturn(existingFlow);        when(metadataService.getFlowByIdWithSnapshotCounts(existingFlow.getId())).thenReturn(existingFlow);        // make a snapshot that has the same version as the one being created        final FlowSnapshotEntity existingSnapshot = new FlowSnapshotEntity();        existingSnapshot.setFlowId(snapshot.getSnapshotMetadata().getFlowIdentifier());        existingSnapshot.setVersion(snapshot.getSnapshotMetadata().getVersion());        existingSnapshot.setComments("This is an existing snapshot");        existingSnapshot.setCreated(new Date());        existingSnapshot.setCreatedBy("test-user");        final List<FlowSnapshotEntity> existingSnapshots = Arrays.asList(existingSnapshot);        when(metadataService.getSnapshots(existingFlow.getId())).thenReturn(existingSnapshots);        // set the version to -1 to indicate that registry should make this the latest version        snapshot.getSnapshotMetadata().setVersion(-1);        registryService.createFlowSnapshot(snapshot);        final VersionedFlowSnapshot createdSnapshot = registryService.createFlowSnapshot(snapshot);        assertNotNull(createdSnapshot);        assertNotNull(createdSnapshot.getSnapshotMetadata());        assertEquals(2, createdSnapshot.getSnapshotMetadata().getVersion());    }
@Test  public void testAuthenticationNullPassword() {    expect(mockAuthPropsConfig.isAuthFileEnabled()).andReturn(true);        replay(mockAuthPropsConfig);        Authentication authentication = new TestingAuthenticationToken("principal", null);        try {      provider.authenticate(authentication);      assertTrue("Should have thrown BadCredentialsException", false);    } catch(BadCredentialsException e) {      assertEquals("Password can't be null or empty.", e.getMessage());    }        verify(mockAuthPropsConfig);  }
@Test    public void testFilter_fullOrbit() {        final int width = 512;        final int height = 40000;        final int maxOrbit = 1;        final int count = 100000;        final List<SamplingPoint> samplingPoints = new ArrayList<>(count);        final SobolSequenceGenerator sequenceGenerator = new SobolSequenceGenerator(3);        for (int i = 0; i < count; i++) {            final double[] rands = sequenceGenerator.nextVector();            final int x = (int) (width * rands[0]);            final int y = (int) (height * rands[1]);            final int orbitRef = (int) (maxOrbit * rands[2]);            final SamplingPoint point = new SamplingPoint(x, y);            point.setReference(orbitRef);            samplingPoints.add(point);        }//        final Timer timer = new Timer();//        System.out.println("Initial count  = " + samplingPoints.size());//        timer.start();        final List<SamplingPoint> filtererList = filter.apply(samplingPoints);//        timer.stop();//        System.out.println("Filtered count = " + filtererList.size());//        System.out.println("time [s]       = " + timer.deltaTInSecs());        assertEquals(82715, filtererList.size());    }
@Test    public void testAddUser() {        configureWithInitialUsers();        final Set<User> users = userGroupProvider.getUsers();        assertEquals(0, users.size());        final User user1 = new User.Builder()                .identifier(UUID.randomUUID().toString())                .identity("user1")                .build();        final User createdUser1 = userGroupProvider.addUser(user1);        assertNotNull(createdUser1);        final Set<User> usersAfterCreate = userGroupProvider.getUsers();        assertEquals(1, usersAfterCreate.size());        final User retrievedUser1 = usersAfterCreate.stream().findFirst().get();        assertEquals(user1.getIdentifier(), retrievedUser1.getIdentifier());        assertEquals(user1.getIdentity(), retrievedUser1.getIdentity());    }
@Test	public void testHandleError_Notification_Is_Published() {		Message<MessagingException> errorMessageMock = (Message<MessagingException>) mock(Message.class);		MessagingException messagingExceptionMock = mock(MessagingException.class);		when(errorMessageMock.getPayload()).thenReturn(messagingExceptionMock);		Message<?> failedMessageMock = (Message<?>) mock(Message.class);		doReturn(failedMessageMock).when(messagingExceptionMock)				.getFailedMessage();		String origMessagePayload = "origMessagePayload";		doReturn(origMessagePayload).when(failedMessageMock).getPayload();		Throwable exMock = mock(Throwable.class);		when(messagingExceptionMock.getCause()).thenReturn(exMock);		String expectedDetails = "bla";		String expectedSubject = "Consent signed/revoked message hanlding error";		sut.handleError(errorMessageMock);		verify(notificationPublisher, times(1)).publish(				argThat(new IsNotificationAsExpected(expectedSubject,						expectedDetails)));	}
@Test    void get11Test() {        assertEquals(11, (int) instance.get11());    }
@Test	public void testNetworkMbps() {		Offer offer = new Offer(offer(resources(network(10.0)), attrs()));		Assert.assertEquals(10.0, offer.networkMbps(), EPSILON);	}
@Test    void testOf() {        final SingletonStream<String> ss = SingletonStream.of(OTHER_ELEMENT);        final List<String> s = ss.collect(toList());        assertEquals(singletonList(OTHER_ELEMENT), s);    }
@Test    public void headings() {        final String content = "=  this is a heading\n" +                "              This is the source file. If the receiving program is not running as the super-user\n" +                "              (or if --no-super was specified), only groups that the invoking user on the receiving\n" +                "\n" +                "              SECTION 2\n" +                "              A    fall back to using the ID number in some circumstances (see also the --numeric-ids\n" +                "              option for a full discussion).\n" +                "              #   section 3\n" +                "              The preservation of group information will associate matching\n";        final Document document = DocumentParser.parser(content);        final String actual = Join.join("\n", document.elements);        assertEquals("" +                "Heading{content='this is a heading'}\n" +                "Paragraph{content='This is the source file. If the receiving" +                " program is not running as the super-user (or if --no-super " +                "was specified), only groups that the invoking user on the receiving'}\n" +                "Heading{content='SECTION 2'}\n" +                "Paragraph{content='A fall back to using the ID number in " +                "some circumstances (see also the --numeric-ids option for a full discussion).'}\n" +                "Heading{content='section 3'}\n" +                "Paragraph{content='The preservation of group information will associate matching'}", actual);    }
@Test  public void testGetServiceState() throws Exception {    String[] args = {"-getServiceState", "rm1"};    // RM HA is disabled.    // getServiceState should not be executed    assertEquals(-1, rmAdminCLI.run(args));    verify(haadmin, never()).getServiceStatus();    // Now RM HA is enabled.    // getServiceState should be executed    assertEquals(0, rmAdminCLIWithHAEnabled.run(args));    verify(haadmin).getServiceStatus();  }
@Test    public void shouldNotTouchNonMatchingHeaders() throws Exception {        final HttpHeaders httpHeaders = new HttpHeaders();        httpHeaders.setContentType(MediaType.APPLICATION_JSON);        final HttpHeaders modified = sut.modify(httpHeaders);        assertThat(modified.getContentType(), is(MediaType.APPLICATION_JSON));    }
@Test  public void textListAt() {    ObjectNode node = newObject();    node.putArray("foo").add("hello").add("world");    List<String> value = Selectors.textListAt(node, FOO_FIELD);    assertThat(value, contains("hello", "world"));  }
@Test    public void onEmptyJsonUrl_warningShouldBePrintedToTheLog() {        siren.checkVersion(activity, SirenVersionCheckType.IMMEDIATELY, "");        Mockito.verify(sirenHelper, Mockito.times(1)).logError(Mockito.anyString(), Mockito.anyString());    }
@Test    public void isToBeTriggered() {        assertTrue(strategy.isToBeTriggered(null));        assertTrue(clone.isToBeTriggered(null));    }
@Test    public void test03() {        List list = new ArrayList();        list.add(1);        list.add("2");        list.add(null);        String src = DDRJSONUtils.toJSONString(list);        Assert.equals(src, "[1,\"2\",null]");    }
@Test(expected = IllegalArgumentException.class)  public void testCreateInvalidSecurityType() throws Exception {    Map<String, Object> reuqestMap = new HashMap<>();    Map<String, Object> security = new HashMap<>();    security.put(SecurityConfigurationFactory.TYPE_PROPERTY_ID, "INVALID_SECURITY_TYPE");    reuqestMap.put(SecurityConfigurationFactory.SECURITY_PROPERTY_ID, security);    SecurityConfiguration securityConfiguration = testSubject.createSecurityConfigurationFromRequest(reuqestMap, false);    assertTrue(securityConfiguration.getType() == SecurityType.KERBEROS);  }
@Test    void escapeAttributeValueApos()    {        assertNotEquals("&apos;", XMLUtils.escapeAttributeValue("'"), "' wrongly escaped to non-HTML &apos;");    }
@Test    public void testColor2Hexadecimal() {        Assert.assertEquals("magenta without alpha => " + MAGENTA, MAGENTA, //$NON-NLS-1$            WProperties.color2Hexadecimal(Color.MAGENTA, false));        Assert.assertEquals("magenta with alpha => " + MAGENTA_ALPHA, MAGENTA_ALPHA, //$NON-NLS-1$            WProperties.color2Hexadecimal(Color.MAGENTA, true));        Assert.assertEquals("grey with alpha => " + GREY_ALPHA, GREY_ALPHA, //$NON-NLS-1$            WProperties.color2Hexadecimal(COLOR_ALPHA, true));        Assert.assertEquals("grey withtout alpha => " + GREY, GREY, WProperties.color2Hexadecimal(COLOR_ALPHA, false)); //$NON-NLS-1$    }
@Test    public void getStatusColor_success() {        when(history.getResult()).thenReturn(RESULT.SUCCESS);        String icon = item.getStatusColor();        assertTrue(StringUtils.isNotBlank(icon));    }
@Test	public void testUnsafeGetByteArray() throws Exception {		UnsyncByteArrayOutputStream unsyncByteArrayOutputStream =			new UnsyncByteArrayOutputStream();		unsyncByteArrayOutputStream.write(_BUFFER);		byte[] bytes1 = unsyncByteArrayOutputStream.unsafeGetByteArray();		Assert.assertTrue(Arrays.equals(_BUFFER, bytes1));		Assert.assertSame(			_bufferField.get(unsyncByteArrayOutputStream), bytes1);		byte[] bytes2 = unsyncByteArrayOutputStream.unsafeGetByteArray();		Assert.assertTrue(Arrays.equals(_BUFFER, bytes2));		Assert.assertSame(bytes1, bytes2);		ByteBuffer byteBuffer =			unsyncByteArrayOutputStream.unsafeGetByteBuffer();		Assert.assertSame(bytes1, byteBuffer.array());	}
@Test	public void testCat() {		fsCmd.cat(tmpFile);	}
@Test    public void instanciateShouldDelegateAnyExceptionToCRestHandle() throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {        RuntimeException expected = mock(RuntimeException.class);        InvocationTargetException e = mock(InvocationTargetException.class);        mockStatic(ComponentFactory.class);        when(ComponentFactory.instantiate(String.class, mockCRestConfig)).thenThrow(e);                mockStatic(CRestException.class);        when(CRestException.handle((Exception)e)).thenReturn(expected);        try {            toTest.instantiate(String.class);            fail();        } catch (Exception e1) {            assertSame(expected, e1);        }    }
@Test  public void tampered() {    synchronized (TestTicketRsaKeyFileProvider.class) {      TestTicketRsaKeyFileProvider.clean();      TestTicketRsaKeyFileProvider.files.add(PRIVATE_PLAIN);      TestTicketRsaKeyFileProvider.isFilesWithPrivateKeyAreRequired = true;      startNewContext(0);      // GIVEN      Ticket t = new Ticket();      t.setClaim(new TicketClaim());      t.getClaim().setTicketId(RUuidUtil.toRUuid(UUID.randomUUID()));      t.getClaim().setUsername("abc");      t.getClaim().setValidUntil(123);      t.getClaim().setIsSuperUser(false);      ticketSignatureService.signTicket(t);      // WHEN      t.getClaim().setUsername("xyz");      boolean isValid = ticketValidityService.isTicketValid(t);      // THEN      Assert.assertFalse(isValid, "Ticket should NOT be valid.");    }  }
@Test(expected = JsonParseException.class)    public void testCannotConvertJsonStringWithEmbeddedObject() {        Convert.jsonToJava("{\"key\": {\"a\": 1}}");    }
@Test    public void testValidateImageName() {        assertValid("xx.png");        assertValid("xx.svg");        assertValid("xx");        assertValid("xx.v1.png");        assertValid("xx_v1.png");        assertValid("xx-v1.png");        assertValid("dir/xx.png");        assertValid("dir//xx.png");        assertInvalid("dir/../xx.png");        assertInvalid("../xx.png");    }
@Test	public void testExecuteUpdateByQueryDocumentRequest() {		UpdateByQueryDocumentRequest updateByQueryDocumentRequest =			new UpdateByQueryDocumentRequest((Query)null, null);		_elasticsearchDocumentRequestExecutor.executeDocumentRequest(			updateByQueryDocumentRequest);		Mockito.verify(			_updateByQueryDocumentRequestExecutor		).execute(			updateByQueryDocumentRequest		);	}
@Test  public void testKeytabAndPrincipal() throws Throwable {    kdiag(ARG_KEYLEN, KEYLEN,        ARG_KEYTAB, keytab.getAbsolutePath(),        ARG_PRINCIPAL, "foo@EXAMPLE.COM");  }
@Test  public void testGenerateFast() throws Exception {    try {      ClassicEngineBoot.getInstance().start();      ReportListenerThreadHolder.clear();      PentahoSessionHolder.setSession( new StandaloneSession() );      final File file = new File( "target/test/resource/solution/test/reporting/limit10.prpt" );      final MasterReport report =        (MasterReport) new ResourceManager().createDirectly( file.getPath(), MasterReport.class ).getResource();      try ( ByteArrayOutputStream baos = new ByteArrayOutputStream() ) {        fastCSVOutput.generate( report, 1, baos, 1 );        assertTrue( baos.size() > 0 );      }      verify( listener, times( 0 ) ).reportProcessingStarted( any( ReportProgressEvent.class ) );      verify( listener, times( 0 ) ).reportProcessingFinished( any( ReportProgressEvent.class ) );      verify( listener, times( 0 ) ).reportProcessingUpdate( any( ReportProgressEvent.class ) );    } finally {      PentahoSessionHolder.removeSession();    }  }
@Test    public void tagNameTest() {        SingleValueAssignExtension assign = new SingleValueAssignExtension();        Assert.assertEquals("assign", assign.getTagName());    }
@Test    public void should_not_migrate_a_page_with_a_version_greater_than_migration() throws Exception {        page.setDesignerVersion("1.0.2");        migration.migrate(page);        verify(migrationStep, never()).migrate(page);    }
@Test	public void testUnpackSfxArchives() throws Exception {		HotColdFileCache unpackCache = new HotColdFileCache(20);		FileFactory fileFactory = new FileFactory(unpackCache);		IndexingConfig config = new IndexingConfig();		config.setDetectExecutableArchives(true);		String[] paths = {				TestFiles.sfx_zip.getPath() + "/test.txt",				TestFiles.sfx_7z.getPath() + "/test.txt"		};		for (String path : paths)			assertTrue(fileFactory.createFile(config, new Path(path)).getFile().isFile());	}
@Test    void compare() {        assertEquals(0, instance.compare(null, null));        assertEquals(1, instance.compare(null, "test"));        assertEquals(-1, instance.compare("test", null));        assertEquals(0, instance.compare("test", "test"));        assertEquals("test".length() - "a".length(), instance.compare("test", "a"));        assertEquals("a".length() - "test".length(), instance.compare("a", "test"));    }
@Test  public void testLogScaledForwardAlgorithm() {    // intialize the expected alpha values    double[][] alphaExpectedA = {        {0.02, 0.0392, 0.002438, 0.00035456, 0.0011554672, 7.158497e-04,            4.614927e-05},        {0.01, 0.0054, 0.001824, 0.00069486, 0.0007586904, 2.514137e-04,            1.721505e-05},        {0.32, 0.0262, 0.002542, 0.00038026, 0.0001360234, 3.002345e-05,            9.659608e-05},        {0.03, 0.0000, 0.013428, 0.00951084, 0.0000000000, 0.000000e+00,            2.428986e-05},};    // fetch the alpha matrix using the forward algorithm    Matrix alpha = HmmAlgorithms.forwardAlgorithm(getModel(), getSequence(), true);    // first do some basic checking    assertNotNull(alpha);    assertEquals(4, alpha.numCols());    assertEquals(7, alpha.numRows());    // now compare the resulting matrices    for (int i = 0; i < 4; ++i) {      for (int j = 0; j < 7; ++j) {        assertEquals(Math.log(alphaExpectedA[i][j]), alpha.get(j, i), EPSILON);      }    }  }
@Test  public void testDeserializerNoData() throws IOException {    final DataInputStream in = Mockito.mock(DataInputStream.class);    Mockito.when(in.hasUnReadData()).thenReturn(false);    Assert.assertEquals(0, serializer.deserializeKV(in, key, value));  }
@Test  public void testVersion() throws Exception {    assertThat(client.version()).isEqualTo("1.0.0");  }
@Test    public void testAddHeader() {        String headerName = "customized_header0";        String headerValue = "customized_value0";        httpService.addHeader(headerName, headerValue);        assertTrue(httpService.getHeaders().get(headerName).equals(headerValue));    }
@Test    public void highlightCode() {        final List<Option> options = new ArrayList<>();        options.add(new Option("--assignee, -a=<String[]>", null));        options.add(new Option("--body, -b=<String>", null));        final Highlight highlight = new Highlight(options);        /*         * Can we support no leading or trailing characters?         */        assertEquals("send a " +                        "\u001B[0m\u001B[1mGET\u001B[0m request to " +                        "\u001B[0m\u001B[1m/some/place\u001B[0m",                highlight.matches("send a `GET` request to `/some/place`"));    }
@Test	public void testSetEidValues_PRPAIN201302UV02() throws JAXBException {		// Arrange		String xmlPRPAIN201302UV02 = "<PRPA_IN201302UV02 xmlns=\"urn:hl7-org:v3\" ITSVersion=\"XML_1.0\"><id root=\"21acf7be-007c-41e6-b176-d0969794983b\"></id><creationTime value=\"20091112115139\"></creationTime><interactionId extension=\"PRPA_IN201302UV02\" root=\"2.16.840.1.113883.1.6\"></interactionId><processingCode code=\"P\"></processingCode><processingModeCode code=\"T\"></processingModeCode><acceptAckCode code=\"AL\"></acceptAckCode><receiver typeCode=\"RCV\"><device classCode=\"DEV\" determinerCode=\"INSTANCE\"><id root=\"1.2.840.114350.1.13.99999.4567\"></id><asAgent classCode=\"AGNT\"><representedOrganization classCode=\"ORG\" determinerCode=\"INSTANCE\"><id root=\"1.2.840.114350.1.13.99999.1234\"></id></representedOrganization></asAgent></device></receiver><sender typeCode=\"SND\"><device classCode=\"DEV\" determinerCode=\"INSTANCE\"><id root=\"1.2.840.114350.1.13.99998.8734\"></id><asAgent classCode=\"AGNT\"><representedOrganization classCode=\"ORG\" determinerCode=\"INSTANCE\"><id root=\"1.2.840.114350.1.13.99998\"></id></representedOrganization></asAgent></device></sender><controlActProcess classCode=\"CACT\" moodCode=\"EVN\"><code code=\"PRPA_TE201302UV02\" codeSystem=\"2.16.840.1.113883.1.6\"></code><subject typeCode=\"SUBJ\"><registrationEvent classCode=\"REG\" moodCode=\"EVN\"><id nullFlavor=\"NA\"></id><statusCode code=\"active\"></statusCode><subject1 typeCode=\"SBJ\"><patient classCode=\"PAT\"><id assigningAuthorityName=\"NIST2010\" extension=\"1c5c59f0-5788-11e3-84b3-00155d3a2124\" root=\"2.16.840.1.113883.4.357\"></id><statusCode code=\"active\"></statusCode><patientPerson><name><given>Asample</given><family>Patientone</family></name><telecom use=\"H\" value=\"555-255-5454\"></telecom><administrativeGenderCode code=\"M\"></administrativeGenderCode><birthTime value=\"19710510\"></birthTime><addr><streetAddressLine>3351 N chatham rd</streetAddressLine><city>ellicott city</city><state>Maryland</state></addr></patientPerson><providerOrganization><id root=\"1.2.840.114350.1.13.99998.8734\"></id><contactParty></contactParty></providerOrganization></patient></subject1><custodian typeCode=\"CST\"><assignedEntity classCode=\"ASSIGNED\"><id root=\"1.2.840.114350.1.13.99998.8734\"></id></assignedEntity></custodian></registrationEvent></subject></controlActProcess></PRPA_IN201302UV02>";		PRPAIN201302UV02 requestMock = marshaller.unmarshalFromXml(				PRPAIN201302UV02.class, xmlPRPAIN201302UV02);		String eIdMock = "eIdMock";		String eIdDomainMock = "eIdDomainMock";		// Act		sut.setEidValues(requestMock, eIdMock, eIdDomainMock);		// Assert		assertEquals(eIdMock, requestMock.getControlActProcess().getSubject()				.getRegistrationEvent().getSubject1().getPatient().getId()				.getExtension());		assertEquals(eIdDomainMock, requestMock.getControlActProcess()				.getSubject().getRegistrationEvent().getSubject1().getPatient()				.getId().getRoot());	}
@Test  @SuppressWarnings("all")  public void getAdGroupSimulationTest() {    com.google.ads.googleads.v5.services.AdGroupSimulationName resourceName2 =        com.google.ads.googleads.v5.services.AdGroupSimulationName.of(            "[CUSTOMER]", "[AD_GROUP_SIMULATION]");    long adGroupId = 85224585L;    String startDate = "startDate-1573629589";    String endDate = "endDate1725067410";    AdGroupSimulation expectedResponse =        AdGroupSimulation.newBuilder()            .setResourceName(resourceName2.toString())            .setAdGroupId(adGroupId)            .setStartDate(startDate)            .setEndDate(endDate)            .build();    mockAdGroupSimulationService.addResponse(expectedResponse);    AdGroupSimulationName resourceName =        AdGroupSimulationName.of("[CUSTOMER]", "[AD_GROUP_SIMULATION]");    AdGroupSimulation actualResponse = client.getAdGroupSimulation(resourceName);    Assert.assertEquals(expectedResponse, actualResponse);    List<AbstractMessage> actualRequests = mockAdGroupSimulationService.getRequests();    Assert.assertEquals(1, actualRequests.size());    GetAdGroupSimulationRequest actualRequest = (GetAdGroupSimulationRequest) actualRequests.get(0);    Assert.assertEquals(resourceName, AdGroupSimulationName.parse(actualRequest.getResourceName()));    Assert.assertTrue(        channelProvider.isHeaderSent(            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));  }
@Test  public void parseCea708AccessibilityChannel() {    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("1=lang:eng")))        .isEqualTo(1);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("2=lang:eng")))        .isEqualTo(2);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("3=lang:eng")))        .isEqualTo(3);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("62=lang:eng")))        .isEqualTo(62);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("63=lang:eng")))        .isEqualTo(63);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors(null)))        .isEqualTo(Format.NO_VALUE);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("")))        .isEqualTo(Format.NO_VALUE);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("0=lang:eng")))        .isEqualTo(Format.NO_VALUE);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("64=lang:eng")))        .isEqualTo(Format.NO_VALUE);    assertThat(            DashManifestParser.parseCea708AccessibilityChannel(                buildCea708AccessibilityDescriptors("Wrong format")))        .isEqualTo(Format.NO_VALUE);  }
@Test	public void testAvroByDefault() {		final TypeSerializer<User> serializer = new AvroTypeInfo<>(User.class).createSerializer(new ExecutionConfig());		assertTrue(serializer instanceof AvroSerializer);	}
@Test	public void test() throws Exception {		ClientEnvironment env = lookup(ClientEnvironment.class);		Properties config = env.getProducerConfig("test_topic");		assertNotNull(config);		assertEquals(config.getProperty("hermes"), "mq");		assertEquals(config.getProperty("inherited"), "got");		config = env.getProducerConfig("not_exist");		assertNotNull(config);		assertEquals(config.getProperty("hermes"), "default");		assertEquals(config.getProperty("inherited"), "got");	}
@Test  public void testDetermineCacheVisibilities() throws IOException {    fs.setPermission(TEST_VISIBILITY_PARENT_DIR,        new FsPermission((short)00777));    fs.setPermission(TEST_VISIBILITY_CHILD_DIR,        new FsPermission((short)00777));    fs.setWorkingDirectory(TEST_VISIBILITY_CHILD_DIR);    Job job = Job.getInstance(conf);    Path relativePath = new Path(SECOND_CACHE_FILE);    Path wildcardPath = new Path("*");    Map<URI, FileStatus> statCache = new HashMap<>();    Configuration jobConf;    job.addCacheFile(firstCacheFile.toUri());    job.addCacheFile(relativePath.toUri());    jobConf = job.getConfiguration();    // skip test if scratch dir is not PUBLIC    assumeTrue(TEST_VISIBILITY_PARENT_DIR + " is not public",        ClientDistributedCacheManager.isPublic(            jobConf, TEST_VISIBILITY_PARENT_DIR.toUri(), statCache));    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,        statCache);    // We use get() instead of getBoolean() so we can tell the difference    // between wrong and missing    assertEquals("The file paths were not found to be publicly visible "        + "even though the full path is publicly accessible",        "true,true", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));    checkCacheEntries(statCache, null, firstCacheFile, relativePath);    job = Job.getInstance(conf);    job.addCacheFile(wildcardPath.toUri());    jobConf = job.getConfiguration();    statCache.clear();    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,        statCache);    // We use get() instead of getBoolean() so we can tell the difference    // between wrong and missing    assertEquals("The file path was not found to be publicly visible "        + "even though the full path is publicly accessible",        "true", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));    checkCacheEntries(statCache, null, wildcardPath.getParent());    Path qualifiedParent = fs.makeQualified(TEST_VISIBILITY_PARENT_DIR);    fs.setPermission(TEST_VISIBILITY_PARENT_DIR,        new FsPermission((short)00700));    job = Job.getInstance(conf);    job.addCacheFile(firstCacheFile.toUri());    job.addCacheFile(relativePath.toUri());    jobConf = job.getConfiguration();    statCache.clear();    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,        statCache);    // We use get() instead of getBoolean() so we can tell the difference    // between wrong and missing    assertEquals("The file paths were found to be publicly visible "        + "even though the parent directory is not publicly accessible",        "false,false", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));    checkCacheEntries(statCache, qualifiedParent,        firstCacheFile, relativePath);    job = Job.getInstance(conf);    job.addCacheFile(wildcardPath.toUri());    jobConf = job.getConfiguration();    statCache.clear();    ClientDistributedCacheManager.determineCacheVisibilities(jobConf,        statCache);    // We use get() instead of getBoolean() so we can tell the difference    // between wrong and missing    assertEquals("The file path was found to be publicly visible "        + "even though the parent directory is not publicly accessible",        "false", jobConf.get(MRJobConfig.CACHE_FILE_VISIBILITIES));    checkCacheEntries(statCache, qualifiedParent, wildcardPath.getParent());  }
@Test  public void testLongitude() {    final NumericDimensionField[] fields =        new NumericDimensionField[] {new LongitudeField(GeometryUtils.MAX_GEOMETRY_PRECISION)};    final Geometry geo =        factory.createLineString(            new Coordinate[] {                new Coordinate(-99.22, 33.75000000000001), // notice                // that                // this gets                // tiled as                // 33.75                new Coordinate(-99.15, 33.75000000000001)            // notice that this gets tiled as 33.75            });    final GeometryWrapper wrapper = new GeometryWrapper(geo);    NumericRange rangeData = new NumericRange(-99.15 - (1E-10d), -99.140348473);    assertTrue(wrapper.overlaps(fields, new NumericData[] {rangeData}));    rangeData = new NumericRange(-99.15 + (1E-10d), -99.140348473);    assertFalse(wrapper.overlaps(fields, new NumericData[] {rangeData}));    rangeData = new NumericRange(-99.23, -99.22 + (1E-9d));    assertTrue(wrapper.overlaps(fields, new NumericData[] {rangeData}));    rangeData = new NumericRange(-99.23, -99.22 - (1E-10d));    assertFalse(wrapper.overlaps(fields, new NumericData[] {rangeData}));  }
@Test  public void testRunCommand() throws Exception {    ShellCommandUtil.Result result;    if (ShellCommandUtil.LINUX) {      result = ShellCommandUtil.              runCommand(new String [] {"echo", "dummy"});      Assert.assertEquals(0, result.getExitCode());      Assert.assertEquals("dummy\n", result.getStdout());      Assert.assertEquals("", result.getStderr());      Assert.assertTrue(result.isSuccessful());      result = ShellCommandUtil.              runCommand(new String [] {"false"});      Assert.assertEquals(1, result.getExitCode());      Assert.assertFalse(result.isSuccessful());    } else {      // Skipping this test under Windows/Mac    }  }
@Test    public void receiveObservationCancellation_withCode() throws Exception {        ObservationHandler observationHandler = mock(ObservationHandler.class);        server.setObservationHandler(observationHandler);        server.coapRequestHandler.handleObservation(newCoapPacket(LOCAL_5683).con(Code.C404_NOT_FOUND).obs(0).token(33).payload("A").mid(2).build(), TransportContext.NULL);        verify(observationHandler).callException(isA(ObservationTerminatedException.class));        //ack response        assertSendResponse(newCoapPacket(LOCAL_5683).emptyAck(2));    }
@Test( expected = IllegalArgumentException.class )    public void shouldFailTryingToRemoveEmptyFunctionName() throws Exception {        this.model.removeFunction( getTransaction(), EMPTY_STRING );    }
@Test	public void testPrecedence() throws Exception {		DDMExpressionImpl<BigDecimal> ddmExpressionImpl = createDDMExpression(			"4 - 2 * 6");		BigDecimal expected = new BigDecimal("-8");		BigDecimal bigDecimal = ddmExpressionImpl.evaluate();		Assert.assertEquals(0, bigDecimal.compareTo(expected));	}
@Test    public void testPermittedTopology_polygon_point() {        DimensionInfo sourceDimensionInfo = DimensionInfo.XY_POLYGON;        DimensionInfo targetDimensionInfo = DimensionInfo.XY_POINT;        RccPartiallyOverlappingFF instance = new RccPartiallyOverlappingFF();        boolean expResult = false;        boolean result = instance.permittedTopology(sourceDimensionInfo, targetDimensionInfo);        assertEquals(expResult, result);    }
@SuppressWarnings("unchecked")    @Test    public void testParse_elevationValues()                            throws Exception {        GetMapParser getMapXMLAdapter = new GetMapParser();        XMLStreamReader xmlStreamReader = createXmlStreamReader( "wms-1.3.0-GetMap_elevationValues.xml" );        GetMap getMap = getMapXMLAdapter.parse( xmlStreamReader );        HashMap<String, List<?>> dimensions = getMap.getDimensions();        assertThat( dimensions.size(), is( 1 ) );        List<Double> elevationValues = (List<Double>) dimensions.get( "elevation" );        assertThat( elevationValues.size(), is( 5 ) );        assertThat( elevationValues, hasItems( -1.5, -0.5, 0d, 0.5, 1.5 ) );    }
@Test  public void getFloat_MalformedFloatInString_ShouldReturnNull() {    String str = "abc12.1";    assert (Utils.getFloat(str) == null);  }
@Test  public void shouldSubscribeExactlyOnce1() {    final TestRequesterResponderSupport streamManager = TestRequesterResponderSupport.client();    final LeaksTrackingByteBufAllocator allocator = streamManager.getAllocator();    final TestDuplexConnection sender = streamManager.getDuplexConnection();    for (int i = 1; i < 50000; i += 2) {      final Payload payload = ByteBufPayload.create("testData", "testMetadata");      final FireAndForgetRequesterMono fireAndForgetRequesterMono =          new FireAndForgetRequesterMono(payload, streamManager);      final StateAssert<FireAndForgetRequesterMono> stateAssert =          StateAssert.assertThat(FireAndForgetRequesterMono.STATE, fireAndForgetRequesterMono);      Assertions.assertThatThrownBy(              () ->                  RaceTestUtils.race(                      () -> {                        AtomicReference<Throwable> atomicReference = new AtomicReference();                        fireAndForgetRequesterMono.subscribe(null, atomicReference::set);                        Throwable throwable = atomicReference.get();                        if (throwable != null) {                          throw Exceptions.propagate(throwable);                        }                      },                      fireAndForgetRequesterMono::block))          .matches(              t -> {                Assertions.assertThat(t)                    .hasMessageContaining("FireAndForgetMono allows only a single Subscriber");                return true;              });      final ByteBuf frame = sender.awaitFrame();      FrameAssert.assertThat(frame)          .isNotNull()          .hasPayloadSize(              "testData".getBytes(CharsetUtil.UTF_8).length                  + "testMetadata".getBytes(CharsetUtil.UTF_8).length)          .hasMetadata("testMetadata")          .hasData("testData")          .hasNoFragmentsFollow()          .typeOf(FrameType.REQUEST_FNF)          .hasClientSideStreamId()          .hasStreamId(i)          .hasNoLeaks();      stateAssert.isTerminated();      streamManager.assertNoActiveStreams();    }    Assertions.assertThat(sender.isEmpty()).isTrue();    allocator.assertHasNoLeaks();  }
@Test  public void getAllChildWorkflowsQueriesAllChildWorkflows() {    List<WorkflowInstance> result = singletonList(mock(WorkflowInstance.class));    when(workflowDao.queryWorkflowInstances(queryCaptor.capture())).thenReturn(result);    assertThat(execution.getAllChildWorkflows(), is(result));    QueryWorkflowInstances actualQuery = queryCaptor.getValue();    assertThat(actualQuery.parentWorkflowId, is(99L));    assertThat(actualQuery.types, emptyCollectionOf(String.class));    assertThat(actualQuery.businessKey, is(nullValue()));    assertThat(actualQuery.includeCurrentStateVariables, is(false));  }
@Test  public void evaluate_MockData_ShouldBeExpectedScalar1() throws CelloException {    Map<Variable, Double> args = new HashMap<>();    args.put(lut.getVariables().findCObjectByName("x"), 1.5);    args.put(lut.getVariables().findCObjectByName("bin"), 1.5);    assertEquals(lut.evaluate(args), 5.0, TOLERANCE);  }
@Test    public void testCheckLock() {        long v = dynoLockClient.acquireLock(resource, 5000);        Assert.assertTrue("Acquire lock did not succeed in time", v > 0);        Assert.assertEquals(1, dynoLockClient.getLockedResources().size());        v = dynoLockClient.checkLock(resource);        Assert.assertTrue("Check lock failed for acquired lock",v > 0);        dynoLockClient.releaseLock(resource);        Assert.assertTrue("Check lock failed for acquired lock", dynoLockClient.checkLock(resource) == 0);    }
@Test  public void testSingleton() {    final String[] as = singleton(String.class).apply("1");    assertEquals("1", as[0]);  }
@Test	public void testHrefAbsoluteURLRewriting() throws Exception {		String template = "<a href=\"/resource\">";		MailTemplate mailTemplate = new DefaultMailTemplate(template, false);		String result = mailTemplate.renderAsString(			Locale.ENGLISH, _mailTemplateContext);		Assert.assertEquals("<a href=\"http://liferay.com/resource\">", result);	}
@Test	public void testAddAMImageFileEntryItemSelectorReturnType()		throws Exception {		AMBlogsEditorConfigContributor amBlogsEditorConfigContributor =			new AMBlogsEditorConfigContributor();		BlogsItemSelectorCriterion blogsItemSelectorCriterion =			new BlogsItemSelectorCriterion();		blogsItemSelectorCriterion.setDesiredItemSelectorReturnTypes(			new FileEntryItemSelectorReturnType());		amBlogsEditorConfigContributor.			addAMImageFileEntryItemSelectorReturnType(				blogsItemSelectorCriterion);		List<ItemSelectorReturnType> desiredItemSelectorReturnTypes =			blogsItemSelectorCriterion.getDesiredItemSelectorReturnTypes();		Assert.assertEquals(			desiredItemSelectorReturnTypes.toString(), 2,			desiredItemSelectorReturnTypes.size());		Assert.assertTrue(			desiredItemSelectorReturnTypes.get(0) instanceof				AMImageFileEntryItemSelectorReturnType);		Assert.assertTrue(			desiredItemSelectorReturnTypes.get(1) instanceof				FileEntryItemSelectorReturnType);	}
@Test    @SuppressWarnings("deprecation")    public void TestCancelReservation02() throws IllegalArgumentException, IllegalAccessException {        // setup parameters        TransactionTokenInfo beginTransactionToken = new TransactionTokenInfo("testTokenAttribute1", TransactionTokenType.BEGIN);        TransactionToken receivedToken = new TransactionToken("aaa", "key", "value");        // setup up expected result        ReserveCommand expectedCommand = ReserveCommand.UPDATE_TOKEN;        // run        TransactionTokenContextImpl contextImpl = new TransactionTokenContextImpl(beginTransactionToken, receivedToken);        contextImpl.cancelReservation();        // test        Field field = ReflectionUtils.findField(                TransactionTokenContextImpl.class, "defaultCommand");        ReflectionUtils.makeAccessible(field);        ReserveCommand resultCommand = (ReserveCommand) field.get(contextImpl);        assertThat(resultCommand, is(expectedCommand));    }
@Test	public void testValidateConfigurationValidFieldColorPaletteRequired()		throws Exception {		_fragmentEntryValidatorImpl.validateConfiguration(			_read("configuration_valid_field_colorpalette_required.json"));	}
@Test  public void testSaveFactReturnsNullOnNullInput() {    assertNull(getFactManager().saveFact(null));  }
@Test    public void otherFolderNameResolution() {        v6Loader().schemaJson(get("otherFolderNameResolution")).build().load().build();    }
@Test	public void testAcceptsHTMLAndText() {		ReadingTimeCalculator readingTimeCalculator =			new ReadingTimeCalculatorImpl();		for (String contentType : _supportedContentTypes) {			Optional<Duration> readingTimeOptional =				readingTimeCalculator.calculate(					StringUtil.randomString(), contentType,					LocaleUtil.getDefault());			Assert.assertTrue(readingTimeOptional.isPresent());		}	}
@Test  public void testWriteStringsFileContext() throws IOException {    URI uri = tmp.toURI();    Configuration conf = new Configuration();    FileContext fc = FileContext.getFileContext(uri, conf);    Path testPath = new Path(new Path(uri), "writestrings.out");    Collection<String> write = Arrays.asList("over", "the", "lazy", "dog");    FileUtil.write(fc, testPath, write, StandardCharsets.UTF_8);    List<String> read =        FileUtils.readLines(new File(testPath.toUri()), StandardCharsets.UTF_8);    assertEquals(write, read);  }
@Test    public void shouldLoadFromPropertyFile() throws LifecycleExecutionException, URISyntaxException {        List<Dependency> dependencyList = loader.load(TestHelper.getClasspathResource("yaks.properties"), properties, logger);        TestHelper.verifyDependencies(dependencyList);    }
@Test  public void testHasOnlyInjectAnnotation() {    assertThat(mInjectionConfig.provideInjectableFieldAnnotations()).containsOnly(Inject.class);  }
@Test    void parse_AngleTypeVars() {        t=testee.parse("a.b.c<T,U> |-> a<T,U>");        assertEquals(                t.check("bad names", x -> x.names().contains("a"))                .check("arrow must be DIRECT", x -> x.conversionCoverage() == ConversionCoverage.DIRECT)                .check("must have type var T", x -> x.typeVariables().contains("T"))                .check("must have type var U", x -> x.typeVariables().contains("U"))                .check("must have an a", x -> x.tsExpressionElements().get(0).value().equals("a"))                .check("must have added the ts container <T,U>", x -> x.tsExpressionElements().get(1).value().equals("<T,U>"))                .leftOrNull()                , null        );        assertTrue(t.value().tsExpressionElements().get(1) instanceof TSMappedTypeContainer);        TSMappedTypeContainer t2 = (TSMappedTypeContainer) t.value().tsExpressionElements().get(1);        assertEquals(t2.expressions().size(),5);        assertEquals(t2.expressions().get(0).value(),"<");        assertEquals(t2.expressions().get(1), TSMappedTypeVarBuilder.of("T"));        assertEquals(t2.expressions().get(2).value(),",");        assertEquals(t2.expressions().get(3), TSMappedTypeVarBuilder.of("U"));        assertEquals(t2.expressions().get(4).value(),">");    }
@Test public void testBuildWithLocationQuery() {		// Arrange:		final MapIntent mapIntent = new MapIntent();		mapIntent.locationQuery("Rome, Italy");		// Act:		final Intent intent = mapIntent.build(context);		// Assert:		assertThatIntentIsValid(intent);		assertThat(				intent.getData(),				is(Uri.parse("geo:0,0?q=" + Uri.encode("Rome, Italy")))		);	}
@Test    public void single() {        final CommandParser.Command[] args = new CommandParser().toArgs("a");        assertEquals(1, args.length);        assertEquals(singletonList("a"), asList(args[0].getArgs()));    }
@Test    public void testLoadStream() throws Exception {        final InputStream resourceAsStream = XmlTest.class.getResourceAsStream("xmltest/sampleXml.xml");        Element element = Xml.loadStream(resourceAsStream);        assertSampleXml(element);    }
@Test    public void testGetStringNoFont() throws Exception {        assertNotNull(rsf.getString(100));        assertNotNull(rsf.getString(1));    }
@Test	public void testClone() {		Int8MultiArray clone = a1.clone();		assertEquals(a1.toString(), clone.toString());		assertEquals(a1.toJsonObject(), clone.toJsonObject());		assertEquals(a1.getMessageType(), clone.getMessageType());		assertTrue(Arrays.equals(a1.getData(), clone.getData()));		assertEquals(a1.getLayout(), clone.getLayout());		assertEquals(a1.size(), clone.size());		assertNotSame(a1, clone);		assertNotSame(a1.toString(), clone.toString());		assertNotSame(a1.toJsonObject(), clone.toJsonObject());		assertNotSame(a1.getData(), clone.getData());	}
@Test	public void test12GetTagResourceMapsByServiceId() {		Mockito.when(daoMgr.getXXTagResourceMap()).thenReturn(xXTagResourceMapDao);		rangerTagResourceMapService.getTagResourceMapsByServiceId(1L);	}
@Test    public void testPickParts_bigEnoughToUseRecommendedSize() {        final List<B2PartSpec> specs = partSizes.pickParts(3 * recSize + (recSize-2));        checkSpecs(specs,                new B2PartSpec(1, 0, 1332),                new B2PartSpec(2, 1332, 1332),                new B2PartSpec(3, 2664, 1334)        );    }
@Test	public void test12createService() throws Exception {		RangerService rangerService = rangerService();		Mockito.when(serviceREST.createService(rangerService)).thenReturn(rangerService);		RangerService dbRangerService = publicAPIsv2.createService(rangerService);		Assert.assertNotNull(dbRangerService);		Assert.assertEquals(dbRangerService, rangerService);		Assert.assertEquals(dbRangerService.getId(),				rangerService.getId());		Assert.assertEquals(dbRangerService.getName(),				rangerService.getName());		Mockito.verify(serviceREST).createService(rangerService);	}
@Test    void testMissingFileInRecordFileRepository() {        recordFileRepository.deleteAll();        assertThrows(MissingFileException.class, () -> {            sqlEntityListener.onStart(new StreamFileData(fileName, null));        });    }
@Test(expected = IllegalArgumentException.class)  public void empty() {    KeyPathParser.parse("");  }
@Test    void handle() {        assertThat(SUT.packetConsumer, nullValue());        SUT.handle(o -> o.notify());        assertThat(SUT.commands, hasSize(0));        assertThat(SUT.packetConsumer, notNullValue());        assertThrows(ConversationContext.PlcWiringException.class, () -> SUT.handle(o -> o.notify()));    }
@Test  public void dropAllRowsAsync() throws Exception {    String tableId = "tableWithNoDataId";    adminGCJClient.dropAllRowsAsync(tableId).get();    DropRowRangeRequest rangeRequest = (DropRowRangeRequest) serviceImpl.getRequests().get(0);    assertEquals(tableId, NameUtil.extractTableIdFromTableName(rangeRequest.getName()));  }
@Test    public void testAddAll() {        metadata.commit(() -> {            List<String> list = getList("prop1");            boolean result = list.addAll(Arrays.asList("x", "y", "z"));                        assertThat(result).isTrue();        }, MetadataAccess.SERVICE);                metadata.read(() -> {            List<String> list = getList("prop1");                        assertThat(list).contains("a", "b", "c", "x", "y", "z");        }, MetadataAccess.SERVICE);    }
@Test    public void testSetTableName01() throws Exception {        // 前処理        DBMessageResourceDAOImpl daoImpl = new DBMessageResourceDAOImpl();        daoImpl.tableName = "MESSAGES";        // テスト実施        daoImpl.setTableName("test01");        // 判定        assertEquals("test01", ReflectionTestUtils.getField(daoImpl,                "tableName"));    }
@Test  public void invokingClusterGetSlaves() {    commandCreatesNewSpan(RedisCommand.CLUSTER_SLAVES,        () -> getConnection().clusterGetSlaves(mockRedisClusterNode));    verify(mockRedisConnection()).clusterGetSlaves(mockRedisClusterNode);  }
@Test  public void testPreservePermissionOnDirectory() throws IOException {    FileSystem fs = FileSystem.get(config);    EnumSet<FileAttribute> attributes = EnumSet.of(FileAttribute.PERMISSION);    Path dst = new Path("/tmp/abc");    Path src = new Path("/tmp/src");    createDirectory(fs, src);    createDirectory(fs, dst);    fs.setPermission(src, fullPerm);    fs.setOwner(src, "somebody", "somebody-group");    fs.setPermission(dst, noPerm);    fs.setOwner(dst, "nobody", "nobody-group");    CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src));    DistCpUtils.preserve(fs, dst, srcStatus, attributes, false);    CopyListingFileStatus dstStatus = new CopyListingFileStatus(fs.getFileStatus(dst));    // FileStatus.equals only compares path field, must explicitly compare all fields    Assert.assertTrue(srcStatus.getPermission().equals(dstStatus.getPermission()));    Assert.assertFalse(srcStatus.getOwner().equals(dstStatus.getOwner()));    Assert.assertFalse(srcStatus.getGroup().equals(dstStatus.getGroup()));  }
@Test	public void testGetElementLocatorFromReferencedView() throws Exception {		String elementDescriptor = seleniumElementService.getElementLocatorFromReferencedView("Test page1", "navigation");				assertNotNull(elementDescriptor);		assertEquals("ID:navigation", elementDescriptor);	}
@Test    @Ignore    public void testUpdateDraggableViews() throws Exception {    }
@Test  public void testUnsetTimestampsAreNotPopulated() {    PutAdapter adapter = new PutAdapter(-1, false);    byte[] row = dataHelper.randomData("rk-");    byte[] family1 = dataHelper.randomData("f1");    byte[] qualifier1 = dataHelper.randomData("qual1");    byte[] value1 = dataHelper.randomData("v1");    Put hbasePut = new Put(row).addColumn(family1, qualifier1, value1);    com.google.cloud.bigtable.data.v2.models.Mutation unsafeMutation =        com.google.cloud.bigtable.data.v2.models.Mutation.createUnsafe();    adapter.adapt(hbasePut, unsafeMutation);    RowMutation rowMutation =        RowMutation.create(TABLE_ID, ByteString.copyFrom(hbasePut.getRow()), unsafeMutation);    MutateRowRequest request = rowMutation.toProto(REQUEST_CONTEXT);    Assert.assertArrayEquals(row, request.getRowKey().toByteArray());    Assert.assertEquals(1, request.getMutationsCount());    Mutation mutation = request.getMutations(0);    Assert.assertEquals(MutationCase.SET_CELL, mutation.getMutationCase());    SetCell setCell = mutation.getSetCell();    Assert.assertArrayEquals(family1, setCell.getFamilyNameBytes().toByteArray());    Assert.assertArrayEquals(qualifier1, setCell.getColumnQualifier().toByteArray());    Assert.assertEquals(-1, setCell.getTimestampMicros());    Assert.assertArrayEquals(value1, setCell.getValue().toByteArray());  }
@Test	public void testBooleanQuery() throws Exception {		SearchContext searchContext = getSearchContext();		searchContext.setKeywords("+test* -test.doc");		String cmisQuery = buildQuery(searchContext);		assertQueryEquals(			"((cmis:name LIKE 'test%' AND NOT(cmis:name = 'test.doc')) OR " +				"(cmis:createdBy LIKE 'test%' AND NOT(cmis:createdBy = " +					"'test.doc')))",			cmisQuery);	}
@Test    public void testSetWindow() {        Map<String, Long> oldMappings = new HashMap<>();        try (FDBRecordContext context = database.openContext()) {            for (int i = 0; i < 20; i++) {                String key = "old-resolved-" + i;                Long value = globalScope.resolve(context.getTimer(), key).join();                oldMappings.put(key, value);            }        }        globalScope.setWindow(10000L).join();        try (FDBRecordContext context = database.openContext()) {            for (int i = 0; i < 20; i++) {                Long value = globalScope.resolve(context.getTimer(), "new-resolved-" + i).join();                assertThat("resolved value is larger than the set window", value, greaterThanOrEqualTo(10000L));            }            for (Map.Entry<String, Long> entry : oldMappings.entrySet()) {                Long value = globalScope.resolve(context.getTimer(), entry.getKey()).join();                assertThat("we can still read the old mappings", value, is(entry.getValue()));            }        }    }
@Test	public void testAWriterDoesNotBlockReaders() {		final Lock testLock = new LockMRPlusSW();		testLock.enterCriticalSection(false);		final AtomicBoolean readerHasLock = new AtomicBoolean();		// new reader		defaultThreadFactory().newThread(() -> {			testLock.enterCriticalSection(true);			readerHasLock.set(true);		}).start();		await().untilTrue(readerHasLock);	}
@Test  public void testValueReplacement() throws Exception {    makeUpgradeCluster();    Cluster c = clusters.getCluster("c1");    assertEquals(1, c.getConfigsByType("zoo.cfg").size());    c.setDesiredStackVersion(HDP_220_STACK);    Config config = cf.createNew(c, "zoo.cfg", "version2", new HashMap<String, String>() {      {        put("key_to_replace", "My New Cat");        put("key_with_no_match", "WxyAndZ");      }    }, new HashMap<String, Map<String, String>>());    c.addDesiredConfig("user", Collections.singleton(config));    assertEquals(2, c.getConfigsByType("zoo.cfg").size());    Map<String, String> commandParams = new HashMap<>();    commandParams.put("upgrade_direction", "upgrade");    commandParams.put("version", HDP_2_2_0_1);    commandParams.put("clusterName", "c1");    commandParams.put(ConfigureTask.PARAMETER_CONFIG_TYPE, "zoo.cfg");    // Replacement task    List<Replace> replacements = new ArrayList<>();    Replace replace = new Replace();    replace.key = "key_to_replace";    replace.find = "New Cat";    replace.replaceWith = "Wet Dog";    replacements.add(replace);    replace = new Replace();    replace.key = "key_with_no_match";    replace.find = "abc";    replace.replaceWith = "def";    replacements.add(replace);    commandParams.put(ConfigureTask.PARAMETER_REPLACEMENTS, new Gson().toJson(replacements));    ExecutionCommand executionCommand = new ExecutionCommand();    executionCommand.setCommandParams(commandParams);    executionCommand.setClusterName("c1");    executionCommand.setRoleParams(new HashMap<String, String>());    executionCommand.getRoleParams().put(ServerAction.ACTION_USER_NAME, "username");    HostRoleCommand hostRoleCommand = hostRoleCommandFactory.create(null, null, null, null);    hostRoleCommand.setExecutionCommandWrapper(new ExecutionCommandWrapper(executionCommand));    action.setExecutionCommand(executionCommand);    action.setHostRoleCommand(hostRoleCommand);    CommandReport report = action.execute(null);    assertNotNull(report);    assertEquals(3, c.getConfigsByType("zoo.cfg").size());    config = c.getDesiredConfigByType("zoo.cfg");    assertNotNull(config);    assertFalse("version2".equals(config.getTag()));    assertEquals("My Wet Dog", config.getProperties().get("key_to_replace"));    assertEquals("WxyAndZ", config.getProperties().get("key_with_no_match"));  }
@Test(expected = IllegalStateException.class)    public void testReleaseUnknownEntry() throws Exception {        final LaxConnPool<String, HttpConnection> pool = new LaxConnPool<>(2);        pool.release(new PoolEntry<String, HttpConnection>("somehost"), true);    }
@Test  public void handleIncomingCancel() throws Exception {    underTest.handleIncomingEvent(new Request(10L));    underTest.handleIncomingEvent(new Cancel());    assertThat(underTest.getRequested(), is(0L));  }
@Test  public void updateRoad_withDeleteRoadPatch() throws Exception {    store.put(road1.getName(), road1);    client.updateRoad(new PatchSet(road1.getName(), singletonList(PatchOperation.remove(""))));    assertNull(store.get(road1.getName()));  }
@Test	public void lockDBEntityTest() {		Assert.notNull(getManager(), "ArchidocManager es nulo");		ILockDBEntity dbEntity = getManager().getLockDBEntity();		Assert.notNull(dbEntity, "entity es nulo");		Assert.isTrue(ArchivoTables.AGOBJBLOQUEO_TABLE_NAME.equals(dbEntity				.getTableName()),"Las tablas no coinciden");		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount()));	}
@Test  public void constructDateAndTimeValue() {    assertEquals(new ExprDateValue("2012-07-07"),        ExprValueUtils.fromObjectValue("2012-07-07", DATE));    assertEquals(new ExprTimeValue("01:01:01"),        ExprValueUtils.fromObjectValue("01:01:01", TIME));    assertEquals(new ExprDatetimeValue("2012-07-07 01:01:01"),        ExprValueUtils.fromObjectValue("2012-07-07 01:01:01", DATETIME));    assertEquals(new ExprTimestampValue("2012-07-07 01:01:01"),        ExprValueUtils.fromObjectValue("2012-07-07 01:01:01", TIMESTAMP));  }
@Test    public void testDeprecatedConfigOnSetterOnlyClass()            throws Exception    {        TestMonitor monitor = new TestMonitor();        ConfigurationMetadata<?> metadata = ConfigurationMetadata.getConfigurationMetadata(DeprecatedConfigOnSetterOnlyClass.class, monitor);        Map<String, Set<String>> expectedAttributes = new HashMap<>();        expectedAttributes.put("Value", ImmutableSet.of("value"));        expectedAttributes.put("Deprecated", ImmutableSet.of("deprecated-value"));        verifyMetaData(metadata, DeprecatedConfigOnSetterOnlyClass.class, null, false, expectedAttributes);        monitor.assertNumberOfErrors(1);        monitor.assertNumberOfWarnings(0);        monitor.assertMatchingErrorRecorded("getDeprecated", "setDeprecated", "must be @Deprecated together");    }
@Test    public void testIsApplicable_NoMatch_WrongFamily() {        assertFalse(extractor.isApplicable(new KeyValue(ROW, Bytes.toBytes("wrong family"), COLUMN_QUALIFIER,                Bytes.toBytes("value"))));    }
@Test    public void showPage() {        String homeView = controller.showPage();        assertEquals(HomeController.HOME_VIEW, homeView);    }
@Test  public void testMockspressoExtensionRule_create2() {    testMockspressoRule.create(TYPE_TOKEN);    verify(mockspressoRule).create(TYPE_TOKEN);  }
@Test    public void toLabel_oneminute() {    	assertEquals("1 minute ago", DateUtils.toLabel(new Date(new Date().getTime() - (65 * SECOND)), true));    }
@Test    public void testMultipleContentLength() throws Exception {        // Use HTTP 1.1        final HttpResponse response = new BasicHttpResponse(200, "OK");        response.addHeader("Content-Length", "10");        response.addHeader("Content-Length", "11");        Assert.assertFalse(reuseStrategy.keepAlive(null, response, context));    }
@Test(description = "This test case tests is compliant",          dependsOnMethods = "testIsCompliant")    public void testIsCompliant2() throws Exception {        MonitoringDAO monitoringDAO = spy(MonitoringDAOImpl.class);        doReturn(null).when(monitoringDAO).getCompliance(anyInt(),anyInt());        Object oldObj = changeFieldValue(monitoringManager, "monitoringDAO", monitoringDAO);        try {            DeviceIdentifier deviceIdentifier = new DeviceIdentifier();            deviceIdentifier.setType(DEVICE_TYPE_E);            deviceIdentifier.setId(String.valueOf(device5.getDeviceIdentifier()));            boolean compliant = monitoringManager.isCompliant(deviceIdentifier);            Assert.assertEquals(compliant,false);        } finally {            changeFieldValue(monitoringManager, "monitoringDAO", oldObj);        }    }
@Test    public void formatTest() {        ByteFormat bf = new ByteFormat();        Assert.assertEquals("100 bytes", bf.format(100));        Assert.assertEquals("999 bytes", bf.format(999L));    }
@Test	public void shouldConstructCriteriaQuery() {		Filter filter = new Filter(mock(Condition.class), mock(Condition.class));		CriteriaBuilder builder = mock(CriteriaBuilder.class);		Root root = mock(Root.class);		Predicate p1 = mock(Predicate.class);		Predicate p2 = mock(Predicate.class);		when(filter.getConditions().get(0).constructQuery(builder, root)).thenReturn(p1);		when(filter.getConditions().get(1).constructQuery(builder, root)).thenReturn(p2);		CriteriaQuery query = mock(CriteriaQuery.class);		filter.constructQuery(builder, query, root);		verify(query).where(p1, p2);	}
@Test  public void dropRowRangeAsync() throws Exception {    String rowKey = "cf-dropRange-async";    adminGCJClient.dropRowRangeAsync(TABLE_ID, rowKey).get();    DropRowRangeRequest rangeRequest = (DropRowRangeRequest) serviceImpl.getRequests().get(0);    assertEquals(TABLE_ID, NameUtil.extractTableIdFromTableName(rangeRequest.getName()));    assertEquals(rowKey, rangeRequest.getRowKeyPrefix().toStringUtf8());  }
@Test    public void testRead() throws Exception {        BufferedPullDataSource pds = spy(new BufferedPullDataSource());        pds.remoteReader = new DataInputStream(new MockInputStream(BufferedPullDataSource.MAX_BUFFER * 5));        pds.remoteWriter = new ByteArrayOutputStream(); // dummy output stream        pds._buffer = new byte[BufferedPullDataSource.MAX_BUFFER];        pds.opened = true;        pds.size = BufferedPullDataSource.MAX_BUFFER * 5;        byte buffer[] = new byte[BufferedPullDataSource.MAX_BUFFER];        // read a single byte, which should force the buffer to fill        int size = 1;        int read = pds.read(0, buffer, 0, 1);        assertEquals(size, read);        assertEquals(new String(data, 0, size), new String(buffer, 0, size));        verify(pds, times(1)).fillBuffer(eq(0l));        // now read a bunch of other single byte reads, which should NOT force a buffer re-fill        read = pds.read(0, buffer, 1, 1);        assertEquals(size, read);        assertEquals(new String(data, 1, size), new String(buffer, 1, size));        verify(pds, times(1)).fillBuffer(eq(0l));        // now read some data that is outside the buffer range, and it should force a re-read        read = pds.read(BufferedPullDataSource.MAX_BUFFER * 2, buffer, 0, 1);        assertEquals(size, read);        //assertEquals(((BufferedPullDataSource.MAX_BUFFER*2)%10)+'0', buffer[0]);        verify(pds, times(1)).fillBuffer(eq(BufferedPullDataSource.MAX_BUFFER * 2l));    }
@Test    public void shouldDelegateTheAccessControlLogicToTheAccessController() throws Exception {        assertThat(System.getProperty(ACCESS_CONTROL_DISABLED_PROPERTY), is(nullValue()));        final Optional<AccessControlViolation> accessControlViolation =                of(mock(AccessControlViolation.class));        when(policyEvaluator.checkAccessPolicyFor("command", jsonEnvelope)).thenReturn(accessControlViolation);        assertThat(accessControlService.checkAccessControl("command", jsonEnvelope),                is(sameInstance(accessControlViolation)));        assertLogStatement();    }
@Test    public void imdsv2() {        stubFor(any(urlPathEqualTo("/latest/api/token")).willReturn(ok("token")));        stubFor(any(urlPathEqualTo("/latest/dynamic/instance-identity/document"))                    .willReturn(okJson(IDENTITY_DOCUMENT)));        Map<EC2MetadataFetcher.EC2Metadata, String> metadata = fetcher.fetch();        assertThat(metadata).containsOnly(            entry(EC2MetadataFetcher.EC2Metadata.INSTANCE_ID, "i-1234567890abcdef0"),            entry(EC2MetadataFetcher.EC2Metadata.AVAILABILITY_ZONE, "us-west-2b"),            entry(EC2MetadataFetcher.EC2Metadata.INSTANCE_TYPE, "t2.micro"),            entry(EC2MetadataFetcher.EC2Metadata.AMI_ID, "ami-5fb8c835"));        verify(putRequestedFor(urlEqualTo("/latest/api/token"))                   .withHeader("X-aws-ec2-metadata-token-ttl-seconds", equalTo("60")));        verify(getRequestedFor(urlEqualTo("/latest/dynamic/instance-identity/document"))                   .withHeader("X-aws-ec2-metadata-token", equalTo("token")));    }
@Test(expected = ExternalAppNotMappedException.class)	public void testGenerateTicketWithWrongApp() throws ExternalAppNotMappedException	{		manager.generateNewTicket("IdoNOTexist", "doesntREALLYmatter");	}
@Test	public void testNextChunkEvenIfThereAreNone() throws IOException {		// Test Constants		final int TOTAL_FILE_SIZE = 5*1024;		final int CHUNK_SIZE = 512*1024;				// Setup						File inputFile = TestFileUtil.createRandomFileInDirectory(tempDir, TOTAL_FILE_SIZE);				Chunker chunker = new TttdChunker(CHUNK_SIZE);				// Create chunks		Enumeration<Chunk> chunkEnumeration = chunker.createChunks(inputFile);				while (chunkEnumeration.hasMoreElements()) {			chunkEnumeration.nextElement();		}				// This should lead to an IOException		assertNull("No chunk expected, but data received.", chunkEnumeration.nextElement());		assertFalse("hasElements() should return 'false' if no chunk available.", chunkEnumeration.hasMoreElements());	}
@Test    public void isLogLevelEnabled_TRACE_enabled() throws Exception {        when(underlyingLogger.isTraceEnabled()).thenReturn(true);        assertThat(LambdaLoggerUtils.isLogLevelEnabled(underlyingLogger, Level.TRACE, null)).isTrue();    }
@Test	public void testHTMLParser_parse_checkTitle() {		Document doc = HTMLParser.parse(SAMPLE_HTML);		assertNotNull(doc);		assertEquals(doc.title(), "My title");	}
@Test    public void testGetImage() throws IOException {        AnalysisController ac = new AnalysisController();        ac.setFilename(BASEDIR + "qav-analysis-result.json");        ac.init();        ResponseEntity<Resource> img = ac.getImage("p1.png");        assertThat(img).isNotNull();        assertThat(img.getStatusCode()).isEqualTo(HttpStatus.OK);        assertThat(img.getBody()).isNotNull();        assertThat(img.getBody().contentLength()).isEqualTo(4679L);        img = ac.getImage("p1.svg");        assertThat(img).isNotNull();        assertThat(img.getStatusCode()).isEqualTo(HttpStatus.OK);        assertThat(img.getBody()).isNotNull();        assertThat(img.getBody().contentLength()).isEqualTo(2248L);        img = ac.getImage("p1.graphml");        assertThat(img).isNotNull();        assertThat(img.getStatusCode()).isEqualTo(HttpStatus.OK);        assertThat(img.getBody()).isNotNull();        assertThat(img.getBody().contentLength()).isEqualTo(0L); // because it's a fake file.        assertThat(img.getHeaders().getFirst("Content-Disposition")).isEqualTo("attachment; filename=\"p1.graphml\"");    }
@Test	public void twoArgFormatter() {		TwoArgFormatter formatter = (TwoArgFormatter) FormatterRegistry				.createFormatter(TwoArgFormatter.class, Arrays.asList("a", "b"));		assertEquals("a", formatter.arg1);		assertEquals("b", formatter.arg2);	}
@Test    public void putProperty() {        assertNull(model.putProperty(null, VALUE));        assertNull(model.putProperty(NAME, VALUE));        assertEquals(VALUE, model.putProperty(NAME, null));    }
@Test    public void shouldSerializeNodeProperties() {        String result = new JsonResourceSerializer().serialize(resource);        assertThat(result)                .as("Node's properties should be serialized")                .contains(PARENT_PROP)                .contains(PARENT_VALUE);    }
@Test	public void testExecutePutMappingIndexRequest() {		PutMappingIndexRequest putMappingIndexRequest =			new PutMappingIndexRequest(null, null, null);		_elasticsearchIndexRequestExecutor.executeIndexRequest(			putMappingIndexRequest);		Mockito.verify(			_putMappingIndexRequestExecutor		).execute(			putMappingIndexRequest		);	}
@Test    void create15() {        final MutableTuple15<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> tuple = MutableTuples.create15();        test(tuple);        final MutableTuple15<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> defaultTuple = new MutableTuple15<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>()         {            private Integer t0;            private Integer t1;            private Integer t2;            private Integer t3;            private Integer t4;            private Integer t5;            private Integer t6;            private Integer t7;            private Integer t8;            private Integer t9;            private Integer t10;            private Integer t11;            private Integer t12;            private Integer t13;            private Integer t14;            @Override            public Optional<Integer> get0() {                return Optional.of(0);            }            @Override            public void set0(Integer val) {                t0 = val;            }            @Override            public Optional<Integer> get1() {                return Optional.of(1);            }            @Override            public void set1(Integer val) {                t1 = val;            }            @Override            public Optional<Integer> get2() {                return Optional.of(2);            }            @Override            public void set2(Integer val) {                t2 = val;            }            @Override            public Optional<Integer> get3() {                return Optional.of(3);            }            @Override            public void set3(Integer val) {                t3 = val;            }            @Override            public Optional<Integer> get4() {                return Optional.of(4);            }            @Override            public void set4(Integer val) {                t4 = val;            }            @Override            public Optional<Integer> get5() {                return Optional.of(5);            }            @Override            public void set5(Integer val) {                t5 = val;            }            @Override            public Optional<Integer> get6() {                return Optional.of(6);            }            @Override            public void set6(Integer val) {                t6 = val;            }            @Override            public Optional<Integer> get7() {                return Optional.of(7);            }            @Override            public void set7(Integer val) {                t7 = val;            }            @Override            public Optional<Integer> get8() {                return Optional.of(8);            }            @Override            public void set8(Integer val) {                t8 = val;            }            @Override            public Optional<Integer> get9() {                return Optional.of(9);            }            @Override            public void set9(Integer val) {                t9 = val;            }            @Override            public Optional<Integer> get10() {                return Optional.of(10);            }            @Override            public void set10(Integer val) {                t10 = val;            }            @Override            public Optional<Integer> get11() {                return Optional.of(11);            }            @Override            public void set11(Integer val) {                t11 = val;            }            @Override            public Optional<Integer> get12() {                return Optional.of(12);            }            @Override            public void set12(Integer val) {                t12 = val;            }            @Override            public Optional<Integer> get13() {                return Optional.of(13);            }            @Override            public void set13(Integer val) {                t13 = val;            }            @Override            public Optional<Integer> get14() {                return Optional.of(14);            }            @Override            public void set14(Integer val) {                t14 = val;            }        };        test(defaultTuple);    }
@Test    public void test_getAuthUrl_successful() {        OidcRequest oidcRequest = new OidcRequest("default", "http://localhost:3000");        String jsonStr = "{  \"role\": \"default\",  \"redirect_uri\": \"http://localhost:3000\"}";        String responseJson = "{\n" +                "  \"request_id\": \"test8b8-6ac68f0ab58d\",\n" +                "  \"lease_id\": \"\",\n" +                "  \"renewable\": false,\n" +                "  \"lease_duration\": 0,\n" +                "  \"data\": {\n" +                "    \"auth_url\": \"https://login.authdomain.com/test123123/oauth2/v2.0/authorize?client_id=test123123&nonce=123123&redirect_uri=http%3A%2F%2Flocalhost%3A3000&response_type=code&scope=openid+https%3A%2F%2Fgraph.authdomain.com%2F.default+profile&state=test4343545\"\n" +                "  },\n" +                "  \"wrap_info\": null,\n" +                "  \"warnings\": null,\n" +                "  \"auth\": null\n" +                "}";        Response response = getMockResponse(HttpStatus.OK, true, responseJson);        when(JSONUtil.getJSON(any(OidcRequest.class))).thenReturn(jsonStr);        when(reqProcessor.process("/auth/oidc/oidc/auth_url",jsonStr,"")).thenReturn(response);        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseJson);        ResponseEntity<String> responseEntity = oidcAuthService.getAuthUrl(oidcRequest);        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());        assertEquals(responseEntityExpected, responseEntity);    }
@Test(dataProvider = "matchObjects")    public void test(String string, String pattern, boolean expected) {        assertEquals(WildcardMatching.isMatch(string, pattern), expected, String.format("s: %s, p: %s", string, pattern));    }
@Test( expected = IOException.class )	public void testSendMessageToTheDm_messagingError() throws Exception {		Mockito.verifyZeroInteractions( this.msgClient );		Mockito.doThrow( new IOException( "for test" )).when( this.msgClient ).sendMessageToTheDm( Mockito.any( MsgCmdRemoveInstance.class ));		this.mngr.sendMessageToTheDm( new MsgCmdRemoveInstance( "/" ));	}
@Test(expected = NoSuchElementException.class)  public void testGetItems() throws Exception {    LongPrimitiveIterator it = model.getItemIDs();    assertNotNull(it);    assertTrue(it.hasNext());    assertEquals(123, it.nextLong());    assertTrue(it.hasNext());    assertEquals(234, it.nextLong());    assertTrue(it.hasNext());    assertEquals(456, it.nextLong());    assertTrue(it.hasNext());    assertEquals(654, it.nextLong());    assertTrue(it.hasNext());    assertEquals(789, it.nextLong());    assertTrue(it.hasNext());    assertEquals(999, it.nextLong());    assertFalse(it.hasNext());    it.next();  }
@Test  public void testIsInjectedType() {    assertTrue(typeLoader.isInjectedType(TypeToken.of(HttpServletRequest.class)));    assertFalse(typeLoader.isInjectedType(TypeToken.of(String.class)));  }
@Test    public void testSaveVSCLAction() {        jsonString =                "{\"userid\":\"demo\",\"vsclActionDictionaryData\":{\"description\":\"test\",\"vsclaction\":\"Test\"}}";        try (BufferedReader br = new BufferedReader(new StringReader(jsonString))) {            when(request.getReader()).thenReturn(br);            controller.saveVSCLAction(request, response);            assertTrue(response.getContentAsString() != null                    && response.getContentAsString().contains("vsclActionDictionaryDatas"));        } catch (Exception e) {            logger.error("Exception" + e);        }    }
@Test    public void testDeleteById() {        RowAndFamilyAddingSolrUpdateWriter updateWriter = new RowAndFamilyAddingSolrUpdateWriter("_row_", null,                uniqueKeyFormatter, keyValue, delegateWriter);        byte[] rowBytes = Bytes.toBytes("_row_");        doReturn("_rowkey_").when(uniqueKeyFormatter).formatRow(rowBytes);        updateWriter.deleteById(uniqueKeyFormatter.formatRow(rowBytes));        verify(delegateWriter).deleteById("_rowkey_");    }
@Test  public void testTuple_3Parsers() {    Parser<?> parser = Parsers.tuple(isChar('a'), isChar('b'), isChar('c'));    assertEquals(Tuples.tuple('a', 'b', 'c'), parser.parse("abc", mode));    assertFailure(mode, parser, "xbc", 1, 1);    assertFailure(mode, parser, "axc", 1, 2);    assertFailure(mode, parser, "abx", 1, 3);  }
@Test(expected = NullPointerException.class)    public void testNullInputName() {        qavNameMatcher.matches("pattern", null);    }
@Test    void forEach() {        instance.forEach(i -> cnt.incrementAndGet());        assertEquals(1, cnt.get());        assertThrows(IllegalStateException.class, () -> instance.forEach(x -> {}));    }
@Test(expected = InvalidRoadNameException.class)  public void nullRoadName() {    underTest.validate(null);  }
@Test    public void testGetFormatNames(){        final String[] formatNames = plugIn.getFormatNames();        assertEquals(1, formatNames.length);        assertEquals("AMSRE_L2A", formatNames[0]);    }
@Test    public void testIfThen() {        Observable<Integer> source1 = Observable.from(1, 2, 3);        Observable<Integer> result = Statement.ifThen(condition, source1);        observe(result, 1, 2, 3);        observe(result);        observe(result, 1, 2, 3);        observe(result);    }
@Test	public void testRemainingChunksOrderIsPreserved() throws Exception {		InputStream inputStream = _createInputStream(			_PNG_SIGNATURE, _MISC_CHUNK1, _ZTXT_CHUNK, _COMPRESSED_ITXT_CHUNK,			_MISC_CHUNK2, _ICCP_CHUNK);		byte[] bytes = new byte			[_PNG_SIGNATURE.length + _MISC_CHUNK1.length + _MISC_CHUNK2.length];		inputStream.read(bytes);		Assert.assertArrayEquals(			ArrayUtil.append(_PNG_SIGNATURE, _MISC_CHUNK1, _MISC_CHUNK2),			bytes);		Assert.assertEquals(-1, inputStream.read());	}
@Test    public void testQueryString() {        TabixDataSource instance = new ErrorThrowingTabixDataSource("LOCAL");        assertThrows(IllegalArgumentException.class,  () -> instance.query("X:12345-12345"));    }
@Test    public void DebugStringTest() {        String s = Blessings.DebugString();        assertTrue(s.contains("Default Blessings"));    }
@Test	public void testChildInnerJoin() {		Function<FromStep, JoinStep> childJoinFunction =			fromStep -> fromStep.from(				ReferenceExampleTable.INSTANCE			).innerJoinON(				MainExampleTable.INSTANCE,				MainExampleTable.INSTANCE.mainExampleId.eq(					ReferenceExampleTable.INSTANCE.mainExampleId)			);		TableReferenceDefinition<MainExampleTable> tableReferenceDefinition =			new TestTableReferenceDefinition<MainExampleTable>(				MainExampleTable.INSTANCE) {				@Override				public void defineChildTableReferences(					ChildTableReferenceInfoBuilder<MainExampleTable>						childTableReferenceInfoBuilder) {					childTableReferenceInfoBuilder.referenceInnerJoin(						childJoinFunction);				}				@Override				public void defineParentTableReferences(					ParentTableReferenceInfoBuilder<MainExampleTable>						parentTableReferenceInfoBuilder) {				}			};		TableReferenceInfo<MainExampleTable> tableReferenceInfo =			TableReferenceInfoFactory.create(				MainExampleTable.CLASS_NAME_ID,				MainExampleTable.INSTANCE.mainExampleId,				tableReferenceDefinition);		Assert.assertNotNull(tableReferenceInfo);		Assert.assertSame(			tableReferenceDefinition,			tableReferenceInfo.getTableReferenceDefinition());		Map<Table<?>, List<TableJoinHolder>> childTableJoinHoldersMap =			tableReferenceInfo.getChildTableJoinHoldersMap();		Assert.assertEquals(			childTableJoinHoldersMap.toString(), 1,			childTableJoinHoldersMap.size());		List<TableJoinHolder> childJoinHolders = childTableJoinHoldersMap.get(			ReferenceExampleTable.INSTANCE);		Assert.assertEquals(			childJoinHolders.toString(), 1, childJoinHolders.size());		TableJoinHolder childJoinHolder = childJoinHolders.get(0);		Assert.assertSame(childJoinFunction, childJoinHolder.getJoinFunction());		Map<Table<?>, List<TableJoinHolder>> parentTableJoinHoldersMap =			tableReferenceInfo.getParentTableJoinHoldersMap();		Assert.assertTrue(			parentTableJoinHoldersMap.toString(),			parentTableJoinHoldersMap.isEmpty());		Assert.assertEquals(			MainExampleTable.CLASS_NAME_ID,			tableReferenceInfo.getClassNameId());	}
@Test    public void doPost() throws IOException {        dockerClientFty.addConfigurator(dockerClient ->                dockerClient.setSupportedAPIVersion(DockerCloudUtils.DOCKER_API_TARGET_VERSION));        CheckConnectivityController ctrl = createController();        TestHttpServletRequest request = new TestHttpServletRequest();        request.parameters(TestUtils.getSampleDockerConfigParams());        EditableNode responseNode = Node.EMPTY_OBJECT.editNode();        ctrl.doPost(request, new TestHttpServletResponse(), responseNode);        assertThat(responseNode.getObject("version", null)).isNotNull();        TestDockerClient client = dockerClientFty.getClient();        Node version = client.getVersion();        EditableNode versionNode = responseNode.getObject("version");        assertThat(versionNode).isEqualTo(version);        Node info = client.getInfo();        EditableNode infoNode = responseNode.getObject("info");        assertThat(infoNode).isEqualTo(info);        EditableNode meta = responseNode.getObject("meta");        assertThat(meta.getAsLong("serverTime"))                .isCloseTo(System.currentTimeMillis(), Offset.offset(400L));        assertThat(meta.getAsString("effectiveApiVersion"))                .isEqualTo(client.getApiVersion().getVersionString());    }
@Test(expected = DDMExpressionException.class)	public void testUnavailableLogicalVariable() throws Exception {		DDMExpressionImpl<Boolean> ddmExpressionImpl = createDDMExpression(			"a > 5");		ddmExpressionImpl.evaluate();	}
@Test  public void tolerateEmptyFiles() throws Exception {    createSourceFiles("com/hello/", "com/hello/package-info.java");    Path file = writeFile(workspace.resolve("com/hello/package-info.java"), "package com.hello;");    JavaSourceFileParser parser = createParser(file);    assertThatGraphsEqual(parser.getClassToClass(), newGraph());  }
@Test    public void testGetScore() {//        assertThat(instance.getScore(), closeTo(score, 0.0001));        assertThat(instance.getScore(), equalTo(score));    }
@Test    public void should_increment_an_asset() throws Exception {        Widget widget = aWidget().id("my-widget").custom().build();        Asset asset = anAsset().withComponentId("my-widget").withOrder(3).build();        when(widgetRepository.get("my-widget")).thenReturn(widget);        mockMvc.perform(                put("/rest/widgets/my-widget/assets/UIID?increment=true")                        .contentType(MediaType.APPLICATION_JSON_VALUE)                        .content(convertObjectToJsonBytes(asset)))                .andExpect(status().isOk());        verify(widgetAssetService).changeAssetOrderInComponent(widget, "UIID", INCREMENT);    }
@Test  public void setUpOmegaContextInTransactionRequest() throws Exception {    when(request.getHeader(OmegaContext.GLOBAL_TX_ID_KEY)).thenReturn(globalTxId);    when(request.getHeader(OmegaContext.LOCAL_TX_ID_KEY)).thenReturn(localTxId);    requestInterceptor.preHandle(request, response, null);    assertThat(omegaContext.globalTxId(), is(globalTxId));    assertThat(omegaContext.localTxId(), is(localTxId));  }
@SuppressWarnings({ "unchecked", "rawtypes" })  @Test (timeout = 10000)  public void testSerilizationAfterRecovery() throws Exception {    // Add to cluster node labels, p2/p6 are non-exclusive.    mgr.addToCluserNodeLabels(Arrays.asList(NodeLabel.newInstance("p1", true),        NodeLabel.newInstance("p2", false), NodeLabel.newInstance("p3", true),        NodeLabel.newInstance("p4", true), NodeLabel.newInstance("p5", true),        NodeLabel.newInstance("p6", false)));    mgr.replaceLabelsOnNode(ImmutableMap.of(toNodeId("n1"), toSet("p1"),        toNodeId("n2"), toSet("p2")));    mgr.replaceLabelsOnNode((Map) ImmutableMap.of(toNodeId("n3"), toSet("p3"),        toNodeId("n4"), toSet("p4"), toNodeId("n5"), toSet("p5"),        toNodeId("n6"), toSet("p6"), toNodeId("n7"), toSet("p6")));    /*     * node -> labels      * p1: n1      * p2: n2      * p3: n3     * p4: n4      * p5: n5      * p6: n6, n7     */    mgr.removeFromClusterNodeLabels(toSet("p1"));    mgr.removeFromClusterNodeLabels(Arrays.asList("p3", "p5"));    /*     * After removed      * p2: n2      * p4: n4      * p6: n6, n7     */    // shutdown mgr and start a new mgr    mgr.stop();    mgr = new MockNodeLabelManager();    mgr.init(conf);    mgr.start();    // check variables    Assert.assertEquals(3, mgr.getClusterNodeLabelNames().size());    Assert.assertTrue(mgr.getClusterNodeLabelNames().containsAll(        Arrays.asList("p2", "p4", "p6")));    assertMapContains(mgr.getNodeLabels(), ImmutableMap.of(toNodeId("n2"),        toSet("p2"), toNodeId("n4"), toSet("p4"), toNodeId("n6"), toSet("p6"),        toNodeId("n7"), toSet("p6")));    assertLabelsToNodesEquals(mgr.getLabelsToNodes(),        ImmutableMap.of(        "p6", toSet(toNodeId("n6"), toNodeId("n7")),        "p4", toSet(toNodeId("n4")),        "p2", toSet(toNodeId("n2"))));    Assert.assertFalse(mgr.isExclusiveNodeLabel("p2"));    Assert.assertTrue(mgr.isExclusiveNodeLabel("p4"));    Assert.assertFalse(mgr.isExclusiveNodeLabel("p6"));    /*     * Add label p7,p8 then shutdown     */    mgr = new MockNodeLabelManager();    mgr.init(conf);    mgr.start();    mgr.addToCluserNodeLabelsWithDefaultExclusivity(toSet("p7", "p8"));    mgr.stop();        /*     * Restart, add label p9 and shutdown     */    mgr = new MockNodeLabelManager();    mgr.init(conf);    mgr.start();    mgr.addToCluserNodeLabelsWithDefaultExclusivity(toSet("p9"));    mgr.stop();        /*     * Recovery, and see if p9 added     */    mgr = new MockNodeLabelManager();    mgr.init(conf);    mgr.start();    // check variables    Assert.assertEquals(6, mgr.getClusterNodeLabelNames().size());    Assert.assertTrue(mgr.getClusterNodeLabelNames().containsAll(        Arrays.asList("p2", "p4", "p6", "p7", "p8", "p9")));    mgr.stop();  }
@Test    void get6Test() {        assertEquals(6, (int) instance.get6());    }
@Test	public void testGetUpgradePathWithCyclesReturnsShortestPath() {		UpgradeInfo upgradeInfo1 = createUpgradeInfo("0.0.0", "0.1.0");		UpgradeInfo upgradeInfo2 = createUpgradeInfo("0.1.0", "0.2.0");		UpgradeInfo upgradeInfo3 = createUpgradeInfo("0.2.0", "1.0.0");		UpgradeInfo upgradeInfo4 = createUpgradeInfo("1.0.0", "2.0.0");		UpgradeInfo upgradeInfo5 = createUpgradeInfo("0.0.0", "2.0.0");		ReleaseGraphManager releaseGraphManager = new ReleaseGraphManager(			Arrays.asList(				upgradeInfo1, upgradeInfo2, upgradeInfo3, upgradeInfo4,				upgradeInfo5));		List<UpgradeInfo> upgradePath = releaseGraphManager.getUpgradeInfos(			"0.0.0", "2.0.0");		Assert.assertEquals(Arrays.asList(upgradeInfo5), upgradePath);	}
@Test(expected = ResourceNotFoundException.class)    public void testGetFlowDirectDoesNotExist() {        when(metadataService.getFlowById(any(String.class))).thenReturn(null);        registryService.getFlow("flow1");    }
@Test    void singleShouldThrowOnBigResult()    {        assertThrows( NoSuchRecordException.class, () -> createResult( 42 ).single() );    }
@Test    public void testGetPropertyTypesLimited() {        int limit = 20;        int start = 10;        service.getPropertyTypes(limit, start);        verify(dao).readTypes(limit, start);    }
@Test	public void testGetRestHighLevelClientWithRemoteModeEnabled() {		enableRemoteMode();		Assert.assertEquals(			_defaultRemoteElasticsearchConnection.getRestHighLevelClient(),			_elasticsearchConnectionManager.getRestHighLevelClient());	}
@Test(expected = VRaptorException.class)	public void convertingANonAnnotatedConverterEndsUpComplaining() {	converters.register(WrongConverter.class);	}
@Test(expected = IndexOutOfBoundsException.class)	public void testGetWhenIndexIsZeroAndAssignmentIsNull() {		KaleoTaskInstanceToken kaleoTaskInstanceToken =			KaleoRuntimeTestUtil.mockKaleoTaskInstanceToken();		LazyWorkflowTaskAssigneeList lazyWorkflowTaskAssigneeList =			new LazyWorkflowTaskAssigneeList(kaleoTaskInstanceToken, null);		lazyWorkflowTaskAssigneeList.get(0);	}
@Test  public void testNoBlankWithNull() {      assertEquals("%W=U~)O|0'#?,zA", StringUtil.noBlank(null, "%W=U~)O|0'#?,zA"));  }
@Test    public void fieldIsType() {        final DescriptorProtos.FileDescriptorProto file = TestRecords1Proto.getDescriptor().toProto();        assertEquals(FieldTypeMatch.MATCHES,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", "MySimpleRecord"));        assertEquals(FieldTypeMatch.MATCHES,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", ".com.apple.foundationdb.record.test1.MySimpleRecord"));        assertEquals(FieldTypeMatch.MATCHES_AS_NESTED,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", ".com.apple.foundationdb.record"));        assertEquals(FieldTypeMatch.DOES_NOT_MATCH,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", "MySimpleRecord.MyNestedRecord"));        assertEquals(FieldTypeMatch.DOES_NOT_MATCH,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", ".com.apple.foundationdb.record.test1.MySimpleRecord.MyNestedRecord"));        assertEquals(FieldTypeMatch.DOES_NOT_MATCH,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", ".com.apple.foundationdb.record.test2.MySimpleRecord"));        assertEquals(FieldTypeMatch.DOES_NOT_MATCH,                fieldIsType(file, RecordMetaDataBuilder.DEFAULT_UNION_NAME, "_MySimpleRecord", "MyOtherRecord"));    }
@Test  public void testDisabled() throws Exception {    configuration.setClientSecurityType(ClientSecurityType.LOCAL);    Authentication authentication = new UsernamePasswordAuthenticationToken("allowedUser", "password");    Authentication auth = authenticationProvider.authenticate(authentication);    Assert.assertTrue(auth == null);  }
@Test    public void shouldDeserializeNullToNull() throws Exception {        assertNull(deserialize(toTest, null));    }
@Test public void shouldCreateHelper() throws Exception {        IabHelper helper = new IabHelper(Robolectric.application, PUBLIC_KEY);        assertThat(helper.isDisposed()).isFalse();    }
@Test  public void buildPrimitiveType() {    ContextURL contextURL = ContextURL.with().serviceRoot(serviceRoot)        .type(OData.newInstance().createPrimitiveTypeInstance(EdmPrimitiveTypeKind.String))        .build();    assertEquals(serviceRoot + "$metadata#Edm.String",        ContextURLBuilder.create(contextURL).toASCIIString());    contextURL = ContextURL.with().serviceRoot(serviceRoot)        .type(OData.newInstance().createPrimitiveTypeInstance(EdmPrimitiveTypeKind.String)).asCollection()        .build();    assertEquals(serviceRoot + "$metadata#Collection(Edm.String)",        ContextURLBuilder.create(contextURL).toString());  }
@Test	public void shouldBeAbleToInstantiateABean() {	this.picoContainer.addComponent(Fruit.class);	assertThat(container.instanceFor(Fruit.class), is(notNullValue()));	}
@Test    public void manageMap_RuleSimpleType() {        Map<String, String> expectedMap1 = new HashMap<>();        expectedMap1.put(LOWER_CASE_VALUE, NUMBER_CLASS_NAME);        manageMap(NUMBER_CLASS_NAME, RULE, expectedMap1);    }
@Test    void shouldResolvePromiseOnFailure()    {        Promise<Boolean> promise = newPromise();        PingResponseHandler handler = newHandler( promise );        handler.onFailure( new RuntimeException() );        assertTrue( promise.isSuccess() );        assertFalse( promise.getNow() );    }
@Test	public void format() {		final String expr = "(((5.0 - 6.0*x) - (3.0 + 4.0)) + sin(x)^34.0) + (1.0 + sin(x*5.0)/4.0)/6.0";		Assert.assertEquals(MathExpr.format(MathExpr.parse(expr).toTree()), expr);	}
@Test    public void writeToStringPassOnlyAnyModeOfInheritance() throws Exception {        Analysis analysis = this.analysisBuilder.analysisMode(AnalysisMode.PASS_ONLY).build();        AnalysisResults analysisResults = this.analysisResultsBuilder.build();        OutputSettings outputSettings = this.settingsBuilder.outputContributingVariantsOnly(true).build();        JsonResultsWriter instance = new JsonResultsWriter();        String result = instance.writeString(ModeOfInheritance.ANY, analysis, analysisResults, outputSettings);        String expected = readFromFile("src/test/resources/writers/contributing_only_any_moi_test.json");        JSONAssert.assertEquals(expected, result, true);    }
@Test    public void testGetExperiment() {        get(EXPERIMENT_ENDPOINT, EXPERIMENT_BAD)            .assertStatus(Status.NOT_FOUND);        final ExperimentDto expected = MAPPER.toDto(experiment(EXPERIMENT_1), ExperimentDto.class);        final ExperimentDto actual =            get(EXPERIMENT_ENDPOINT, EXPERIMENT_1)                .assertStatus(Status.OK)                .result(ExperimentDto.class);        assertEquals(expected, actual);    }
@Test  public void TestConvertDatanodeStorage() {    DatanodeStorage dns1 = new DatanodeStorage(        "id1", DatanodeStorage.State.NORMAL, StorageType.SSD);    DatanodeStorageProto proto = PBHelperClient.convert(dns1);    DatanodeStorage dns2 = PBHelperClient.convert(proto);    compare(dns1, dns2);  }
@Test    public void encode() throws Exception {        Assert.assertEquals(codec.encode(TO_BE_ENCODE), TO_BE_DECODE);    }
@Test    public void testInvoke() throws Throwable {        expect(mockInvocation.getThis()).andReturn(mockHarvester);        expect(mockInvocation.proceed()).andReturn(null);        EasyMockUnitils.replay();        interceptor.invoke(mockInvocation);    }
@Test    public void testParse()            throws Exception {        What3WordsSearchChannel channel = new What3WordsSearchChannel();        JSONObject json = ResourceHelper.readJSONResource("What3Words-success.json", this);        SearchResultItem item = channel.parseResult(json, "EPSG:3067");        assertEquals("Title", item.getTitle(), "carting.pint.invent");        assertEquals("Lat", item.getLat(), 6675293.715526561, 0.1);        assertEquals("Lon", item.getLon(), 385547.65760422836, 0.1);    }
@Test    @SuppressWarnings("ConstantConditions")    public void invalidNPipeSettings() {        // Using TLS with a unix socket.        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() ->                DefaultDockerClient.newInstance(createConfig(DockerCloudUtils.DOCKER_DEFAULT_NAMED_PIPE_URI, true)));        // Invalid slash count after scheme.        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() ->                DefaultDockerClient.newInstance(createConfig(URI.create("npipe:///./pipe/non_standard_location"),                        false)));        // With query.        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() ->                DefaultDockerClient.newInstance(createConfig(URI.create("npipe:////" +                        "./pipe/non_standard_location?param=value"), false)));    }
@Test(expected = UnsupportedOperationException.class)    public void setCharacterEncoding() throws UnsupportedEncodingException {        request.setCharacterEncoding("");    }
@Test  public void testSwap() {    Matrix m = new DenseMatrix(10, 10);    for (int i = 0; i < 10; i++) {      for (int j = 0; j < 10; j++) {        m.set(i, j, 10 * i + j);      }    }    PivotedMatrix pm = new PivotedMatrix(m);    pm.swap(3, 5);    assertEquals(0, pm.viewDiagonal().minus(        new DenseVector(new double[]{0, 11, 22, 55, 44, 33, 66, 77, 88, 99})).norm(1), 1.0e-10);    pm.swap(2, 7);    assertEquals(0, pm.viewDiagonal().minus(        new DenseVector(new double[]{0, 11, 77, 55, 44, 33, 66, 22, 88, 99})).norm(1), 1.0e-10);    pm.swap(5, 8);    assertEquals(0, pm.viewColumn(4).minus(        new DenseVector(new double[]{4.0,14.0,74.0,54.0,44.0,84.0,64.0,24.0,34.0,94.0})).norm(1), 1.0e-10);    assertEquals(0, pm.viewDiagonal().minus(        new DenseVector(new double[]{0, 11, 77, 55, 44, 88, 66, 22, 33, 99})).norm(1), 1.0e-10);  }
@Test    public void testAuditLoggerWithBasicCatalog() throws Exception {        auditLogger = buildAuditLogger(new ClassPathCatalogReader(Collections.singletonMap("catalogFile", "basicCatalog.json")));        auditLogger.logEvent("login", null);    }
@Test    public void shouldNotifyOnDetach() {        dispatcher.onDetach(fragment);        verify(lifeCycleComponent1).onDetach(fragment);        verify(lifeCycleComponent2).onDetach(fragment);    }
@Test    public void canDealRequestWithSeveralReactor() throws IOException {        int availablePort = NetUtils.getAvailablePort();        MultiReactor reactor = MultiReactor.newBuilder()                .setPort(availablePort)                .setHandlerClass(InsureReactorHandler.class)                .setMainReactorName("MainReactor")                .setSubReactorCount(3)                .build();        // start a new thread        Thread reactorT = new Thread(reactor);        reactorT.start();        String first = NetWorkClient.doRequest("localhost", availablePort, "test\n");        String second = NetWorkClient.doRequest("localhost", availablePort, "test\n");        String third = NetWorkClient.doRequest("localhost", availablePort, "test\n");        String nextRoundFirst = NetWorkClient.doRequest("localhost", availablePort, "test\n");        List<String> responses = new ArrayList<>();        responses.add(first);        responses.add(second);        responses.add(third);        responses.add(nextRoundFirst);        Map<String, Long> result = responses.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));        Map<String, Long> expect = new HashMap<>();        expect.put("subReactor-0", 1L);        expect.put("subReactor-1", 1L);        expect.put("subReactor-2", 2L);        assertEquals(expect, result);    }
@Test    public void givenAStepStarted_whenWritingAllItemsAtOnce_thenAnEventWith100ProgressIsTriggered() {        startAStepWithEmployees(100);        jobProgressListener.afterWrite(aListWithSize(100));        Mockito.verify(eventBus, times(2)).post(eventArgumentCaptor.capture());        checkPercentageComplete(eventArgumentCaptor.getAllValues().get(0), 0);        checkPercentageComplete(eventArgumentCaptor.getAllValues().get(1), 100);    }
@Test    public void action_restart_ok() throws Exception {        final URIBuilder uriBuilder = createGetUrl(ROOT_URI + "/42/action");        JsonObject request = createJson()                .add("type", "RESTART")                .add("data", createJson()                        .add("totalRestart", "false"))                .build();        // performs POST: /api/messages/42/action        mockMvc.perform(post(toUrl(uriBuilder))                .content(request.toString())                .contentType(MediaType.APPLICATION_JSON)                .accept(MediaType.APPLICATION_JSON)                .with(SecurityMockMvcRequestPostProcessors.authentication(mockAuthentication("ADMIN"))))                .andExpect(status().isOk())                .andExpect(jsonPath("result", is("OK")))        ;        Mockito.verify(messageOperationService, times(1)).restartMessage(eq(42L), eq(false));    }
@Test    public void testRest()throws Exception{        given(this.roleRepository.findOne(2)).willReturn(new Role(2, "ROLE_USER"));        String content = mockMvc.perform(get("/mock/rest/2"))                .andExpect(status().is(200)).andReturn().getResponse().getContentAsString();        System.out.println(content);    }
@Test  public void testEditorOperationStart() throws WorkflowOperationException, IOException {    // uri for new preview track smil file    EasyMock.expect(            workspaceMock.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),                    (String) EasyMock.anyObject(), (InputStream) EasyMock.anyObject())).andReturn(            URI.create("http://localhost:8080/foo/presenter.smil"));    // uri for new episode smil file    String episodeSmilUri = "http://localhost:8080/foo/episode.smil";    EasyMock.expect(            workspaceMock.put((String) EasyMock.anyObject(), (String) EasyMock.anyObject(),                    (String) EasyMock.anyObject(), (InputStream) EasyMock.anyObject())).andReturn(            URI.create(episodeSmilUri));    EasyMock.replay(workspaceMock);    WorkflowInstanceImpl workflowInstance = getWorkflowInstance(mp, getDefaultConfiguration(true));    WorkflowOperationResult result = videoEditorWorkflowOperationHandler.start(workflowInstance, null);    Assert.assertNotNull(            "VideoEditor workflow operation returns null but should be an instantiated WorkflowOperationResult", result);    EasyMock.verify(workspaceMock);    WorkflowOperationInstance worflowOperationInstance = workflowInstance.getCurrentOperation();    String smillFlavorsProperty = worflowOperationInstance.getConfiguration("smil-flavors");    String previewFlavorsProperty = worflowOperationInstance.getConfiguration("preview-flavors");    MediaPackageElementFlavor smilFlavor = MediaPackageElementFlavor.parseFlavor(smillFlavorsProperty);    MediaPackageElementFlavor previewFlavor = MediaPackageElementFlavor.parseFlavor(previewFlavorsProperty);    // each preview track (e.g. presenter/preview) should have an own smil catalog in media package    Catalog[] previewSmilCatalogs = result.getMediaPackage().getCatalogs(            new MediaPackageElementFlavor("presenter", "smil"));    Assert.assertTrue(previewSmilCatalogs != null && previewSmilCatalogs.length > 0);    for (Track track : result.getMediaPackage().getTracks()) {      if (track.getFlavor().matches(previewFlavor)) {        boolean smilCatalogFound = false;        MediaPackageElementFlavor trackSmilFlavor = new MediaPackageElementFlavor(track.getFlavor().getType(),                smilFlavor.getSubtype());        for (Catalog previewSmilCatalog : previewSmilCatalogs) {          if (previewSmilCatalog.getFlavor().matches(trackSmilFlavor)) {            smilCatalogFound = true;            break;          }        }        Assert.assertTrue("Mediapackage doesn't contain a smil catalog with flavor " + trackSmilFlavor.toString(),                smilCatalogFound);      }    }    // an "target-smil-flavor catalog" schould be in media package    String targetSmilFlavorProperty = worflowOperationInstance.getConfiguration("target-smil-flavor");    Catalog[] episodeSmilCatalogs = result.getMediaPackage().getCatalogs(            MediaPackageElementFlavor.parseFlavor(targetSmilFlavorProperty));    Assert.assertTrue("Mediapackage should contain catalog with flavor " + targetSmilFlavorProperty,            episodeSmilCatalogs != null && episodeSmilCatalogs.length > 0);    Assert.assertTrue("Target smil catalog URI does not match",            episodeSmilCatalogs[0].getURI().compareTo(URI.create(episodeSmilUri)) == 0);  }
@Test    public void testTryResetStreamForRetry_CanReset() throws IOException {        when(is.markSupported()).thenReturn(true);        Retriers.tryResetStreamForRetry(is);        verify(is).markSupported();        verify(is).reset();        verifyNoMoreInteractions(is);    }
@Test    public void testEmpty() {        new DimensionQueue(mTracker);        verify(mTracker).addTrackingCallback(mCaptor.capture());        TrackMe pre = new TrackMe();        TrackMe post = mCaptor.getValue().onTrack(pre);        assertThat(post, notNullValue());        assertThat(pre, is(post));    }
@Test    public void testComponentInputMapEnabledControlsFocusedKeyBindings() {        JXMonthView monthView = new JXMonthView();        // initial: no bindings        assertEquals("monthView must not have in-focused keyBindings", 0,                 monthView.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).size());        monthView.setComponentInputMapEnabled(true);        // setting the flag installs bindings        assertTrue("monthView must have in-focused keyBindings after showing in popup",                monthView.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).size() > 0);        monthView.setComponentInputMapEnabled(false);        // resetting the flag uninstalls the bindings        assertEquals("monthView must not have in-focused keyBindings", 0,                 monthView.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).size());    }
@Test    public void answersCorrectValueType() {        assertEquals( Path.class, new PathConverter().valueType() );    }
@Test  void should_ReturnEntity_When_ConvertingRepresentationModelToEntity() throws Exception {    ObjectReference primaryObjRef = new ObjectReference();    primaryObjRef.setId("abc");    WorkbasketSummaryRepresentationModel workbasketResource =        new WorkbasketSummaryRepresentationModel();    workbasketResource.setWorkbasketId("workbasketId");    ClassificationSummaryRepresentationModel classificationSummary =        new ClassificationSummaryRepresentationModel();    classificationSummary.setKey("keyabc");    classificationSummary.setDomain("DOMAIN_A");    classificationSummary.setType("MANUAL");    AttachmentRepresentationModel attachment = new AttachmentRepresentationModel();    attachment.setClassificationSummary(classificationSummary);    attachment.setAttachmentId("attachmentId");    TaskSummaryRepresentationModel repModel = new TaskRepresentationModel();    repModel.setAttachmentSummaries(Collections.singletonList(attachment));    repModel.setClassificationSummary(classificationSummary);    repModel.setWorkbasketSummary(workbasketResource);    repModel.setPrimaryObjRef(primaryObjRef);    repModel.setTaskId("taskId");    repModel.setExternalId("externalId");    repModel.setCreated(Instant.parse("2019-09-13T08:44:17.588Z"));    repModel.setClaimed(Instant.parse("2019-09-13T08:44:17.588Z"));    repModel.setCompleted(Instant.parse("2019-09-13T08:44:17.588Z"));    repModel.setModified(Instant.parse("2019-09-13T08:44:17.588Z"));    repModel.setPlanned(Instant.parse("2019-09-13T08:44:17.588Z"));    repModel.setDue(Instant.parse("2019-09-13T08:44:17.588Z"));    repModel.setName("name");    repModel.setCreator("creator");    repModel.setDescription("desc");    repModel.setNote("note");    repModel.setPriority(123);    repModel.setState(TaskState.READY);    repModel.setBusinessProcessId("businessProcessId");    repModel.setParentBusinessProcessId("parentBusinessProcessId");    repModel.setOwner("owner");    repModel.setRead(true);    repModel.setTransferred(true);    repModel.setCustom1("custom1");    repModel.setCustom2("custom2");    repModel.setCustom3("custom3");    repModel.setCustom4("custom4");    repModel.setCustom5("custom5");    repModel.setCustom6("custom6");    repModel.setCustom7("custom7");    repModel.setCustom8("custom8");    repModel.setCustom9("custom9");    repModel.setCustom10("custom10");    repModel.setCustom11("custom11");    repModel.setCustom12("custom12");    repModel.setCustom13("custom13");    repModel.setCustom14("custom14");    repModel.setCustom15("custom15");    repModel.setCustom16("custom16");    // when    TaskSummary task = assembler.toEntityModel(repModel);    // then    testEquality(task, repModel);  }
@Test    public void parseMappingAddPrefix() {        final Map<String, String> target = new HashMap<>();        assertTrue(XmlNamespaceUtils.parseMappingAddPrefix("x=y", target));        assertFalse(XmlNamespaceUtils.parseMappingAddPrefix("a", target));        assertEquals("y", target.get("xmlns:x"));        assertNull(target.get("xmlns:a"));    }
@Test  public void testDoNotLeaveDefaultEmpty() throws Exception {    final String prog = "void main() {"        + "  switch(0) {"        + "    default:"        + "    1;"        + "  }"        + "}";    final String expected = "void main() {"        + "}";    final TranslationUnit tu = ParseHelper.parse(prog);    List<StmtReductionOpportunity> ops = StmtReductionOpportunities        .findOpportunities(MakeShaderJobFromFragmentShader.make(tu), new ReducerContext(true,            ShadingLanguageVersion.ESSL_310,            new RandomWrapper(0), new IdGenerator()));    assertEquals(1, ops.size());    ops.get(0).applyReduction();    CompareAsts.assertEqualAsts(expected, tu);  }
@Test    public void testGetValueAsBoolean() throws Exception {        final HarvesterData data = new HarvesterData();        final ISODate value = new ISODate();        data.setValue(value);        assertEquals(value, data.getValueAsDate());    }
@Test    public void testConvertPrimitiveArrayToList31() throws Exception {        // 前処理        short[] value = { (short) 1, (short) 2, (short) 3 };        // テスト実施        Object result = ConvertUtil.convertPrimitiveArrayToList(value);        // 判定        assertNotNull(result);        assertTrue(result instanceof List);        List<?> listResult = (List<?>) result;        assertEquals(3, listResult.size());        assertEquals("1", listResult.get(0));        assertEquals("2", listResult.get(1));        assertEquals("3", listResult.get(2));    }
@Test	public void testGetGridValue() {		DDMFormFieldValue ddmFormFieldValue =			DDMFormValuesTestUtil.createDDMFormFieldValue(				"Grid", new UnlocalizedValue("{\"RowValue\":\"ColumnValue\"}"));		Assert.assertEquals(			"{\"RowValue\":\"ColumnValue\"}",			String.valueOf(				_gridDDMFormFieldValueAccessor.getValue(					ddmFormFieldValue, LocaleUtil.US)));	}
@Test	public final void testProcessRelationWithNoUser() {		Relation relation =			new Relation(new CommonEntityData(1234, 2, timestamp, OsmUser.NONE, 0));		relation.getMembers().add(new RelationMember(2345, EntityType.Node, "noderole"));		relation.getMembers().add(new RelationMember(3456, EntityType.Way, "wayrole"));		relation.getMembers().add(new RelationMember(4567, EntityType.Relation, "relationrole"));		relation.getTags().add(new Tag("relationkey", "relationvalue"));				testRelationWriter.process(relation);		try {			testBufferedWriter.flush();		} catch (IOException e) {			e.printStackTrace();			fail("IOException");		}		String relationOpeningNoUserMatch = "^\\s*<relation\\s*"				+ "id=['\"]1234['\"]\\s*"				+ "version=['\"]2['\"]\\s*"				+ "timestamp=['\"]2013-10-07T10:24:31Z?['\"]\\s*"				+ ">\\s*";		String[] strArray = testWriter.toString().split("\\n", 6);		assertTrue(strArray[0].matches(relationOpeningNoUserMatch));		assertTrue(strArray[1].matches(nodeMemberMatch));		assertTrue(strArray[2].matches(wayMemberMatch));		assertTrue(strArray[3].matches(relationMemberMatch));		assertTrue(strArray[4].matches(relationTagMatch));		assertTrue(strArray[5].matches(relationClosingMatch));	}
@Test    public void toStringTest() throws Exception {        String message = m_singleDeviceRequest.toString();        assertTrue(message.contains("name"));    }
@Test    public void testUpdateRiskTypeDictionary() {        jsonString = "{\"userid\":\"demo\",\"riskTypeDictionaryData\":{\"description\":\"test\",\"name\":\"Test\"}}";        try (BufferedReader br = new BufferedReader(new StringReader(jsonString))) {            when(request.getReader()).thenReturn(br);            controller.saveRiskTypeDictionary(request, response);            assertTrue(response.getContentAsString() != null                    && response.getContentAsString().contains("riskTypeDictionaryDatas"));        } catch (Exception e) {            logger.error("Exception" + e);        }    }
@Test    void requireNotEquals5() {        assertEquals(1.0, DoubleRangeUtil.requireNotEquals(1.0, -1.0));    }
@Test(expected = IllegalArgumentException.class)	public void testInvalid4() throws Exception {		RetryPolicyFactory.create("2:  ");	}
@Test  void testOnHeadersRead_preflightOptionsRequest() {    CorsConfig corsConfig =        CorsConfigBuilder.forOrigin("test.domain")            .allowCredentials()            .allowedRequestMethods(HttpMethod.GET)            .build();    Http2CorsHandler corsHandler = new Http2CorsHandler(corsConfig);    testHandler = new Http2Handler(mockEncoder, MAX_PAYLOAD, corsHandler);    headers        .method("OPTIONS")        .add("origin", "test.domain")        .add("access-control-request-method", "GET")        .path(OK_PATH);    testHandler.onHeadersRead(mockContext, STREAM_ID, headers, 1, true);    assertEquals(1L, requestMeter.getCount());    verifyResponse(        HttpResponseStatus.OK,        ImmutableMap.of(            "access-control-allow-methods",            "GET",            "access-control-allow-origin",            corsConfig.origin(),            "access-control-allow-credentials",            "true"),        Optional.empty(),        STREAM_ID);  }
@Test    public void fetchAllMovies_200OkResponse_InvokesCorrectApiCalls() {        //Given        when(mMovieDbRestService.fetchAllMovies(anyString()))                .thenReturn(Observable.just(moviesList()));        //When        TestSubscriber<List<Movie>> testSubscriber = new TestSubscriber<>();        mMovieRepository.fetchMovies(POPULAR).subscribe(testSubscriber);        //Then        testSubscriber.awaitTerminalEvent();        testSubscriber.assertNoErrors();        List<List<Movie>> onNextEvents = testSubscriber.getOnNextEvents();        List<Movie> movies = onNextEvents.get(0);        Assert.assertEquals(JURASIC_WORLD, movies.get(0).getOriginalTitle());        Assert.assertEquals(FAST_AND_FURIOUS, movies.get(1).getOriginalTitle());        verify(mMovieDbRestService).fetchAllMovies(POPULAR);    }
@Test  public void testFifoOrderingPolicyForPendingApps() {    FifoOrderingPolicyForPendingApps<MockSchedulableEntity> policy =        new FifoOrderingPolicyForPendingApps<MockSchedulableEntity>();    MockSchedulableEntity r1 = new MockSchedulableEntity();    MockSchedulableEntity r2 = new MockSchedulableEntity();    assertThat(policy.getComparator().compare(r1, r2)).isEqualTo(0);    r1.setSerial(1);    r1.setRecovering(true);    assertThat(policy.getComparator().compare(r1, r2)).isEqualTo(-1);    r1.setRecovering(false);    r2.setSerial(2);    r2.setRecovering(true);    assertThat(policy.getComparator().compare(r1, r2)).isEqualTo(1);  }
@Test  public void interpretNumericalLessThanWithAddition() {    assertTrue(WorkflowConditionInterpreter.interpret("1+1 < 3"));  }
@DisplayName("throws NullPointerException with null name")  @Test  void createNullName() {    assertThatNullPointerException()        .isThrownBy(() -> LocalClientTransport.create(null))        .withMessage("name must not be null");  }
@Test    public void getCourse() {        MutableLiveData<CourseEntity> course = new MutableLiveData<>();        course.setValue(dummyCourse);        when(academyRepository.getCourseWithModules(courseId)).thenReturn(course);        CourseEntity courseEntity = viewModel.getCourse().getValue();        verify(academyRepository).getCourseWithModules(courseId);        assertNotNull(courseEntity);        assertEquals(dummyCourse.getCourseId(), courseEntity.getCourseId());        assertEquals(dummyCourse.getDeadline(), courseEntity.getDeadline());        assertEquals(dummyCourse.getDescription(), courseEntity.getDescription());        assertEquals(dummyCourse.getImagePath(), courseEntity.getImagePath());        assertEquals(dummyCourse.getTitle(), courseEntity.getTitle());        viewModel.getCourse().observeForever(courseObserver);        verify(courseObserver).onChanged(dummyCourse);    }
@Test    void shouldSkipInvalidJsonLookingLikeAValidOne() {        final String invalidJson = "{invalid}";        final String filtered = unit.filter("application/custom+json", invalidJson);        assertThat(filtered, is(invalidJson));    }
@Test    public void testEmptyRender() throws Exception {        final TNodeRepeatIter repeat = new TNodeRepeatIter(info, TextContentParserTest.createTestTextContentParser(),            false, null, TNode.EMPTY_ATTRIBUTES, "iter", "key");        Map<String, Object> model = Collections.<String, Object>singletonMap("iter", Collections.emptyList());        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();        repeat.render(new TRenderContext(outputStream, model));        assertEquals("<!-- fmt-repeat: key in iter is empty -->", outputStream.toString());    }
@Test  public void testTranspose() throws Exception {    DistributedRowMatrix m = randomDistributedMatrix(10, 9, 5, 4, 1.0, false);    m.setConf(getConfiguration());    DistributedRowMatrix mt = m.transpose();    mt.setConf(getConfiguration());    Path tmpPath = getTestTempDirPath();    m.setOutputTempPathString(tmpPath.toString());    Path tmpOutPath = new Path(tmpPath, "/tmpOutTranspose");    mt.setOutputTempPathString(tmpOutPath.toString());    HadoopUtil.delete(getConfiguration(), tmpOutPath);    DistributedRowMatrix mtt = mt.transpose();    assertEquals(m, mtt, EPSILON);  }
@Test  public void testPushMetricsFailed() throws Exception {    final UrlService svcMock = createStrictMock(UrlService.class);    final String payload = "test";    final String expectedResponse = "mockResponse";    RestMetricsSender sender = new RestMetricsSender("expectedHostName") {      @Override      protected UrlService getConnectedUrlService() throws IOException {        return svcMock;      }    };    expect(svcMock.send(anyString())).andThrow(new IOException());    svcMock.disconnect();    expectLastCall();    replay(svcMock);    String response = sender.pushMetrics(payload);    verify(svcMock);  }
@Test  @Ignore // TODO @Transactional annotation breaks this test  public void testCreateUserDefaultParams() throws Exception {    final Users spy = Mockito.spy(users);    spy.createUser("user", "user");    Mockito.verify(spy).createUser("user", "user", UserType.LOCAL, true, false);  }
@Test    void getSkipLimitSupport() {        assertNotNull(instance.getSkipLimitSupport());    }
@Test    void linkMissingPolicy() {        Bundle fullBundle = new Bundle();        fullBundle.addEntity(myEncass);        fullBundle.addEntity(createFolder("myFolder", "1", null));        FolderTree folderTree = new FolderTree(fullBundle.getEntities(Folder.class).values());        fullBundle.setFolderTree(folderTree);        assertThrows(LinkerException.class, () -> encassLinker.link(bundle, fullBundle));    }
@Test    public void testRemovePSClosedLoopDictionary() {        jsonString = "{\"userid\":\"demo\",\"data\":{\"id\":1,\"description\":\"test\",\"name\":\"Test\"}}";        try (BufferedReader br = new BufferedReader(new StringReader(jsonString))) {            when(request.getReader()).thenReturn(br);            controller.removePSClosedLoopDictionary(request, response);            assertTrue(response.getContentAsString() != null                    && response.getContentAsString().contains("psClosedLoopDictionaryDatas"));        } catch (Exception e) {            logger.error("Exception" + e);        }    }
@Test(expected = UnsupportedOperationException.class)    public void testToHexStringZeroPaddedTooLargs() {        Numeric.toHexStringNoPrefixZeroPadded(BigInteger.valueOf(-1), 5);    }
@Test    public void testCheckBounds_lon_small() {        double latitude = 0.0;        double longitude = -180.0;        ConvertLatLon.checkBounds(latitude, longitude);    }
@Test    public void testReadEmtpyBeat() throws Exception {        instance.openFile(simpleFile);        Mockito.verify(listener).readEmptyBeat(0, 1, 0, true, false);        Mockito.verify(listener).readEmptyBeat(0, 2, 0, true, false);    }
@Test(expected = IllegalArgumentException.class)  public void testNonExistingIdField() throws IOException {    commitDocuments(getDirectory(getIndexPath1AsFile()), docs.subList(0, 500));    lucene2SeqConf = new LuceneStorageConfiguration(configuration,        asList(getIndexPath1()),        seqFilesOutputPath,        "nonExistingField",        asList(SingleFieldDocument.FIELD));    lucene2Seq.run(lucene2SeqConf);  }
@Test  public void getTypename() throws Exception {    TypeConstructorExpr e = new TypeConstructorExpr("foo",        new BinaryExpr(new IntConstantExpr("2"), new IntConstantExpr("1"), BinOp.MOD),        new BoolConstantExpr(true));    assertEquals("foo", e.getTypename());  }
@Test    public void min() {        Aggregation<Long> min = Aggregations.min();        min.aggregate(1L);        min.aggregate(2L);        min.aggregate(3L);        min.aggregate(null);        min.aggregate(4L);        double aggregated = min.getAggregated();        Assert.assertEquals(1L, aggregated, DELTA);        Assert.assertEquals("min", min.getIdentifier());        min.reset();    }
@Test    public void testResponseToHead() throws Exception {        final HttpCoreContext context = HttpCoreContext.create();        final ClassicHttpRequest request = new BasicClassicHttpRequest(Method.HEAD, "/");        Mockito.when(conn.receiveRequestHeader()).thenReturn(request);        Mockito.when(responseFactory.newHttpResponse(200)).thenReturn(response);        Mockito.when(handlerResolver.resolve(request, context)).thenReturn(requestHandler);        Mockito.when(connReuseStrategy.keepAlive(request, response, context)).thenReturn(Boolean.TRUE);        httpservice.handleRequest(conn, context);        Assert.assertSame(request, context.getRequest());        Mockito.verify(httprocessor).process(response, response.getEntity(), context);        Mockito.verify(requestHandler).handle(request, response, context);        Mockito.verify(conn).sendResponseHeader(response);        Mockito.verify(conn, Mockito.never()).sendResponseEntity(ArgumentMatchers.<ClassicHttpResponse>any());        Mockito.verify(conn).flush();        Mockito.verify(conn, Mockito.never()).close();        Mockito.verify(response).close();    }
@Test    public void testDeclareOutputFields() {        OutputFieldsDeclarer fields = mock(OutputFieldsDeclarer.class);        underTest.declareOutputFields(fields);        verify(fields).declare(any(Fields.class));    }
@Test    public void testMapping()            throws URISyntaxException, IOException    {        final String repoDir = getRepoDir();        P2ArtifactCoordinates foundArtifact = getArtifact(repoDir);        final String expectedFilename = String.format("%s/plugins/%s_%s.jar", repoDir, ID, VERSION);        assertThat(foundArtifact.getFilename()).isEqualTo(expectedFilename);    }
@Test  public void invokingSave() {    commandCreatesNewSpan(RedisCommand.SAVE, () -> getConnection().save(mockRedisClusterNode));    verify(mockRedisConnection()).save(mockRedisClusterNode);  }
@Test	public void evaluateTrue(){		assertEquals(Boolean.TRUE, evaluate(True.INSTANCE));	}
@Test    public void testInitDefaultValueWithoutActiveDecisionTable() throws Exception {        when(event.getEditedDefaultValue()).thenReturn(defaultValue);        when(presenter.getActiveDecisionTable()).thenReturn(Optional.empty());        columnConfigRow.init(attributeColumn,                             presenter);        verify(view).addDefaultValue(eq(attributeColumn),                                     eq(true),                                     defaultValueCaptor.capture());        //Simulates that checkbox was clicked        defaultValueCaptor.getValue().onDefaultValueChanged(event);        verify(decisionTable,               never()).updateColumn(any(AttributeCol52.class),                                     any(AttributeCol52.class));    }
@Test  public void interpretStringEquality() {    assertFalse(WorkflowConditionInterpreter.interpret("'a' == 'b'"));  }
@Test  public void testReadBytesFromByteBufferWithoutConsume() {    byte[] expectedBytes = "hello world".getBytes();    ByteBuffer bb = ByteBuffer.wrap(expectedBytes);    byte[] returnedBytes = BytesUtil.readBytesFromByteBufferWithoutConsume(bb);    assertArrayEquals(expectedBytes, returnedBytes);    assertEquals(0, bb.position());  }
@Test    public void trackScreenOnResume() {        tracker.onResume(activity);        verify(operations).trackScreen(activity);    }
@Test    @SuppressWarnings("deprecation")    public void testVersion1HomeFolderProvider() throws Exception    {        // Should just log a message to say it can't do anything        final String name = "v1Provider";        HomeFolderProvider v1Provider = new HomeFolderProvider()        {            @Override            public void onCreateNode(ChildAssociationRef childAssocRef)            {            }            @Override            public String getName()            {                return name;            }        };        homeFolderManager.addProvider(v1Provider);        createUser("a/b/c", "fred");                homeFolderProviderSynchronizer.setOverrideHomeFolderProviderName(name);        moveUserHomeFolders();        assertHomeFolderLocation("fred", "a/b/c/fred");    }
@Test    void spliteratorConsumer() {        instance.spliterator().forEachRemaining((Consumer<Integer>) i -> cnt.incrementAndGet());    }
@Test  public void testGetMedicationExternalValuesForUnitsWithEmptySet()  {    final Map<String, String> unitsMap =        medicationsDao.getMedicationExternalValues("FDB", MedicationsExternalValueType.UNIT, new HashSet<>());    assertTrue(unitsMap.isEmpty());  }
@Test    public void findMinimum() {        List<String> ss = Arrays.asList("Holla", "World", "Hello", "Hippo", "Hiplo");        CharSequence min = Levenshtein.findMinimum(ss, "Hillo");        assertEquals("Hello", min);    }
@Test	public void findElements_element_notFound() throws Exception {		DomSelector selector = new DomSelector(SelectorType.ID, "none");		assertThat(selector.findElements(defaultContentElement), is(Collections.<WebElement> emptyList()));	}
@Ignore  @Test  public void testImportAtPoint3() throws Exception {    JavaAnalyzer analyzer = getAnalyzer();    JavaImportCompletion completion = new JavaImportCompletion(GradleTestBase::getProject);    String cp = getClasspath();    List<File> files = new ArrayList<>();    File file =        new File(project.getProjectRootPath(), "./src/test/resources/MissingImport5.java")            .getCanonicalFile();    assertTrue(file.exists());    files.add(file);    String tmp = System.getProperty("java.io.tmpdir");    CompileResult compileResult = analyzer.analyzeAndCompile(files, cp, tmp, false);    Optional<Map<String, List<String>>> res = completion.importAtPoint(file, 5, 5, "assertEquals");    assertTrue(res.isPresent());    List<String> methods = res.get().get("method");    System.out.println(methods);    assertEquals(3, methods.size());  }
@Test    public void openLinkStringWithClosedActivity() throws Exception {        final String baseUrl = "/root/path";        final String humanLink = "Gen 1:1";        initMocks(baseUrl, humanLink);        doAnswer(invocation -> {            presenter.detachView();            return mock(Chapter.class);        }).when(librarian).openChapter(any());        presenter.openLink("RST.Gen.1.1");        verify(view).showProgress(eq(false));        verify(view, never()).setTitle(anyString(), anyString());        verify(view, never()).onOpenChapterFailure(any());    }
@Test  public void testEquals() throws AmbariException {    Assert.assertTrue(createFromJSON().equals(createFromJSON()));    Assert.assertFalse(createFromJSON().equals(createFromMap()));  }
@Test(description = "Get active policy if enrollment status removed should be return PolicyManagement exception" +            " caused by InvalidDeviceException",dependsOnMethods = "addPolicy",expectedExceptions = PolicyManagementException.class)    public void getActivatePolicyForEnrolmentStatusAsRemoved() throws Exception {        EnrolmentInfo.Status status =null;        try{            Device device = DeviceManagementDataHolder.getInstance().getDeviceManagementProvider().                    getDevice(new DeviceIdentifier(DEVICE1, DEVICE_TYPE_A), false);            status = device.getEnrolmentInfo().getStatus();            device.getEnrolmentInfo().setStatus(EnrolmentInfo.Status.REMOVED);            policyManagerService.getEffectivePolicy(new DeviceIdentifier(DEVICE1, DEVICE_TYPE_A));        }catch (Exception e){            Assert.assertTrue(e.getCause() instanceof InvalidDeviceException);            throw e;        }finally {            if(status != null){                DeviceManagementDataHolder.getInstance().getDeviceManagementProvider().                        getDevice(new DeviceIdentifier(DEVICE1, DEVICE_TYPE_A), false).getEnrolmentInfo().setStatus(status);            }        }    }
@Test    void get10() {        assertEquals(m10, instance.get10());    }
@Test  public void shouldFailToReadWorkflow() throws Exception {    when(transaction.workflow(HOURLY_WORKFLOW.id())).thenThrow(new IOException("read error"));    try {      workflowInitializer.store(HOURLY_WORKFLOW, PASS);      fail();    } catch (RuntimeException e) {      assertEquals("read error", e.getCause().getMessage());    }  }
@Test    public void onOtherwiseCellNoCellSelected() throws VetoException {        dtPresenter.onOtherwiseCell();        verify(synchronizer,               never()).setCellOtherwiseState(any(Integer.class),                                              any(Integer.class));    }
@Test	public void testLocalPortForward() throws JSchException {		//transit host		SshInfo sshInfo=new SshInfo();		sshInfo.setHost("192.168.1.1")				.setPort(22)				.setPassword("password")				.setUser("root");		PortForwardingHandler handler=new PortForwardingHandler(sshInfo);		//监听10080端口，如果参数=0，则自动分配端口		int localPort=handler.startLocalPortForwarding(10080, "8.8.8.8",22);		//do something		//....		//stop local port listening		handler.stopLocalPortForwarding(localPort);		handler.disconnect();	}
@Test    public void testIsDeletion() {        assertThat(isDeletion("A", "T"), is(false));        assertThat(isDeletion("AA", "GT"), is(false));        assertThat(isDeletion("ATT", "A"), is(true));        assertThat(isDeletion("T", "TTA"), is(false));    }
@Test    public void partitionsRevokedNoTopic() {        final Consumer<Long, String> consumer = mock(Consumer.class);        final PartitionedWriter writer = mock(PartitionedWriter.class);        final java.util.function.Consumer partitionsRevokedConsumer = mock(java.util.function.Consumer.class);        final OffsetResetter offsetResetter = new OffsetResetter<>(consumer, partitionsRevokedConsumer,                Collections.singleton(writer));        offsetResetter.onPartitionsRevoked(Collections.emptyList());        verify(writer, times(1)).close();        verifyZeroInteractions(partitionsRevokedConsumer);    }
@Test    void apply() {        assertEquals(Tuples.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19), instance.apply(0));    }
@Test    public void addFile() {        // Mock Spark context        final SparkContext sparkContext = Mockito.mock(SparkContext.class);        Mockito.when(sparkContext.hadoopConfiguration()).thenReturn(new Configuration(false));        // Test adding null file        final DataSourceResourceLoader loader = DataSourceResourceLoader.create(sparkContext);        loader.addFile(null);        Mockito.verify(sparkContext, Mockito.never()).addFile(Mockito.anyString());        // Test adding missing file        loader.addFile("file:/tmp/" + UUID.randomUUID().toString());        Mockito.verify(sparkContext, Mockito.never()).addFile(Mockito.anyString());        // Test adding new file        final String filePath = getClass().getResource("DataSourceResourceLoaderTest.class").toString();        loader.addFile(filePath);        loader.addFile(filePath);  // de-duplication check        Mockito.verify(sparkContext, Mockito.times(1)).addFile(filePath);    }
@Test  public void testSetRtfAvailable() throws Exception {    assertTrue( roh.isRtfAvailable() );    roh.setRtfAvailable( false );    assertFalse( roh.isRtfAvailable() );  }
@Test    public void testGetOrCreateDMNType() {        final String namespace = "namespace";        final String typeOneName = "tTypeOne";        final String typeTwoName = "tTypeTwo";        final String typeThreeName = "tTypeThree";        final JSITItemDefinition definition1 = createJSITItemDefinitionMock(typeOneName);        final JSITItemDefinition definition2 = createJSITItemDefinitionMock(typeTwoName);        final JSITItemDefinition definition3 = createJSITItemDefinitionMock(typeThreeName);        final Map<String, JSITItemDefinition> indexed = abstractKogitoDMNServiceSpy.indexDefinitionsByName(Arrays.asList(definition1, definition2, definition3));        final Map<String, ClientDMNType> createdTypes = new HashMap<>();        final ClientDMNType dmnTypeOne = mock(ClientDMNType.class);        final ClientDMNType dmnTypeTwo = mock(ClientDMNType.class);        final ClientDMNType dmnTypeThree = mock(ClientDMNType.class);        doReturn(dmnTypeOne).when(abstractKogitoDMNServiceSpy).createDMNType(indexed,                                                                             definition1,                                                                             namespace,                                                                             createdTypes);        doReturn(dmnTypeTwo).when(abstractKogitoDMNServiceSpy).createDMNType(indexed,                                                                             definition2,                                                                             namespace,                                                                             createdTypes);        doReturn(dmnTypeThree).when(abstractKogitoDMNServiceSpy).createDMNType(indexed,                                                                               definition3,                                                                               namespace,                                                                               createdTypes);        final ClientDMNType actualDmnTypeOne = abstractKogitoDMNServiceSpy.getOrCreateDMNType(indexed,                                                                                              typeOneName,                                                                                              namespace,                                                                                              createdTypes);        final ClientDMNType actualDmnTypeTwo = abstractKogitoDMNServiceSpy.getOrCreateDMNType(indexed,                                                                                              typeTwoName,                                                                                              namespace,                                                                                              createdTypes);        final ClientDMNType actualDmnTypeThree = abstractKogitoDMNServiceSpy.getOrCreateDMNType(indexed,                                                                                                typeThreeName,                                                                                                namespace,                                                                                                createdTypes);        assertEquals(dmnTypeOne, actualDmnTypeOne);        assertEquals(dmnTypeTwo, actualDmnTypeTwo);        assertEquals(dmnTypeThree, actualDmnTypeThree);    }
@Test  @SuppressWarnings("all")  public void createAccountLinkTest() {    String resourceName = "resourceName979421212";    CreateAccountLinkResponse expectedResponse =        CreateAccountLinkResponse.newBuilder().setResourceName(resourceName).build();    mockAccountLinkService.addResponse(expectedResponse);    String customerId = "customerId-1772061412";    AccountLink accountLink = AccountLink.newBuilder().build();    CreateAccountLinkResponse actualResponse = client.createAccountLink(customerId, accountLink);    Assert.assertEquals(expectedResponse, actualResponse);    List<AbstractMessage> actualRequests = mockAccountLinkService.getRequests();    Assert.assertEquals(1, actualRequests.size());    CreateAccountLinkRequest actualRequest = (CreateAccountLinkRequest) actualRequests.get(0);    Assert.assertEquals(customerId, actualRequest.getCustomerId());    Assert.assertEquals(accountLink, actualRequest.getAccountLink());    Assert.assertTrue(        channelProvider.isHeaderSent(            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));  }
@Test(expected=IOException.class)    public void testStreamInterleavedInvalidPrefixRight() throws Exception {        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();        new SangerFastqWriter().write(outputStream, ImmutableList.of(left, invalidPrefix));        Reader invalidPrefixRightReader = new StringReader(outputStream.toString());        streamInterleaved(invalidPrefixRightReader, listener);    }
@Test    public void copyCopyToPackage() {        final Path path = mock(Path.class);        final String newFileName = "newFileName";        final Path newPackagePath = mock(Path.class);        final String comment = "comment";        service.copy(path,                     newFileName,                     newPackagePath,                     comment);        verify(copyService,               times(1)).copy(eq(path),                              eq(newFileName),                              eq(newPackagePath),                              eq(comment));    }
@SuppressWarnings("rawtypes")    @Test    public void testBuildStringConverters05() throws Exception {        // 前処理(試験対象)        String fileName = "fileName";        Class<AbstractFileLineWriter_Stub23> clazz = AbstractFileLineWriter_Stub23.class;        Map<String, ColumnFormatter> columnFormatterMap = new HashMap<String, ColumnFormatter>();        columnFormatterMap.put("int", new IntColumnFormatter());        columnFormatterMap.put("java.lang.String", new NullColumnFormatter());        AbstractFileLineWriter<AbstractFileLineWriter_Stub23> fileLineWriter = new AbstractFileLineWriterImpl01<AbstractFileLineWriter_Stub23>(fileName, clazz, columnFormatterMap);        Method method = AbstractFileLineWriter.class.getDeclaredMethod(                "buildFields");        method.setAccessible(true);        method.invoke(fileLineWriter);        // 前処理(フィールド)        Map<Class, StringConverter> preStringConverterCacheMap = new HashMap<Class, StringConverter>();        Field field = AbstractFileLineWriter.class.getDeclaredField(                "stringConverterCacheMap");        field.setAccessible(true);        field.set(AbstractFileLineWriter.class, preStringConverterCacheMap);        try {            // テスト実施            method = AbstractFileLineWriter.class.getDeclaredMethod(                    "buildStringConverters");            method.setAccessible(true);            method.invoke(fileLineWriter);            fail("FileLineExceptionが発生しませんでした。");        } catch (InvocationTargetException e) {            // 判定(例外)            assertTrue(FileLineException.class.isAssignableFrom(e                    .getTargetException().getClass()));            assertEquals("Failed in an instantiate of a stringConverter.", e                    .getTargetException().getMessage());            assertTrue(InstantiationException.class.isAssignableFrom(e                    .getTargetException().getCause().getClass()));            assertEquals(fileName, ((FileLineException) e.getTargetException())                    .getFileName());            assertEquals(-1, ((FileLineException) e.getTargetException())                    .getLineNo());            assertEquals("column1", ((FileLineException) e.getTargetException())                    .getColumnName());            assertEquals(0, ((FileLineException) e.getTargetException())                    .getColumnIndex());        } finally {            field = AbstractFileLineWriter.class.getDeclaredField(                    "stringConverterCacheMap");            field.setAccessible(true);            field.set(AbstractFileLineWriter.class,                    new HashMap<Class, StringConverter>());        }    }
@Test    public void connectionForDeprecatedPostRequest() throws Exception {        TestRequest.DeprecatedPost request = new TestRequest.DeprecatedPost();        assertEquals(request.getMethod(), Method.DEPRECATED_GET_OR_POST);        HurlStack.setConnectionParametersForRequest(mMockConnection, request);        verify(mMockConnection).setRequestMethod("POST");        verify(mMockConnection).setDoOutput(true);    }
@Test    public void testConnectionTokens4() throws Exception {        // Use HTTP 1.1        final HttpResponse response = new BasicHttpResponse(200, "OK");        response.addHeader("Transfer-Encoding", "chunked");        response.addHeader("Connection", "yadda, close, dumdy");        response.addHeader("Proxy-Connection", "keep-alive");        // Connection takes precedence over Proxy-Connection        Assert.assertFalse(reuseStrategy.keepAlive(null, response, context));    }
@Test    void filterShouldDoNothingIfCorrelatorIsNotPresent() throws IOException {        unit.filter(request, response);        verifyNoInteractions(logbook);    }
@Test    public void testIsWhitespace01() throws Exception {        // 入力値の設定        char input = ' ';        // テスト実行と結果確認        assertTrue(StringUtil.isWhitespace(input));    }
@Test    public void testUninstallBundle() throws Exception {        Bundle bundle = Mockito.mock(Bundle.class);        Mockito.when(context.getBundle(5)).thenReturn(bundle);        mbean.uninstallBundle(5);        Mockito.verify(bundle).uninstall();    }
@Test void notSupported() {    assertThatThrownBy(() -> KafkaStorage.newBuilder().strictTraceId(false))        .isInstanceOf(IllegalArgumentException.class);  }
@Test    void get0Test() {        assertEquals(0, (int) instance.get0().orElseThrow(NoSuchElementException::new));    }
@Test    public void testCompareDatabaseVersionHeaderSimultaneous() {        DatabaseVersionHeaderComparator databaseVersionHeaderComparator = new DatabaseVersionHeaderComparator(true);        vc1.setClock("A", 3);        vc1.setClock("B", 7);        vc2.setClock("A", 5);        vc2.setClock("B", 4);        dbvh2.setDate(new Date(0xFEBEBEBE));        assertThat(databaseVersionHeaderComparator.compare(dbvh1, dbvh2), is(-1));    }
@Test    void get5Test() {        assertEquals(5, (int) instance.get5());    }
@Test  public void testNodeSlash() throws JSONException, Exception {    WebResource r = resource();    ClientResponse response = r.path("ws").path("v1").path("node/")        .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());    JSONObject json = response.getEntity(JSONObject.class);    verifyNodeInfo(json);  }
@Test  public void testPreserveGroupOnDirectory() throws IOException {    FileSystem fs = FileSystem.get(config);    EnumSet<FileAttribute> attributes = EnumSet.of(FileAttribute.GROUP);    Path dst = new Path("/tmp/abc");    Path src = new Path("/tmp/src");    createDirectory(fs, src);    createDirectory(fs, dst);    fs.setPermission(src, fullPerm);    fs.setOwner(src, "somebody", "somebody-group");    fs.setPermission(dst, noPerm);    fs.setOwner(dst, "nobody", "nobody-group");    CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src));    DistCpUtils.preserve(fs, dst, srcStatus, attributes, false);    CopyListingFileStatus dstStatus = new CopyListingFileStatus(fs.getFileStatus(dst));    // FileStatus.equals only compares path field, must explicitly compare all fields    Assert.assertFalse(srcStatus.getPermission().equals(dstStatus.getPermission()));    Assert.assertFalse(srcStatus.getOwner().equals(dstStatus.getOwner()));    Assert.assertTrue(srcStatus.getGroup().equals(dstStatus.getGroup()));  }
@Test  public void testPrivilegeMustHaveExcatlyOneHost() {    KafkaPrivilegeValidator kafkaPrivilegeValidator = new KafkaPrivilegeValidator();    try {      kafkaPrivilegeValidator.validate(new PrivilegeValidatorContext("host=host1->host=host2->action=read"));      Assert.fail("Multiple Host resources are not allowed within a Kafka privilege.");    } catch (ConfigurationException ex) {      Assert.assertEquals("Host authorizable can be specified just once in a Kafka privilege.\n" + KafkaPrivilegeValidator.KafkaPrivilegeHelpMsg, ex.getMessage());    }  }
@Test  public void testGetSecrets() throws Exception {    Secrets secrets = SecretsManager.get().getSecrets("test");    SecretKey secretKey = secrets.getSecretKey();    PublicKey publicKey = secrets.getPublicKey();    PrivateKey privateKey = secrets.getPrivateKey();    System.out.println(secretKey.getAlgorithm());    System.out.println(publicKey.getAlgorithm());    System.out.println(privateKey.getAlgorithm());  }
@Test(expected = AssertionError.class)    public void validateFailsIfURINotHostPortAndNotActiveMQ() throws Exception {        TestRunner runner = TestRunners.newTestRunner(mock(Processor.class));        JMSConnectionFactoryProvider cfProvider = new JMSConnectionFactoryProvider();        runner.addControllerService("cfProvider", cfProvider);        runner.setProperty(cfProvider, JMSConnectionFactoryProvider.BROKER_URI, "myhost");        runner.setProperty(cfProvider, JMSConnectionFactoryProvider.CLIENT_LIB_DIR_PATH, "test-lib");        runner.setProperty(cfProvider, JMSConnectionFactoryProvider.CONNECTION_FACTORY_IMPL,                "org.apache.nifi.jms.testcflib.TestConnectionFactory");        runner.enableControllerService(cfProvider);        runner.assertNotValid(cfProvider);    }
@Test  public void testRemoteAddrWithTrustedProxy() {    assertEquals(clientAddr, getRemoteAddr(clientAddr, proxyAddr, true));    assertEquals(clientAddr, getRemoteAddr(chainedClientAddr, proxyAddr, true));  }
@Test    public void sendError_when_CoapCodeException_whileHandlingRequest() throws Exception {        server.addRequestHandler("/err", exchange -> {            throw new CoapCodeException(Code.C503_SERVICE_UNAVAILABLE, new IOException());        });        CoapPacket req = newCoapPacket(LOCAL_1_5683).mid(1).con().put().uriPath("/err").build();        server.coapRequestHandler.handleRequest(req, TransportContext.NULL);        assertSendResponse(newCoapPacket(LOCAL_1_5683).mid(1).ack(Code.C503_SERVICE_UNAVAILABLE).payload("503 SERVICE UNAVAILABLE"));    }
@Test    public void getFileWithIncrementedNameShouldUseTheSameParent() throws IOException {        final String home = System.getProperty("user.home");        final String homeWithSeparator = home + File.separatorChar;        createTemporaryFile(homeWithSeparator + "donkeys.jpg");        createTemporaryFile(homeWithSeparator + "donkeys_1.jpg");        final File file = Tools.getFileWithIncrementedName(new File(homeWithSeparator + "donkeys.jpg"));        assertEquals("donkeys_2.jpg", file.getName());        assertEquals(home, file.getParent());    }
@Test    void iteratorOutOfRange() {        final Iterator<String> iterator = instance.iterator();        String element = iterator.next();        assertThrows(NoSuchElementException.class, iterator::next);    }
@Test  public void testValidPropertyIds() {    Request request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.HostComponent));    Set<String> validPropertyIds = request.getPropertyIds();    //HostComponent resource properties    Assert.assertFalse(validPropertyIds.contains("HostRoles/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("params/run_smoke_test"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/actual_configs"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/desired_stack_id"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/stack_id"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/desired_state"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/state"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/component_name"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/host_name"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("HostRoles/role_id"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Cluster));    validPropertyIds = request.getPropertyIds();    //Cluster resource properties    Assert.assertFalse(validPropertyIds.contains("Clusters/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Clusters/cluster_id"));    Assert.assertTrue(validPropertyIds.contains("Clusters/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("Clusters/version"));    Assert.assertTrue(validPropertyIds.contains("Clusters/state"));    Assert.assertTrue(validPropertyIds.contains("Clusters/desired_configs"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Service));    validPropertyIds = request.getPropertyIds();    //Service resource properties    Assert.assertFalse(validPropertyIds.contains("ServiceInfo/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("ServiceInfo/service_name"));    Assert.assertTrue(validPropertyIds.contains("ServiceInfo/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("ServiceInfo/state"));    Assert.assertTrue(validPropertyIds.contains("Services/description"));    Assert.assertTrue(validPropertyIds.contains("Services/display_name"));    Assert.assertTrue(validPropertyIds.contains("Services/attributes"));    Assert.assertTrue(validPropertyIds.contains("params/run_smoke_test"));    Assert.assertTrue(validPropertyIds.contains("params/reconfigure_client"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Host));    validPropertyIds = request.getPropertyIds();    //Host resource properties    Assert.assertFalse(validPropertyIds.contains("Hosts/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Hosts/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("Hosts/host_name"));    Assert.assertTrue(validPropertyIds.contains("Hosts/ip"));    Assert.assertTrue(validPropertyIds.contains("Hosts/attributes"));    Assert.assertTrue(validPropertyIds.contains("Hosts/total_mem"));    Assert.assertTrue(validPropertyIds.contains("Hosts/cpu_count"));    Assert.assertTrue(validPropertyIds.contains("Hosts/ph_cpu_count"));    Assert.assertTrue(validPropertyIds.contains("Hosts/os_arch"));    Assert.assertTrue(validPropertyIds.contains("Hosts/os_type"));    Assert.assertTrue(validPropertyIds.contains("Hosts/rack_info"));    Assert.assertTrue(validPropertyIds.contains("Hosts/last_heartbeat_time"));    Assert.assertTrue(validPropertyIds.contains("Hosts/last_agent_env"));    Assert.assertTrue(validPropertyIds.contains("Hosts/last_registration_time"));    Assert.assertTrue(validPropertyIds.contains("Hosts/disk_info"));    Assert.assertTrue(validPropertyIds.contains("Hosts/host_status"));    Assert.assertTrue(validPropertyIds.contains("Hosts/host_health_report"));    Assert.assertTrue(validPropertyIds.contains("Hosts/public_host_name"));    Assert.assertTrue(validPropertyIds.contains("Hosts/host_state"));    Assert.assertTrue(validPropertyIds.contains("Hosts/desired_configs"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Component));    validPropertyIds = request.getPropertyIds();    //Component resource properties    Assert.assertFalse(validPropertyIds.contains("ServiceComponentInfo/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("ServiceComponentInfo/service_name"));    Assert.assertTrue(validPropertyIds.contains("ServiceComponentInfo/component_name"));    Assert.assertTrue(validPropertyIds.contains("ServiceComponentInfo/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("ServiceComponentInfo/state"));    Assert.assertTrue(validPropertyIds.contains("ServiceComponents/display_name"));    Assert.assertTrue(validPropertyIds.contains("ServiceComponents/description"));    Assert.assertTrue(validPropertyIds.contains("params/run_smoke_test"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Action));    validPropertyIds = request.getPropertyIds();    //Action resource properties    Assert.assertFalse(validPropertyIds.contains("Action/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Actions/action_name"));    Assert.assertTrue(validPropertyIds.contains("Actions/action_type"));    Assert.assertTrue(validPropertyIds.contains("Actions/inputs"));    Assert.assertTrue(validPropertyIds.contains("Actions/target_service"));    Assert.assertTrue(validPropertyIds.contains("Actions/target_component"));    Assert.assertTrue(validPropertyIds.contains("Actions/description"));    Assert.assertTrue(validPropertyIds.contains("Actions/target_type"));    Assert.assertTrue(validPropertyIds.contains("Actions/default_timeout"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Request));    validPropertyIds = request.getPropertyIds();    //Request resource properties    Assert.assertFalse(validPropertyIds.contains("Requests/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Requests/id"));    Assert.assertTrue(validPropertyIds.contains("Requests/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("Requests/request_status"));    Assert.assertTrue(validPropertyIds.contains("Requests/request_context"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Task));    validPropertyIds = request.getPropertyIds();    //Task resource properties    Assert.assertFalse(validPropertyIds.contains("Task/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Tasks/id"));    Assert.assertTrue(validPropertyIds.contains("Tasks/request_id"));    Assert.assertTrue(validPropertyIds.contains("Tasks/cluster_name"));    Assert.assertTrue(validPropertyIds.contains("Tasks/stage_id"));    Assert.assertTrue(validPropertyIds.contains("Tasks/host_name"));    Assert.assertTrue(validPropertyIds.contains("Tasks/command"));    Assert.assertTrue(validPropertyIds.contains("Tasks/role"));    Assert.assertTrue(validPropertyIds.contains("Tasks/status"));    Assert.assertTrue(validPropertyIds.contains("Tasks/exit_code"));    Assert.assertTrue(validPropertyIds.contains("Tasks/stderr"));    Assert.assertTrue(validPropertyIds.contains("Tasks/stdout"));    Assert.assertTrue(validPropertyIds.contains("Tasks/start_time"));    Assert.assertTrue(validPropertyIds.contains("Tasks/attempt_cnt"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.User));    validPropertyIds = request.getPropertyIds();    //User resource properties    Assert.assertFalse(validPropertyIds.contains("Users/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Users/user_name"));    Assert.assertTrue(validPropertyIds.contains("Users/password"));    Assert.assertTrue(validPropertyIds.contains("Users/old_password"));    Assert.assertTrue(validPropertyIds.contains("Users/ldap_user"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.Stack));    validPropertyIds = request.getPropertyIds();    //Stack resource properties    Assert.assertFalse(validPropertyIds.contains("Stacks/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Stacks/stack_name"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.StackVersion));    validPropertyIds = request.getPropertyIds();    //StackVersion resource properties    Assert.assertFalse(validPropertyIds.contains("Versions/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Versions/stack_name"));    Assert.assertTrue(validPropertyIds.contains("Versions/stack_version"));    Assert.assertTrue(validPropertyIds.contains("Versions/min_upgrade_version"));    request = PropertyHelper.getReadRequest(OperatingSystemResourceProvider.propertyIds);    validPropertyIds = request.getPropertyIds();    //OperatingSystem resource properties    Assert.assertFalse(validPropertyIds.contains("OperatingSystems/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("OperatingSystems/stack_name"));    Assert.assertTrue(validPropertyIds.contains("OperatingSystems/stack_version"));    Assert.assertTrue(validPropertyIds.contains("OperatingSystems/os_type"));    request = PropertyHelper.getReadRequest(RepositoryResourceProvider.propertyIds);    validPropertyIds = request.getPropertyIds();    //Repository resource properties    Assert.assertFalse(validPropertyIds.contains("Repositories/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("Repositories/stack_name"));    Assert.assertTrue(validPropertyIds.contains("Repositories/stack_version"));    Assert.assertTrue(validPropertyIds.contains("Repositories/os_type"));    Assert.assertTrue(validPropertyIds.contains("Repositories/base_url"));    Assert.assertTrue(validPropertyIds.contains("Repositories/repo_id"));    Assert.assertTrue(validPropertyIds.contains("Repositories/repo_name"));    Assert.assertTrue(validPropertyIds.contains("Repositories/mirrors_list"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.StackService));    validPropertyIds = request.getPropertyIds();    //Repository resource properties    Assert.assertFalse(validPropertyIds.contains("StackServices/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("StackServices/stack_name"));    Assert.assertTrue(validPropertyIds.contains("StackServices/stack_version"));    Assert.assertTrue(validPropertyIds.contains("StackServices/service_name"));    Assert.assertTrue(validPropertyIds.contains("StackServices/user_name"));    Assert.assertTrue(validPropertyIds.contains("StackServices/comments"));    Assert.assertTrue(validPropertyIds.contains("StackServices/service_version"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.StackConfiguration));    validPropertyIds = request.getPropertyIds();    //StackConfigurations resource properties    Assert.assertFalse(validPropertyIds.contains("StackConfigurations/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("StackConfigurations/stack_name"));    Assert.assertTrue(validPropertyIds.contains("StackConfigurations/stack_version"));    Assert.assertTrue(validPropertyIds.contains("StackConfigurations/service_name"));    Assert.assertTrue(validPropertyIds.contains("StackConfigurations/property_name"));    Assert.assertTrue(validPropertyIds.contains("StackConfigurations/property_description"));    Assert.assertTrue(validPropertyIds.contains("StackConfigurations/property_value"));    request = PropertyHelper.getReadRequest(PropertyHelper.getPropertyIds(Resource.Type.StackServiceComponent));    validPropertyIds = request.getPropertyIds();    //StackServiceComponent resource properties    Assert.assertFalse(validPropertyIds.contains("StackServiceComponents/unsupported_property_id"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/stack_version"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/stack_name"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/service_name"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/component_name"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/component_category"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/is_master"));    Assert.assertTrue(validPropertyIds.contains("StackServiceComponents/is_client"));  }
@Test    public void test_readSecretIdAccessors_WithUserDetails_successfully() throws Exception {        String token = "5PDrOhsy4ig8L3EpsJZSLAMg";        String responseJson = "{\r\n" +         		"  \"keys\": [\r\n" +         		"    \"generated-accessor-id1\",\r\n" +         		"    \"generated-accessor-id2\"\r\n" +         		"  ]\r\n" +         		"}";    	String role_id_response = "{\n" +     			"  \"data\": {\n" +     			"    \"role_id\": \"generated-role-id\"\n" +     			"  }\n" +     			"}";        Response response =getMockResponse(HttpStatus.OK, true, responseJson);        UserDetails userDetails = getMockUser("testuser1", false);        String role_name = "approle1";        String username = userDetails.getUsername();        String path = TVaultConstants.APPROLE_METADATA_MOUNT_PATH + "/" + role_name;                Map<String, Object> responseMap = new HashMap<>();        Map<String,Object> roleIdDataMap = new HashMap<>();        roleIdDataMap.put("role_id", "generated-id");        roleIdDataMap.put("createdBy", username);        responseMap.put("data", roleIdDataMap);                ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseJson);                when(reqProcessor.process("/auth/approle/role/accessors/list","{\"role_name\":\""+role_name+"\"}",userDetails.getSelfSupportToken())).thenReturn(response);        when(reqProcessor.process("/auth/approle/role/readRoleID","{\"role_name\":\""+role_name+"\"}",userDetails.getSelfSupportToken())).thenReturn        (getMockResponse(HttpStatus.OK, true, role_id_response));        when(ControllerUtil.parseJson(role_id_response)).thenReturn(responseMap);                Response approleMetadataResponse = getMockResponse(HttpStatus.OK, true, getAppRoleMetadataJSON(path, username, role_name));        when(reqProcessor.process("/read","{\"path\":\""+path+"\"}",userDetails.getSelfSupportToken())).thenReturn(approleMetadataResponse);        when(ControllerUtil.parseJson("{\"path\":\""+path+"\",\"data\":{\"name\":\""+role_name+"\",\"createdBy\":\""+username+"\"}}")).thenReturn(responseMap);        ResponseEntity<String> responseEntityActual = appRoleService.readSecretIdAccessors(token, role_name, userDetails);        assertEquals(HttpStatus.OK, responseEntityActual.getStatusCode());        assertEquals(responseEntityExpected, responseEntityActual);    }
@Test    public void testFromStringMissingField1() {        final String content = "Fact' : ['a', 'b']";        final List<EnumRow> enums = EnumParser.fromString( content );        assertFalse( enums.isEmpty() );        assertEquals( "Fact' : ['a', 'b']",                      enums.get( 0 ).getRaw() );    }
@Test	public void testIsNotAdmin(){		boolean isAdminChk = rangerBizUtil.isAdmin();		Assert.assertFalse(isAdminChk);	}
@Test    public void testLogInit() {        try {            logger = KLog.getLogger();            assertNotNull(logger);        } catch (Throwable throwable) {            fail("Should not throw an exception " + throwable.getLocalizedMessage());        }    }
@Test	public void testDeployPoliciesListOfEvaluatable_NOT_APPLICABLE()			throws AuditException {		// Arrange		final LinkedList<Evaluatable> emptyPolicyList = new LinkedList<Evaluatable>();		final XacmlRequest xacmlRequest = new XacmlRequest();		// Act		final String decision = pdp.evaluateRequest(request, emptyPolicyList,				xacmlRequest).getPdpDecision();		// Assert		assertEquals("NOT_APPLICABLE", decision);	}
@Test  public void testCsvStream1() throws IOException, CsvParseException {    CsvReader reader = Csv.readerNoBOM(new PushbackReader(new StringReader("")));    Assert.assertEquals(TokenType.ELEMENT, reader.next());    Assert.assertEquals("", reader.getElement().toString());    Assert.assertEquals(TokenType.END_ROW, reader.next());    Assert.assertEquals(TokenType.END_DOCUMENT, reader.next());    Assert.assertEquals(TokenType.END_DOCUMENT, reader.next());  }
@Test    public void testTrim17() throws Exception {        // 前処理(引数)        String columnString = "aaa1aaa";        String fileEncoding = null;        char trimChar = 'a';        TrimType trimType = TrimType.LEFT;        try {            // テスト実施            FileDAOUtility.trim(columnString, fileEncoding, trimChar, trimType);            fail("NullPointerExceptionが発生しませんでした。");        } catch (NullPointerException e) {            // 判定            assertTrue(e instanceof NullPointerException);        }    }
@Test	public void testParse() throws Exception {		BasicProjectsJsonParser parser = new BasicProjectsJsonParser();		final Iterable<BasicProject> project = parser.parse(ResourceUtil.getJsonArrayFromResource("/json/project/projects.json"));		assertEquals(3, Iterables.size(project));		assertEquals(TST_PROJECT, Iterables.get(project, 0));	}
@Test    public void testAfterPropertiesSet() throws Exception {        // do setup.        applicationLogger.setLevel(Level.INFO);        monitoringLogger.setLevel(Level.INFO);        Exception ex = new SystemException("i.code01", "system error.");        ExceptionCodeResolver mockExceptionCodeResolver = mock(                ExceptionCodeResolver.class);        when(mockExceptionCodeResolver.resolveExceptionCode(ex)).thenReturn(                "i.code01");        testTarget.setExceptionCodeResolver(mockExceptionCodeResolver);        testTarget.setExceptionLevelResolver(null);        testTarget.afterPropertiesSet();        // do test.        testTarget.log(ex);        // do assert.        String expectedLogMessage = "[i.code01] system error.";        verifyLogging(expectedLogMessage, Level.INFO, ex,                mockApplicationLoggerAppender);        verifyLogging(expectedLogMessage, Level.INFO,                mockMonitoringLoggerAppender);    }
@Test( expected = IllegalArgumentException.class )    public void shouldFailTryingToRemoveEmptyTableName() throws Exception {        this.model.removeTable( getTransaction(), EMPTY_STRING );    }
@Test    public void testLineStyling()                            throws Exception {        BufferedImage img = new BufferedImage( 1000, 1000, TYPE_INT_ARGB );        long time = currentTimeMillis();        Graphics2D g = img.createGraphics();        GeometryFactory geomFac = new GeometryFactory();        Java2DRenderer r = new Java2DRenderer( g, img.getWidth(), img.getHeight(),                                               geomFac.createEnvelope( new double[] { 0, 0 },                                                                       new double[] { 5000d, 5000d }, mapcs ) );        List<Curve> curves = new LinkedList<Curve>();        for ( int i = 0; i < 10; ++i ) {            //curves.add( randomCurve( 500, i * 500, 0 ) );            curves.add( testCurve( 100 + i * 480, 100, 300, 250 ) );        }        LineStyling styling = new LineStyling();        for ( int y = 0; y < 10; ++y ) {            switch ( y ) {            case 0:                break;            case 1:                styling.stroke.linecap = BUTT;                break;            case 2:                styling.stroke.linecap = ROUND;                break;            case 3:                styling.stroke.linecap = SQUARE;                break;            case 4:                styling.stroke.linecap = BUTT;                styling.stroke.linejoin = BEVEL;                break;            case 5:                styling.stroke.linejoin = MITRE;                break;            case 6:                styling.stroke.linejoin = LineJoin.ROUND;                break;            case 7:                styling.stroke.dasharray = new double[] { 15, 15, 17, 5 };                break;            case 8:                styling.stroke.linecap = SQUARE;                break;            case 9:                styling.stroke.linecap = ROUND;                break;            }            Iterator<Curve> iterator = curves.iterator();            for ( int x = 0; x < 10; ++x ) {                styling.stroke.width = x;                Curve curve = (Curve) move( iterator.next(), 0, ( 9 - y ) * 500 );                r.render( styling, curve );            }        }        g.dispose();        long time2 = currentTimeMillis();        List<String> texts = new LinkedList<String>();        texts.add( "line 1: default style lines with line width 0, 1, ..., 9, ending square" );        texts.add( "line 2: default style lines with line width 0, 1, ..., 9, ending square" );        texts.add( "line 3: default style lines with line width 0, 1, ..., 9, ending butt" );        texts.add( "line 4: default style lines with line width 0, 1, ..., 9, ending round" );        texts.add( "line 5: default style lines with line width 0, 1, ..., 9, join bevel" );        texts.add( "line 6: default style lines with line width 0, 1, ..., 9, join mitre" );        texts.add( "line 7: default style lines with line width 0, 1, ..., 9, join round" );        texts.add( "line 8: default style lines with line width 0, 1, ..., 9, dashed with pattern 15, 15, 17, 5" );        texts.add( "line 9: default style lines with line width 0, 1, ..., 9, dashed with pattern 15, 15, 17, 5, ending square" );        texts.add( "line 10: default style lines with line width 0, 1, ..., 9, dashed with pattern 15, 15, 17, 5, ending round" );        validateImage( img, time2 - time, "linestyling" );    }
@Test    public void testComplexComand() throws Exception    {        List<String> command = CommandTokeniser.tokeniseCommandLine("/bin/sh -c 'echo H4sIAGXUbVUAA42QP2vDMBDFd32KRzBYKmlsd6xJIHTo0KHQoR2aQhRbdgWybCQ39A/57j1JtIROnR73Tve7exo+kPlZzlijrNlAlVFHZajM7+/y5GjbjWTs27GHHVuFaFy6fWoPvg/P6XE3OiWbV0SMtgrcT0bPKHa2WCaOwBcLfZ6ZA1lefyqSN69aEnmU2pBOjSBinOUFwmigiZqlZas1GQeskIe9pDQQqiXoBugOnPOIRJE2CFygKkuBDbLtw+3jc/kS78Bv9qo+C/4kndW2D7ATlPH/IVZ/iVfnxBunZ91IE5HsxCan7fzTp8uvU4wYDoudXdRMvdPHRVjNvgHrCL0BpQEAAA== | base64 -d | gunzip | perl - 66 80'");        assertThat(command.size(), is(equalTo(3)));        assertThat(command.get(0), is(equalTo("/bin/sh")));        assertThat(command.get(1), is(equalTo("-c")));        assertThat(command.get(2), is(equalTo("echo H4sIAGXUbVUAA42QP2vDMBDFd32KRzBYKmlsd6xJIHTo0KHQoR2aQhRbdgWybCQ39A/57j1JtIROnR73Tve7exo+kPlZzlijrNlAlVFHZajM7+/y5GjbjWTs27GHHVuFaFy6fWoPvg/P6XE3OiWbV0SMtgrcT0bPKHa2WCaOwBcLfZ6ZA1lefyqSN69aEnmU2pBOjSBinOUFwmigiZqlZas1GQeskIe9pDQQqiXoBugOnPOIRJE2CFygKkuBDbLtw+3jc/kS78Bv9qo+C/4kndW2D7ATlPH/IVZ/iVfnxBunZ91IE5HsxCan7fzTp8uvU4wYDoudXdRMvdPHRVjNvgHrCL0BpQEAAA== | base64 -d | gunzip | perl - 66 80")));    }
@Test  public void getWindow_setsTag() {    Object tag = new Object();    SinglePeriodTimeline timeline =        new SinglePeriodTimeline(            /* durationUs= */ C.TIME_UNSET,            /* isSeekable= */ false,            /* isDynamic= */ false,            /* isLive= */ false,            /* manifest= */ null,            tag);    assertThat(timeline.getWindow(/* windowIndex= */ 0, window).tag).isEqualTo(tag);  }
@Test    void testSetO()    {        final String value = "foobar";        this.arguments.setO(value);        assertAfterSetter(value, this.arguments.getOutputFormat());    }
@Test  public void testMocksOnThisClass() {    mFieldPreparer.prepareFields(this);    assertThat(mMockRunnable)        .isNotNull()        .is(mockCondition());  }
@Test	public void testRemoveConnectionWithNullConnectionId() {		_elasticsearchConnectionManager.removeElasticsearchConnection(null);	}
@Test    public void testValidateNoBackups() throws Exception {        new Expectations() {            {                backupVerification.verifyBackup(                        BackupVersion.SNAPSHOT_META_SERVICE,                        anyBoolean,                        new DateUtil.DateRange((Instant) any, (Instant) any));                result = Optional.empty();            }        };        Response response =                resource.validateV2SnapshotByDate(                        new DateUtil.DateRange(Instant.now(), Instant.now()).toString(), true);        assertEquals(204, response.getStatus());        assertEquals(                response.getEntity().toString(), "No valid meta found for provided time range");    }
@Test    public void testGetFields01() throws Exception {        // テスト対象のインスタンス化        URL url = this.getClass().getResource(                "AbstractFileLineIterator_skip01.txt");        String fileName = url.getPath();        Map<String, ColumnParser> columnParserMap = new HashMap<String, ColumnParser>();        columnParserMap.put("java.lang.String", new NullColumnParser());        @SuppressWarnings("rawtypes")        AbstractFileLineIteratorImpl02<AbstractFileLineIterator_Stub01> fileLineIterator = new AbstractFileLineIteratorImpl02<AbstractFileLineIterator_Stub01>(                fileName, AbstractFileLineIterator_Stub01.class,                columnParserMap);        // 引数の設定        // なし        // 前提条件の設定        Field[] fields = new Field[] {};        ReflectionTestUtils.setField(fileLineIterator, "fields", fields);        // テスト実施        Field[] result = fileLineIterator.getFields();        // 返却値の確認        assertSame(fields, result);        // 状態変化の確認        // なし    }
@Test	public void testCreatedMetaDataBean() {		Assert.assertTrue(postProcessor.createAndRegisterMetaDataBean(beanFactory).getInterceptors().size()>0);		Assert.assertTrue(beanFactory.containsBean("interceptorMetaDataBean"));	}
@Test  public void testArrayBinarySearchCeil() {    long[] values = new long[0];    assertThat(binarySearchCeil(values, 0, false, false)).isEqualTo(0);    assertThat(binarySearchCeil(values, 0, false, true)).isEqualTo(-1);    values = new long[] {1, 3, 5};    assertThat(binarySearchCeil(values, 0, false, false)).isEqualTo(0);    assertThat(binarySearchCeil(values, 0, true, false)).isEqualTo(0);    assertThat(binarySearchCeil(values, 1, false, false)).isEqualTo(1);    assertThat(binarySearchCeil(values, 1, true, false)).isEqualTo(0);    assertThat(binarySearchCeil(values, 2, false, false)).isEqualTo(1);    assertThat(binarySearchCeil(values, 2, true, false)).isEqualTo(1);    assertThat(binarySearchCeil(values, 5, false, false)).isEqualTo(3);    assertThat(binarySearchCeil(values, 5, true, false)).isEqualTo(2);    assertThat(binarySearchCeil(values, 5, false, true)).isEqualTo(2);    assertThat(binarySearchCeil(values, 5, true, true)).isEqualTo(2);    assertThat(binarySearchCeil(values, 6, false, false)).isEqualTo(3);    assertThat(binarySearchCeil(values, 6, true, false)).isEqualTo(3);    assertThat(binarySearchCeil(values, 6, false, true)).isEqualTo(2);    assertThat(binarySearchCeil(values, 6, true, true)).isEqualTo(2);  }
@Test	public void fondoDbEntityTest() {		Assert.notNull(getManager(), "ArchidocManager es nulo");		IFondoDbEntity dbEntity = getManager().getFondoDbEntity();		Assert.notNull(dbEntity, "entity es nulo");		Assert.isTrue(ArchivoTables.ASGFFONDO_TABLE_NAME.equals(dbEntity				.getTableName()),"Las tablas no coinciden");		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount()));	}
@Test    public void typeFailure() {        TestSupport.failureOf(ObjectSchema.builder())                .expectedKeyword("type")                .input("a")                .expect();    }
@Test  public void testTraverseWithObjectsAndParams() throws Exception {    UUID objectId1 = UUID.randomUUID();    UUID objectId2 = UUID.randomUUID();    String query = "g.outE()";    when(objectFactDao.getObject(objectId1)).thenReturn(new ObjectRecord().setId(objectId1));    when(objectFactDao.getObject(objectId2)).thenReturn(new ObjectRecord().setId(objectId2));    Long before = 1L;    Long after = 2L;    TraverseGraphByObjectsRequest request = new TraverseGraphByObjectsRequest()            .setQuery(query)            .setBefore(before)            .setAfter(after)            .setIncludeRetracted(true)            .setLimit(10)            .setObjects(set(objectId1.toString(), objectId2.toString()));    delegate.handle(request);    verify(traverseGraphHandler).traverse(            eq(set(objectId1, objectId2)),            eq(query),            argThat(traverseParams -> {              assertTrue(traverseParams.isIncludeRetracted());              assertEquals(after, traverseParams.getAfterTimestamp());              assertEquals(before, traverseParams.getBeforeTimestamp());              assertEquals(10, traverseParams.getLimit());              return true;            }));  }
@Test  public void shouldCreateRightTezAutoUrl() throws Exception {    String newUrl = upgradeCatalog250.getUpdatedTezHistoryUrlBase("http://hostname:8080/#/main/views/TEZ/0.7.0.2.6.0.0-561/tez1");    Assert.assertEquals("incorrect tez view url create.", "http://hostname:8080/#/main/view/TEZ/tez_cluster_instance", newUrl);  }
@Test    public final void testOnCopyComplete()    {        NodeRef content2 = newContent(folderPath2, "cm:content2");        nodeChange.onCopyComplete(null, content2, content1, true, null);                Map<String, Serializable> auditMap = nodeChange.getAuditData(false);        assertStandardData(auditMap, "COPY", "copyNode");        assertEquals("/cm:homeFolder/cm:folder2/cm:content2", auditMap.get("copy/from/path"));        assertEquals(content2, auditMap.get("copy/from/node"));        assertEquals("cm:content", auditMap.get("copy/from/type"));    }
@Test  public void testFilenameMeansMultiSwitch() throws Throwable {    Configuration conf = new Configuration();    conf.set(ScriptBasedMapping.SCRIPT_FILENAME_KEY, "any-filename");    ScriptBasedMapping mapping = createMapping(conf);    assertFalse("Expected to be multi switch", mapping.isSingleSwitch());    mapping.setConf(new Configuration());    assertTrue("Expected to be single switch", mapping.isSingleSwitch());  }
@Test    public void testMakeInheritanceFilterReport() {        Filter filter = new InheritanceFilter(ModeOfInheritance.AUTOSOMAL_DOMINANT, ModeOfInheritance.AUTOSOMAL_RECESSIVE);        FilterType filterType = FilterType.INHERITANCE_FILTER;        ImmutableList<String> messages = ImmutableList.of("Genes filtered for compatibility with AUTOSOMAL_DOMINANT, AUTOSOMAL_RECESSIVE inheritance.");        FilterReport report = new FilterReport(filterType, 0, 0, messages);        FilterReport result = instance.makeFilterReport(filter, analysisResults);        assertThat(result, equalTo(report));    }
@Test	public void testGetNumUsersWithDelegateUsersOnly() throws TasteException {    PreferenceArray prefs = new GenericUserPreferenceArray(1);    long sampleUserID = 1;		prefs.setUserID(0, sampleUserID);    long sampleItemID = 11;    prefs.setItemID(0, sampleItemID);		FastByIDMap<PreferenceArray> delegatePreferences = new FastByIDMap<PreferenceArray>();		delegatePreferences.put(sampleUserID, prefs);		PlusAnonymousConcurrentUserDataModel instance = getTestableWithDelegateData(10, delegatePreferences);		assertEquals(1, instance.getNumUsers());	}
@Test    public void getKieAssetsDropdownItemFileWithLongPathWindows() {        String path = "long\\pat\\";        String fileName = "filename.etc";        String fullPath = path + fileName;        KieAssetsDropdownItem item = scenarioSimulationKogitoRuntimeCreationAssetsDropdownProviderImplSpy.getKieAssetsDropdownItem(fullPath);        assertNotNull(item);        assertEquals(fullPath, item.getValue());        assertEquals(fullPath, item.getSubText());        assertEquals(fileName, item.getText());    }
@Test  public void testValue() throws Exception {    // Given    ServicePropertyInfo p = getServiceProperty(XML);    // When    String value = p.getValue();    // Then    assertEquals("prop_value", value);  }
@Test	public void priorityForGetAnnotationShouldBeDefault() throws Exception {		List<Route> routes = parser.rulesFor(new DefaultResourceClass(GetAnnotatedController.class));		Route route = getRouteMatching(routes, "/prefix/relativePath");		assertThat(route.getPriority(), is(Path.DEFAULT));	}
@Test // TIKA-2232    public void testJBIG2() throws Exception {        Metadata metadata = new Metadata();        metadata.set(Metadata.CONTENT_TYPE, "image/x-jbig2");        try (InputStream stream = getClass().getResourceAsStream("/test-documents/testJBIG2.jb2")) {            parser.parse(stream, new DefaultHandler(), metadata, new ParseContext());        }        assertEquals("78", metadata.get("height"));        assertEquals("328", metadata.get("width"));        assertEquals("image/x-jbig2", metadata.get("Content-Type"));    }
@Test public void testIndexHasEntityMap() {        TextIndexLucene index = (TextIndexLucene) Assembler.general.open(SIMPLE_INDEX_SPEC);        try {            assertEquals(RDFS.label.asNode(), index.getDocDef().getPrimaryPredicate());        }        finally {            index.close();        }    }
@Test    public void tryParseAsUUID() {        assertThat(DockerCloudUtils.tryParseAsUUID(TestUtils.TEST_UUID.toString())).isEqualTo(TestUtils.TEST_UUID);    }
@Test    public void testGetNameLength() {        assertEquals(TestParameters.nameLength, dle.getNameLength());    }
@Test  public void testLastElementSingle() {    assertEquals("first", lastElement(l("first")));  }
@Test  public void testGetUrl_https() throws Exception {    Cluster cluster = createNiceMock(Cluster.class);    Config config = createNiceMock(Config.class);    Map<String, String> map = new HashMap<>();    map.put("atlas.enableTLS", "true");    map.put("atlas.server.https.port", "21443");    expect(cluster.getDesiredConfigByType("application-properties")).andReturn(config).anyTimes();    expect(config.getProperties()).andReturn(map).anyTimes();    replay(cluster, config);    AtlasServerHttpPropertyRequest propertyRequest = new AtlasServerHttpPropertyRequest();    String url = propertyRequest.getUrl(cluster, "host1");    Assert.assertEquals("https://host1:21443/api/atlas/admin/status", url);  }
@Test  public void testNamePatternEnvironmentPropertyTruncatedFromBeginning() {    environmentVariables.set("my_prop", "abcdefghi");    final HeapDumpNameFormatter subject =        new HeapDumpNameFormatter("hda_%env:my_prop[,4]%.hprof", "my_host", uuidProvider);    assertThat(subject.format(date), is("hda_abcd.hprof"));  }
@Test	public void testClone() {		Vector3Stamped clone = v1.clone();		assertEquals(v1.toString(), clone.toString());		assertEquals(v1.toJsonObject(), clone.toJsonObject());		assertEquals(v1.getMessageType(), clone.getMessageType());		assertEquals(v1.getHeader(), clone.getHeader());		assertEquals(v1.getVector3(), clone.getVector3());		assertNotSame(v1, clone);		assertNotSame(v1.toString(), clone.toString());		assertNotSame(v1.toJsonObject(), clone.toJsonObject());	}
@Test(expected = UnknownRoadException.class)  public void roadDoesNotExist() throws Exception {    store.clear();    try {      underTest.checkAuthorisation(null, ROAD_NAME, emptySet());    } finally {      verify(metrics).increment("road1", ANONYMOUS, ERROR);    }  }
@Test    public void testByNullAndInterruptedIoSub() {        LogRecord r1 = new LogRecord(Level.INFO, Level.INFO.toString());        LogRecord r2 = new LogRecord(Level.INFO, Level.INFO.toString());        assertEquals(r1.getLevel(), r2.getLevel());        //Esure subclass of IOE is less than null.        r1.setThrown(headSubIioeChain(null));        assertNull(r2.getThrown());        assertRecordLessThan(r1, r2);        r1.setThrown(headSubIioeChain(new Error()));        assertNull(r2.getThrown());        assertRecordLessThan(r1, r2);        r1.setThrown(headSubIioeChain(new RuntimeException()));        assertNull(r2.getThrown());        assertRecordLessThan(r1, r2);        r1.setThrown(headSubIioeChain(new Exception()));        assertNull(r2.getThrown());        assertRecordLessThan(r1, r2);    }
@Test    public void testSetEditingCol() throws Exception {        page.setEditingCol("factField");        verify(plugin).setFactField(eq("factField"));    }
@Test    public void testGetSignature() {        assertEquals(                TestParameters.VP_CONTROL_DATA_SIGNATURE.getBytes(UTF_8).length,                chmLzxcControlData.getSignature().length);    }
@Test    public void testIntEncode() {        Int zero = new Int64(BigInteger.ZERO);        assertThat(PlatOnTypeEncoder.encode(zero),                is("0000000000000000"));        Int maxLong = new Int64(BigInteger.valueOf(Long.MAX_VALUE));        assertThat(PlatOnTypeEncoder.encode(maxLong),                is("7fffffffffffffff"));                Int minLong = new Int64(BigInteger.valueOf(Long.MIN_VALUE));        assertThat(PlatOnTypeEncoder.encode(minLong),                is("8000000000000000"));        Int minusOne = new Int64(BigInteger.valueOf(-1));        assertThat(PlatOnTypeEncoder.encode(minusOne),                is("ffffffffffffffff"));    }
@Test(timeout=30000L)  public void testNodeAttributesFetchInterval()      throws IOException, InterruptedException {    Set<NodeAttribute> expectedAttributes1 = new HashSet<>();    expectedAttributes1.add(NodeAttribute        .newInstance("test.io", "host",            NodeAttributeType.STRING, "host1"));    Configuration conf = new Configuration();    // Set fetch interval to 1s for testing    conf.setLong(        YarnConfiguration.NM_NODE_ATTRIBUTES_PROVIDER_FETCH_INTERVAL_MS, 1000);    ConfigurationNodeAttributesProvider spyProvider =        Mockito.spy(nodeAttributesProvider);    Mockito.when(spyProvider.parseAttributes(Mockito.any()))        .thenReturn(expectedAttributes1);    spyProvider.init(conf);    spyProvider.start();    // Verify init value is honored.    Assert.assertEquals(expectedAttributes1, spyProvider.getDescriptors());    // Configuration provider provides a different set of attributes.    Set<NodeAttribute> expectedAttributes2 = new HashSet<>();    expectedAttributes2.add(NodeAttribute        .newInstance("test.io", "os",            NodeAttributeType.STRING, "windows"));    Mockito.when(spyProvider.parseAttributes(Mockito.any()))        .thenReturn(expectedAttributes2);    // Since we set fetch interval to 1s, it needs to wait for 1s until    // the updated attributes is updated to the provider. So we are expecting    // to see some old values for a short window.    ArrayList<String> keysMet = new ArrayList<>();    int numOfOldValue = 0;    int numOfNewValue = 0;    // Run 5 times in 500ms interval    int times=5;    while(times>0) {      Set<NodeAttribute> current = spyProvider.getDescriptors();      Assert.assertEquals(1, current.size());      String attributeName =          current.iterator().next().getAttributeKey().getAttributeName();      if ("host".equals(attributeName)){        numOfOldValue++;      } else if ("os".equals(attributeName)) {        numOfNewValue++;      }      Thread.sleep(500);      times--;    }    // We should either see the old value or the new value.    Assert.assertEquals(5, numOfNewValue + numOfOldValue);    // Both values should be more than 0.    Assert.assertTrue(numOfOldValue > 0);    Assert.assertTrue(numOfNewValue > 0);  }
@Test    public void testReportProfile() throws Exception {        String logType = TracerSystemLogEnum.MIDDLEWARE_ERROR.getDefaultLogName();        CommonTracerManager.reportError(new CommonLogSpan(this.sofaTracer, System            .currentTimeMillis(), "testReportProfile", SofaTracerSpanContext.rootStart(), null));        TestUtil.waitForAsyncLog();        File file = customFileLog(logType);        assertTrue(file.exists());        List<String> errorContents = FileUtils.readLines(file);        assertTrue(errorContents.toString(), errorContents.size() == 1);    }
@Test	@Ignore("Deprecated API")	public void testProvideAndRegisterDocumentSet() throws Throwable {		// Arrange		sut.setXdsbRepository(xdsbRepositoryAdapterMock);		String documentXmlStringMock = "documentXmlStringMock";		String domainIdMock = "domainIdMock";		XdsbDocumentType xdsbDocumentTypeMock = XdsbDocumentType.CLINICAL_DOCUMENT;		when(				xdsbRepositoryAdapterMock.provideAndRegisterDocumentSet(						documentXmlStringMock, domainIdMock,						xdsbDocumentTypeMock, null, null)).thenReturn(				registryResponseMock);		// Act		RegistryResponse actualResponse = sut.provideAndRegisterDocumentSet(				documentXmlStringMock, domainIdMock, xdsbDocumentTypeMock);		// Assert		assertEquals(registryResponseMock, actualResponse);	}
@Test(expected=NullPointerException.class)    public void testMatchesNull() {        matches(null);    }
@Test  public void closesSocket() {    doAnswer(            AdditionalAnswers.answerVoid(                (RunnableFunction onRequestFulfilled) -> onRequestFulfilled.run()))        .when(requestFulfiller)        .fulfillRequest(any());    testSubject.handleRequest();    verify(socketHolder, times(1)).close(logTag);  }
@Test	public void testReadSpecial() throws IOException {		Assert.assertEquals(			"\b\t\n\f\r+a",			ConfigurationHandler.read("\"\\b\\t\\n\\f\\r\\u002B\\a\""));	}
@Test    public void toOrgJSONObject() {        JSONObject orig = new JSONObject("{\"a\":{\"b\":1}}");        JSONObject actual = SchemaLoader.toOrgJSONObject((JsonObject) JsonValue.of(orig));        assertEquals(orig.toString(), actual.toString());    }
@Test    public void createClient() {        CloudClientParameters clientParams = new CloudClientParameters();        // 1. Populate the client parameters with our own configuration fields.        TestUtils.getSampleDockerConfigParams(false).forEach(clientParams::setParameter);        DockerImageConfig imageConfig = DockerImageConfigBuilder.                newBuilder("Test", Node.EMPTY_OBJECT).                build();        // 2. Add a set of TC cloud image parameters in the cloud client parameter map.        CloudImageParameters imageParams = new CloudImageParameters();        imageParams.setParameter(CloudImageParameters.SOURCE_ID_FIELD, "Test");        imageParams.setParameter(CloudImageParameters.AGENT_POOL_ID_FIELD, "0");        clientParams.setParameter(CloudImageParameters.SOURCE_IMAGES_JSON,                CloudImageParameters.collectionToJson(Collections.singleton(imageParams)));        TestDockerImageConfigParser parser = testCloudSupport.getImageParser();        parser.addConfig(imageConfig);        clientParams.setParameter(DockerCloudUtils.IMAGES_PARAM, parser.getImagesParams().toString());        DockerCloudClientFactory fty = createFactory();        // 3. Register another set of cloud image parameters, as Java instance, in the cloud client parameters.        imageParams.setParameter(CloudImageParameters.AGENT_POOL_ID_FIELD, "42");        Collection<CloudImageParameters> imageParamsCol = Collections.singleton(imageParams);        clientParams.setCloudImages(imageParamsCol);        fty.createNewClient(new TestCloudState(), clientParams);        // 4. Checks that the cloud image parameters instance from 3) have been imported in the image configuration,        // overriding the parameters from the client map.        List<Collection<CloudImageParameters>> imagesParameters = parser.getImagesParametersList();        assertThat(imagesParameters).hasSize(1);        assertThat(TestUtils.areImageParametersEqual(imagesParameters.get(0), imageParamsCol)).isTrue();    }
@Test    public void testMultipleSubscriptionsReceiveSameResult() throws Exception {        Observable<String> observable = Observable.just("1");        Action1<String> testAction = new Action1<String>() {            @Override            public void call(String s) {                assertEquals("1", s);            }        };        observable                .compose(mLifecycleHandler.<String>load(4))                .subscribe(testAction);        observable                .compose(mLifecycleHandler.<String>load(4))                .subscribe(testAction);    }
@Test    public void testCreateBean() {        // tested from lookup tests    }
@Test    public void testGetExtensionBundleVersionByBucketGroupArtifactVersionWhenDoesNotExist() {        final String bucketId = "3";        final String groupId = "org.apache.nifi";        final String artifactId = "nifi-example-processors-nar";        final String version = "FOO";        final BundleVersionEntity bundleVersion = metadataService.getBundleVersion(bucketId, groupId, artifactId, version);        assertNull(bundleVersion);    }
@Test  public void buildFromPropertiesFile_invalidFilePath_throwsException() throws IOException {    File nonExistentFile = new File(folder.getRoot(), "I_dont_exist.properties");    // Invokes the fromPropertiesFile method on the builder, which should fail.    thrown.expect(FileNotFoundException.class);    thrown.expectMessage(nonExistentFile.getName());    GoogleAdsClient.newBuilder().fromPropertiesFile(nonExistentFile);  }
@Test    public void testGetAttributes() throws Exception {        String[] expectedStrings = new String[]{"arg1", "arg2"};        String tag = "myFunction(arg1,arg2)";        assertArrayEquals(expectedStrings, CarpaccioHelper.getAttributes(tag));    }
@Test    public void testDistanceBetweenTwoPolygons() throws                                                 Exception {        // given two Polygons        final double distance = distanceTo(createPolygon(gf,                                                         createCoordinate(gf,                                                                          47.226116d,                                                                          -1.554169d),                                                         createCoordinate(gf,                                                                          47.226126d,                                                                          -1.554097d),                                                         createCoordinate(gf,                                                                          47.225527d,                                                                          -1.553986d),                                                         createCoordinate(gf,                                                                          47.225519d,                                                                          -1.554061d),                                                         createCoordinate(gf,                                                                          47.226116d,                                                                          -1.554169d)),                                           createPolygon(gf,                                                         createCoordinate(gf,                                                                          47.226219d,                                                                          -1.554430d),                                                         createCoordinate(gf,                                                                          47.226237d,                                                                          -1.554261d),                                                         createCoordinate(gf,                                                                          47.226122d,                                                                          -1.554245d),                                                         createCoordinate(gf,                                                                          47.226106d,                                                                          -1.554411d),                                                         createCoordinate(gf,                                                                          47.226219d,                                                                          -1.554430d)));        // then the computed distance should be roughly equals to 19m        assertEquals(19d,                     distance,                     1d);    }
@Test    public void getReadVersionTwice() {        final FDBStoreTimer timer = new FDBStoreTimer();        try (FDBRecordContext context = fdb.openContext(null, timer)) {            long readVersion1 = context.getReadVersion();            assertEquals(1, timer.getCount(FDBStoreTimer.Events.GET_READ_VERSION));            long grvNanos = timer.getTimeNanos(FDBStoreTimer.Events.GET_READ_VERSION);            long readVersion2 = context.getReadVersion();            assertEquals(readVersion1, readVersion2);            assertEquals(1, timer.getCount(FDBStoreTimer.Events.GET_READ_VERSION));            assertEquals(grvNanos, timer.getTimeNanos(FDBStoreTimer.Events.GET_READ_VERSION));        }    }
@Test    public void testCreateOffset_ATSR3_2009() throws Exception {        final Offset offset = factory.createOffset("ATS", 2009);        assertEquals(1, offset.getAcrossTrackOffset());        assertEquals(-1, offset.getAlongTrackOffset());    }
@DisplayName("starts server")  @Test  void start() {    InetSocketAddress address = InetSocketAddress.createUnresolved("localhost", 0);    WebsocketServerTransport serverTransport = WebsocketServerTransport.create(address);    serverTransport        .start(duplexConnection -> Mono.empty())        .as(StepVerifier::create)        .expectNextCount(1)        .verifyComplete();  }
@Test  public void testCreateKey() throws Exception {    assertNull( rrl.createKey( 0, null ) );    Map<String, Object> keys = new HashMap<String, Object>() {{        put( "key", "value" );    }};    ResourceKey key = rrl.createKey( rrl.SOLUTION_SCHEMA_NAME + rrl.SCHEMA_SEPARATOR, keys );    assertNotNull( key );    assertEquals( rrl.SOLUTION_SCHEMA_NAME, key.getSchema() );  }
@Test  public void typicalWithNumber() {    assertThat(underTest.validate("normal2"), is("normal2"));  }
@Test	public void add() {		final SampleBuffer<Double> buffer = new SampleBuffer<>(33);		for (int i = 0; i < 10; ++i) {			buffer.add(Sample.ofDouble(i, 2*i));		}		Assert.assertEquals(buffer.samples(), List.of());	}
@Test    public void renewCertificate_Non_Admin_Success() throws Exception {    	String certficateName = "testCert.t-mobile.com";    	String certficateType = "internal";    	String token = "FSR&&%S*";    	String jsonStr = "{  \"username\": \"testusername1\",  \"password\": \"testpassword1\"}";    	String jsonStr2 = "{\"certificates\":[{\"sortedSubjectName\": \"CN=CertificateName.t-mobile.com, C=US, " +                "ST=Washington, " +                "L=Bellevue, O=T-Mobile USA, Inc\"," +                "\"certificateId\":57258,\"certificateStatus\":\"Active\"," +                "\"containerName\":\"cont_12345\",\"NotAfter\":\"2021-06-15T04:35:58-07:00\"}]}";    	 UserDetails userDetails = new UserDetails();         userDetails.setSelfSupportToken("tokentTest");         userDetails.setUsername("normaluser");         userDetails.setAdmin(false);         userDetails.setClientToken(token);         userDetails.setSelfSupportToken(token);        Map<String, Object> requestMap = new HashMap<>();        requestMap.put("access_token", "12345");        requestMap.put("token_type", "type");        when(ControllerUtil.parseJson(jsonStr)).thenReturn(requestMap);        CertManagerLogin certManagerLogin = new CertManagerLogin();        certManagerLogin.setToken_type("token type");        certManagerLogin.setAccess_token("1234");        String metaDataJson = "{\"data\":{\"akmid\":\"102463\",\"applicationName\":\"tvs\",\"applicationOwnerEmailId\":\"SpectrumClearingTools@T-Mobile.com\",\"applicationTag\":\"TVS\",\"authority\":\"T-Mobile Issuing CA 01 - SHA2\",\"certCreatedBy\":\"nnazeer1\",\"certOwnerEmailId\":\"ltest@smail.com\",\"certType\":\"internal\",\"certificateId\":59880,\"certificateName\":\"certtest260630.t-mobile.com\",\"certificateStatus\":\"Revoked\",\"containerName\":\"VenafiBin_12345\",\"createDate\":\"2020-06-26T05:10:41-07:00\",\"expiryDate\":\"2021-06-26T05:10:41-07:00\",\"projectLeadEmailId\":\"Daniel.Urrutia@T-Mobile.Com\",\"users\":{\"normaluser\":\"write\",\"certuser\":\"read\",\"safeadmin\":\"deny\",\"testsafeuser\":\"write\",\"testuser1\":\"deny\",\"testuser2\":\"read\"}}}";        Response response = new Response();        response.setHttpstatus(HttpStatus.OK);        response.setResponse(metaDataJson);        response.setSuccess(true);        when(reqProcessor.process(eq("/read"), anyObject(), anyString())).thenReturn(response);        CertResponse certResponse = new CertResponse();        certResponse.setHttpstatus(HttpStatus.OK);        certResponse.setResponse(jsonStr);        certResponse.setSuccess(true);        when(reqProcessor.processCert(eq("/auth/certmanager/login"), anyObject(), anyString(), anyString())).thenReturn(certResponse);        CertResponse renewResponse = new CertResponse();        renewResponse.setHttpstatus(HttpStatus.OK);        renewResponse.setResponse(null);        renewResponse.setSuccess(true);        when(reqProcessor.processCert(eq("/certificates/renew"), anyObject(), anyString(), anyString())).thenReturn(renewResponse);        CertResponse findCertResponse = new CertResponse();        findCertResponse.setHttpstatus(HttpStatus.OK);        findCertResponse.setResponse(jsonStr2);        findCertResponse.setSuccess(true);        when(reqProcessor.processCert(eq("/certmanager/findCertificate"), anyObject(), anyString(), anyString())).thenReturn(findCertResponse);        when(ControllerUtil.updateMetaData(anyString(), anyMap(), anyString())).thenReturn(Boolean.TRUE);        ResponseEntity<?> renewCertResponse =                sSLCertificateService.renewCertificate(certficateType, certficateName, userDetails, token);        //Assert        assertNotNull(renewCertResponse);    }
@Test  public void testTableCaching() throws IOException {    File mapFile = File.createTempFile(getClass().getSimpleName() +        ".testTableCaching", ".txt");    Files.write("a.b.c /rack1\n" +                "1.2.3.4\t/rack2\n", mapFile, Charsets.UTF_8);    mapFile.deleteOnExit();    TableMapping mapping = new TableMapping();    Configuration conf = new Configuration();    conf.set(NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY, mapFile.getCanonicalPath());    mapping.setConf(conf);    List<String> names = new ArrayList<String>();    names.add("a.b.c");    names.add("1.2.3.4");    List<String> result1 = mapping.resolve(names);    assertEquals(names.size(), result1.size());    assertEquals("/rack1", result1.get(0));    assertEquals("/rack2", result1.get(1));    // unset the file, see if it gets read again    conf.set(NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY, "some bad value for a file");    List<String> result2 = mapping.resolve(names);    assertEquals(result1, result2);  }
@Test(expected = IllegalArgumentException.class)    public void pathTemplateCreateShouldFailIfTwoTemplateWithSameNameAreDetected() throws Exception {        try {            RegexPathTemplate.create("http://localhost/{template-name}/{template-name:[a-z]{2}}");        } catch (Exception e) {            assertEquals("Template name 'template-name' is already defined!", e.getMessage());            throw e;        }    }
@Test    public void inPortHasSignal() {        try (ModuleInterpretation moduleInterpretation = testCaseBuilder("successfulExecution").build()) {            Props props = moduleInterpretation.toSimpleModuleInterpreterProps(MODULE_ID, bitSetOf(0, 1), bitSetOf(0));            TestActorRef<SimpleModuleInterpreterActor> actorRef = TestActorRef.create(                moduleInterpretation.getActorSystem(), props, moduleInterpretation.getSupervisor());            // Now send InPortHasSignal messages            TestProbe executorProbe = moduleInterpretation.getExecutorProbe();            Assert.assertFalse(executorProbe.msgAvailable());            actorRef.receive(new InPortHasSignal(0));            Assert.assertFalse(executorProbe.msgAvailable());            actorRef.receive(new InPortHasSignal(1));            // Verify that executor receives an ExecuteTrace message            ExecuteTrace executeTraceMessage = executorProbe.expectMsgClass(ExecuteTrace.class);            RuntimeStateProvider runtimeStateProvider = executeTraceMessage.getRuntimeStateProvider();            InstanceProvider instanceProvider = mock(InstanceProvider.class);            RuntimeContext restoredRuntimeContext = await(runtimeStateProvider.provideRuntimeContext(instanceProvider));            Assert.assertSame(restoredRuntimeContext.getRepository(), repository);            // Send the SimpleModuleExecutorResult that the executor would send. Verify that the parent actor receives a            // SubmoduleOutPortHasSignal message            SimpleModuleExecutorResult executionResult = new SimpleModuleExecutorResult.Builder(                    Name.qualifiedName(SimpleModuleExecutorResult.class.getName()))                .build();            actorRef.receive(executionResult);            TestProbe parentProbe = moduleInterpretation.getParentProbe();            parentProbe.expectMsg(new SubmoduleOutPortHasSignal(MODULE_ID, 0));            // Verify that the actor terminates properly. The Akka manual says: "the watching actor will receive a            // Terminated message even if the watched actor has already been terminated at the time of registration."            parentProbe.watch(actorRef);            parentProbe.expectMsgClass(Terminated.class);            Assert.assertFalse(parentProbe.msgAvailable());        }    }
@Test  public void testApplyToZero() {    assertEquals(Vector3.ZERO, new Quaternion().apply(new Vector3(0, 0, 0), null));  }
@Test  public void shouldHandleWorkflowNotFoundWhenEnabling() {    final String component = "quux";    final WorkflowState workflowState = WorkflowState.builder()        .enabled(true)        .build();    final ApiErrorException exception = new ApiErrorException("not found", 404, true, requestId);    when(client.updateWorkflowState(any(), any(), eq(workflowState)))        .thenReturn(exceptionallyCompletedFuture(exception));    CliMain.run(cliContext, "workflow", "enable", component, "foo", "bar");    verify(cliOutput).printMessage("Workflow foo in component " + component + " not found.");    verify(cliOutput).printMessage("Workflow bar in component " + component + " not found.");  }
@Test    public void shouldAddExpenseIfConversionInformationIsConsistent() throws Exception {        final Nobt nobt = aNobt()                .withCurrency(new CurrencyKey("EUR"))                .build();        final ExpenseDraft expenseDraft = anExpenseDraft()                .withConversionInformation(new ConversionInformation(new CurrencyKey("USD"), BigDecimal.TEN))                .build();        nobt.createExpenseFrom(expenseDraft);    }
@Test    public void test_ip2ByteArray_ipv6_exception() throws Exception {        // ipv6 with char        try {            IpParserUtil.ip2ByteArray("2404:6800:4005:80a:0:0:0:200z");            fail();        } catch (IllegalArgumentException expected) {            expected.printStackTrace();        }                // ipv6 minus        try {            IpParserUtil.ip2ByteArray("-2404:6800:4005:80a:0:0:0:200e");            fail();        } catch (IllegalArgumentException expected) {            expected.printStackTrace();        }        // ipv6 too long        try {            IpParserUtil.ip2ByteArray("2404:6800:4005:80a:0:0:0:200:123");            fail();        } catch (IllegalArgumentException expected) {            expected.printStackTrace();        }    }
@Test    public void testNotifyOnContainerDestroyed() throws Exception    {        EnvironmentEventListener listener = mock( EnvironmentEventListener.class );        environmentManager.listeners.add( listener );        environmentManager.notifyOnContainerDestroyed( environment, TestHelper.CONTAINER_ID );        verify( cachedExecutor ).submit( isA( Runnable.class ) );    }
@Test    public void testJoin() {        assertThat(Strings.join(Arrays.asList("a", "b"), "|"), is("a|b"));        assertNull(Strings.join(null, "|"));        assertThat(Strings.join(Collections.singletonList("a"), "|"), is("a"));    }
@Test    public void listStatus() throws IOException {        // Create temp files        final File file1 = tempFolder.newFile("file1");        Assert.assertTrue(file1.setLastModified(currentTimeMillis));        final File folder1 = tempFolder.newFolder("folder1");        final File file2 = tempFolder.newFile("folder1/file2");        Assert.assertTrue(file2.setLastModified(currentTimeMillis));        tempFolder.newFolder("folder1", "folder2");        final File file3 = tempFolder.newFile("folder1/folder2/file3");        Assert.assertTrue(file3.setLastModified(currentTimeMillis));        // Test listing files        final Job job = Job.getInstance(new Configuration(false));        HighWaterMarkInputFormat.setInputPaths(job, file1.getAbsolutePath() + "," + folder1.getAbsolutePath());        final HighWaterMarkInputFormat inputFormat = new MockHighWaterMarkInputFormat();        final List<FileStatus> files = inputFormat.listStatus(job);        Collections.sort(files, new FileStatusComparator());        Assert.assertEquals(new Path(file1.toURI()), files.get(0).getPath());        Assert.assertEquals(new Path(file2.toURI()), files.get(1).getPath());        Assert.assertEquals(2, files.size());        Assert.assertEquals(currentTimeMillis, inputFormat.getLastHighWaterMark());        // Verify files are not listed again        Assert.assertEquals(0, inputFormat.listStatus(job).size());    }
@Test    public void testGetLabel() {        assertThat(instance.getLabel(), equalTo(label));    }
@Test    public void builderThrowsIfCantReadKey() {        // given        PEMCertInfo testCertInfo = createTestCertInfoBuilder()                .withKeyPath(TEST_KEY_PATH_WITH_PASSPHRASE)                .withKeyPassphrase("")                .build();        expectedException.expect(ConfigurationException.class);        expectedException.expectMessage(PEMCertInfo.configExceptionMessage);        // when        testCertInfo.applyTo(mock(HttpClientConfig.Builder.class));    }
@Test    public void convert2Proto() {        GlobalStatusResponse globalStatusResponse = new GlobalStatusResponse();        globalStatusResponse.setGlobalStatus(GlobalStatus.AsyncCommitting);        globalStatusResponse.setMsg("msg");        globalStatusResponse.setResultCode(ResultCode.Failed);        globalStatusResponse.setTransactionExceptionCode(TransactionExceptionCode.BranchRegisterFailed);        GlobalStatusResponseConvertor convertor = new GlobalStatusResponseConvertor();        GlobalStatusResponseProto proto = convertor.convert2Proto(            globalStatusResponse);        GlobalStatusResponse real = convertor.convert2Model(proto);        assertThat((real.getTypeCode())).isEqualTo(globalStatusResponse.getTypeCode());        assertThat((real.getMsg())).isEqualTo(globalStatusResponse.getMsg());        assertThat((real.getResultCode())).isEqualTo(globalStatusResponse.getResultCode());        assertThat((real.getTransactionExceptionCode())).isEqualTo(            globalStatusResponse.getTransactionExceptionCode());    }
@Test  @DatabaseSetup("HibernateMedicationsDaoTest.testCustomGroups.xml")  public void testGetCustomGroupNames()  {    final Set<Long> medicationCodes = new HashSet<>();    medicationCodes.add(1L);    medicationCodes.add(2L);    medicationCodes.add(3L);    medicationCodes.add(4L);    final Map<Long, Pair<String, Integer>> resultMapPek =        medicationsDao.getCustomGroupNameSortOrderMap("1", medicationCodes);    assertEquals(1L, (long)resultMapPek.size());    assertEquals("Paracetamol Kardio Hosp", resultMapPek.get(1L).getFirst());    assertEquals(Integer.valueOf(2), resultMapPek.get(1L).getSecond());    final Map<Long, Pair<String, Integer>> resultMapKookit =        medicationsDao.getCustomGroupNameSortOrderMap("2", medicationCodes);    assertEquals(4L, (long)resultMapKookit.size());    assertEquals("Paracetamol KOOKIT EIT", resultMapKookit.get(1L).getFirst());    assertEquals(Integer.valueOf(1), resultMapKookit.get(1L).getSecond());  }
@Test  public void testTherapyModifiedFromLastReviewWithModifyAction()  {    final MedicationOrderComposition composition =        MedicationsTestUtils.buildTestMedicationOrderComposition("uid2::1", null, null);    final MedicationInstructionInstruction instruction =        MedicationsTestUtils.buildTestMedicationInstruction("MedicationInstructionInstruction 2");    composition.getMedicationDetail().getMedicationInstruction().add(instruction);    final List<MedicationActionAction> actionsList = new ArrayList<>();    actionsList.add(MedicationsTestUtils.buildMedicationAction(MedicationActionEnum.SCHEDULE, new DateTime(2013, 5, 10, 12, 0)));    actionsList.add(MedicationsTestUtils.buildMedicationAction(MedicationActionEnum.START, new DateTime(2013, 5, 10, 12, 0)));    actionsList.add(MedicationsTestUtils.buildMedicationAction(MedicationActionEnum.REVIEW, new DateTime(2013, 5, 10, 12, 0)));    actionsList.add(MedicationsTestUtils.buildMedicationAction(MedicationActionEnum.REVIEW, new DateTime(2013, 5, 11, 12, 0)));    actionsList.add(MedicationsTestUtils.buildMedicationAction(MedicationActionEnum.REVIEW, new DateTime(2013, 5, 12, 12, 0)));    actionsList.add(MedicationsTestUtils.buildMedicationAction(MedicationActionEnum.MODIFY_EXISTING, new DateTime(2013, 5, 12, 13, 0)));    composition.getMedicationDetail().getMedicationAction().addAll(actionsList);    final boolean modified = medicationsBo.isTherapyModifiedFromLastReview(instruction, actionsList, new DateTime(2013, 5, 12, 5, 0));    assertTrue(modified);  }
@Test    public void extract() {        final List<SiteMapEntry> entries = model.extract(parent);        assertEquals(2, entries.size());        final SiteMapEntry entry = entries.get(0);        assertTrue(StringUtils.startsWith(entry.getUrl(), DOMAIN));    }
@Test  public void testUncaughtExceptionHandlerWithRuntimeException()      throws InterruptedException {    final YarnUncaughtExceptionHandler spyYarnHandler = spy(exHandler);    final YarnRuntimeException yarnException = new YarnRuntimeException(        "test-yarn-runtime-exception");    final Thread yarnThread = new Thread(new Runnable() {      @Override      public void run() {        throw yarnException;      }    });    yarnThread.setUncaughtExceptionHandler(spyYarnHandler);    assertSame(spyYarnHandler, yarnThread.getUncaughtExceptionHandler());    yarnThread.start();    yarnThread.join();    verify(spyYarnHandler).uncaughtException(yarnThread, yarnException);  }
@Test	public void testCountXResource() {		List<RangerPolicy> rangerPolicyList = new ArrayList<RangerPolicy>();		List<VXResource> vXResourcesList = new ArrayList<VXResource>();		RangerService rangerService = rangerService(Id);		long i;		for (i = 1; i <= 2; i++) {			RangerPolicy rangerPolicy = rangerPolicy(i);			VXResource vXresource = vxResource(i);			rangerPolicyList.add(rangerPolicy);			vXResourcesList.add(vXresource);			Mockito.when(serviceUtil.toVXResource(rangerPolicy, rangerService)).thenReturn(vXresource);		}		VXLong expectedXResouce = new VXLong();		expectedXResouce.setValue(2l);		Mockito.when(serviceREST.getServiceByName(rangerPolicyList.get(0).getService())).thenReturn(rangerService);		VXResourceList expectedVXResourceList = new VXResourceList();		expectedVXResourceList.setVXResources(vXResourcesList);		SearchFilter searchFilter = new SearchFilter();		Mockito.when(searchUtil.getSearchFilterFromLegacyRequest(request, null)).thenReturn(searchFilter);		Mockito.when(serviceREST.getPolicies(searchFilter)).thenReturn(rangerPolicyList);		VXLong actualXResource = assetREST.countXResources(request);		Assert.assertEquals(expectedXResouce.getValue(), actualXResource.getValue());	}
@Test  public void newInstance () {    val value = new byte[] { 1, 2, 3 };    val bytes = Bytes.resizableArray()        .write1B(BINARY.getCode())        .write4B(value.length)        .writeNB(value)        .arrayCopy();    ErlangBinary binary = ErlangTerm.newInstance(wrappedBuffer(bytes));    assertThat(binary).isNotNull();    SoftAssertions.assertSoftly(softly -> {      softly.assertThat(binary.isBinary())          .isTrue();      softly.assertThat(binary.asBinary())          .isEqualTo(value);    });  }
@Test    public void testVerifyBuffered() {        List<Data> data = generateTestData();        insertData(data);        Data d = Variables.register("d",                data.get(TestData.getScaleCount() % data.size()));        boolean verify = Numbers.isOdd(count(data, d));        Assert.assertEquals(verify, store.verify(d.key, d.value, d.record));    }
@Test    public void testGetPaths() {        logger.debug("testGetPaths: enter");        try {            // valid test            String logPaths = "C:\\pap-log\\pap-rest.log;C:\\pap-log\\debug.log;C:\\pap-log\\error.log";            String[] retrunObject = ParseLog.getPaths(logPaths);            assertEquals(3, retrunObject.length);            // valid test            logPaths = "C:\\pap-log\\pap-rest.log";            retrunObject = ParseLog.getPaths(logPaths);            assertEquals(1, retrunObject.length);            // invalid test            logPaths = "";            retrunObject = ParseLog.getPaths(logPaths);            assertTrue(retrunObject == null);        } catch (final Exception e) {            fail();        }        logger.debug("testGetPaths: exit");    }
@SuppressWarnings("unchecked")  @Test  public void testInsertionWithFailover() {    Configuration conf = new Configuration();    // Config for server to throw StandbyException instead of the    // regular RetriableException if call queue is full.    conf.setBoolean(        "ns." + CommonConfigurationKeys.IPC_CALLQUEUE_SERVER_FAILOVER_ENABLE,        true);    // 3 queues, 2 slots each.    fcq = Mockito.spy(new FairCallQueue<>(3, 6, "ns", conf));    Schedulable p0 = mockCall("a", 0);    Schedulable p1 = mockCall("b", 1);    // add to first queue.    addToQueueAndVerify(p0, 1, 0, 0);    // 0:x- 1:-- 2:--    // add to second queue.    addToQueueAndVerify(p1, 0, 1, 0);    // 0:x- 1:x- 2:--    // add to first queue.    addToQueueAndVerify(p0, 1, 0, 0);    // 0:xx 1:x- 2:--    // add to first full queue spills over to second.    addToQueueAndVerify(p0, 1, 1, 0);    // 0:xx 1:xx 2:--    // add to second full queue spills over to third.    addToQueueAndVerify(p1, 0, 1, 1);    // 0:xx 1:xx 2:x-    // add to first and second full queue spills over to third.    addToQueueAndVerify(p0, 1, 1, 1);    // 0:xx 1:xx 2:xx    // adding non-lowest priority with all queues full throws a    // standby exception for client to try another server.    Mockito.reset(fcq);    try {      fcq.add(p0);      fail("didn't fail");    } catch (IllegalStateException ise) {      checkOverflowException(ise, RpcStatusProto.FATAL, true);    }  }
@Test    public void testTable2() {        // JENA-1468 : op to string and back.        String qs = "SELECT * WHERE { ?x ?p ?z . VALUES ?y { } }" ;        Query query = QueryFactory.create(qs);         Op op = Algebra.compile(query);        String x = op.toString();        Op op1 = SSE.parseOp(x);        Query query2 = OpAsQuery.asQuery(op1);        assertEquals(query, query2);    }
@Test    public void canResolve_unknownAlias_returnFalse() {        SimpleAliasRegistry registry = new SimpleAliasRegistry();        assertFalse(registry.canResolve(ALIAS));    }
@Test  public void testDropSuffixWithEmptyString() {      String string = StringUtil.dropSuffix("", "^Fahs");      assertEquals("", string);  }
@Test  @SuppressWarnings("all")  public void mutateKeywordPlanAdGroupsTest() {    MutateKeywordPlanAdGroupsResponse expectedResponse =        MutateKeywordPlanAdGroupsResponse.newBuilder().build();    mockKeywordPlanAdGroupService.addResponse(expectedResponse);    String customerId = "customerId-1772061412";    List<KeywordPlanAdGroupOperation> operations = new ArrayList<>();    MutateKeywordPlanAdGroupsResponse actualResponse =        client.mutateKeywordPlanAdGroups(customerId, operations);    Assert.assertEquals(expectedResponse, actualResponse);    List<AbstractMessage> actualRequests = mockKeywordPlanAdGroupService.getRequests();    Assert.assertEquals(1, actualRequests.size());    MutateKeywordPlanAdGroupsRequest actualRequest =        (MutateKeywordPlanAdGroupsRequest) actualRequests.get(0);    Assert.assertEquals(customerId, actualRequest.getCustomerId());    Assert.assertEquals(operations, actualRequest.getOperationsList());    Assert.assertTrue(        channelProvider.isHeaderSent(            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));  }
@Test( expected = KException.class )    public void shouldFailRemovingResultSetIfOneDoesNotExist() throws Exception {        this.function.removeResultSet( getTransaction() );    }
@Test	public void testExtractPatientId() throws JAXBException, IOException {		// Arrange		String expectedResponse = "'1c5c59f0-5788-11e3-84b3-00155d3a2124^^^&2.16.840.1.113883.4.357&ISO'";		AdhocQueryRequest requestMock = marshaller.unmarshalFromXml(				AdhocQueryRequest.class,				fileReader.readFile("unitTestAdhocQueryRequest.xml"));		// Act		String actualResponse = xdsbRegistryAdapterSpy				.extractPatientId(requestMock);		// Assert		assertEquals(expectedResponse, actualResponse);	}
@Test    void get6() {        assertEquals(m6, instance.get6());    }
@Test  public void testIndexerAll() throws Exception {    Privilege indexerAll = create(new KeyValue("indexer", ALL));    Privilege indexer1 = create(new KeyValue("indexer", "ind1"));    assertTrue(indexerAll.implies(indexer1));    assertTrue(indexer1.implies(indexerAll));    Privilege allWrite =      create(new KeyValue("indexer", ALL), new KeyValue("action", "write"));    Privilege allRead =      create(new KeyValue("indexer", ALL), new KeyValue("action", "read"));    Privilege ind1Write =      create(new KeyValue("indexer", "ind1"), new KeyValue("action", "write"));    Privilege ind1Read =      create(new KeyValue("indexer", "ind1"), new KeyValue("action", "read"));    assertTrue(allWrite.implies(ind1Write));    assertTrue(allRead.implies(ind1Read));    assertTrue(ind1Write.implies(allWrite));    assertTrue(ind1Read.implies(allRead));    assertFalse(allWrite.implies(ind1Read));    assertFalse(ind1Write.implies(ind1Read));    assertFalse(allRead.implies(ind1Write));    assertFalse(ind1Read.implies(allWrite));    assertFalse(allWrite.implies(allRead));    assertFalse(allRead.implies(allWrite));    assertFalse(ind1Write.implies(ind1Read));    assertFalse(ind1Read.implies(ind1Write));    // test different length paths    assertTrue(indexerAll.implies(allWrite));    assertTrue(indexerAll.implies(allRead));    assertTrue(indexerAll.implies(ind1Write));    assertTrue(indexerAll.implies(ind1Read));    assertFalse(allWrite.implies(indexerAll));    assertFalse(allRead.implies(indexerAll));    assertFalse(ind1Write.implies(indexerAll));    assertFalse(ind1Read.implies(indexerAll));  }
@Test    public void testCloneDTCellValueWhenDTCellValue52IsNotNull() {        final DTCellValue52 dcv = new DTCellValue52() {{            setStringValue("value");        }};        final DTCellValue52 clone = plugin.cloneDTCellValue(dcv);        assertEquals(dcv,                     clone);        assertNotSame(dcv,                      clone);    }
@Test    public void onChildDestroyed() {        Component childView = (Component) child2.getView();        uut.onChildDestroyed(childView);        verify(presenter).onChildDestroyed(childView);    }
@Test    public void should_create_read_only_widget_for_aggregated_input() {        BusinessDataReference dataReference = new BusinessDataReference("aggregatedReference", Object.class.getName(),                RelationType.AGGREGATION, LoadingType.EAGER);        NodeContractInput parent = new NodeContractInput("aggregatedObject");        parent.setDataReference(dataReference);        parent.setMode(EditMode.EDIT);        LeafContractInput input = new LeafContractInput(ContractInputDataHandler.PERSISTENCEID_INPUT_NAME, String.class);        input.setReadonly(true);        input.setMode(EditMode.EDIT);        parent.addInput(input);        AbstractParametrizedWidget widget = createFactory().createParametrizedWidget(input);        assertThat(widget).isInstanceOf(TextWidget.class);        assertThat(widget.getHidden()).isEqualTo("!aggregatedReference");        assertThat(((TextWidget) widget).isLabelHidden()).isFalse();        assertThat(((TextWidget) widget).getLabel()).isEqualTo("Aggregated Reference");        assertThat(((TextWidget) widget).getText()).isEqualTo("{{aggregatedReference}}");    }
@Test    public void test_refundPoint() {        BigDecimal refund = BigDecimal.valueOf(100L).setScale(DecimalUtils.SCALE_2);        BigDecimal cost = BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2);        rec.setAvailable(BigDecimal.valueOf(150L).setScale(DecimalUtils.SCALE_2))                .setRefund(DecimalUtils.ZERO)                .setRefundCost(DecimalUtils.ZERO)                .setFrozen(DecimalUtils.ZERO);        PointRecPo result = this.calculator.refundPoint(rec, refund, cost);        log.info("result = {}", result);        Assertions.assertEquals(rec.getId(), result.getId());        Assertions.assertEquals(BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2), // 150 - 100                rec.getAvailable());        Assertions.assertEquals(BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2), // 150 - 100                result.getAvailable());        Assertions.assertEquals(BigDecimal.valueOf(100L).setScale(DecimalUtils.SCALE_2), rec.getRefund());        Assertions.assertEquals(BigDecimal.valueOf(100L).setScale(DecimalUtils.SCALE_2), result.getRefund());        Assertions.assertEquals(BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2), rec.getRefundCost());        Assertions.assertEquals(BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2), result.getRefundCost());        Assertions.assertTrue(rec.getEnable());        Assertions.assertTrue(result.getEnable());        rec.setAvailable(BigDecimal.valueOf(100L))                .setRefund(DecimalUtils.ZERO)                .setRefundCost(DecimalUtils.ZERO);        result = this.calculator.refundPoint(rec, refund, cost);        log.info("result = {}", result);        Assertions.assertEquals(rec.getId(), result.getId());        Assertions.assertEquals(DecimalUtils.ZERO, // 150 - 100                rec.getAvailable());        Assertions.assertEquals(DecimalUtils.ZERO, // 150 - 100                result.getAvailable());        Assertions.assertEquals(BigDecimal.valueOf(100L).setScale(DecimalUtils.SCALE_2), rec.getRefund());        Assertions.assertEquals(BigDecimal.valueOf(100L).setScale(DecimalUtils.SCALE_2), result.getRefund());        Assertions.assertEquals(BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2), rec.getRefundCost());        Assertions.assertEquals(BigDecimal.valueOf(50L).setScale(DecimalUtils.SCALE_2), result.getRefundCost());        Assertions.assertFalse(rec.getEnable());        Assertions.assertFalse(result.getEnable());    }
@Test  public void notFound() throws IOException {    req.setRequestURI("/_ah/api/notfound");    req.setMethod("GET");    servlet.service(req, resp);    assertThat(resp.getStatus()).isEqualTo(HttpServletResponse.SC_NOT_FOUND);  }
@Test    public void wrapsText() {        assertThat(StringUtils.wrap("hello, there, bud", 6), equalTo(String.format("hello,%nthere,%nbud")));    }
@Test	public void testFromJsonObject() {		JsonObject jsonObject = Json.createObjectBuilder()				.add(GoalStatus.FIELD_GOAL_ID, g1.getGoalID().toJsonObject())				.add(GoalStatus.FIELD_STATUS, g1.getStatus())				.add(GoalStatus.FIELD_TEXT, g1.getText()).build();		GoalStatus p = GoalStatus.fromJsonObject(jsonObject);		assertEquals(g1.toString(), p.toString());		assertEquals(g1.toJsonObject(), p.toJsonObject());		assertEquals(g1.getMessageType(), p.getMessageType());		assertEquals(g1.getGoalID(), p.getGoalID());		assertEquals(g1.getStatus(), p.getStatus());		assertEquals(g1.getText(), p.getText());		assertNotSame(g1, p);		assertNotSame(g1.toString(), p.toString());		assertNotSame(g1.toJsonObject(), p.toJsonObject());	}
@Test    public void testStoreCheckedValueIntoChildJSONObject() throws JSONException {        field.setOptionStrings(new HashMap<String, List<String>>(){{put("en", Arrays.asList("one", "two", "three"));}});        view.initialize(field, child);        CheckBox checkBox1 = checkCheckBoxAtIndex(0, true);        JSONArray options = new JSONArray();        options.put(checkBox1.getText());        assertEquals(options.toString(), (child.get(field.getId())).toString());        CheckBox checkBox2 = checkCheckBoxAtIndex(1, true);        options.put(checkBox2.getText());        assertEquals(options.toString(), child.get(field.getId()).toString());    }
@Test    public void testSerialize() throws Exception {        PacketParser parser = new HandshakePacket().getParser();        HandshakePacket.Flags flags = new HandshakePacket.Flags();        flags.setRegistered(true);        flags.setHandshakeRequest(true);        flags.setRequestsReturnService(true);        byte[] buffer = new byte[] {                (byte) PACKETS.HANDSHAKE_OPEN.ordinal(), 0,2,4,8,16,32,64,2,4,8,16,32,64,2,4,8,16,32,64,2,4,8,16,32,64,2,4,8,16,32,64,0, flags.toByte()        };        HandshakePacket packet = (HandshakePacket) parser.parse(new PacketBuffer().write(buffer), null);        byte[] bytes = packet.getParser().serialize();        assertArrayEquals(buffer, bytes);    }
@Test    public void shouldReturnWritableCopy() {        ByteBuf buf = unmodifiableBuffer(buffer(1));        assertFalse(buf.copy() instanceof ReadOnlyByteBuf);    }
@Test  public void readSeekTableMetadataBlock_returnsCorrectSeekPoints() throws Exception {    ExtractorInput input = buildExtractorInput("flac/bear.flac");    // Skip to seek table block.    input.skipFully(FlacConstants.STREAM_MARKER_SIZE + FlacConstants.STREAM_INFO_BLOCK_SIZE);    int seekTableBlockSize = 598;    ParsableByteArray scratch = new ParsableByteArray(seekTableBlockSize);    input.read(scratch.data, 0, seekTableBlockSize);    FlacStreamMetadata.SeekTable seekTable = FlacMetadataReader.readSeekTableMetadataBlock(scratch);    assertThat(seekTable.pointOffsets[0]).isEqualTo(0);    assertThat(seekTable.pointSampleNumbers[0]).isEqualTo(0);    assertThat(seekTable.pointOffsets[31]).isEqualTo(160602);    assertThat(seekTable.pointSampleNumbers[31]).isEqualTo(126976);  }
@Test  public void testUnsuccessfulPostHandler() throws Exception {    String path = "/testUnsuccessfulPostHandler";    boolean[] didRun = {false};    Handler h = new TestHandler(path, () -> {      didRun[0] = true;      throw new GripServerException("Expected");    });    instance.addHandler(h);    HttpResponse response = doPost(path, path.getBytes(StandardCharsets.UTF_8));    assertEquals("Server should return an internal error (500)",        500,        response.getStatusLine().getStatusCode());    assertTrue("Handler should have run", didRun[0]);  }
@Test    void get6Test() {        assertEquals(6, (int) instance.get6().orElseThrow(NoSuchElementException::new));    }
@Test  public void testParse() {    assertEquals(orderByNameAsc, SortCriterionImpl.parse("name:ASC"));    assertEquals(orderByDateDesc, SortCriterionImpl.parse("date:DESC"));  }
@Test  public void testHandleRequest__InvalidField() {    Request request = createNiceMock(Request.class);    ResourceInstance resource = createNiceMock(ResourceInstance.class);    Query query = createStrictMock(Query.class);    Map<String, TemporalInfo> mapPartialResponseFields = new HashMap<String, TemporalInfo>();    mapPartialResponseFields.put("foo/bar", null);    Renderer renderer = new DefaultRenderer();    expect(request.getResource()).andReturn(resource);    expect(request.getFields()).andReturn(mapPartialResponseFields);    expect(request.getRenderer()).andReturn(renderer);    expect(resource.getQuery()).andReturn(query);    query.setPageRequest(null);    query.setSortRequest(null);    query.setRenderer(renderer);    query.addProperty("foo/bar", null);    expectLastCall().andThrow(new IllegalArgumentException("testMsg"));    replay(request, resource, query);    ReadHandler handler = new ReadHandler();    Result result = handler.handleRequest(request);    assertEquals(ResultStatus.STATUS.BAD_REQUEST, result.getStatus().getStatus());    assertEquals("testMsg", result.getStatus().getMessage());    verify(request, resource, query);  }
@Test  public void invokingRPopLPushCreatesNewSpan() {    commandCreatesNewSpan(RedisCommand.RPOPLPUSH,        () -> getConnection().rPopLPush("src".getBytes(), "dst".getBytes()));    verify(mockRedisConnection()).rPopLPush("src".getBytes(), "dst".getBytes());  }
@Test    public void testEncode() {        assertArrayEquals(                new byte[] { (byte) 0xc2, (byte) 0xa1 },                StringObservable.encode(Observable.just("\u00A1"), "UTF-8").toBlockingObservable().single());    }
@Test  public void testMergeAclEntriesAutomaticDefaultGroup() throws AclException {    List<AclEntry> existing = new ImmutableList.Builder<AclEntry>()      .add(aclEntry(ACCESS, USER, ALL))      .add(aclEntry(ACCESS, GROUP, READ))      .add(aclEntry(ACCESS, OTHER, READ))      .build();    List<AclEntry> aclSpec = Lists.newArrayList(      aclEntry(DEFAULT, USER, READ_EXECUTE),      aclEntry(DEFAULT, OTHER, READ));    List<AclEntry> expected = new ImmutableList.Builder<AclEntry>()      .add(aclEntry(ACCESS, USER, ALL))      .add(aclEntry(ACCESS, GROUP, READ))      .add(aclEntry(ACCESS, OTHER, READ))      .add(aclEntry(DEFAULT, USER, READ_EXECUTE))      .add(aclEntry(DEFAULT, GROUP, READ))      .add(aclEntry(DEFAULT, OTHER, READ))      .build();    assertEquals(expected, mergeAclEntries(existing, aclSpec));  }
@Test  public void testWriteFully() throws IOException {    final int INPUT_BUFFER_LEN = 10000;    final int HALFWAY = 1 + (INPUT_BUFFER_LEN / 2);    byte[] input = new byte[INPUT_BUFFER_LEN];    for (int i = 0; i < input.length; i++) {      input[i] = (byte)(i & 0xff);    }    byte[] output = new byte[input.length];        try {      RandomAccessFile raf = new RandomAccessFile(TEST_FILE_NAME, "rw");      FileChannel fc = raf.getChannel();      ByteBuffer buf = ByteBuffer.wrap(input);      IOUtils.writeFully(fc, buf);      raf.seek(0);      raf.read(output);      for (int i = 0; i < input.length; i++) {        assertEquals(input[i], output[i]);      }      buf.rewind();      IOUtils.writeFully(fc, buf, HALFWAY);      for (int i = 0; i < HALFWAY; i++) {        assertEquals(input[i], output[i]);      }      raf.seek(0);      raf.read(output);      for (int i = HALFWAY; i < input.length; i++) {        assertEquals(input[i - HALFWAY], output[i]);      }      raf.close();    } finally {      File f = new File(TEST_FILE_NAME);      if (f.exists()) {        f.delete();      }    }  }
@Test     public void get_public() {    	ObjectMap objmap = new ObjectMap(new ObjGet());    	assertEquals("pub field value", objmap.get("field_pub"));    }
@Test	public void testDegenerateRepetition() {		assertEquals(toAtomList(1, 2, 3), toAtomList(p.parse("(1 2 3)")));	}
@Test    public void buildShouldCallThroughToShareIntentBuilder() {        Intent intent = streamBuilder.build();        verify(builder).build();        assertThat(intent).isSameAs(dummyIntent);    }
@Test    public void testConnectionTokens2() throws Exception {        // Use HTTP 1.1        final HttpResponse response = new BasicHttpResponse(200, "OK");        response.addHeader("Transfer-Encoding", "chunked");        response.addHeader("Connection", "yadda, kEEP-alive, dumdy");        Assert.assertTrue(reuseStrategy.keepAlive(null, response, context));    }
@Test  public void testGetBasePrecedence() {    assertEquals(1, new OrOperator(1).getBasePrecedence());  }
@Test	public void parserLongList() throws IOException, JsonFormatException {		String json = "[0,null,2,3,4]";		JsonPullParser parser = JsonPullParser.newParser(json);		List<Long> list = JsonParseUtil.parserLongList(parser);		assertThat(list.size(), is(5));		assertThat(list.get(0), is(0L));		assertThat(list.get(1), nullValue());		assertThat(list.get(2), is(2L));		assertThat(list.get(3), is(3L));		assertThat(list.get(4), is(4L));	}
@Test    public void testDoesntHavekeyword() throws Exception {        boolean result = writableThesaurus.hasKeyword("http://test.com/keywords#testKeyword");        assertFalse(result);    }
@Test(expected = NullPointerException.class)    public void pushNull() {        stack.push(null);    }
@Test  public void testNullCheckGetEntityTimelines() throws Exception {    try {      store.getEntityTimelines("YARN_APPLICATION", null, null, null, null,          null);    } catch (NullPointerException e) {      Assert.fail("NPE when getEntityTimelines called with Null EntityIds");    }  }
@Test    public void testUpdateFramework() throws Exception {        Bundle bundle = Mockito.mock(Bundle.class);        Mockito.when(context.getBundle(0)).thenReturn(bundle);        mbean.restartFramework();        Mockito.verify(bundle).update();    }
@Test	 public void shouldBeAbleToConvertEmpty() {	 assertThat(converter.convert("", BigDecimal.class, bundle), is(nullValue()));	 }
@Test    public void testDelete() {        workflowResource.delete("w123", true);        verify(mockWorkflowService, times(1)).deleteWorkflow(anyString(), anyBoolean());    }
@Test    void testTableWithTwoInds() throws AlgorithmExecutionException {        // GIVEN        Attribute attributeA = new Attribute(new ColumnIdentifier(TABLE_NAME, "a"), Range.closed("1", "3"));        Attribute attributeB = new Attribute(new ColumnIdentifier(TABLE_NAME, "b"), Range.closed("2", "4"));        Attribute attributeC = new Attribute(new ColumnIdentifier(TABLE_NAME, "c"), Range.closed("1", "4"));        ImmutableList<Attribute> attributes = ImmutableList.of(attributeA, attributeB, attributeC);        TableInfo tableInfo = new TableInfo(TABLE_NAME, attributes);        InclusionDependency indAC = toInd(attributeA.getColumnIdentifier(), attributeC.getColumnIdentifier());        InclusionDependency indBC = toInd(attributeB.getColumnIdentifier(), attributeC.getColumnIdentifier());        ImmutableSet<InclusionDependency> validInds = ImmutableSet.of(indAC, indBC);        when(dataAccessObject.isValidUIND(any(InclusionDependency.class)))                .thenAnswer(invocation -> validInds.contains(invocation.<InclusionDependency>getArgument(0)));        // WHEN        when(dataAccessObject.getTableInfo(TABLE_NAME)).thenReturn(tableInfo);        bellBrockhausen.execute();        // THEN        assertThat(resultReceiver.getReceivedResults()).containsExactlyInAnyOrder(toArray(validInds));    }
@Test  public void getArrayType() throws Exception {    assertEquals(BasicType.VEC4, arrayConstructor.getArrayType().getBaseType());  }
@Test	public void findElement_element_nested() throws Exception {		DomSelector selector = new DomSelector(SelectorType.CLASS_NAME, "child", new DomSelector(SelectorType.ID,				"main"));		assertThat(selector.findElement(defaultContentElement), is(childElement));	}
@Test  public void shouldGetRunStates() throws Exception {    RunState runState = RunState.create(        INSTANCE, State.QUEUED, StateData.zero(), NOW.minusMillis(1), 17);    Map<WorkflowInstance, RunState> states = Maps.newConcurrentMap();    states.put(INSTANCE, runState);    when(storage.readActiveStates()).thenReturn(states);    Map<WorkflowInstance, RunState> returnedRunStates = stateManager.getActiveStates();    assertThat(returnedRunStates.get(INSTANCE), is(runState));    assertThat(returnedRunStates.size(), is(1));  }
@Test(expected = ExecutorManagerException.class)  public void testInvalidIntegerParam() throws ExecutorManagerException {    final Map<String, String> params = new HashMap<>();    params.put("param1", "1dff2");    HttpRequestUtils.validateIntegerParam(params, "param1");  }
@Test    void testOfTwoList() {        final Set<List<String>> actual = Combination.of(Arrays.asList("a", "b"))            .collect(toSet());        final Set<List<String>> expected = new HashSet<>(asList(            singletonList("a"),            singletonList("b"),            asList("a", "b")        ));        assertEquals(expected, actual);    }
@Test    public void testToAttachment() {        Attachment attachment = card.toAttachment();        Assert.assertNotNull(attachment);        Assert.assertEquals("application/vnd.microsoft.card.video", attachment.getContentType());    }
@Test  public void atan_null_value() {    FunctionExpression atan = dsl.atan(DSL.ref(DOUBLE_TYPE_NULL_VALUE_FIELD, DOUBLE));    assertEquals(DOUBLE, atan.type());    assertTrue(atan.valueOf(valueEnv()).isNull());    atan = dsl.atan(DSL.ref(DOUBLE_TYPE_NULL_VALUE_FIELD, DOUBLE), DSL.literal(1));    assertEquals(DOUBLE, atan.type());    assertTrue(atan.valueOf(valueEnv()).isNull());    atan = dsl.atan(DSL.literal(1), DSL.ref(DOUBLE_TYPE_NULL_VALUE_FIELD, DOUBLE));    assertEquals(DOUBLE, atan.type());    assertTrue(atan.valueOf(valueEnv()).isNull());    atan = dsl.atan(DSL.ref(DOUBLE_TYPE_NULL_VALUE_FIELD, DOUBLE),        DSL.ref(DOUBLE_TYPE_NULL_VALUE_FIELD, DOUBLE));    assertEquals(DOUBLE, atan.type());    assertTrue(atan.valueOf(valueEnv()).isNull());  }
@Test    public void testDehyphenizationWithLayoutTokens() throws Exception {        List<String> tokens = GrobidAnalyzer.getInstance().tokenize("This is hype-\n nized.");        List<LayoutToken> layoutTokens = new ArrayList<>();        for (String token : tokens) {            if (token.equals("\n")) {                layoutTokens.get(layoutTokens.size() - 1).setNewLineAfter(true);            }            layoutTokens.add(new LayoutToken(token));        }        List<LayoutToken> output = TextUtilities.dehyphenize(layoutTokens);        assertNotNull(output);        assertThat(LayoutTokensUtil.toText(output), is("This is hypenized."));    }
@Test    public void should_handle_pong() throws Exception {        FutureCallbackAdapter<CoapPacket> resp = new FutureCallbackAdapter<>();        tcpMessaging.ping(LOCAL_1_5683, resp);        receive(newCoapPacket(LOCAL_1_5683).code(Code.C703_PONG));        assertEquals(Code.C703_PONG, resp.get().getCode());    }
@Test    public void testAllFailed() {        List<ListenableFuture<Boolean>> responses = Lists.newArrayList(Futures.<Boolean> immediateFailedFuture(new Exception()), Futures.<Boolean> immediateFailedFuture(new Exception()), Futures.<Boolean> immediateFailedFuture(new Exception()));        ListenableFuture<Boolean> collector = majorityResponse(responses, Identity);        assertFalse(Futures.getUnchecked(collector));    }
@Test(timeout=120000)  public void testRandomLong() throws Exception {    OsSecureRandom random = getOsSecureRandom();        long rand1 = random.nextLong();    long rand2 = random.nextLong();    while (rand1 == rand2) {      rand2 = random.nextLong();    }    random.close();  }
@Test    void testFind() {        final Meta meta = metaService.create(createProperties("FEED1"));        metaService.addAttributes(meta, createAttributes());        ExpressionOperator expression = new ExpressionOperator.Builder()                .addTerm(MetaFields.ID, Condition.EQUALS, meta.getId())                .addTerm(MetaFields.CREATE_TIME, Condition.EQUALS, DateUtil.createNormalDateTimeString(meta.getCreateMs()))                .build();        FindMetaCriteria criteria = new FindMetaCriteria(expression);        assertThat(metaService.find(criteria).size()).isEqualTo(1);        expression = new ExpressionOperator.Builder()                .addTerm(MetaFields.ID, Condition.EQUALS, meta.getId())                .addTerm(MetaFields.CREATE_TIME, Condition.EQUALS, DateUtil.createNormalDateTimeString(0L))                .build();        criteria = new FindMetaCriteria(expression);        assertThat(metaService.find(criteria).size()).isEqualTo(0);        expression = new ExpressionOperator.Builder()                .addTerm(MetaFields.ID, Condition.EQUALS, meta.getId())                .addTerm(MetaFields.FILE_SIZE, Condition.GREATER_THAN, 0)                .build();        criteria = new FindMetaCriteria(expression);        assertThat(metaService.find(criteria).size()).isEqualTo(1);        expression = new ExpressionOperator.Builder()                .addTerm(MetaFields.ID, Condition.EQUALS, meta.getId())                .addTerm(MetaFields.FILE_SIZE.getName(), Condition.BETWEEN, "0,1000000")                .build();        criteria = new FindMetaCriteria(expression);        assertThat(metaService.find(criteria).size()).isEqualTo(1);    }
@Test    public void doAction_allProperties() throws PersistenceException, ValueFormatException, VersionException, LockException,            ConstraintViolationException, RepositoryException {        ReplaceResourcePropertyValues action = new ReplaceResourcePropertyValues(OLD_VAL, NEW_VAL, Arrays.asList());        String result = action.doAction(resource);        assertEquals("Updated values from " + OLD_VAL + " to " + NEW_VAL + " in " + PATH, result);        verify(prop1, times(1)).setValue("val1_newVal_suffix");        verify(prop2, never()).setValue(Mockito.anyString());        verify(prop3, times(1)).setValue(Mockito.any(Value[].class));        verify(prop4, never()).setValue(Mockito.anyString());    }
@Test    void recommendWrongAmount() {        final LoanImpl mockedLoan = LoanDescriptorTest.mockLoan();        final LoanDescriptor ld = new LoanDescriptor(mockedLoan);        final Optional<RecommendedLoan> r = ld.recommend(mockedLoan.getNonReservedRemainingInvestment()            .add(1));        assertThat(r).isEmpty();    }
@Test	public void testCompare4()	{		Range r1 = new Range(new Position(1, 0), new Position(0, 0));		Range r2 = new Range(new Position(0, 0), new Position(0, 0));		assertTrue(r1.compareTo(r2) > 0);	}
@Test  public void testViewPart() {    int[] offset = {1, 1};    int[] size = {2, 1};    Matrix view = test.viewPart(offset, size);    for (int row = 0; row < view.rowSize(); row++) {      for (int col = 0; col < view.columnSize(); col++) {        assertEquals("value[" + row + "][" + col + ']',            values[row + 2][col + 2], view.getQuick(row, col), EPSILON);      }    }  }
@Test	public void cacheNegativeTimeToLive() {		assertThat(builder.build().cacheNegativeTimeToLive()).isEqualTo(DEFAULT_CACHE_NEGATIVE_TIME_TO_LIVE);		Duration cacheNegativeTimeToLive = Duration.ofSeconds(5);		builder.cacheNegativeTimeToLive(cacheNegativeTimeToLive);		assertThat(builder.build().cacheNegativeTimeToLive()).isEqualTo(cacheNegativeTimeToLive);	}
@Test  void shouldParsePlainBuildGradle() {    URL gradleInitial = GradleInfoReaderTest.class.getClassLoader().getResource(GRADLE_INITIAL);    File file = Urls.toFile(gradleInitial);    Path root = file.toPath().getParent();    BuildInfo info = new GradleInfoReader().getInfo(root);    assertNotNull(info);    assertEquals("gradle-initial", info.getName());    assertEquals("jar", info.getPackaging());    assertEquals("latest", info.getVersion());  }
@Test    void buildBundleWithDependency() {        Policy policy = new Policy();        policy.setName("from-file");        when(entityLoaderRegistry.getEntityLoaders()).thenReturn(Collections.singleton(new TestPolicyLoader(policy)));        List<DependentBundle> dummyList = new ArrayList<>();        dummyList.add(new DependentBundle(new File("test.bundle")));        Bundle dependencyBundle = new Bundle();        when(bundleCache.getBundleFromFile(any(File.class))).thenReturn(dependencyBundle);        BundleFileBuilder bundleFileBuilder = Mockito.spy(new BundleFileBuilder(documentTools, documentFileUtils,                jsonFileUtils, entityLoaderRegistry, bundleEntityBuilder, bundleCache));        bundleFileBuilder.buildBundle(new File("input"), new File("output"), dummyList, projectInfo);        Assert.assertNotNull(dependencyBundle.getDependentBundleFrom());    }
@Test public void prefixes3() {        // Some URIs without prefixes.        String data = StrUtils.strjoinNL            ("@prefix : <http://example/> ." ,             "" ,             "<http://other/s1> :p :x1 ."             ) ;        Graph graph1 = create(data) ;        PrefixMapping pmap = PrefixMappingUtils.calcInUsePrefixMapping(graph1) ;        PrefixMapping pmapExpected = new PrefixMappingImpl() ;        pmapExpected.setNsPrefix("", "http://example/") ;        Assert.assertTrue(sameMapping(pmapExpected, pmap)) ;    }
@Test    public void testSearchWorkflowsByTasks() {        workflowResource.searchWorkflowsByTasks(0, 100, "asc", "*", "*");        verify(mockWorkflowService, times(1)).searchWorkflowsByTasks(anyInt(), anyInt(),                anyString(), anyString(), anyString());    }
@Test    public void shouldHandleAJsonProcessingException() throws Exception {        final JsonProcessingException jsonProcessingException = new JsonGenerationException("Ooops");        final String actionName = "example.action-name";        final Optional<MediaType> mediaType = of(new MediaType("application/vnd.example.action-name+json"));        final JsonEnvelope jsonEnvelope = mock(JsonEnvelope.class);        final JsonValue payload = mock(JsonValue.class);        when(jsonEnvelope.payload()).thenReturn(payload);        when(objectMapper.writeValueAsString(payload)).thenThrow(jsonProcessingException);        envelopeValidator.validate(jsonEnvelope, actionName, mediaType);        verify(envelopeValidationExceptionHandler).handle(exceptionArgumentCaptor.capture());        final EnvelopeValidationException envelopeValidationException = exceptionArgumentCaptor.getValue();        assertThat(envelopeValidationException.getMessage(), is("Error serialising json."));        assertThat(envelopeValidationException.getCause(), is(jsonProcessingException));        verifyZeroInteractions(jsonSchemaValidator);    }
@Test    void shouldPrepareToCloseChannel()    {        protocol.prepareToCloseChannel( channel );        assertThat( channel.outboundMessages(), hasSize( 1 ) );        assertThat( channel.outboundMessages().poll(), instanceOf( GoodbyeMessage.class ) );        assertEquals( 1, messageDispatcher.queuedHandlersCount() );    }
@Test(expected = WebApplicationException.class)        public void testGetBindingDetailJSON_NULL() {                System.out.println("getBindingDetailJSON_NULL");                String id = UUID.randomUUID().toString();                BindingTemplate expResult = null;                BindingTemplate result = instance.getBindingDetailJSON(id);        }
@Test    @SuppressWarnings("rawtypes")    void testToArray() {        final Map.Entry[] expected = refStream().toArray(Map.Entry[]::new);        final Map.Entry[] actual = instance.toArray(Map.Entry[]::new);        assertArrayEquals(expected, actual);    }
@Test  public void archiveWorkflowsWithActionsWorks() {    List<Long> workflowIds = new ArrayList<>();    List<Long> actionIds = new ArrayList<>();    storeActions(storeActiveWorkflow(archiveTime1), 3);    storeActions(storeActiveWorkflow(prodTime1), 1);    storeActions(storePassiveWorkflow(prodTime1), 2);    long archivable1 = storePassiveWorkflow(archiveTime1);    long archivable2 = storePassiveWorkflow(archiveTime2);    actionIds.addAll(storeActions(archivable1, 1));    actionIds.addAll(storeActions(archivable2, 3));    workflowIds.addAll(asList(archivable1, archivable2));    int actionCountBefore = getActiveActionCount();    assertEquals(workflowIds.size(), maintenanceDao.archiveWorkflows(workflowIds));    int actionCountAfter = getActiveActionCount();    assertActiveWorkflowsRemoved(workflowIds);    assertArchiveWorkflowsExist(workflowIds);    assertActiveActionsRemoved(actionIds);    assertArchiveActionsExist(actionIds, true);    assertEquals(actionIds.size(), getArchiveActionCount());    assertEquals(actionCountAfter, actionCountBefore - actionIds.size());  }
@Test  public void shouldHandleCustomerValidatedEvent() {    given().      eventHandlers(accountEventHandlers.domainEventHandlers()).    when().      aggregate("net.chrisrichardson.bankingexample.customerservice.backend.Customer", customerId).      publishes(new CustomerValidatedEvent(accountId)).    then().      verify(() -> {        verify(accountService).noteCustomerValidated(accountId);      })    ;  }
@Test    void get6Test() {        assertEquals(6, (int) instance.get6());    }
@Test    public void createDefaultFilterTest() throws IOException {        String expectedXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                + "<filter>\n"                + "  <repositories>\n"                + "    <repository>\n"                + "      <id>default</id>\n"                + "      <filenames>\n"                + "        <includes>\n"                + "          <include>.*</include>\n"                + "        </includes>\n"                + "      </filenames>\n"                + "      <paths>\n"                + "        <includes>\n"                + "          <include>*</include>\n"                + "        </includes>\n"                + "      </paths>\n"                + "      <properties>\n"                + "        <includes>\n"                + "          <include>*</include>\n"                + "        </includes>\n"                + "      </properties>\n"                + "    </repository>\n"                + "  </repositories>\n"                + "</filter>\n";        Repository repos = new Repository();        IncludeExcludeList includeList = new IncludeExcludeList();        includeList.addInclude(".*");        repos.setId("default");        repos.setFilenames(includeList);        IncludeExcludeList il = new IncludeExcludeList();        il.addInclude("*");        repos.setPaths(il);        il = new IncludeExcludeList();        il.addInclude("*");        repos.setProperties(il);        Repositories repositories = new Repositories();        repositories.addRepository(repos);        Filter filter = new Filter();        filter.setRepositories(repositories);        assertEquals(FilterFile.toString(filter), expectedXML);    }
@Test	public void testApply2() {		ConcatFunction concatFunction = new ConcatFunction();		String actualString = concatFunction.apply(			new String[] {"liferay", null, "forms"});		Assert.assertEquals("liferayforms", actualString);	}
@Test    public void loadsConfigurationClass() {        Model model = Model.assembler()                .addImport(getClass().getResource("sources/a.smithy"))                .assemble()                .unwrap();        MockManifest manifest = new MockManifest();        PluginContext context = PluginContext.builder()                .settings(Node.objectNode()                                  .withMember("foo", "hello")                                  .withMember("bar", 10)                                  .withMember("baz", true))                .fileManifest(manifest)                .model(model)                .originalModel(model)                .build();        new Configurable().execute(context);        String manifestString = manifest.getFileString("Config").get();        assertThat(manifestString, containsString("hello"));        assertThat(manifestString, containsString("10"));        assertThat(manifestString, containsString("true"));    }
@Test    void testLargeConsensusSubmitMessage() throws SQLException {        var topicMessages = new HashSet<TopicMessage>();        topicMessages.add(topicMessage(1, 6000)); // max 6KiB        topicMessages.add(topicMessage(2, 6000));        topicMessages.add(topicMessage(3, 6000));        topicMessages.add(topicMessage(4, 6000));        topicMessagePgCopy.copy(topicMessages, dataSource.getConnection());        assertThat(topicMessageRepository.findAll()).hasSize(4).containsExactlyInAnyOrderElementsOf(topicMessages);    }
@Test    public void v6SchemaJsonIdIsRecognized() {        SchemaClient client = mock(SchemaClient.class);        ByteArrayInputStream retval = new ByteArrayInputStream("{}".getBytes());        when(client.get("http://example.org/schema/schema.json")).thenReturn(retval);        v6Loader()                .schemaJson(get("schemaWithIdV6"))                .schemaClient(client)                .build().load();    }
@Test    public void makeWithoutObservedListThrowsException() {        mThrown.expect(IllegalStateException.class);        mThrown.expectMessage("Must have a list to modify.");        mConverter.make(mAdvertisement);    }
@Test(expected = SDKNoResponseException.class)    public void shouldThrowExceptionWhenServerReturnsNoResponseForExecuteRequestWithClass() {        given(httpClient.sendRequest(anyString(), any(Request.class))).willReturn("");        this.baseClient.executeRequest(new Request(HttpMethod.GET, ANY_URI_STRING), Object.class);    }
@Test    public void returnsMembers() {        StructureShape shape = StructureShape.builder()                .id("ns.foo#bar")                .addMember("foo", ShapeId.from("ns.foo#bam"))                .addMember("baz", ShapeId.from("ns.foo#bam"))                .build();        assertThat(shape.members(), hasSize(2));        // Members are ordered.        assertThat(shape.members(), contains(shape.getMember("foo").get(), shape.getMember("baz").get()));        assertThat(shape.getAllMembers().keySet(), contains("foo", "baz"));    }
@Test	public void testItemSelectorURLWhenNotAllowBrowseAndValidWikiPage()		throws Exception {		setAllowBrowseDocuments(false);		setWikiPageResourcePrimKey(1);		JSONObject originalJSONObject =			getJSONObjectWithDefaultItemSelectorURL();		JSONObject jsonObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		WikiAttachmentImageCreoleEditorConfigContributor			wikiAttachmentImageCreoleEditorConfigContributor =				new WikiAttachmentImageCreoleEditorConfigContributor();		wikiAttachmentImageCreoleEditorConfigContributor.setItemSelector(			_itemSelector);		wikiAttachmentImageCreoleEditorConfigContributor.			populateConfigJSONObject(				jsonObject, _inputEditorTaglibAttributes, null, null);		JSONObject expectedJSONObject = JSONFactoryUtil.createJSONObject(			originalJSONObject.toJSONString());		expectedJSONObject.put("removePlugins", "plugin1");		JSONAssert.assertEquals(			expectedJSONObject.toJSONString(), jsonObject.toJSONString(), true);	}
@Test    public void testToBaseMessageIdStringWithString() {        String stringMessageId = "myIdString";        String baseMessageIdString = messageIdHelper.toBaseMessageIdString(stringMessageId);        assertNotNull("null string should not have been returned", baseMessageIdString);        assertEquals("expected base id string was not returned", stringMessageId, baseMessageIdString);    }
@Test(invocationCount = 10)	public void add() {		final Random random = new Random();		final List<Vec<double[]>> elements = new ArrayList<>();		final ParetoFront<Vec<double[]>> set = new ParetoFront<>(Vec::dominance);		for (int i = 0; i < 500; ++i) {			final Vec<double[]> point = circle(random);			elements.add(point);			set.add(point);			Assert.assertEquals(				new HashSet<>(set),				new HashSet<>(Pareto.front(ISeq.of(elements)).asList())			);		}	}
@Test	public void testApplicationTemplateBinding_5() throws Exception {		ApplicationTemplate app = new ApplicationTemplate( "my application" );		app.setExternalExportsPrefix( "test" );		ObjectMapper mapper = JSonBindingUtils.createObjectMapper();		StringWriter writer = new StringWriter();		mapper.writeValue( writer, app );		String s = writer.toString();		ApplicationTemplate readApp = mapper.readValue( s, ApplicationTemplate.class );		Assert.assertEquals( app, readApp );		Assert.assertEquals( app.getName(), readApp.getName());		Assert.assertEquals( app.getDescription(), readApp.getDescription());		Assert.assertEquals( app.getVersion(), readApp.getVersion());		Assert.assertEquals( app.getExternalExportsPrefix(), readApp.getExternalExportsPrefix());		Assert.assertEquals( app.getTags(), readApp.getTags());	}
@Test    public void testFilterPassesVariantEvaluationWithAllFrequenciesUnderThreshold() {        VariantEvaluation variantEvaluation = makeVariantEvaluation(                passFrequency(FrequencySource.ESP_ALL),                passFrequency(FrequencySource.THOUSAND_GENOMES)        );        assertThat(instance.runFilter(variantEvaluation), equalTo(PASS_FREQUENCY_FILTER_RESULT));    }
@Test    public void test09() {        List<String> expectedResult = new ArrayList<String>();        expectedResult.add("1b3");        expectedResult.add("1b4");        expectedResult.add("1b9");        expectedResult.add("2b3");        expectedResult.add("2b4");        expectedResult.add("2b9");        final List<String> result = new ArrayList<>();        new RangeExpressionParser("[1..2]b[3..4,9]").visit(new RangeExpressionItemVisitor() {            @Override            public void visit(Object val) {                result.add((String) val);                // System.out.println(val);            }        });        Assert.equals(result, expectedResult);    }
@Test	public void testClone() {		GoalStatus clone = g1.clone();		assertEquals(g1.toString(), clone.toString());		assertEquals(g1.toJsonObject(), clone.toJsonObject());		assertEquals(g1.getMessageType(), clone.getMessageType());		assertEquals(g1.getGoalID(), clone.getGoalID());		assertEquals(g1.getStatus(), clone.getStatus());		assertEquals(g1.getText(), clone.getText());		assertNotSame(g1, clone);		assertNotSame(g1.toString(), clone.toString());		assertNotSame(g1.toJsonObject(), clone.toJsonObject());	}
@Test    public void test_isAuthorized_failure_400() {        UserDetails userDetails = getMockUser(false);        String path = "users/safe1";        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Invalid path specified\"]}");        when(ControllerUtil.isPathValid(path)).thenReturn(false);        ResponseEntity<String> responseEntity = selfSupportService.isAuthorized(userDetails, path);        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());        assertEquals(responseEntityExpected, responseEntity);    }
@Test    public void should_import_zip_file() throws Exception {        ImportReport expectedReport = anImportReportFor(aPage()).withStatus(IMPORTED).build();        when(importer.doImport(aMockedImport())).thenReturn(expectedReport);        ImportReport report = pathImporter.importFromPath(unzipedPath, importer);        assertThat(expectedReport).isEqualTo(report);    }
@Test(expected = WorkflowOperationException.class)  public void testUserNoEmail() throws Exception {    operation.setConfiguration(EmailWorkflowOperationHandler.TO_PROPERTY, USER_NAME_NO_EMAIL);    operation.setConfiguration(EmailWorkflowOperationHandler.CC_PROPERTY, USER_NAME_NO_EMAIL);    operation.setConfiguration(EmailWorkflowOperationHandler.BCC_PROPERTY, USER_NAME_NO_EMAIL);    operation.setConfiguration(EmailWorkflowOperationHandler.SUBJECT_PROPERTY, DEFAULT_SUBJECT);    operation.setConfiguration(EmailWorkflowOperationHandler.BODY_PROPERTY,            "This is the media package: ${mediaPackage.identifier}");    WorkflowOperationResult result = operationHandler.start(workflowInstance, null);    Assert.assertEquals(Action.CONTINUE, result.getAction());    Assert.assertEquals(DEFAULT_TO, capturedTo.getValue());    Assert.assertEquals(DEFAULT_TO, capturedCC.getValue());    Assert.assertEquals(DEFAULT_TO, capturedBCC.getValue());    Assert.assertEquals(DEFAULT_SUBJECT, capturedSubject.getValue());    Assert.assertEquals("This is the media package: 3e7bb56d-2fcc-4efe-9f0e-d6e56422f557", capturedBody.getValue());  }
@Test    public void testExecute03() throws Exception {        // 事前準備        RuntimeException re = new RuntimeException("test");        when(blogic.execute(blogicParam)).thenThrow(re);        // テスト実施        BLogicResult result = target.execute(applicationContext, blogic,                blogicParam, null);        // 結果検証        assertEquals(255, result.getBlogicStatus());        assertEquals(re, result.getBlogicThrowable());        assertEquals(0, tga.size());        assertThat(logger.getLoggingEvents(), is(asList(                debug("[DAL025044] The BLogic detail is as follow. BLogic-class:" + blogic.getClass().getName() + ", " + blogicParam.toString()),                error(re, "[EAL025057] An exception occurred at BLogic execution. This error log should be logged by the exception-handler, but the handler is not set."))));    }
@Test    public void testGetMandatoryStringValue() {        configuration.put("the.key", "the.value");        assertEquals("the.value", configuration.getMandatoryStringValue("the.key", "the.default"));        assertEquals("the.default", configuration.getMandatoryStringValue("no.key", "the.default"));    }
@Test	public void checkDateGetter() {		ApplicationContextBean bean = new ApplicationContextBean();		Date date = new Date();		bean.lastModified = date;		Assert.assertNotSame( date, bean.getLastModified());		Assert.assertEquals( date, bean.getLastModified());	}
@Test	public void crossoverAll1() {		final CharSeq chars = CharSeq.of("a-zA-Z");		final ISeq<CharacterGene> g1 = ISeq.of(CharacterChromosome.of(chars, 20));		final ISeq<CharacterGene> g2 = ISeq.of(CharacterChromosome.of(chars, 20));		final MultiPointCrossover<CharacterGene, Double> crossover =				new MultiPointCrossover<>(2000);		final int[] points = new int[g1.length()];		for (int i = 0; i < points.length; ++i) {			points[i] = i;		}		final MSeq<CharacterGene> ms1 = g1.copy();		final MSeq<CharacterGene> ms2 = g2.copy();		crossover.crossover(ms1, ms2);	}
@Test    public void testEncodedValue() throws Exception {        SofaTracerSpanContext spanContext = SofaTracerSpanContext.rootStart();        Map<String, String> baggage = new HashMap<String, String>();        baggage.put("key", "value");        baggage.put("key1", "value1");        baggage.put("key2", "value2");        spanContext.addBizBaggage(baggage);        //        final TextMap carrier = new TextMap() {            Map<String, String> carr = new HashMap<String, String>();            @Override            public Iterator<Map.Entry<String, String>> iterator() {                return carr.entrySet().iterator();            }            @Override            public void put(String key, String value) {                carr.put(key, value);            }            @Override            public String toString() {                return "$classname{" + "carr=" + carr + '}';            }        };        this.registryExtractorInjector.inject(spanContext, carrier);        //carrier        SofaTracerSpanContext extractContext = this.registryExtractorInjector.extract(carrier);        //traceId spanId sampled        extractContext.equals(spanContext);        assertTrue("Extract : " + extractContext, baggage.equals(extractContext.getBizBaggage()));    }
@Test  public void refreshesAsynchronously() throws Throwable {    // Initial load    var initialValue = sut.get();    assertThat(initialValue, is(INITIAL_VALUE));    verify(delegate).get();    // Set up reload to block    var reloadFuture = new CompletableFuture<Integer>();    when(delegate.get()).then(a -> reloadFuture.join());    // Progress time enough to exceed timeout    now = now.plus(TIMEOUT).plusSeconds(1);    // Trigger refresh - should return old value and not block    var triggerValue = sut.get();    assertThat(triggerValue, is(INITIAL_VALUE));    // Wait for refresh    await().until(() -> Try.of(() -> verify(delegate, times(2)).get()).isSuccess());    // Complete reload    reloadFuture.complete(NEW_VALUE);    // Eventually observe new value    await().until(() -> sut.get() == NEW_VALUE);  }
@Test    public void testActionWithoutCors() throws Exception {        AwsProxyRequest req = new AwsProxyRequestBuilder(requestJsonStream)                .resourcePath("/test_action_without_cors")                .httpMethod("GET")                .build();        AwsProxyResponse res = router.apply(req, mockContext);        assertEquals(200, res.getStatusCode());        assertThat(res.getHeaders(), hasEntry(CONTENT_TYPE, APPLICATION_JSON));        assertThat(res.getHeaders(), is(not((hasKey(ACCESS_CONTROL_ALLOW_ORIGIN)))));        assertThat(res.getHeaders(), is(not((hasKey(ACCESS_CONTROL_ALLOW_CREDENTIALS)))));        assertEquals("\"TestActionWithoutCors\"", res.getBody());        assertFalse(res.isBase64Encoded());    }
@Test    public void testBitActive() {        RecordWindow recordWindow = Windows.bitActive(                new InnerBooleanSupplier()        );        RecordWindow clone = ClonerUtil.clone(recordWindow);        innerTestBitActiver(recordWindow);        innerTestBitActiver(clone);    }
@Test    public void testSingleWithPredicateAndEmpty() {        Observable<Integer> observable = Observable.from(1).single(                new Func1<Integer, Boolean>() {                    @Override                    public Boolean call(Integer t1) {                        return t1 % 2 == 0;                    }                });        @SuppressWarnings("unchecked")        Observer<Integer> observer = (Observer<Integer>) mock(Observer.class);        observable.subscribe(observer);        InOrder inOrder = inOrder(observer);        inOrder.verify(observer, times(1)).onError(                isA(IllegalArgumentException.class));        inOrder.verifyNoMoreInteractions();    }
@Test    void testPrepareIncludeAssertionNoPolicyGuid() {        String policyPath = "my/policy/path.xml";        Policy policy = new Policy();        policy.setGuid("123-abc-567");        bundle.getPolicies().put(policyPath, policy);        Element includeAssertion = document.createElement(INCLUDE);        document.appendChild(includeAssertion);        policyBuilderContext = new PolicyBuilderContext("path.xml", document, bundle, new IdGenerator());        policyBuilderContext.withPolicy(policy);        policyBuilderContext.withAnnotatedBundle(new AnnotatedBundle(bundle, null, null));        assertThrows(EntityBuilderException.class, () -> includeAssertionBuilder.buildAssertionElement(includeAssertion, policyBuilderContext));    }
@Test    public void testMisMatchType() {        class MyParser extends Configurable {            @Field(required = true) int config;        }        Map<String, Param> params = new HashMap<>();        try {            params.put("config", new Param<>("config", 1));            MyParser bean = new MyParser();            AnnotationUtils.assignFieldParams(bean, params);            Assert.assertEquals(bean.config, 1);        } catch (TikaConfigException e) {            e.printStackTrace();            Assert.fail("Exception Not expected");        }        params.clear();        try {            params.put("config", new Param<>("config", "a string value"));            AnnotationUtils.assignFieldParams(new MyParser(), params);            Assert.fail("Exception expected");        } catch (TikaConfigException e) {            //expected        }    }
@Test    public void exportGraphWithoutEdgeLabels() {        String fileNameBase = "build/test-output/test_02";        DotExporter dotExporter = new DotExporter(dependencyGraph, fileNameBase, architecture, new ArrayList<>(), false);        dotExporter.exportGraph();        String graphML = FileSystemUtil.readFileAsText(fileNameBase + ".dot");        assertThat(graphML, notNullValue());        assertThat(graphML, not(containsString("_root_c1 -> _root_c2 [ color = \"#000000\", fontcolor = \"#000000\", penwidth = 3.0, style = dashed , label=\"2\", headlabel=\"1\", taillabel=\"2\"];")));    }
@Test  public void testGetFactById() throws Exception {    UUID id = UUID.randomUUID();    when(getTiService().getFact(any(), isA(GetFactByIdRequest.class))).then(i -> {      assertEquals(id, i.<GetFactByIdRequest>getArgument(1).getId());      return Fact.builder().setId(id).build();    });    Response response = target(String.format("/v1/fact/uuid/%s", id)).request().get();    assertEquals(200, response.getStatus());    assertEquals(id.toString(), getPayload(response).get("id").textValue());    verify(getTiService(), times(1)).getFact(notNull(), isA(GetFactByIdRequest.class));  }
@Test	public void testGetTargetId() {		Assert.assertEquals( Ec2IaasHandler.TARGET_ID, new Ec2IaasHandler().getTargetId());	}
@Test    public void testRelate_polygon_linestring_false() throws FactoryException, MismatchedDimensionException, TransformException {        GeometryWrapper subjectGeometryWrapper = GeometryWrapper.extract(ResourceFactory.createTypedLiteral("<http://www.opengis.net/def/crs/EPSG/0/27700> POLYGON((140 15, 140 45, 200 45, 200 15, 140 15))", WKTDatatype.INSTANCE));        GeometryWrapper objectGeometryWrapper = GeometryWrapper.extract(ResourceFactory.createTypedLiteral("<http://www.opengis.net/def/crs/EPSG/0/27700> LINESTRING(75 60, 145 60)", WKTDatatype.INSTANCE));        EhOverlapFF instance = new EhOverlapFF();        Boolean expResult = false;        Boolean result = instance.relate(subjectGeometryWrapper, objectGeometryWrapper);        assertEquals(expResult, result);    }
@Test    public void testFindUserIdByUserName() throws Exception {        // Arrange        final String id = "id";        final String username = "username";        final SearchResultsWrapperWithId searchResultsMock = mock(SearchResultsWrapperWithId.class);        final IdentifierDto identifier = new IdentifierDto();        identifier.setId(id);        when(searchResultsMock.getResources()).thenReturn(Arrays.asList(identifier));        when(restTemplate.getForObject(usersEndpoint + "?filter=userName eq \"" + username + "\"&attributes=id", SearchResultsWrapperWithId.class)).thenReturn(searchResultsMock);        // Act        final String response = sut.findUserIdByUserName(username);        // Assert        assertEquals(id, response);    }
@Test    void reduce3Arg() {        assertEquals(OTHER_ELEMENT + ELEMENT, instance.reduce(OTHER_ELEMENT, (a, b) -> a + b, (a, b) -> a + b));        assertThrows(IllegalStateException.class, () -> instance.reduce(OTHER_ELEMENT, (a, b) -> a + b, (a, b) -> a + b));    }
@Test  public void undo() throws Exception {  }
@Test  public void testGenerateListener() throws Exception {    ClassicEngineBoot.getInstance().start();    fastStreamHtmlOutput.generate( new MasterReport(), 1, new ByteArrayOutputStream(), 1 );    verify( listener, times( 1 ) ).reportProcessingStarted( any( ReportProgressEvent.class ) );    verify( listener, times( 1 ) ).reportProcessingFinished( any( ReportProgressEvent.class ) );    verify( listener, atLeastOnce() ).reportProcessingUpdate( any( ReportProgressEvent.class ) );  }
@Test	public void getFunctionClassShouldReturnTheOnlyFunction() {		assertEquals(OperatorWithOneFunction.Implementation.class,			new OperatorWithOneFunction().getFunctionClass());	}
@Test  public void testResolveNull() {    assertNull(resolver.apply(null));  }
@Test	public void testLocalRepository() throws Exception {		String url = MavenUtils.findMavenUrlForRoboconf( "roboconf-core", "0.4-SNAPSHOT" );		System.out.println( "Local repository => " + url );		Assert.assertNotNull( url );		Assert.assertTrue( url.startsWith( "file:/" ));	}
@Test    public void deleteMessagingAccount() throws Exception {        testVoidSpec(resource.deleteMessagingAccount(MessagingAccount.SKYPE));    }
@Test    public void shouldInsert() {        DocumentEntity entity = getEntity();        DocumentEntity documentEntity = entityManager.insert(entity);        assertEquals(entity, documentEntity);    }
@Test  public void testRequestValidationFailsOnBlank() {    Set<ConstraintViolation<TraverseByObjectSearchRequest>> violations = getValidator().validate(new TraverseByObjectSearchRequest()            .setQuery(" ")    );    assertEquals(1, violations.size());    assertPropertyInvalid(violations, "query");  }
@Test    public void testHandleShortSyntaxSingleMethodWithParens() {        String line = "add(\"foo\", \"bar\", 1)";        String expected = "concourse.add(\"foo\", \"bar\", 1)";        Assert.assertEquals(expected,                SyntaxTools.handleShortSyntax(line, options()));    }
@Test    public void testAcceptValidType1() {        DefaultValueStandardizer standardizer = new DefaultValueStandardizer("default");        assertTrue(standardizer.accepts("string-value"));    }
@Test  public void testChip() throws ChipOutOfBoundsException, ParseException, InterruptedException {    Boundary mainImage = new Boundary(52.0, 15.0, 100, Math.toRadians(30));    Boundary chip = new Boundary(52.0, 15.0, 10, Math.toRadians(30));    Polygon mainPolygon = createPolygon(mainImage.getBoundary());    Polygon chipPolygon = createPolygon(chip.getBoundary());    BufferedImage result = chipService.chip(inputImage, mainPolygon, chipPolygon);    assertThat(result.getWidth(), is(102));    assertThat(result.getHeight(), is(102));    verify(lock).acquire();    verify(lock).release();  }
@Test	public void testControlCharacters() {		String testString = "\b \t \n \f \r default";		String controlString = StringUtils.showControlCharacters(testString);		assertEquals("\\b \\t \\n \\f \\r default", controlString);	}
@Test  public void test() throws Exception {    InputStream is = new ByteArrayInputStream("abc".getBytes());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    InputStreamEntity i = new InputStreamEntity(is);    i.write(baos);    baos.close();    assertEquals(new String(baos.toByteArray()), "abc");    is = new ByteArrayInputStream("abc".getBytes());    baos = new ByteArrayOutputStream();    i = new InputStreamEntity(is, 1, 1);    i.write(baos);    baos.close();    assertEquals(baos.toByteArray()[0], 'b');  }
@Test	public void testReverseRange() throws Exception {		seq s = makeSeq();		s.reverserange(1, 3);		assertEquals(makeSeq("A", "D", "C", "B", "E"), s);		s.reverserange(4, 3);		assertEquals(makeSeq("A", "D", "C", "E", "B"), s);	}
@Test    public void testExecutePlugin_preserveVarType() throws Exception {        final ListVariable listVar = new ListVariable(Arrays.asList(1, 2, 3));        contextMock.returns(                asList(new KeyValuePair("list", listVar)).iterator()).                iterator();        ReflectionAssert.assertReflectionEquals(listVar, createPlugin(                XmlNodeTestUtils.createXmlNode("<value-of expr='${list}'/>",                XmlNodeTestUtils.NAMESPACE_21),                ValueOfPlugin.class).executePlugin(contextMock.getMock()));    }
@Test    public void test_processCallback_failed() {        String state = "teststatecode";        String code = "testauthcode";        String pathStr = "?code="+code+"&state="+state;        String responseJson = "{\"errors\":[\"Failed to get process callback\"]}";;        Response response = getMockResponse(HttpStatus.BAD_REQUEST, true, responseJson);        when(reqProcessor.process("/auth/oidc/oidc/callback","{\"path\":\""+pathStr+"\"}","")).thenReturn(response);        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseJson);        ResponseEntity<String> responseEntity = oidcAuthService.processOIDCCallback(state, code);        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());        assertEquals(responseEntityExpected, responseEntity);    }
@Test	public void testOnProjectChangedNoOld() {		presenterImpl.presenting = true;		presenterImpl.oldProject = null;		// prep done, test!		Project alt = new Project("alt");		when(view.getProject()).thenReturn(alt);		when(view.getHours()).thenReturn("01:00");		presenterImpl.onProjectChanged();		assertEquals(alt, dayEntry.getProject());		assertEquals("01:00", dayEntry.getHours());		verify(view).getProject();		verify(observer).hoursChanged(alt);		verify(observer, never()).hoursChanged(project);	}
@Test    public void encryptWithDefaultScryptParams() throws CipherException {        byte[] privKey = Numeric.hexStringToByteArray(                "7fe9d4b69f85c1fe15387a76e79d2b95c4c9e3fe756de3435afbc077d99d5346");        String pw = "neo";        String expectedNep2Encrypted = "6PYLykbKcbwnCuTJiQQ5PYu5uH9NgwGYLoMyTUabRxRJUsiA9GP8NgorUV";        ECKeyPair keyPair = ECKeyPair.create(privKey);        assertThat(NEP2.encrypt(pw, keyPair), is(expectedNep2Encrypted));    }
@Test  public void testSetClientIdsIfSpecified_empty() throws Exception {    String[] empty = {};    annotationConfig.setClientIdsIfSpecified(empty);    assertEquals(Collections.emptyList(), config.getClientIds());    String[] clientIds = {"bleh", "more bleh"};    annotationConfig.setClientIdsIfSpecified(clientIds);    annotationConfig.setClientIdsIfSpecified(empty);    assertEquals(Collections.emptyList(), config.getClientIds());  }
@Test    public void testAlbumFetching1YesPreferDownloadCaaErrorFallsBackToLastFM() throws IOException {        /*        hasAlbumArtist = true;        hasUri = true;        isOnline = true        wantAlbumArt = true;        preferDownload = true;        isLocalArt = true;         */        ArtInfo artInfo = ArtInfo.forAlbum("alvvays", "alvvays", Uri.parse("content://test/alvvays.jpg"));        //no to wifi        when(mPreferences.getBoolean(ArtworkPreferences.ONLY_ON_WIFI, true)).thenReturn(false);        //yes were connected        NetworkInfo networkInfo = mock(NetworkInfo.class);        when(networkInfo.isConnectedOrConnecting()).thenReturn(true);        when(mConnectivityManager.getActiveNetworkInfo()).thenReturn(networkInfo);        //no to cache        when(mL2Cache.containsKey(artInfo.cacheKey())).thenReturn(false);        //yes to want        when(mPreferences.getBoolean(ArtworkPreferences.DOWNLOAD_MISSING_ARTWORK, true)).thenReturn(true);        //yes to download        when(mPreferences.getBoolean(ArtworkPreferences.PREFER_DOWNLOAD_ARTWORK, false)).thenReturn(true);        //prep the server        mServer.enqueue(new MockResponse().setBody(IOUtils.toString(getClass().getClassLoader()                .getResourceAsStream("lfm_album_alvvays_alvvays.xml"))));        mServer.enqueue(new MockResponse().setResponseCode(404));        mServer.enqueue(new MockResponse().setBody(new Buffer().readFrom(getClass().getClassLoader()                .getResourceAsStream("alvvays_alvvays_thumb.jpg"))));        mFetcher.fetch(artInfo, mListener);        verify(mListener).onNext(Matchers.<Bitmap>any());        verify(mListener).onCompleted();        verify(mListener, never()).onError(Matchers.<Throwable>any());        assertThat(mFetcher.originalUri).isEqualTo("http://img2-ak.lst.fm/i/u/63ea8d50b43146e7c64414891c20d378.png");        verifyZeroInteractions(mContext);    }
@Test    public void testWriteMultiLineString() {        LineString[] lineStrings = new LineString[2];        lineStrings[0] = GEOMETRY_FACTORY.createLineString(new CustomCoordinateSequence(CoordinateSequenceDimensions.XYZM, "10 10 0 1, 20 20 0 1, 10 40 0 1"));        lineStrings[1] = GEOMETRY_FACTORY.createLineString(new CustomCoordinateSequence(CoordinateSequenceDimensions.XYZM, "40 40 0 1, 30 30 0 1, 40 20 0 1, 30 10 0 1"));        Geometry geometry = GEOMETRY_FACTORY.createMultiLineString(lineStrings);        GeometryWrapper geometryWrapper = new GeometryWrapper(geometry, SRS_URI.WGS84_CRS, WKTDatatype.URI, new DimensionInfo(4, 3, 1));        String expResult = "<" + SRS_URI.WGS84_CRS + "> MULTILINESTRING ZM((10 10 0 1, 20 20 0 1, 10 40 0 1), (40 40 0 1, 30 30 0 1, 40 20 0 1, 30 10 0 1))";        String result = WKTWriter.write(geometryWrapper);        //        //        assertEquals(expResult, result);    }
@Test    public void test_createSafe_failure() {        String token = "5PDrOhsy4ig8L3EpsJZSLAMg";        UserDetails userDetails = getMockUser(false);        SafeBasicDetails safeBasicDetails = new SafeBasicDetails("mysafe01", "youremail@yourcompany.com", null, "My first safe");        Safe safe = new Safe("shared/mysafe01",safeBasicDetails);        ResponseEntity<String> readResponse = ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"You have reached the limit of number of allowed safes that can be created\"]}");        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"You have reached the limit of number of allowed safes that can be created\"]}");        ReflectionTestUtils.setField(selfSupportService, "safeQuota", "2");        when(ControllerUtil.getSafeType("shared/mysafe01")).thenReturn("shared");        String [] policies = {"s_shared_s1, s_shared_s2"};        when(policyUtils.getCurrentPolicies(token, "normaluser", userDetails)).thenReturn(policies);        String [] safes = {"s1", "s2"};        when(safeUtils.getManagedSafes(policies, "shared")).thenReturn(safes);        when(safesService.createSafe(token, safe)).thenReturn(readResponse);        ResponseEntity<String> responseEntity = selfSupportService.createSafe(userDetails, token, safe);        assertEquals(HttpStatus.BAD_REQUEST, responseEntity.getStatusCode());        assertEquals(responseEntityExpected, responseEntity);    }
@Test  public void testSetupAndTearDown() {    mDelayedBuilder.setParent(mConfig);    mDelayedBuilder.setParent(null);    InOrder inOrder = Mockito.inOrder(mBackingBuilder, mConfig, mChildConfig);    inOrder.verify(mBackingBuilder).deepCopy();    inOrder.verify(mBackingBuilder).setParent(mConfig);    inOrder.verify(mBackingBuilder).buildInternal();    inOrder.verify(mChildConfig).setup(mChildMockspresso);    inOrder.verify(mChildConfig).teardown();    verifyNoMoreInteractions(mBackingBuilder, mConfig, mChildConfig);  }
@Test    public void testCallRequest() throws Exception {        final InputStream resource = getClass().getClassLoader().getResourceAsStream("callback-request.json");        final byte[] requestBody = ByteStreams.toByteArray(resource);        MockHttpServletRequest request = new MockHttpServletRequest();        request.addHeader("X-Line-Signature", "SSSSIGNATURE");        request.setContent(requestBody);        doReturn(true).when(lineSignatureValidator).validateSignature(requestBody, "SSSSIGNATURE");        final CallbackRequest callbackRequest = lineBotCallbackRequestParser.handle(request);        assertThat(callbackRequest).isNotNull();        final List<Event> result = callbackRequest.getEvents();        final MessageEvent messageEvent = (MessageEvent) result.get(0);        final TextMessageContent text = (TextMessageContent) messageEvent.getMessage();        assertThat(text.getText()).isEqualTo("Hello, world");        final String followedUserId = messageEvent.getSource().getUserId();        assertThat(followedUserId).isEqualTo("u206d25c2ea6bd87c17655609a1c37cb8");        assertThat(messageEvent.getTimestamp()).isEqualTo(Instant.parse("2016-05-07T13:57:59.859Z"));    }
@Test	public void when_seeds_return_an_error__epic_should_not_fail() {		Observable<RadixNode> seeds = Observable.error(new RuntimeException("BAD EXCEPTION!"));		RadixUniverseConfig universe = mock(RadixUniverseConfig.class);		DiscoverNodesEpic discoverNodesEpic = new DiscoverNodesEpic(seeds, universe);		ReplaySubject<RadixNodeAction> actions = ReplaySubject.create();		Observable<RadixNetworkState> networkState = Observable.just(mock(RadixNetworkState.class));		Observable<RadixNodeAction> output = discoverNodesEpic.epic(actions, networkState);		TestObserver<RadixNodeAction> testObserver = TestObserver.create();		output.subscribe(testObserver);		actions.onNext(DiscoverMoreNodesAction.instance());		testObserver.assertNoErrors();		testObserver.awaitCount(1);		testObserver.assertValue(a -> a instanceof DiscoverMoreNodesErrorAction);	}
@Test    void shouldObtainKeys()    {        // Given        RxResultCursor cursor = mock( RxResultCursorImpl.class );        RxResult rxResult = newRxResult( cursor );        List<String> keys = Arrays.asList( "one", "two", "three" );        when( cursor.keys() ).thenReturn( keys );        // When & Then        StepVerifier.create( Flux.from( rxResult.keys() ) )                .expectNext( Arrays.asList( "one", "two", "three" ) )                .verifyComplete();    }
@Test	public void testNormalizeEmailIdNull(){		String email=null;		String lowercase=stringUtil.normalizeEmail(email);		Assert.assertEquals(lowercase,email);		Assert.assertNull(lowercase);	}
@Test    public void errorTest06() {        try {            new RangeExpressionParser("t00..9]").visit(new RangeExpressionItemVisitor() {                @Override                public void visit(Object val) {                    throw new Error();                }            });            throw new Error();        } catch (RangeExpressionException e) {        }    }
@Test    public void testWrap_StringInt() {        assertNull(Wrap.wrap(null, 20));        assertNull(Wrap.wrap(null, -1));        assertEquals("", Wrap.wrap("", 20));        assertEquals("", Wrap.wrap("", -1));        // normal        final String systemNewLine = System.lineSeparator();        String input = "Here is one line of text that is going to be wrapped after 20 columns.";        String expected = "Here is one line of" + systemNewLine + "text that is going"                + systemNewLine + "to be wrapped after" + systemNewLine + "20 columns.";        assertEquals(expected, Wrap.wrap(input, 20));        // long word at end        input = "Click here to jump to the commons website - https://commons.apache.org";        expected = "Click here to jump" + systemNewLine + "to the commons" + systemNewLine                + "website -" + systemNewLine + "https://commons.apache.org";        assertEquals(expected, Wrap.wrap(input, 20));        // long word in middle        input = "Click here, https://commons.apache.org, to jump to the commons website";        expected = "Click here," + systemNewLine + "https://commons.apache.org," + systemNewLine                + "to jump to the" + systemNewLine + "commons website";        assertEquals(expected, Wrap.wrap(input, 20));        // leading spaces on a new line are stripped        // trailing spaces are not stripped        input = "word1             word2                        word3";        expected = "word1  " + systemNewLine + "word2  " + systemNewLine + "word3";        assertEquals(expected, Wrap.wrap(input, 7));    }
@Test    public void givenCloseButtonIconIsSet_thenCloseButtonIconComposerIsAdded() {        simpleChromeCustomTabsIntentBuilder.withCloseButtonIcon(ANY_ICON);        verify(mockComposers).add(any(CloseButtonIconComposer.class));    }
@Test    public void testCanStop002() {        // テスト実施        // 結果検証        assertFalse(asyncBatchStopper.canStop());        assertThat(logger.getLoggingEvents(), IsNot.not(asList(info(                "[IAL025011] Detected the end file. This AsyncBatchExecutor processing will complete. path:/tmp/batch_terminate_file"))));    }
@Test    public void shouldHaveCorrectTypeIdentifier() throws Exception {        assertThat(this.parameter.getTypeIdentifier( getTransaction() ), is(KomodoType.PARAMETER));    }
@Test	public void testReplacesAnAdaptableImgAfterANonadaptableOne()		throws Exception {		Mockito.when(			_amImageHTMLTagFactory.create(				"<img data-fileentryid=\"1989\" src=\"adaptable\"/>",				_fileEntry)		).thenReturn(			"<whatever></whatever>"		);		Assert.assertEquals(			"<img src=\"not-adaptable\"/><whatever></whatever>",			_htmlContentTransformerImpl.transform(				"<img src=\"not-adaptable\"/>" +					"<img data-fileentryid=\"1989\" src=\"adaptable\"/>"));	}
@Test    public void manageList() {        String key = FULL_CLASS_NAME + "#" + LIST_CLASS_NAME;        collectionEditorSingletonDOMElementFactorySpy.manageList(collectionEditorViewImpl, key, STRING_CLASS_NAME, ScenarioSimulationModel.Type.RULE);        Map<String, String> expectedMap1 = new HashMap<>();        expectedMap1.put(LOWER_CASE_VALUE, STRING_CLASS_NAME);        verify(collectionEditorViewImpl, times(1)).initListStructure(eq(key), eq(expectedMap1), isA(Map.class), eq(ScenarioSimulationModel.Type.RULE));        verify(collectionEditorSingletonDOMElementFactorySpy, times(1)).getExpandablePropertiesMap(eq(STRING_CLASS_NAME));    }
@Test(expected = AccessDeniedException.class)  public void testFetchObjectTypesWithoutPermission() throws Exception {    doThrow(AccessDeniedException.class).when(securityContext).checkPermission(TiFunctionConstants.viewThreatIntelType);    delegate.handle(new SearchObjectTypeRequest());  }
@Test    public void update_failedConnection_immediately_reRegister() throws Exception {        //given        RegistrationManager reg = registered();        trnsport.when(newCoapPacket(2).post().uriPath("/stub/0001"))                .thenThrow(new IOException());        trnsport.when(newCoapPacket(3).post().uriPath("/rd").uriQuery("ep=stub-device-01&lt=100").contFormat(CT_APPLICATION_LINK__FORMAT))                .then(newCoapPacket(3).ack(Code.C201_CREATED).locPath("/stub/0001").maxAge(102));        //when        runScheduledTask();        //then        assertTrue(reg.isRegistered());        verifyScheduledInSec(72L);    }
@Test	public void testRedactDocument_Allergies_Medications_Results_Sections_Hiv_Eth_Redacted()			throws Throwable {		// Arrange		final String problems = NOT_SELECTED;		final String allergies = ALLERGIES_SECTION;		final String medications = MEDICATIONS_SECTION;		final String results = RESULTS_SECTION;		final String hiv = HIV_SELECTED;		final String psy = NOT_SELECTED;		final String eth = ETH_SELECTED;		final String gdis = NOT_SELECTED;		final String sdv = NOT_SELECTED;		final String sex = NOT_SELECTED;		final String std = NOT_SELECTED;		initDocumentRedactorWithActualServices();		final RuleExecutionContainer ruleExecutionContainer = ruleExecutionContainerWithHivEth;		final XacmlResult xacmlResultObj = initXacmlResult(problems, allergies,				medications, results, hiv, psy, eth, gdis, sdv, sex, std);		String factModelXml = factModelExtractor.extractFactModel(c32,				marshaller.marshal(xacmlResultObj));		c32 = embeddedClinicalDocumentExtractor				.extractClinicalDocumentFromFactModel(factModelXml);		factModelXml = removeEmbeddedClinicalDocument(factModelXml);		final FactModel factModel = marshaller.unmarshalFromXml(				FactModel.class, factModelXml);		setValueSetCategories(factModel);		final String ethObservationId = "e11275e7-67ae-11db-bd13-0800200c9a66b827vs52h7";		final String hivObservationId = "d11275e7-67ae-11db-bd13-0800200c9a66";		factModel.setXacmlResult(xacmlResultObj);		// Act		final String redactedC32 = documentRedactor.redactDocument(c32,				ruleExecutionContainer, factModel).getRedactedDocument();		// Assert		assertNotNull(getSectionElement(c32, PROBLEMS_SECTION));		assertNotNull(getSectionElement(c32, ALLERGIES_SECTION));		assertNotNull(getSectionElement(c32, MEDICATIONS_SECTION));		assertNotNull(getSectionElement(c32, RESULTS_SECTION));		assertNotNull(getSectionElement(redactedC32, PROBLEMS_SECTION));		// null		assertNull(getSectionElement(redactedC32, ALLERGIES_SECTION));		// null		assertNull(getSectionElement(redactedC32, MEDICATIONS_SECTION));		// null		assertNull(getSectionElement(redactedC32, RESULTS_SECTION));		// RuleExecutionContainer has ETH and HIV sensitivities for these		// observationIds, so the Problems section should exist, but these		// entries should have been redacted.		assertNull(getEntryElement(redactedC32, ethObservationId));		assertNull(getEntryElement(redactedC32, hivObservationId));	}
@Test    public void testWfs200Example1()                            throws Exception {        GetFeatureWithLockXMLAdapter parser = new GetFeatureWithLockXMLAdapter();        parser.load( GetFeatureWithLockXMLAdapterTest.class.getResource( "wfs200/example1.xml" ) );        GetFeatureWithLock request = parser.parse();        assertEquals( VERSION_200, request.getVersion() );        assertEquals( 1, request.getQueries().size() );        assertNull( request.getExpiryInSeconds() );        assertNull( request.getLockAll() );        assertNull( request.getHandle() );    }
@Test    void get2Test() {        assertEquals(2, (int) instance.get2());    }
@Test    public void getFallbackScript_DirectoryLevelFallback() {        verify(resolver, never()).getResource("/path/to/fallback.groovy");        assertNull(service.getFallbackScript(resolver, "/path/to/fallback.groovy"));    }
@Test public void testPaginate() throws Exception {    Assert.assertEquals( 0, pdfOutput.paginate( null, 0 ) );  }
@Test        public void testGetPropertyStringList(){                String key = "ranger.users.roles.list";                PropertiesUtil.getPropertiesMap().put("ranger.users.roles.list", "read,write,access");                String[] actualroles = PropertiesUtil.getPropertyStringList(key);                Assert.assertEquals("read", actualroles[0]);                Assert.assertEquals("write", actualroles[1]);                Assert.assertEquals("access", actualroles[2]);        }
@Test  public void testCreateResources_in_out_of_sync_state() throws Exception {    StackId stackId = new StackId("HDP", "2.0.1");    final Host host1 = createNiceMock("host1", Host.class);    expect(host1.getHostName()).andReturn("host1").anyTimes();    expect(host1.getOsFamily()).andReturn("redhat6").anyTimes();    replay(host1);    Map<String, Host> hostsForCluster = Collections.singletonMap(host1.getHostName(), host1);    ServiceComponentHost sch = createMock(ServiceComponentHost.class);    List<ServiceComponentHost> schs = Collections.singletonList(sch);    ServiceOsSpecific.Package hivePackage = new ServiceOsSpecific.Package();    hivePackage.setName("hive");    List<ServiceOsSpecific.Package> packages = Collections.singletonList(hivePackage);    AbstractControllerResourceProvider.init(resourceProviderFactory);    Map<String, Map<String, String>> hostConfigTags = new HashMap<>();    expect(configHelper.getEffectiveDesiredTags(anyObject(ClusterImpl.class), anyObject(String.class))).andReturn(hostConfigTags);    expect(managementController.getClusters()).andReturn(clusters).anyTimes();    expect(managementController.getAmbariMetaInfo()).andReturn(ambariMetaInfo).anyTimes();    expect(managementController.getActionManager()).andReturn(actionManager).anyTimes();    expect(managementController.getJdkResourceUrl()).andReturn("/JdkResourceUrl").anyTimes();    expect(managementController.getPackagesForServiceHost(anyObject(ServiceInfo.class),            EasyMock.<Map<String, String>>anyObject(), anyObject(String.class))).andReturn(packages).anyTimes();    expect(resourceProviderFactory.getHostResourceProvider(EasyMock.<Set<String>>anyObject(), EasyMock.<Map<Resource.Type, String>>anyObject(),            eq(managementController))).andReturn(csvResourceProvider).anyTimes();    expect(clusters.getCluster(anyObject(String.class))).andReturn(cluster);    expect(clusters.getHost(anyObject(String.class))).andReturn(host1);    expect(cluster.getHosts()).andReturn(hostsForCluster.values()).atLeastOnce();    expect(cluster.getServices()).andReturn(new HashMap<String, Service>()).anyTimes();    expect(cluster.getCurrentStackVersion()).andReturn(stackId);    expect(cluster.getServiceComponentHosts(anyObject(String.class))).andReturn(schs).anyTimes();    expect(sch.getServiceName()).andReturn("HIVE").anyTimes();    expect(        repositoryVersionDAOMock.findByStackAndVersion(            anyObject(StackId.class),            anyObject(String.class))).andReturn(repoVersion);    expect(        hostVersionDAOMock.findByClusterStackVersionAndHost(            anyObject(String.class), anyObject(StackId.class),            anyObject(String.class), anyObject(String.class))).andReturn(        hostVersionEntityMock);    expect(hostVersionEntityMock.getState()).andReturn(RepositoryVersionState.OUT_OF_SYNC).anyTimes();    expect(actionManager.getRequestTasks(anyLong())).andReturn(Collections.<HostRoleCommand>emptyList()).anyTimes();    StageUtils.setTopologyManager(injector.getInstance(TopologyManager.class));    StageUtils.setConfiguration(injector.getInstance(Configuration.class));    // replay    replay(managementController, response, clusters, resourceProviderFactory, csvResourceProvider,            cluster, repositoryVersionDAOMock, configHelper, sch, actionManager, hostVersionEntityMock, hostVersionDAOMock);    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(            type,            PropertyHelper.getPropertyIds(type),            PropertyHelper.getKeyPropertyIds(type),            managementController);    injector.injectMembers(provider);    // add the property map to a set for the request.  add more maps for multiple creates    Set<Map<String, Object>> propertySet = new LinkedHashSet<>();    Map<String, Object> properties = new LinkedHashMap<>();    // add properties to the request map    properties.put(HostStackVersionResourceProvider.HOST_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID, "Cluster100");    properties.put(HostStackVersionResourceProvider.HOST_STACK_VERSION_REPO_VERSION_PROPERTY_ID, "2.2.0.1-885");    properties.put(HostStackVersionResourceProvider.HOST_STACK_VERSION_STACK_PROPERTY_ID, "HDP");    properties.put(HostStackVersionResourceProvider.HOST_STACK_VERSION_VERSION_PROPERTY_ID, "2.0.1");    properties.put(HostStackVersionResourceProvider.HOST_STACK_VERSION_HOST_NAME_PROPERTY_ID, "host1");    propertySet.add(properties);    // create the request    Request request = PropertyHelper.getCreateRequest(propertySet, null);    provider.createResources(request);    // verify    verify(managementController, response, clusters);  }
@Test    public void shouldReturnOneAuthentication() {        Settings settings = Settings.builder()                .put(AUTHENTICATION_SOURCE.get(), "database")                .put(PASSWORD.get(), "password")                .put(USER.get(), "user")                .build();        MongoCredential credential = MongoAuthentication.of(settings).get();        assertEquals("database", credential.getSource());        assertTrue(Arrays.equals("password".toCharArray(), credential.getPassword()));        assertEquals("user", credential.getUserName());        assertNull(credential.getMechanism());    }
@Test    public void testAnyWithPredicate2() {        Observable<Integer> w = Observable.from(1, 2, 3);        Observable<Boolean> observable = Observable.create(any(w,                new Func1<Integer, Boolean>() {                    @Override                    public Boolean call(Integer t1) {                        return t1 < 1;                    }                }));        @SuppressWarnings("unchecked")        Observer<Boolean> observer = mock(Observer.class);        observable.subscribe(observer);        verify(observer, times(1)).onNext(false);        verify(observer, never()).onNext(true);        verify(observer, never()).onError(org.mockito.Matchers.any(Throwable.class));        verify(observer, times(1)).onCompleted();    }
@Test    public void testGetPort() {        Assertions.assertEquals(8088, parameterParser.getPort());    }
@Test    public void testAccept() {        // Setup        final StepLocalTxVisitor visitor = mock(StepLocalTxVisitor.class);        // Run the test        localTransactionStepDefinitionUnderTest.accept(visitor);        // Verify the results        verify(visitor).visit(any());    }
@Test    public void whenCalibrationEndsSetCalibrationButtonToTrue(){        FeatureAutoConfigurationListener listener = getConfigListener();        listener.onConfigurationFinished(mFeature,100);        verify(mView).setCalibrationButtonState(true);    }
@Test    public void create() throws NamingException {        UserDAO dao = (UserDAO) container.getContext().lookup("java:global/rest-example/UserDAO");        User user = dao.create("foo", "dummy", "foo@bar.org");        assertNotNull(dao.find(user.getId()));    }
@Test  public void shouldBuildURLWithNoQueryParameters() throws Exception {    ViewContext context = createNiceMock(ViewContext.class);    ProxyHelper helper = new ProxyHelper(context);    assertEquals("http://abc.com/", helper.getProxyUrl("http://abc.com", "", new MultivaluedHashMap<String, String>(), "kerberos"));    assertEquals("http://abc.com/test/abcd", helper.getProxyUrl("http://abc.com", "test/abcd", new MultivaluedHashMap<String, String>(), "kerberos"));  }
@Test    void get6() {        assertEquals(m6, instance.get6());    }
@Test  @SuppressWarnings("all")  public void getLandingPageViewExceptionTest() throws Exception {    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);    mockLandingPageViewService.addException(exception);    try {      LandingPageViewName resourceName =          LandingPageViewName.of("[CUSTOMER]", "[LANDING_PAGE_VIEW]");      client.getLandingPageView(resourceName);      Assert.fail("No exception raised");    } catch (InvalidArgumentException e) {      // Expected exception    }  }
@Test  public void relational() throws Exception {    Expression expression = parseExpression("5 gt 5");    assertEquals("{5 GT 5}", expression.toString());    expression = parseExpression("5 ge 5");    assertEquals("{5 GE 5}", expression.toString());    expression = parseExpression("5 lt 5");    assertEquals("{5 LT 5}", expression.toString());    expression = parseExpression("5 le 5");    assertEquals("{5 LE 5}", expression.toString());    assertEquals("{5 LE 5.1}", parseExpression("5 le 5.1").toString());    assertEquals("{1 GT null}", parseExpression("1 gt null").toString());    assertEquals("{null GE 2}", parseExpression("null ge 2").toString());    assertEquals("{null LE null}", parseExpression("null le null").toString());    wrongExpression("5 gt duration'PT5H'");  }
@Test  public void testCreateRetractionFactTypeOnDemand() {    when(factManager.saveFactType(any())).thenAnswer(i -> i.getArgument(0));    assertRetractionFactType(resolver.resolveRetractionFactType());    verify(factManager).saveFactType(argThat(e -> {      assertRetractionFactType(e);      return true;    }));  }
@Test    public void invNoDownload() throws Exception {        // Don't download missing blocks.        peer.setDownloadData(false);        connect();        // Make a missing block that we receive.        Block b1 = createFakeBlock(blockStore, Block.BLOCK_HEIGHT_GENESIS).block;        blockChain.add(b1);        Block b2 = makeSolvedTestBlock(b1);        // Receive an inv.        InventoryMessage inv = new InventoryMessage(PARAMS);        InventoryItem item = new InventoryItem(InventoryItem.Type.Block, b2.getHash());        inv.addItem(item);        inbound(writeTarget, inv);        // Peer does nothing with it.        assertNull(outbound(writeTarget));    }
@Test	public void testFromJsonString() {		Point p = Point.fromJsonString(p1.toString());		assertEquals(p1.toString(), p.toString());		assertEquals(p1.toJsonObject(), p.toJsonObject());		assertEquals(p1.getMessageType(), p.getMessageType());		assertEquals(p1.getX(), p.getX(), 0);		assertEquals(p1.getY(), p.getY(), 0);		assertEquals(p1.getZ(), p.getZ(), 0);		assertNotSame(p1, p);		assertNotSame(p1.toString(), p.toString());		assertNotSame(p1.toJsonObject(), p.toJsonObject());	}
@Test	public void testFindConnectingAddressWhenGetLocalHostThrows() throws Exception {		PowerMockito.mockStatic(InetAddress.class);		Mockito.when(InetAddress.getLocalHost()).thenThrow(new UnknownHostException()).thenCallRealMethod();		final InetAddress loopbackAddress = Inet4Address.getByName("127.0.0.1");		Thread socketServerThread;		try (ServerSocket socket = new ServerSocket(0, 1, loopbackAddress)) {			// Make sure that the thread will eventually die even if something else goes wrong			socket.setSoTimeout(10_000);			socketServerThread = new Thread(new Runnable() {				@Override				public void run() {					try {						socket.accept();					} catch (IOException e) {						// ignore					}				}			});			socketServerThread.start();			final InetSocketAddress socketAddress = new InetSocketAddress(loopbackAddress, socket.getLocalPort());			final InetAddress address = ConnectionUtils.findConnectingAddress(				socketAddress, 2000, 400);			PowerMockito.verifyStatic();			// Make sure we got an address via alternative means			assertNotNull(address);		}	}
@Test  public void      defaultInitialBitrateEstimate_for2G_forFastCountry_isGreaterThanEstimateForSlowCountry() {    setActiveNetworkInfo(networkInfo2g);    setNetworkCountryIso(FAST_COUNTRY_ISO);    DefaultBandwidthMeter bandwidthMeterFast =        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();    long initialEstimateFast = bandwidthMeterFast.getBitrateEstimate();    setNetworkCountryIso(SLOW_COUNTRY_ISO);    DefaultBandwidthMeter bandwidthMeterSlow =        new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()).build();    long initialEstimateSlow = bandwidthMeterSlow.getBitrateEstimate();    assertThat(initialEstimateFast).isGreaterThan(initialEstimateSlow);  }
@Test	public void testStart_EndpointStopperCounterpart_Is_SetCounter_To_Zero() {		sut.start();		verify(endpointStopperCounterpart, times(1)).setCounter(0);	}
@Test    public void testHasNextFalse() throws Exception {        LocalDate today = LocalDate.now();        Week week = new Week(today, today, null, today.withDayOfWeek(DateTimeConstants.SUNDAY));        assertFalse(week.hasNext());    }
@Test    public void deleteCompany() throws Exception {        testVoidSpec(resource.deleteCompany("some_id"));    }
@Test    public void testReadToEnd_hitsException() throws IOException {        final InputStream in = new InputStream() {            @Override            public int read() throws IOException {                throw new IOException("test");            }        };        thrown.expect(IOException.class);        thrown.expectMessage("test");        B2IoUtils.readToEnd(in);    }
@Test    public void testDateEditorValueAsDate() throws ParseException  {        DatePickerCellEditor editor = new DatePickerCellEditor();        Date input = new Date();        assertEquals("the input date must be unchanged", input, editor.getValueAsDate(input));        assertEquals("input as long must be same", input, editor.getValueAsDate(input.getTime()));        // PENDING: fails on server, moved out off the way into visual check for now//        String dateString = editor.getFormats()[0].format(input);//        Date fullCycle = editor.getFormats()[0].parse(dateString);//        assertEquals("the formatted input date string must be same", fullCycle, editor.getValueAsDate(dateString));        String nonsenseString = "invalid";        assertNull("invalid string maps to null", editor.getValueAsDate(nonsenseString));        assertNull("empty String maps to null", editor.getValueAsDate(""));        // same with date/string wrapped into TreeNode        DefaultMutableTreeNode node = new DefaultMutableTreeNode(input);        assertEquals("date must be user-object", input, editor.getValueAsDate(node));        // same with date/string wrapped into a TreeTableNode        DefaultMutableTreeTableNode tableNode = new DefaultMutableTreeTableNode(input);        assertEquals("date must be user-object", input, editor.getValueAsDate(tableNode));    }
@Test    public void testGetTrustStoreEntries() {        // trust store should contain the entries        try {            assertNotNull(crypto.getTrustStore().getCertificateAlias(testCACert));            assertNull(crypto.getTrustStore().getCertificate("testtesttest"));        } catch (KeyStoreException | CryptoException e) {            fail("testGetTrustStoreEntries should not have thrown exception. Error: " + e.getMessage());        }    }
@Test  public void testGetStackArtifactResourceProvider() {    AmbariManagementController managementController = createMock(AmbariManagementController.class);    ResourceProvider provider = AbstractControllerResourceProvider.getResourceProvider(        Resource.Type.StackArtifact, null, null, managementController);    assertEquals(StackArtifactResourceProvider.class, provider.getClass());  }
@Test(expected = NullPointerException.class)	public void testNull()	{		FilterFilter filter = new FilterFilter();		filter.apply(null);	}
@Test    public void testGetOperator() {        final String expectedOperator = "operator";        when(plugin.getFactField()).thenReturn("factField");        when(plugin.editingCol()).thenReturn(editingCol);        when(editingCol.getOperator()).thenReturn(expectedOperator);        final String operator = page.getOperator();        verify(plugin).editingCol();        verify(editingCol).getOperator();        assertEquals(expectedOperator,                     operator);    }
@Test	public void testCheckKeyColumnsWithMatchingRecords() throws Exception {		List<String> key = new ArrayList<String>();		key.add("test1");		key.add("test2");		List<String> columns = new ArrayList<String>();		columns.add("test1");		columns.add("test2");		boolean test = ArrayUtils.keysPresentInColumns(key.toArray(new String[] {}), columns.toArray(new String[] {}));		Assert.assertTrue(test);	}
@Test  public void testMultipleContainers() throws Exception {    ApplicationId appId = ApplicationId.newInstance(0, 1);    ApplicationAttemptId appAttemptId =        ApplicationAttemptId.newInstance(appId, 1);    WebResource r = resource();    ClientResponse response =        r.path("ws").path("v1").path("applicationhistory").path("apps")          .path(appId.toString()).path("appattempts")          .path(appAttemptId.toString()).path("containers")          .queryParam("user.name", USERS[round])          .accept(MediaType.APPLICATION_JSON).get(ClientResponse.class);    if (round == 1) {      assertResponseStatusCode(Status.FORBIDDEN, response.getStatusInfo());      return;    }    assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8,        response.getType().toString());    JSONObject json = response.getEntity(JSONObject.class);    assertEquals("incorrect number of elements", 1, json.length());    JSONObject containers = json.getJSONObject("containers");    assertEquals("incorrect number of elements", 1, containers.length());    JSONArray array = containers.getJSONArray("container");    assertEquals("incorrect number of elements", MAX_APPS, array.length());  }
@Test    public void supportsPath() {        final S3FileSystemProvider provider = new S3FileSystemProvider();        Assert.assertTrue("Expected to use provider for s3:///", provider.supportsPath(new Path("s3:///")));        Assert.assertTrue("Expected to use provider for s3a:///", provider.supportsPath(new Path(S3A)));        Assert.assertTrue("Expected to use provider for s3n:///", provider.supportsPath(new Path(S3N)));        Assert.assertFalse("Expected to use Hadoop for s3n://bucket/", provider.supportsPath(new Path(S3N.resolve("//bucket/"))));    }
@Test    public void test2ExecuteQuery() {        System.out.println("executeQuery");        String measurement = "unittest";        Map<String, List<String>> filter = null;        List<TSData> results = new ArrayList<>();        instance.executeQuery(measurement, startTime, stopTime, filter, results);        assertEquals(3, results.size()); //two fields: if:in-errors and if:name        assertEquals(MEASUREMENTS, results.get(0).m_tsPoints.size());        assertEquals(MEASUREMENTS, results.get(1).m_tsPoints.size());        showResult(results);    }
@Test	public void testContentReviewerWithoutAssetViewPermissionHasPermissionOnPendingTask() {		long[] permissionCheckerRoleIds = randomPermissionCheckerRoleIds();		Assert.assertTrue(			_workflowTaskPermissionChecker.hasPermission(				RandomTestUtil.randomLong(),				mockWorkflowTask(					Role.class.getName(), permissionCheckerRoleIds[0]),				mockPermissionChecker(					RandomTestUtil.randomLong(), permissionCheckerRoleIds,					false, false, false)));	}
@Test  public void inlineRegressionTest2() throws Exception {    String program = "struct _GLF_struct_761 {\n"        + "    bvec2 _f0;\n"        + "};\n"        + "struct _GLF_struct_762 {\n"        + "    _GLF_struct_761 _f0;\n"        + "};\n"        + "void f()\n"        + "{\n"        + "    _GLF_struct_762 _GLF_struct_replacement_763 = _GLF_struct_762(_GLF_struct_761("                + "bvec2(true)));\n"        + "    _GLF_struct_762(_GLF_struct_761(bvec2(true)))._f0._f0;\n"        + "}\n";    TranslationUnit tu = ParseHelper.parse(program).clone();    List<InlineStructifiedFieldReductionOpportunity> ops =        InlineStructifiedFieldReductionOpportunities            .findOpportunities(MakeShaderJobFromFragmentShader.make(tu),                new ReducerContext(false, ShadingLanguageVersion.ESSL_100,                    new RandomWrapper(0),              new IdGenerator()));    assertEquals(1, ops.size());    ops.get(0).applyReduction();    final File shaderJobFile = testFolder.newFile("temp.json");    fileOps.writeShaderJobFile(new GlslShaderJob(Optional.empty(), new PipelineInfo(), tu),        shaderJobFile);    assertTrue(fileOps.areShadersValid(shaderJobFile, false));  }
@Test    public void testIsDisconnected() {        EhDisjointFF instance = new EhDisjointFF();        boolean expResult = false;        boolean result = instance.isDisconnected();        assertEquals(expResult, result);    }
@Test(expected = IllegalStateException.class)	public void testClearBackStackWhenDestroyed() {		// Arrange + Act:		createDestroyedController().clearBackStack();	}
@Test	public void longStream() {		final LongChromosome chromosome = LongChromosome.of(0, 10_000, 1000);		final long[] values = chromosome.longStream().toArray();		Assert.assertEquals(values.length, 1000);		for (int i = 0; i < values.length; ++i) {			Assert.assertEquals(chromosome.get(i).longValue(), values[i]);			Assert.assertEquals(chromosome.longValue(i), values[i]);		}	}
@Test    public void testGetTriggerFiredDatapointTime() {        UserService userService = system.getServiceFactory().getUserService();        Alert alert = new Alert(userService.findAdminUser(), userService.findAdminUser(), "alert-name_test", EXPRESSION, "* * * * *");        Metric metric = new Metric("scope", "metric");        double thresholdValue = 90;        long inertia = 10;        long startTime = 1;        long expectedTriggerTime;        Trigger trigger = new Trigger(alert, TriggerType.GREATER_THAN_OR_EQ, "name_test", thresholdValue, inertia);        Map<Long, String> datapoints = new HashMap<Long, String>();        datapoints.putAll(_createDatapoints(inertia + 1, thresholdValue, startTime, true));        metric.setDatapoints(_convertDatapoints(datapoints));        expectedTriggerTime = datapoints.size();        long actualValue = alertService.getTriggerFiredDatapointTime(trigger, metric, alert.getExpression(), startTime);        assertEquals(expectedTriggerTime, actualValue);        startTime = datapoints.size() + 1;        datapoints.putAll(_createDatapoints(201, thresholdValue, startTime, false));        metric.setDatapoints(_convertDatapoints(datapoints));        actualValue = alertService.getTriggerFiredDatapointTime(trigger, metric, alert.getExpression(), startTime);        assertEquals(expectedTriggerTime, actualValue);        startTime = datapoints.size() + 1;        datapoints.putAll(_createDatapoints(inertia - 1, thresholdValue, startTime, true));        metric.setDatapoints(_convertDatapoints(datapoints));        actualValue = alertService.getTriggerFiredDatapointTime(trigger, metric, alert.getExpression(), startTime);        assertEquals(expectedTriggerTime, actualValue);        startTime = datapoints.size() + 1;        datapoints.putAll(_createDatapoints(inertia + 1, thresholdValue, startTime, true));        metric.setDatapoints(_convertDatapoints(datapoints));        actualValue = alertService.getTriggerFiredDatapointTime(trigger, metric, alert.getExpression(), startTime);        expectedTriggerTime = datapoints.size();        assertEquals(expectedTriggerTime, actualValue);        startTime = datapoints.size() + 1;        datapoints.putAll(_createDatapoints(201, thresholdValue, startTime, false));        metric.setDatapoints(_convertDatapoints(datapoints));        actualValue = alertService.getTriggerFiredDatapointTime(trigger, metric, alert.getExpression(), startTime);        assertEquals(expectedTriggerTime, actualValue);    }
@Test  public void testMapperFieldName_configNotMap() {    LOG.info("testMapperFieldName_configNotMap()");    MapperFieldName mapperFieldName = new MapperFieldName();    assertFalse("Was able to initialize!", mapperFieldName.init(null, "someField", null, ""));  }
@Test    public void loadingResourceShouldWork() {        final Set<String> knownClasses = ClassWithInterfaceFieldsRegistry.getKnownClasses();        assertThat(knownClasses).isNotEmpty();        assertThat(knownClasses).size().isEqualTo(4);        assertThat(knownClasses).contains(                "me.snowdrop.istio.api.test.Simple",                "me.snowdrop.istio.api.test.Interface",                "me.snowdrop.istio.api.test.Class",                "me.snowdrop.istio.api.test.Map");    }
@Test    void unescape()    {        assertEquals("&'\"<>", XMLUtils.unescape("&amp;&apos;&quot;&lt;&gt;"), "Failed to unescaped named entities");        assertEquals("&'\"<>", XMLUtils.unescape("&#38;&#39;&#34;&#60;&#62;"), "Failed to unescaped decimal entities");        assertEquals("&'\"<>", XMLUtils.unescape("&#038;&#0039;&#00034;&#000060;&#0000062;"),            "Failed to unescaped decimal entities with leading zeros");        assertEquals("&'\"<<>>", XMLUtils.unescape("&#x26;&#x27;&#x22;&#x3c;&#x3C;&#x3e;&#x3E;"),            "Failed to unescaped hexadecimal entities");        assertEquals("&'\"<<>>", XMLUtils.unescape("&#x026;&#x0027;&#x00022;&#x00003c;&#x0003C;&#x003e;&#x03E;"),            "Failed to unescaped hexadecimal entities with leading zeros");    }
@Test  public void testZip() throws IOException {    File tmpFolder = Files.createTempDir();    File file = File.createTempFile(".bla", ".tmp", tmpFolder);    String testStr = "skjfghskjdhgfjgishfgksjhgjkhdskghsfdkjhg";    File subFolder = new File(file.getParent(), "subFolder");    if (!subFolder.mkdir()) {      throw new IOException("Cannot create folder " + subFolder);    }    File subTestFile = new File(subFolder, "subTestFile.txt");    Files.asCharSink(file, StandardCharsets.UTF_8).write(testStr);    Files.asCharSink(subTestFile, StandardCharsets.UTF_8).write(testStr);    Path zip = Compress.zip(tmpFolder.toPath());    Assert.assertThat(zip.getFileName().toString(), Matchers.endsWith(".zip"));    Assert.assertTrue(java.nio.file.Files.exists(zip));    File tmpFir = Files.createTempDir();    List<Path> unzip = Compress.unzip(zip, tmpFir.toPath());    Assert.assertEquals(2, unzip.size());    Assert.assertEquals(testStr, Files.asCharSource(unzip.get(0).toFile(), StandardCharsets.UTF_8).read());    Assert.assertEquals(testStr, Files.asCharSource(unzip.get(1).toFile(), StandardCharsets.UTF_8).read());  }
@Test    void get5() {        assertEquals(m5, instance.get5());    }
@Test    public void testGetIndex_head() {        assertEquals(TestParameters.VP_INDEX_HEAD,                chmItspHeader.getIndex_head());    }
@Test(expected = AllocationConfigurationException.class)  public void testGibberish() throws Exception {    parseResourceConfigValue("1o24vc0res");  }
@Test public void testQuoting() throws Exception {    assertEquals("ab&lt;cd", HtmlQuoting.quoteHtmlChars("ab<cd"));    assertEquals("ab&gt;", HtmlQuoting.quoteHtmlChars("ab>"));    assertEquals("&amp;&amp;&amp;", HtmlQuoting.quoteHtmlChars("&&&"));    assertEquals(" &apos;\n", HtmlQuoting.quoteHtmlChars(" '\n"));    assertEquals("&quot;", HtmlQuoting.quoteHtmlChars("\""));    assertEquals(null, HtmlQuoting.quoteHtmlChars(null));  }
@Test    void linkNoCert() {        link();    }
@Test    public void generateServerStatReporter() {        AbstractSofaTracerStatisticReporter abstractSofaTracerStatisticReporter = clientTracer            .generateServerStatReporter();        Assert.assertTrue(abstractSofaTracerStatisticReporter == null);    }
@Test    void batchedStreamOf_empty() {        Stream<Integer> sourceStream = Stream.empty();        List<List<Integer>> batches = BatchingIterator.batchedStreamOf(sourceStream, 3)                .collect(Collectors.toList());        assertThat(batches).isNotNull();        assertThat(batches).isEmpty();    }
@Test    public void buildUndoSQL() {        String sql = executor.buildUndoSQL().toLowerCase();        Assertions.assertNotNull(sql);        Assertions.assertTrue(sql.contains("insert"));        Assertions.assertTrue(sql.contains("id"));    }
@Test    public void defaultParserWithExcludes() throws Exception {        try {            TikaConfig config = getConfig("TIKA-1445-default-except.xml");                        CompositeParser cp = (CompositeParser)config.getParser();            List<Parser> parsers = cp.getAllComponentParsers();            Parser p;                        // Will be the three parsers defined in the xml            assertEquals(3, parsers.size());                        // Should have a wrapped DefaultParser, not the main DefaultParser,            //  as it is excluded from handling certain classes            p = parsers.get(0);            assertTrue(p.toString(), p instanceof ParserDecorator);            assertEquals(DefaultParser.class, ((ParserDecorator)p).getWrappedParser().getClass());                        // Should have two others which claim things, which they wouldn't            //  otherwise handle            p = parsers.get(1);            assertTrue(p.toString(), p instanceof ParserDecorator);            assertEquals(EmptyParser.class, ((ParserDecorator)p).getWrappedParser().getClass());            assertEquals("hello/world", p.getSupportedTypes(null).iterator().next().toString());                        p = parsers.get(2);            assertTrue(p.toString(), p instanceof ParserDecorator);            assertEquals(ErrorParser.class, ((ParserDecorator)p).getWrappedParser().getClass());            assertEquals("fail/world", p.getSupportedTypes(null).iterator().next().toString());        } catch (TikaException e) {            fail("Unexpected TikaException: " + e);        }    }
@Test    public void acceptContactRequest() throws Exception {        testVoidSpec(resource.acceptContactRequest("user_id", "sender_id"));    }
@Test    public void showErrorShouldDoNothingIfNoListeners() {        errorHandler.showError("error");    }
@SuppressWarnings("ResultOfMethodCallIgnored")    @Test    public void entrySetDelegates() {        // given        ChronicleMap<CharSequence, ItemSource> chronicleMap = createDefaultTestChronicleMap();        ChronicleMapProxy proxy = createDefaultTestProxy(chronicleMap);        // when        proxy.entrySet();        // then        Mockito.verify(chronicleMap).entrySet();    }
@Test  public void testGetNumWorkflowInstancesByStatus() throws Exception {    int inst = wmc.getNumWorkflowInstancesByStatus("QUEUED");    assertThat(inst, equalTo(0));  }
@Test    void methodChain() {        Token token = parser.parse("method1().method2()");        assertThat(token).isInstanceOf(MethodToken.class);        MethodToken methodToken = (MethodToken) token;        assertThat(methodToken.name).isEqualTo("method1");        assertThat(methodToken.params).isEmpty();        assertThat(methodToken.next).isInstanceOf(MethodToken.class);        MethodToken methodToken2 = (MethodToken) ((MethodToken) token).next;        assertThat(methodToken2.name).isEqualTo("method2");        assertThat(methodToken2.params).isEmpty();    }
@Test  public void testConfigInstalled() {    replay(mBuilder);    Mockspresso.Builder returnedBuilder = mPlugin.apply(mBuilder);    verify(mBuilder);    assertThat(returnedBuilder)        .isNotNull()        .isEqualTo(mBuilder);  }
@Test  public void testSortableBase64Sorting() {    final List<byte[]> sortedBinary = Lists.newArrayList();    for (int i = 0; i < Short.MAX_VALUE; i += 100) {      final byte[] bytes = new byte[2];      bytes[1] = (byte) (i & 0xff);      bytes[0] = (byte) ((i >> 8) & 0xff);      sortedBinary.add(bytes);    }    for (int i = Short.MIN_VALUE; i < 0; i += 100) {      final byte[] bytes = new byte[2];      bytes[1] = (byte) (i & 0xff);      bytes[0] = (byte) ((i >> 8) & 0xff);      sortedBinary.add(bytes);    }    verifySorted(sortedBinary);    final List<byte[]> encodedBinary =        Lists.transform(sortedBinary, (binary) -> DynamoDBUtils.encodeSortableBase64(binary));    verifySorted(encodedBinary);  }
@Test  public void testConstructors() {    assertNull(new SimpleObservable<>().get());    Object val = new Object();    assertEquals(val, new SimpleObservable<>(val).get());  }
@Test // too large negative index returns same as oorgange, null	public void getByPath_path_list_oorange_negative() {		List<String> input = Arrays.asList("a", "b", "c");		assertEquals(null, CollectionUtils.getByPath(input, "-4"));	}
@Test    public void shouldInstantiateAccessibleWithoutCRestConfig() throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {        AccessiblePublicClassNoCRestConfig actual = ComponentFactory.instantiate(AccessiblePublicClassNoCRestConfig.class, mockCRestConfig);        assertNotNull(actual);    }
@Test    public void test_getVaultTokenLookupDetails_failure() throws TVaultValidationException, IOException {        String token = "7QPMPIGiyDFlJkrK3jFykUqa";        Response response = getMockResponse(HttpStatus.FORBIDDEN, true, "");        VaultTokenLookupDetails expectedLookupDetails = new VaultTokenLookupDetails();        expectedLookupDetails.setAdmin(false);        expectedLookupDetails.setValid(true);        expectedLookupDetails.setToken(token);        expectedLookupDetails.setUsername(null);        String [] policies = {"default"};        ArrayList<String> adminPolicies = new ArrayList<>();        adminPolicies.add("adminpolicy");        expectedLookupDetails.setPolicies(policies);        when(reqProcessor.process("/auth/tvault/lookup","{}", token)).thenReturn(response);        try {            VaultTokenLookupDetails lookupDetails = tokenValidator.getVaultTokenLookupDetails(token);        }catch (TVaultValidationException t) {            assertTrue(true);        }    }
@Test	public void coalesceTest() {		Expr e = factory.coalesce(factory.list());		assertTrue(e instanceof E_Coalesce);	}
@Test  public void testConvertNullReturnsNull() throws Exception {    assertNull(converter.apply(null));  }
@Test    public void testForEachByte() {        buffer.clear();        for (int i = 0; i < CAPACITY; i ++) {            buffer.writeByte(i + 1);        }        final AtomicInteger lastIndex = new AtomicInteger();        buffer.setIndex(CAPACITY / 4, CAPACITY * 3 / 4);        assertThat(buffer.forEachByte(new ByteProcessor() {            int i = CAPACITY / 4;            @Override            public boolean process(byte value) throws Exception {                assertThat(value, is((byte) (i + 1)));                lastIndex.set(i);                i ++;                return true;            }        }), is(-1));        assertThat(lastIndex.get(), is(CAPACITY * 3 / 4 - 1));    }
@Test(expected = NoSuchTableException.class)    public void execute_insert_onNonExistingIndex_throwsException() throws Exception {        IndexCommit commit = mock(IndexCommit.class);        when(commit.getTimestamp()).thenReturn(new Date(42));        engine.execute(new InsertOperation(commit, testIndex, new ArrayList<OpenEngSBModel>()));    }
@Test (timeout = 30000)  public void testCopyMergeSingleDirectory() throws IOException {    setupDirs();    boolean copyMergeResult = copyMerge("partitioned", "tmp/merged");    Assert.assertTrue("Expected successful copyMerge result.", copyMergeResult);    File merged = new File(TEST_DIR, "tmp/merged");    Assert.assertTrue("File tmp/merged must exist after copyMerge.",        merged.exists());    BufferedReader rdr = new BufferedReader(new FileReader(merged));    try {      Assert.assertEquals("Line 1 of merged file must contain \"foo\".",          "foo", rdr.readLine());      Assert.assertEquals("Line 2 of merged file must contain \"bar\".",          "bar", rdr.readLine());      Assert.assertNull("Expected end of file reading merged file.",          rdr.readLine());    }    finally {      rdr.close();    }  }
@Test    public void doesNotDoAnythingIfExceptionIsThrown() throws IOException {        PowerMockito.mockStatic(IOUtils.class);        PowerMockito.when(IOUtils.toString(any(InputStream.class))).thenThrow(new IOException("Exception while reading spec"));        String[] args = {                "update", "-a", "configuration.json"        };        Main.main(args);    }
@Test    public void convertToOpCodeString() {        String script = "0c0548656c6c6f0c05576f726c642150419bf667ce41e63f18841140";        String out = ScriptReader.convertToOpCodeString(script);        String expected = ""                + "PUSHDATA1 5 48656c6c6f\n"                + "PUSHDATA1 5 576f726c64\n"                + "NOP\n"                + "SWAP\n"                + "SYSCALL 9bf667ce\n"                + "SYSCALL e63f1884\n"                + "PUSH1\n"                + "RET\n";        assertThat(out, is(expected));    }
@Test    public void testCreateNodePointerNodePointer02() throws Exception {        // 前処理        DynamicPointerFactoryEx factory = new DynamicPointerFactoryEx();        QName qName = new QName("name");        Object bean = new HashMap<Object, Object>();        Locale locale = new Locale("ja");        NodePointer nodePointer = NodePointer.newNodePointer(qName, bean,                locale);        // テスト実施        NodePointer result = factory.createNodePointer(nodePointer, qName,                bean);        // 判定        assertSame(DynamicPointerEx.class, result.getClass());        assertSame(nodePointer, result.getParent());        assertSame(qName, result.getName());        assertSame(bean, ReflectionTestUtils.getField(result, "bean"));    }
@Test    public void shouldReturnAndConvertMatchingEnvironmentVariable() {        environmentVariables.put("APP__ABC", "value1");        assertEquals(            Collections.singletonMap("app.abc", "value1"),            new EnvironmentVariableProperties(                environmentVariables,                "APP__.+"            ).getProperties()        );    }
@Test    public void testPermittedTopology_polygon_polygon() {        DimensionInfo sourceDimensionInfo = DimensionInfo.XY_POLYGON;        DimensionInfo targetDimensionInfo = DimensionInfo.XY_POLYGON;        SfOverlapsFF instance = new SfOverlapsFF();        boolean expResult = true;        boolean result = instance.permittedTopology(sourceDimensionInfo, targetDimensionInfo);        assertEquals(expResult, result);    }
@Test    public void createInstance(@Mocked final PriamInstance instance) {        final String instanceID = "i-abc123";        final String hostname = "dom.com";        final String ip = "123.123.123.123";        final String rack = "us-east-1a";        final String token = "1234567890";        new Expectations() {            {                config.getAppName();                result = APP_NAME;                factory.create(APP_NAME, NODE_ID, instanceID, hostname, ip, rack, null, token);                result = instance;                instance.getId();                result = NODE_ID;            }        };        Response response = resource.createInstance(NODE_ID, instanceID, hostname, ip, rack, token);        assertEquals(201, response.getStatus());        assertEquals("/" + NODE_ID, response.getMetadata().getFirst("location").toString());    }
@Test	public void shouldRegisterConvertersForAllDefaultTypes() {	final HashMap<Class, Class<? extends Converter>> EXPECTED_CONVERTERS = new HashMap<Class, Class<? extends Converter>>() {		{		put(int.class, PrimitiveIntConverter.class);		put(long.class, PrimitiveLongConverter.class);		put(short.class, PrimitiveShortConverter.class);		put(byte.class, PrimitiveByteConverter.class);		put(double.class, PrimitiveDoubleConverter.class);		put(float.class, PrimitiveFloatConverter.class);		put(boolean.class, PrimitiveBooleanConverter.class);		put(Integer.class, IntegerConverter.class);		put(Long.class, LongConverter.class);		put(Short.class, ShortConverter.class);		put(Byte.class, ByteConverter.class);		put(Double.class, DoubleConverter.class);		put(Float.class, FloatConverter.class);		put(Boolean.class, BooleanConverter.class);		put(Calendar.class, LocaleBasedCalendarConverter.class);		put(Date.class, LocaleBasedDateConverter.class);		put(Enum.class, EnumConverter.class);		}		private static final long serialVersionUID = 8559316558416038474L;	};	for (Class<? extends Converter> converterType : EXPECTED_CONVERTERS.values()) {		Converter<?> expected = mock(converterType);		when((Converter)container.instanceFor(converterType)).thenReturn(expected);	}	for (Entry<Class, Class<? extends Converter>> entry : EXPECTED_CONVERTERS.entrySet()) {		Class<?> typeFor = entry.getKey();		Class<? extends Converter> converterType = entry.getValue();		Converter<?> converter = converters.to(typeFor);		assertThat(converter, is(instanceOf(converterType)));	}	}
@Test    public void testComputeSunriseTime() {        String localSunriseTime = "07:05";        assertEquals(localSunriseTime, calc.computeSunriseTime(Zenith.CIVIL, eventDate));    }
@Test  public void testReportList() {    assertEquals("", reportList());    assertEquals("foo", reportList("foo"));    assertEquals("foo or bar", reportList("foo", "bar"));    assertEquals("foo, bar or baz", reportList("foo", "bar", "baz"));    assertEquals("foo, bar or baz", reportList("foo", "bar", "baz", "baz"));    assertEquals("foo or bar", reportList("foo", "foo", "bar"));  }
@Test    public void should_rhs_not_be_evaluated_when_AND_operator_and_lhs_is_false___strong_ref() {        when(lhs.isGranted(any(), any(), any())).thenReturn(false);        GrantEvaluator grantEvaluator = composer.and(lhs, rhs);        boolean granted = grantEvaluator.isGranted(null, null, "fake");        verify(lhs).isGranted(any(), any(), any());        verifyZeroInteractions(rhs);        assertThat(granted).isFalse();    }
@Test public final void testStringToUnixTimestamp() throws ParseException {    final long submissionTime =        logParserUtil.stringToUnixTimestamp("17/07/16 16:27:25");    Assert.assertEquals(jobMetaData.getResourceSkyline().getJobSubmissionTime(),        submissionTime);  }
@Test  public void dontSendPatchOnNewEmptyOps() throws Exception {    given(agent.newModel("key", JSON_STRING_1)).willReturn(Collections.emptyList());    observer.handleNew("key", JSON_STRING_1);    then(emitter).shouldHaveZeroInteractions();  }
@Test    public void testWaitUntilTransportable() throws InterruptedException {        final AtomicLong later = new AtomicLong(0);        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                ((Buffer) store).waitUntilTransportable();                later.set(Time.now());            }        });        thread.start();        long before = Time.now();        while (!((Buffer) store).canTransport()) {            before = Time.now();            add(TestData.getString(), TestData.getTObject(),                    TestData.getLong());        }        thread.join(); // make sure thread finishes before comparing        Assert.assertTrue(later.get() > before);    }
@Test    public void readByte_throwsIOException() throws Exception {        final IOException exception = new IOException("test");        when(wrappedStream.read()).thenThrow(exception);        try {            //noinspection ResultOfMethodCallIgnored            stream.read();            fail("should've thrown!");        } catch (IOException e) {            assertEquals("test", e.getMessage());        }        //noinspection ResultOfMethodCallIgnored        verify(wrappedStream, times(1)).read();        verify(listener, times(1)).hitException(eq(exception), eq(0L));    }
@Test	public void movingFileFromExisitingToNotExitsingPath() {		OperationsOnFiles.moveWithPruneEmptydirectories(goodSourceFilePath, badTargetFilePath);		Assert.assertTrue("File was not moved properly into the target directory.", badTargetfile.exists());		Assert.assertFalse("File still exist in source path after moving.", goodSourceFile.exists());	}
@Test    public void getChannelIdentifiers() {        Collection<String> channels = function.getChannelIdentifiers();        assertTrue(channels.contains("flag"));        assertTrue(channels.contains("test"));        channels = clone.getChannelIdentifiers();        assertTrue(channels.contains("flag"));        assertTrue(channels.contains("test"));    }
@Test  public void testLabel() {    assertEquals("foo", FOO.label("the foo").parse("", mode));    assertFailure(mode, INTEGER.label("number"), "", 1, 1, "number");  }
@Test  public void testsetAngle() {    v1.setAngle(Math.PI / 2);    assertEquals(0, v1.getX(), 0.0001);    assertEquals(0, v1.getY(), 0.0001);    v2.setAngle(3 * Math.PI / 4);    assertEquals(-5, v2.getX(), 0.0001);    assertEquals(5, v2.getY(), 0.0001);  }
@Test    public void should_throw_import_exception_when_there_is_no_resource_folder_in_import_path() throws Exception {        Path newFolder = tempDir.newFolderPath("emptyFolder");        exception.expect(ImportException.class);        exception.expect(hasType(UNEXPECTED_ZIP_STRUCTURE));        pageImporter.doImport(anImport(newFolder));    }
@Test    public void testGetMatchingRecordFields() throws IOException, TokenExpiredException {        try(ArgusService argusService = new ArgusService(getMockedClient("/DiscoveryServiceTest.json"))) {            DiscoveryService discoveryService = argusService.getDiscoveryService();            List<String> result = discoveryService.getMatchingRecordFields("nsReg", "scpReg", "metReg", "tkReg", "tvReg", NAMESPACE, 2);            List<String> expected = Arrays.asList(new String[] { "namespace1", "namespace2" });            assertEquals(expected, result);        }    }
@Test  public void natural() {    ExprValueOrdering ordering = ExprValueOrdering.natural();    assertEquals(1, ordering.compare(integerValue(5), integerValue(4)));    assertEquals(0, ordering.compare(integerValue(5), integerValue(5)));    assertEquals(-1, ordering.compare(integerValue(4), integerValue(5)));  }
@Test    public void testCountElements() {        IndexImpl<Node> index = generateEmptyIndex();        for (Column col : index.columnStore) {            if (col.isIndexed()) {                Assert.assertEquals(index.countElements(col), 0);            }        }        NodeImpl[] nodes = generateNodesWithUniqueAttributes(index, true);        putAll(nodes, index);        for (Column col : index.columnStore) {            if (col.isIndexed()) {                Assert.assertEquals(index.countElements(col), nodes.length);            }        }    }
@Test    public void testBigIntegerFromNull() {        BigInteger actual = MapValueGetter.getAsBigInteger(map, "value");        BigInteger expected = BigInteger.ZERO;        assertEquals(expected, actual);    }
@Test    public void createTableWithoutNameTest() throws ExecutionException, UnsupportedException {        TableMetadata tableMetadata = mock(TableMetadata.class);        when(tableMetadata.getName()).thenReturn(null);        try {            mongoMetadataEngine.createTable(tableMetadata, connection);            fail("the table name is necessary");        } catch (ExecutionException e) {        }        verify(tableMetadata, times(1)).getName();    }
@Test    public void returnsAJmxAttribute() throws Exception {        when(mBeanServer.getAttribute(objectName, "attr")).thenReturn(value);        assertThat(gauge.getValue())                .isEqualTo(value);    }
@Test  public void multipleSuggestionsCreateIssueTypeNode() {    JPanel toolPanel = toolWindow.getContent();    Component[] components = toolPanel.getComponents();    OnePixelSplitter splitter = (OnePixelSplitter) components[0];    JBScrollPane leftPane = (JBScrollPane) splitter.getFirstComponent();    JViewport leftView = leftPane.getViewport();    Tree suggestionTree = (Tree) leftView.getView();    TreePath webPIssuePath =        getTreePathWithString(            suggestionTree, SuggestionDataFactory.issueTypeNodeNames.get(IssueType.WEBP));    DefaultMutableTreeNode webPIssueNode =        (DefaultMutableTreeNode) webPIssuePath.getLastPathComponent();    assertThat(webPIssueNode.getChildCount()).isEqualTo(2);  }
@Test public void cancelGoesToOnFailureWhenInFlight() throws InterruptedException {    RetryableCalls retryableCalls = new RetryableCalls();    MockWebServer server = new MockWebServer();    Retrofit retrofit = new Retrofit.Builder()        .baseUrl(server.url("/"))        .addCallAdapterFactory(retryableCalls.getFactory())        .addConverterFactory(new ToStringConverterFactory())        .build();    Service service = retrofit.create(Service.class);    final CountDownLatch failureLatch = new CountDownLatch(1);    server.enqueue(new MockResponse().setBody("Hi").setBodyDelay(1, SECONDS));    RetryableCall<String> call = service.getString();    call.enqueue(new RetryableCallback<String>() {      @Override public void onResponse(RetryableCall<String> call, Response<String> response) {        throw new AssertionError();      }      @Override public void onFailure(RetryableCall<String> call, Throwable t) {        assertThat(t).isInstanceOf(IOException.class);        assertThat(call.isCanceled()).isTrue();        failureLatch.countDown();      }      @Override public void onFailureButCanRetry(RetryableCall<String> call, IOException e) {        throw new AssertionError();      }    });    call.cancel();    assertThat(failureLatch.await(10, SECONDS)).isTrue();  }
@Test  public void testGetReportByName() throws IOException {    transport = new HttpTransceiver(url);    try {      this.avroClient = (AvroFlumeReportServer) SpecificRequestor.getClient(          AvroFlumeReportServer.class, transport);    } catch (Exception e) {      throw new IOException("Failed to open AvroReportServer at " + PORT          + " : " + e.getMessage());    }    AvroFlumeReport rep = avroClient.getReportByName("reportable1");    assertNotNull("Report 'reportable1' not found", rep);    assertTrue("Expected exactly one double metric",        rep.doubleMetrics.size() == 1);    assertTrue("Expected double metric to be equal to 0.5", rep.doubleMetrics        .get(new Utf8("doubleAttr")) == 0.5);  }
@Test    public void testAnalyseInheritanceModesSingleSampleMultiAllelicTwoPassedVariantHetShouldBeCompatibleWithAD() {        Gene gene = newGene();        List<Allele> alleles = buildAlleles("A", "T", "C");        Genotype proband = buildPhasedSampleGenotype("Cain", alleles.get(1), alleles.get(2));        assertThat(proband.getType(), equalTo(GenotypeType.HET));        VariantContext variantContext = buildVariantContext(1, 12345, alleles, proband);        System.out.println("Built variant context " + variantContext);        gene.addVariant(filteredVariant(1, 12345, "A", "T", FilterResult.pass(FilterType.FREQUENCY_FILTER), variantContext));        gene.addVariant(filteredVariant(1, 12345, "A", "C", FilterResult.pass(FilterType.FREQUENCY_FILTER), variantContext));        Pedigree pedigree = Pedigree.justProband("Cain");        InheritanceModeAnalyser instance = newInstanceForModes(pedigree, ModeOfInheritance.AUTOSOMAL_DOMINANT);        instance.analyseInheritanceModes(gene);        assertThat(gene.isCompatibleWith(ModeOfInheritance.ANY), is(true));        assertThat(gene.isCompatibleWith(ModeOfInheritance.AUTOSOMAL_DOMINANT), is(true));        assertThat(gene.isCompatibleWith(ModeOfInheritance.AUTOSOMAL_RECESSIVE), is(false));        gene.getPassedVariantEvaluations()                .forEach(variant -> {                    System.out.println(variantString(variant));                    assertThat(variant.getCompatibleInheritanceModes(), hasItem(ModeOfInheritance.AUTOSOMAL_DOMINANT));                });    }
@Test    public void whenCalibrationEndsHideDialog(){        FeatureAutoConfigurationListener listener = getConfigListener();        listener.onConfigurationFinished(mFeature,100);        verify(mView).hideCalibrationDialog();    }
@Test	public void testGetXUserId_NoUserSession(){		RangerContextHolder.setSecurityContext(null);		Long chk = rangerBizUtil.getXUserId();		Assert.assertNull(chk);	}
@DisplayName("creates server with BindAddress")  @Test  void createBindAddress() {    assertThat(WebsocketServerTransport.create("test-bind-address", 8000)).isNotNull();  }
@Test  public void testSplitBasedOnHeadroomAndWeights() throws Exception {    // Tests how the headroom info are used to split based on the capacity    // each RM claims to give us.    // Configure policy to be 50% headroom based and 50% weight based    getPolicyInfo().setHeadroomAlpha(0.5f);    initializePolicy();    List<ResourceRequest> resourceRequests = createSimpleRequest();    prepPolicyWithHeadroom(true);    Map<SubClusterId, List<ResourceRequest>> response =        ((FederationAMRMProxyPolicy) getPolicy()).splitResourceRequests(            resourceRequests, new HashSet<SubClusterId>());    // pretty print requests    prettyPrintRequests(response);    validateSplit(response, resourceRequests);    // in this case the headroom allocates 50 containers, while weights allocate    // the rest. due to weights we have 12.5 containers for each    // sublcuster, the rest is due to headroom.    checkExpectedAllocation(response, "subcluster0", 1, 42);  // 30 + 12.5    checkExpectedAllocation(response, "subcluster1", 1, 12);  // 0 + 12.5    checkExpectedAllocation(response, "subcluster2", 1, 20);  // 7.5 + 12.5    checkExpectedAllocation(response, "subcluster3", -1, -1);    checkExpectedAllocation(response, "subcluster4", -1, -1);    checkExpectedAllocation(response, "subcluster5", 1, 25);  // 12.5 + 12.5    checkTotalContainerAllocation(response, 100);  }
@Test    public void testGetDimensionInfo3b() {        WKTReader instance = new WKTReader("point", "m", "(11.0 12.0 7.0)");        DimensionInfo expResult = new DimensionInfo(3, 2, 0);        DimensionInfo result = instance.getDimensionInfo();        //        //        assertEquals(expResult, result);    }
@Test  public void invokingShutdownCreatesNewSpan() {    commandCreatesNewSpan(RedisCommand.SHUTDOWN, () -> getConnection().shutdown());    verify(mockRedisConnection()).shutdown();    commandCreatesNewSpan(RedisCommand.SHUTDOWN,        () -> getConnection().shutdown(RedisServerCommands.ShutdownOption.SAVE));    verify(mockRedisConnection()).shutdown(RedisServerCommands.ShutdownOption.SAVE);  }
@Test	public void shouldSearchByKeyValue() {		assertEquals(model.collection("children").where("children.column1", "testChildColumn0"), Arrays.asList(child1));	}
@Test    public void syntheticAllOf() {        String actual = SchemaLoader.load(get("boolAndNot")).toString();        assertThat(new JSONObject(actual), sameJsonAs(get("boolAndNot")));    }
@Test    public void testLookup04() throws Exception {        // 前処理        DefaultJndiSupport support = new DefaultJndiSupport();        String name = "java:comp/env/abc";        // JndiTemplate取得        DefaultJndiSupport_JndiTemplateStub02 template = new DefaultJndiSupport_JndiTemplateStub02();        template.setCallLookup(false);        template.setJndiNameToUse(null);        support.setJndiTemplate(template);        // super.resourceRef = false;        support.setResourceRef(false);        try {            // テスト実施            support.lookup(name);            fail();        } catch (JndiException e) {            boolean b = template.isCallLookup();            assertTrue(b);            assertEquals("java:comp/env/abc", template.getJndiNameToUse());            // 判定            assertThat(logger.getLoggingEvents(), is(asList(error(                    "Illegal JNDI context name."))));            assertEquals(NamingException.class.getName(), e.getCause()                    .getClass().getName());        }    }
@Test  public void testSerializerTypeMismatch_repeatedItemSerializer() throws Exception {    final class TestSerializer extends DefaultValueSerializer<String, Boolean> {}    config.getApiClassConfig().getMethods()        .get(methodToEndpointMethod(TestEndpoint.class.getMethod("getResultNoParams")))        .addParameter("param", null, false, null, TypeToken.of(Integer[].class))        .setRepeatedItemSerializer(TestSerializer.class);    try {      validator.validate(config);      fail("Expected WrongSerializerTypeException.");    } catch (WrongTransformerTypeException expected) {    }  }
@Test    void unixPathEndingWithSeparator() {        assertEquals("test/", PathUtils.unixPathEndingWithSeparator("test"));        assertEquals("test/path/", PathUtils.unixPathEndingWithSeparator("test", "path"));        assertEquals("test/path/", PathUtils.unixPathEndingWithSeparator("test\\path"));        assertEquals("test/path/subpath/", PathUtils.unixPathEndingWithSeparator("test", "path", "subpath"));        assertEquals("test/path/subpath/", PathUtils.unixPathEndingWithSeparator("test\\path\\subpath"));    }
@Test  public void testBuilder() {    ReorderDecorator.builder().build(new Context(), "0.0", "0.0");  }
@Test    public void testSetInvalidLength() throws Exception {        final CharArrayBuffer buffer = new CharArrayBuffer(4);        try {            buffer.setLength(-2);            Assert.fail("IndexOutOfBoundsException should have been thrown");        } catch (final IndexOutOfBoundsException ex) {            // expected        }        try {            buffer.setLength(200);            Assert.fail("IndexOutOfBoundsException should have been thrown");        } catch (final IndexOutOfBoundsException ex) {            // expected        }    }
@Test  public void setVariableChecksValueLength() {    execution.setVariable("foo", "bar");    verify(workflowDao).checkStateVariableValueLength("foo", "bar");  }
@Test  public void testGetConnection() throws Exception {    URLStreamProvider streamProvider = createNiceMock(URLStreamProvider.class);    HttpURLConnection urlConnection = createNiceMock(HttpURLConnection.class);    ViewContext viewContext = createNiceMock(ViewContext.class);    Map<String, String> headers = new HashMap<String, String>();    headers.put("header", "headerValue");    Map<String, List<String>> headerMap = new HashMap<String, List<String>>();    headerMap.put("header", Collections.singletonList("headerValue"));    expect(streamProvider.processURL(eq("spec"),                                     eq("requestMethod"),                                     aryEq("params".getBytes()),                                     eq(headerMap))).andReturn(urlConnection);    replay(streamProvider, urlConnection);    ViewURLStreamProvider viewURLStreamProvider = new ViewURLStreamProvider(viewContext, streamProvider);    Assert.assertEquals(urlConnection, viewURLStreamProvider.getConnection("spec", "requestMethod", "params", headers));    verify(streamProvider, urlConnection);  }
@Test(expectedExceptions = ZusammenException.class)  public void testCreateBasedOnNonExisting()  {    Id itemId = new Id();    Id baseVersionId = new Id();    mockNonExistingVersion(Space.PRIVATE, itemId, baseVersionId);    itemVersionManagerImpl.create(context, itemId, baseVersionId, new ItemVersionData());  }
@Test    public void shouldSuccessfullyDeserializeStringToJson() {        String jsonString = getJsonString();        MoshiSerializationStrategy<Cinema>                serializationStrategy = getMoshiSerializationStrategy();        Cinema cinema = serializationStrategy.deserialize(jsonString);        assertNotNull(cinema);        assertCinema(cinema);    }
@Test  public void testPreUpgradeCheckNotApplicable() throws Exception {    final CheckHelper helper = new CheckHelper();    List<AbstractCheckDescriptor> updateChecksRegistry = new ArrayList<AbstractCheckDescriptor>();    AbstractCheckDescriptor descriptor = EasyMock.createNiceMock(AbstractCheckDescriptor.class);    EasyMock.expect(descriptor.isApplicable(EasyMock.<PrereqCheckRequest> anyObject())).andReturn(false);    EasyMock.replay(descriptor);    updateChecksRegistry.add(descriptor);    helper.performChecks(new PrereqCheckRequest("cluster"), updateChecksRegistry);    EasyMock.verify(descriptor);  }
@Test	public void usoDocumentoVitalDBEntityTest() {		Assert.notNull(getManager(), "ArchidocManager es nulo");		IUsoDocumentoVitalDBEntity dbEntity = getManager()				.getUsoDocumentoVitalDBEntity();		Assert.notNull(dbEntity, "entity es nulo");		Assert.isTrue(ArchivoTables.ADPCUSODOCVIT_TABLE_NAME.equals(dbEntity				.getTableName()),"Las tablas no coinciden");		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount()));	}
@Test  public void testMultipleItemStream() throws Exception {    Future<Void> producerFuture =        executor.submit(            new Callable<Void>() {              @Override              public Void call() {                for (int i = 0; i < 5; i++) {                  int requestCount = controller.popLastPull();                  Truth.assertWithMessage("ServerStream should request one item at a time")                      .that(requestCount)                      .isEqualTo(1);                  stream.observer().onResponse(i);                }                stream.observer().onComplete();                return null;              }            });    Future<List<Integer>> consumerFuture =        executor.submit(            new Callable<List<Integer>>() {              @Override              public List<Integer> call() {                return Lists.newArrayList(stream);              }            });    producerFuture.get(60, TimeUnit.SECONDS);    List<Integer> results = consumerFuture.get();    Truth.assertThat(results).containsExactly(0, 1, 2, 3, 4);  }
@Test(expected = NullPointerException.class)  public void nullHost() throws Exception {    OfframpOptions.builder(String.class).host(null);  }
@Test    public void testUsingWithSubscribingTwice() {        // When subscribe is called, a new resource should be created.        Func0<Resource> resourceFactory = new Func0<Resource>() {            @Override            public Resource call() {                return new Resource() {                    boolean first = true;                    @Override                    public String getTextFromWeb() {                        if (first) {                            first = false;                            return "Hello world!";                        }                        return "Nothing";                    }                    @Override                    public void unsubscribe() {                    }                    @Override                    public boolean isUnsubscribed() {                        return false;                    }                };            }        };        Func1<Resource, Observable<String>> observableFactory = new Func1<Resource, Observable<String>>() {            @Override            public Observable<String> call(Resource resource) {                return Observable.from(resource.getTextFromWeb().split(" "));            }        };        @SuppressWarnings("unchecked")        Observer<String> observer = (Observer<String>) mock(Observer.class);        Observable<String> observable = Observable.create(using(                resourceFactory, observableFactory));        observable.subscribe(observer);        observable.subscribe(observer);        InOrder inOrder = inOrder(observer);        inOrder.verify(observer, times(1)).onNext("Hello");        inOrder.verify(observer, times(1)).onNext("world!");        inOrder.verify(observer, times(1)).onCompleted();        inOrder.verify(observer, times(1)).onNext("Hello");        inOrder.verify(observer, times(1)).onNext("world!");        inOrder.verify(observer, times(1)).onCompleted();        inOrder.verifyNoMoreInteractions();    }
@Test    void testGetSelectionSummary() {        setup();        SelectionSummary selectionSummary = metaDao.getSelectionSummary(new FindMetaCriteria(MetaExpressionUtil.createFeedExpression(TEST1_FEED_NAME)));        assertThat(selectionSummary.getItemCount()).isEqualTo(20);        selectionSummary = metaDao.getSelectionSummary(new FindMetaCriteria(MetaExpressionUtil.createFeedExpression(TEST2_FEED_NAME)));        assertThat(selectionSummary.getItemCount()).isEqualTo(20);        selectionSummary = metaDao.getSelectionSummary(new FindMetaCriteria(MetaExpressionUtil.createFeedsExpression(TEST1_FEED_NAME, TEST2_FEED_NAME)));        assertThat(selectionSummary.getItemCount()).isEqualTo(40);        selectionSummary = metaDao.getSelectionSummary(new FindMetaCriteria(MetaExpressionUtil.createFeedsExpression()));        assertThat(selectionSummary.getItemCount()).isEqualTo(0);        final ExpressionOperator expression = new ExpressionOperator.Builder(Op.AND)                .addTerm(MetaFields.FEED_NAME, Condition.EQUALS, TEST1_FEED_NAME)                .addTerm(MetaFields.TYPE_NAME, Condition.EQUALS, RAW_STREAM_TYPE_NAME)                .build();        selectionSummary = metaDao.getSelectionSummary(new FindMetaCriteria(expression));        assertThat(selectionSummary.getItemCount()).isEqualTo(10);    }
@Test(timeout = TIMEOUT)    public void testSingleByteRead() throws IOException {        InputStream is = new MergeBytesInputStream(new ByteArrayInputStream(TEST_DATA));        assertEquals(0x44, is.read());        assertEquals(MergeBytesInputStream.BEGIN_FRAME, is.read());        assertEquals(0x55, is.read());        assertEquals(0x85, is.read());        assertEquals(0x00, is.read());        assertEquals(0x80, is.read());        is.close();    }
@Test  public void testGetArray() {    assertArrayEquals(new byte[] {(byte) -1, 0, 1, 2, 3}, test.getArray());  }
@Test  public void testRemoteAddrWithTrustedProxy() {    assertEquals(clientAddr, getRemoteAddr(clientAddr, proxyAddr, true));    assertEquals(clientAddr, getRemoteAddr(chainedClientAddr, proxyAddr, true));  }
@Test	public void shouldSerializeCollectionWithPrefixTag() {		String expectedResult = "{\"price\":15.0,\"comments\":\"pack it nicely, please\"}";		expectedResult += ',' + expectedResult;		expectedResult = "{\"orders\":[" + expectedResult + "]}";		Order order = new Order(new Client("guilherme silveira"), 15.0, "pack it nicely, please");		serialization.from(Arrays.asList(order, order), "orders").serialize();		assertThat(result(), is(equalTo(expectedResult)));	}
@Test    public void testSaveRainyDayDictionary() {        logger.info("testSaveRainyDayDictionary: Entering");        MockHttpServletResponse response = new MockHttpServletResponse();        request = mock(HttpServletRequest.class);        try {            // mock the getReader() call            jsonString = "{\"rainyDayDictionaryData\":{\"bbid\":\"BB2\",\"workstep\":\"1\",\"userDataTypeValues\""                    + ":[{\"$$hashKey\":\"object:233\",\"treatment\":\"test1\"},{\"$$hashKey\":\"object:239\","                    + "\"treatment\":\"test2\"}]},\"userid\":\"mm117s\"}";            BufferedReader br = new BufferedReader(new StringReader(jsonString));            when(request.getReader()).thenReturn(br);            controller.saveRainyDayDictionary(request, response);            logger.info("response.getContentAsString(): " + response.getContentAsString());            assertTrue(response.getContentAsString() != null                    && response.getContentAsString().contains("rainyDayDictionaryDatas"));        } catch (Exception e) {            logger.error("Exception Occured" + e);            fail("Exception: " + e);        }        logger.info("testSaveRainyDayDictionary: exit");    }
@Test    public void testInvokeLater() {        assertThat(SwingUtilities.isEventDispatchThread(), is(false));                Callable<Void> callable = new Callable<Void>() {            @Override            public Void call() throws Exception {                assertThat(SwingUtilities.isEventDispatchThread(), is(true));                                //wait a long time                Thread.sleep(1000);                                return null;            }        };                long start = System.currentTimeMillis();        FutureTask<Void> task = SwingXUtilities.invokeLater(callable);        assertThat((System.currentTimeMillis() - start) < 100, is(true));    }
@Test    public void shouldLoginUser() throws Exception {        task.onPreExecute();        task.execute();        verify(loginService).login(applicationContext, "username", "password", "serverUrl");    }
@Test    public void testGetTimeRange() throws ParseException {        final Configuration config = new Configuration();        config.put("start", "1978-01-01T00:00:00Z");        config.put("stop", "1979-01-01T00:00:00Z");        final TimeRange timeRange = ConfigUtil.getTimeRange("start", "stop", config);        assertNotNull(timeRange);        final Date startDate = timeRange.getStartDate();        assertEquals(TimeUtil.parseCcsdsUtcFormat("1978-01-01T00:00:00Z").getTime(), startDate.getTime());        final Date stopDate = timeRange.getStopDate();        assertEquals(TimeUtil.parseCcsdsUtcFormat("1979-01-01T00:00:00Z").getTime(), stopDate.getTime());    }
@Test    public void testIsLastPage_NotLast() {        PaginationInfo info = new PaginationInfo(page, pathTmpl, queryTmpl, 0);        // run        boolean result = info.isLastPage();        // assert        assertThat(result, is(false));    }
@Test    void getResourceWhenResourceDirNotSet()    {        assertNull(this.environment.getResource("doesntexist"));    }
@Test(timeout=60000)  public void testNonDefaultNonBrowserUserAgentAsNonBrowser() throws Exception {    if (handler != null) {      handler.destroy();      handler = null;    }    handler = getNewAuthenticationHandler();    Properties props = getDefaultProperties();    props.setProperty("alt-kerberos.non-browser.user-agents", "foo, bar");    try {      handler.init(props);    } catch (Exception ex) {      handler = null;      throw ex;    }    // Run the kerberos tests again    testRequestWithoutAuthorization();    testRequestWithInvalidAuthorization();    testRequestWithAuthorization();    testRequestWithInvalidKerberosAuthorization();  }
@Test    public void testVerifyNullInput() {        try {            assertFalse(crypto.verify(null, SIGNING_ALGORITHM, null, null));        } catch (CryptoException e) {            fail("testVerifyNullInput should not have thrown exception. Error: " + e.getMessage());        }    }
@Test    public void testNoOpSegmentWithTraceId() {        TraceID traceID = TraceID.create();        Segment segment = AWSXRay.getGlobalRecorder().beginNoOpSegment(traceID);        assertThat(segment.getTraceId()).isEqualTo(traceID);    }
@Test  public void testSetHtmlPageAvailable() throws Exception {    assertTrue( roh.isHtmlPageAvailable() );    roh.setHtmlPageAvailable( false );    assertFalse( roh.isHtmlPageAvailable() );  }
@Test    void investingNoStrategy() {        final Loan loan = new MockLoanBuilder()            .set(LoanImpl::setAmount, Money.from(2))            .build();        final LoanDescriptor ld = new LoanDescriptor(loan);        final Zonky z = AbstractZonkyLeveragingTest.harmlessZonky();        final PowerTenant tenant = mockTenant(z);        final InvestingOperationDescriptor d = mockInvestingOperationDescriptor(ld);        final StrategyExecutor<LoanDescriptor, InvestmentStrategy, Loan> exec = new StrategyExecutor<>(tenant, d);        assertThat(exec.get()).isEmpty();        // check events        final List<Event> events = getEventsRequested();        assertThat(events).isEmpty();    }
@Test    public void setupWithoutCommand() {        errorReportPopupView.setup(ERROR_TITLE_TEXT, ERROR_CONTENT_TEXT, KEEP_TEXT, MX, MY, PopoverView.Position.RIGHT);        verify(errorReportPopupView, times(1)).addWidgetToRootPanel();        verify(popoverElementMock, times(1)).setAttribute(TITLE, ERROR_TITLE_TEXT);        verify(jQueryPopoverMock, times(1)).wrap(elementMock);        verify(popoverMock, times(1)).popover(isA(PopoverOptions.class));        verify(styleMock, times(1)).setProperty(eq(TOP),eq(TOP_PX));        verify(styleMock, times(1)).setProperty(eq(LEFT), eq(LEFT_PX));        verify(styleMock, times(1)).setProperty(eq(POSITION),eq(ABSOLUTE));        verify(errorContentMock, times(1)).setTextContent(eq(ERROR_CONTENT_TEXT));        verify(keepButtonMock, times(1)).setInnerText(eq(KEEP_TEXT));        verify(applyButtonMock.getStyle(), times(1)).setDisplay(eq(Style.Display.NONE));    }
@Test    public void queryAlertsByCTime() throws Exception {        int numTenants = 1;        int numTriggers = 5;        int numAlerts = 5;        createTestAlerts(numTenants, numTriggers, numAlerts);        Set<String> tenantIds = new HashSet<>();        tenantIds.add("tenant0");        AlertsCriteria criteria = new AlertsCriteria();        criteria.setStartTime(2L);        criteria.setEndTime(2L);        List<Alert> ctime2Alerts = alerts.getAlerts(tenantIds, criteria, null);        assertEquals(5, ctime2Alerts.size());        criteria.setEndTime(null);        List<Alert> ctimeGTE2Alerts = alerts.getAlerts(tenantIds, criteria, null);        assertEquals(5 * 4, ctimeGTE2Alerts.size());        deleteTestAlerts(numTenants);    }
@DisplayName("from returns ApplicationErrorException")  @Test  void fromApplicationException() {    ByteBuf byteBuf = createErrorFrame(1, APPLICATION_ERROR, "test-message");    assertThat(Exceptions.from(1, byteBuf))        .isInstanceOf(ApplicationErrorException.class)        .hasMessage("test-message");    assertThat(Exceptions.from(0, byteBuf))        .isInstanceOf(IllegalArgumentException.class)        .hasMessage(            "Invalid Error frame in Stream ID 0: 0x%08X '%s'", APPLICATION_ERROR, "test-message");  }
@Test(expected = IllegalStateException.class)    public void shouldFailToCreateTimeoutIfTimerNotRunning() throws Exception {        timer.newTimeout(new Timer.TimeoutTask() {            @Override            public void run(Timer.TimeoutHandle timeoutHandle) {                // empty            }        }, 5, TimeUnit.SECONDS);    }
@Test  public void delegate() throws Exception {    final ExecutorService exec = mock( ExecutorService.class );    final DelegatedListenableExecutor delegatedListenableExecutor = new DelegatedListenableExecutor( exec );    final ListeningExecutorService delegate = delegatedListenableExecutor.delegate();    final Callable callable = mock( Callable.class );    delegate.submit( callable );    verify( exec, times( 1 ) ).execute( any( Runnable.class ) );  }
@Test    public void testDownsampleTransformCountOneMetric() {        Transform downsampleTransform = new DownsampleTransform();        Map<Long, Double> datapoints_1 = new HashMap<Long, Double>();        datapoints_1.put(1L, 1.0);        datapoints_1.put(1000L, 1.0);        datapoints_1.put(2000L, 2.0);        datapoints_1.put(3000L, 3.0);        datapoints_1.put(4000L, 4.0);        datapoints_1.put(5000L, 5.0);        datapoints_1.put(6000L, 6.0);        datapoints_1.put(7000L, 7.0);        datapoints_1.put(8000L, 8.0);        datapoints_1.put(9000L, 9.0);        Metric metric_1 = new Metric(TEST_SCOPE + "1", TEST_METRIC);        metric_1.setDatapoints(datapoints_1);        List<Metric> metrics = new ArrayList<Metric>();        metrics.add(metric_1);        List<String> constants = new ArrayList<String>();        constants.add("3s-count");        Map<Long, Double> expected_1 = new HashMap<Long, Double>();        expected_1.put(0L, 3.0);        expected_1.put(3000L, 3.0);        expected_1.put(6000L, 3.0);        expected_1.put(9000L, 1.0);        List<Metric> result = downsampleTransform.transform(null, metrics, constants);        assertEquals(result.size(), 1);        assertEquals(expected_1, result.get(0).getDatapoints());    }
@Test    void withoutContentTypeShouldMatch() {        final Predicate<HttpMessage> unit = withoutContentType();        assertThat(unit.test(request.withContentType(null)), is(true));    }
@Test public void testTag() {		// Arrange:		final FragmentRequest request = new FragmentRequest(mock(FragmentController.class), FragmentRequest.NO_ID);		// Act + Assert:    	assertThat(request.tag("TAG.TestFragment"), is(request));    	assertThat(request.tag(), is("TAG.TestFragment"));	}
@Test    public void testDoIt_calls_afterburner() throws CannotCompileException, AfterBurnerImpossibleException {        //GIVEN        afterBurnerMock = EasyMock.createMock(AfterBurner.class);        afterBurnerMock.addOrInsertMethod((InsertableMethod) EasyMock.anyObject());        EasyMock.replay(afterBurnerMock);        builder = new InsertableMethodBuilder(afterBurnerMock, null);        CtClass classToInsertInto = CtClass.intType;        String targetMethod = "";        String insertionAfterMethod = "";        String fullMethod = "";        String body = "";        //WHEN        builder            .insertIntoClass(classToInsertInto)            .inMethodIfExists(targetMethod)            .afterACallTo(insertionAfterMethod)            .withBody(body)            .elseCreateMethodIfNotExists(fullMethod)            .doIt();        //THEN        EasyMock.verify(afterBurnerMock);    }
@SuppressWarnings("unchecked")    @Test    public void testRemoveItem() throws PAPException {        assertTrue(container.removeItem(group));        PAPPolicyEngine mockPAPPolicyEngine = Mockito.mock(PAPPolicyEngine.class);        PDPGroupContainer groupContainer = new PDPGroupContainer(mockPAPPolicyEngine);        when(mockPAPPolicyEngine.getDefaultGroup()).thenThrow(PAPException.class);        assertFalse(groupContainer.removeItem(group));    }
@Test	public void test35deleteXGroupGroup() {		boolean forceDelete = false;				Mockito.doNothing().when(xUserMgr).deleteXGroupGroup(id, forceDelete);		xUserRest.deleteXGroupGroup(id,request);		Mockito.verify(xUserMgr).deleteXGroupGroup(id,forceDelete);	}
@Test    public void create_a_displayed_container() throws Exception {        ParametrizedWidgetFactory elementFactory = createFactory();        ContractInput input = mock(ContractInput.class);        when(input.isMultiple()).thenReturn(false);        WidgetContainer container = elementFactory.createWidgetContainer(input);        AbstractParametrizedWidgetAssert.assertThat(container).isDisplayed();    }
@Test    void should_be_not_set_when_not_exist_evcache_secure_port() {        processor.postProcessEnvironment(environment, null);        assertThat(environment.containsProperty("eureka.instance.metadata-map.evcache.secure.port")).isFalse();    }
@Test public void recBuffer07() {        RecordBuffer rb = make(4,5);        contains(rb, 2, 4, 6, 8);        rb.shiftUp(3);        rb.set(3, r(1));        contains(rb, 2, 4, 6, 1, 8);        rb.shiftDown(3);        contains(rb, 2, 4, 6, 8);    }
@Test  public void alreadyExists() {    Truth.assertThat(createException(Code.ALREADY_EXISTS))        .isInstanceOf(AlreadyExistsException.class);    Truth.assertThat(createExceptionWithMessage(Code.ALREADY_EXISTS))        .isInstanceOf(AlreadyExistsException.class);  }
@Test    public void testGetEmojisFromMessage() {        Message message = new Message(mentionTime, "randomFrom", "randomUserId",                                      String.format("test message with :%s:", emoji),                                      "randomRoomId", MessageType.MESSAGE);        FatMessage fatMessage = new FatMessage(message, user, room);        List<EmojiEntity> emojis = underTest.getEmojisFromMessage(fatMessage);        assertEquals(1, emojis.size());        EmojiEntity firstEmoji = emojis.get(0);        assertEquals(user.getMentionName(), firstEmoji.getUsername());        assertEquals(room.getName(), firstEmoji.getRoomName());        assertEquals(mentionTime, firstEmoji.getMentionTime());        assertEquals(emoji, firstEmoji.getValue());        assertEquals(1, firstEmoji.getOccurrences());    }
@Test    public void testBasicUriWithSettingsGeneration() {        Rollover rollover = new Rollover.Builder("twitter").conditions(rolloverConditions).settings(rolloverSettings).build();        assertEquals("POST", rollover.getRestMethodName());        assertEquals("twitter/_rollover", rollover.getURI(ElasticsearchVersion.UNKNOWN));        assertEquals("{\"settings\":{\"index.number_of_shards\":\"2\"},\"conditions\":{\"max_age\":\"1d\",\"max_docs\":\"10000\"}}", rollover.getData(new Gson()));    }
@Test    public void jsonview_persitence_should_manage_all_fields() throws Exception {        Page pageInitial = createAFilledPage();        //We serialize and deserialize our object        Page pageAfterJsonProcessing = objectMapper.readValue(                objectMapper.writeValueAsString(pageInitial),                Page.class);        assertThat(pageAfterJsonProcessing.getName()).isNotNull();        assertThat(pageAfterJsonProcessing.getId()).isNotNull();        assertThat(pageAfterJsonProcessing.getVariables()).isNotEmpty();        assertThat(pageAfterJsonProcessing.getRows()).isNotNull();        assertThat(((Component) ((Container) pageAfterJsonProcessing.getRows().get(0).get(1)).getRows().get(1).get(1)).getDescription()).isNotNull().isNotEmpty();    }
@Test  public void testFindAllCurrent() {    List<AlertCurrentEntity> currentAlerts = m_dao.findCurrent();    assertNotNull(currentAlerts);    assertEquals(5, currentAlerts.size());  }
@Test	public void testIsCancelCheckoutDocumentActionAvailableWithNullFileEntry()		throws PortalException {		_configureDLFileEntryPermission(true, true);		FileEntryDisplayContextHelper fileEntryDisplayContextHelper =			new FileEntryDisplayContextHelper(null, null);		Assert.assertFalse(			fileEntryDisplayContextHelper.				isCancelCheckoutDocumentActionAvailable());	}
@Test    public void testCancel01() {        Reserve reserve = new Reserve("001");        reserve.setAdultCount(1);        reserve.setChildCount(2);        TourInfo tour = new TourInfo("01");        reserve.setTourInfo(tour);        reserve.setTransfer(Reserve.NOT_TRANSFERED);        when(reserveRepository.findById("001")).thenReturn(Optional.of(                reserve));        when(reserveRepository.findOneForUpdate("001")).thenReturn(reserve);        when(tourInfoSharedService.isOverPaymentLimit(tour)).thenReturn(false); // within limit        reserveService.cancel("001");        ArgumentCaptor<String> argOfDelete = ArgumentCaptor.forClass(                String.class);        verify(reserveRepository, times(1)).deleteById(argOfDelete.capture());        assertThat(argOfDelete.getValue(), is("001"));    }
@Test	public void testAliasByTagTransformOneValidOneInvalidTagKey() {		Metric metric = new Metric("scope", "metric");		metric.setTag("device", "someDevice");		metric.setTag("target", "someTarget");				Metric actual = aliasByTagTransform.transform(null, Arrays.asList(metric), Arrays.asList("devicessss", "target")).get(0);		assertEquals("someTarget", actual.getDisplayName());	}
@Test(dependsOnMethods = "testExecuteWithoutProperties", description = "testing execute method without properties " +            "and operation type config")    public void testExecutionWithoutPropertiesNonCommandType() throws PushNotificationExecutionFailedException {        operation.setType(Operation.Type.CONFIG);        operation.setProperties(null);        notificationContext = new NotificationContext(deviceIdentifier, operation);        mqttNotificationStrategy.execute(notificationContext);    }
@Test	public void testFromJsonString() {		WrenchStamped p = WrenchStamped.fromJsonString(w1.toString());		assertEquals(w1.toString(), p.toString());		assertEquals(w1.toJsonObject(), p.toJsonObject());		assertEquals(w1.getMessageType(), p.getMessageType());		assertEquals(w1.getHeader(), p.getHeader());		assertEquals(w1.getWrench(), p.getWrench());		assertNotSame(w1, p);		assertNotSame(w1.toString(), p.toString());		assertNotSame(w1.toJsonObject(), p.toJsonObject());	}
@Test        public void tcListStringCompare_0_0_Wert()        {        	ArrayList<String> List_1 = new ArrayList<String>();        	ArrayList<String> List_2 = new ArrayList<String>();            Boolean expected = true;            Boolean actual = true;            actual = OKW_Helper.compareListString(List_1, List_2);            assertEquals(expected, actual);        }
@Test    void security() {        assertTrue(JvmVersion.security() >= 0);    }
@Test    void findInNotRequired() {        final Foo expected = InjectorUtil.findIn(Foo.class, injector, instances, false);        assertEquals(foo, expected);        assertNull(InjectorUtil.findIn(Integer.class, injector, instances, false));    }
@Test    public void testGracefulFailure() throws Exception {        InstallReferrerReceiver receiver = new InstallReferrerReceiver();        Intent badIntent = new Intent("bad.action");        badIntent.setPackage(Robolectric.application.getPackageName());        String testReferrerData1 = "utm_source=test_source&utm_medium=test_medium&utm_term=test_term&utm_content=test_content&utm_campaign=test_name";        badIntent.putExtra(InstallReferrerReceiver.ARG_KEY_GPLAY_REFERRER, testReferrerData1);        receiver.onReceive(Robolectric.application.getApplicationContext(), badIntent);        Thread.sleep(250);        String referrerDataFromPreferences = getMatomo().getPreferences().getString(InstallReferrerReceiver.PREF_KEY_INSTALL_REFERRER_EXTRAS, null);        assertNull(referrerDataFromPreferences);        Intent nullIntent = new Intent();        nullIntent.setPackage(Robolectric.application.getPackageName());        testReferrerData1 = "utm_source=test_source&utm_medium=test_medium&utm_term=test_term&utm_content=test_content&utm_campaign=test_name";        nullIntent.putExtra(InstallReferrerReceiver.ARG_KEY_GPLAY_REFERRER, testReferrerData1);        receiver.onReceive(Robolectric.application.getApplicationContext(), nullIntent);        Thread.sleep(250);        referrerDataFromPreferences = getMatomo().getPreferences().getString(InstallReferrerReceiver.PREF_KEY_INSTALL_REFERRER_EXTRAS, null);        assertNull(referrerDataFromPreferences);    }
@Test    public void test_agentmain_unknownAction() throws Exception {        DcmAgent.agentmain("  unknownAction  arg1  arg2   file " + outputFilePath);        final List<String> content = FileUtils.readLines(outputFile);        assertThat(content.get(0), containsString("No action in agent argument, do nothing!"));    }
@Test    public void outputTest() {        List<Map<String, Object>> stuff = ImmutableList.of(                ImmutableMap.of("a", "1", "b", 2),                ImmutableMap.of("b", 2, "c", 3, "d", 4),                ImmutableMap.of("a", ImmutableList.of(1, 2, 3)));        ByteArrayOutputStream out = new ByteArrayOutputStream();        PrintStream stream = new PrintStream(out);        Exporters.csv(stream).export(stuff);        StringBuilder expected = new StringBuilder();        expected.append("a,b,c,d").append(System.lineSeparator())                .append("1,2,null,null").append(System.lineSeparator())                .append("null,2,3,4").append(System.lineSeparator())                .append("\"1,2,3\",null,null,null");        Assert.assertEquals(expected.toString(), out.toString());    }
@Test    public void update() throws Exception {        //given        RegistrationManager reg = registered();        trnsport.when(newCoapPacket(2).post().uriPath("/stub/0001"))                .then(newCoapPacket(2).ack(Code.C204_CHANGED).maxAge(101));        //when        runScheduledTask();        //then        assertTrue(reg.isRegistered());        verifyScheduledInSec(71L);    }
@Test  public void testEquals() throws Exception {    EqualsVerifier      .forClass(ServiceConfigVersionResponse.class)      .suppress(Warning.NONFINAL_FIELDS)      .verify();  }
@Test  @Ignore  public void testMainProgramHTML() throws Exception {    assertEquals(0, Main.mainProgram(new String[]{"-OUTPUT_FILE:" + getJJDocOutputDirectory() + "JavaCC.html", getJJInputDirectory() + "JavaCC.jj"}));  }
@Test    public void deserializesLinkedHashSets() {        Node value = Node.fromStrings("a", "b");        NodeMapper mapper = new NodeMapper();        Set<String> result = mapper.deserializeCollection(value, LinkedHashSet.class, String.class);        assertThat(result, instanceOf(LinkedHashSet.class));        assertThat(result, contains("a", "b"));    }
@Test	public void shouldBeAbleToConvertNull() {		assertThat(converter.convert(null, LocalDateTime.class, bundle), is(nullValue()));	}
@Test    void testLaxBuildWithDescriptorsWithUnknownParents() {        DeploymentDescriptor deploymentDescriptor = buildDeploymentDescriptor(FOO_ID);        ExtensionDescriptor extensionDescriptor1 = buildExtensionDescriptor(BAR_ID, FOO_ID);        ExtensionDescriptor extensionDescriptor2 = buildExtensionDescriptor(QUX_ID, BAZ_ID);        List<ExtensionDescriptor> extensionDescriptors = Arrays.asList(extensionDescriptor2, extensionDescriptor1);        List<ExtensionDescriptor> expectedExtensionDescriptorChain = Collections.singletonList(extensionDescriptor1);        ExtensionDescriptorChainBuilder extensionDescriptorChainBuilder = new ExtensionDescriptorChainBuilder(false);        List<ExtensionDescriptor> extensionDescriptorChain = extensionDescriptorChainBuilder.build(deploymentDescriptor,                                                                                                   extensionDescriptors);        assertEquals(expectedExtensionDescriptorChain, extensionDescriptorChain);    }
@Test  public void testShortHelpSwitch() {    exit.expectSystemExitWithStatus(0);    FSConfigToCSConfigConverterMain.main(new String[] {"-h"});    verifyHelpText();  }
@Test    public void test_getFolders() throws Exception {        String responseJson = "{  \"keys\": [    \"mysafe01\"  ]}";        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseJson);        when(safesService.getFolders("5PDrOhsy4ig8L3EpsJZSLAMg", "users/safe1")).thenReturn(responseEntityExpected);        mockMvc.perform(MockMvcRequestBuilders.get("/v2/sdb/folder?path=users/safe1")                .header("vault-token", "5PDrOhsy4ig8L3EpsJZSLAMg")                .header("Content-Type", "application/json;charset=UTF-8"))                .andExpect(status().isOk())                .andExpect(content().string(containsString(responseJson)));    }
@Test  public void testPolyWithPoly() {    final SimpleFeature feature1 =        createFeature(            factory.createPolygon(                new Coordinate[] {                    new Coordinate(0.000, 0.000),                    new Coordinate(-0.000, -0.001),                    new Coordinate(-0.001, -0.001),                    new Coordinate(0.00, 0.00)}));    final SimpleFeature feature2 =        createFeature(            factory.createPolygon(                new Coordinate[] {                    new Coordinate(0.001, 0.001),                    new Coordinate(0.001, 0.002),                    new Coordinate(0.002, 0.002),                    new Coordinate(0.001, 0.001)}));    testBounds(functionUnderTest.measure(feature1, feature2), 100, 200);  }
@Test  void discoverUnaryDiscardEmptyColumns() throws Exception {    configuration.setProcessEmptyColumns(false);    unarySQL.execute(configuration);    verify(resultReceiver, atLeastOnce()).receiveResult(ind.capture());    assertThat(ind.getAllValues())        .hasSize(1)        .first()        .isEqualTo(validInd());  }
@Test    public void testSetContext_historyShapeIsSetFromDimensionMap() {        final Map<String, Integer> dimensionConfiguration = new HashMap<>();        dimensionConfiguration.put(Constants.DIMENSION_NAME_INSITU_NTIME, 82);        final Context context = new ContextBuilder().dimensionConfiguration(dimensionConfiguration).build();        final InsituMohcId insituMohcId = new InsituMohcId();        insituMohcId.setContext(context);        assertNotNull(insituMohcId.historyShape);        assertArrayEquals(new int[]{1, 82}, insituMohcId.historyShape);    }
@Test  public void evaluate_MockData_ShouldBeExpectedScalar3() throws CelloException {    Map<Variable, Double> args = new HashMap<>();    args.put(lut.getVariables().findCObjectByName("x"), 4.0);    args.put(lut.getVariables().findCObjectByName("bin"), 4.0);    assertEquals(lut.evaluate(args), 8.0, TOLERANCE);  }
@Test(dependsOnMethods="testDelete")    public void testDataSourceHasDataSets() {        metadata.read(() -> {            Optional<DataSource> dsrc = this.dataSourceProvider.find(dSrcIds.get(0));                        assertThat(dsrc).isNotNull().isPresent();                        List<? extends DataSet> dsList = dsrc.get().getDataSets();                        assertThat(dsList).hasSize(COUNT);        }, MetadataAccess.SERVICE);    }
@Test	public void testParse() throws JSONException {		final BasicVotesJsonParser parser = new BasicVotesJsonParser();		final BasicVotes basicVotes = parser.parse(ResourceUtil.getJsonObjectFromResource("/json/votes/valid.json"));		assertEquals(1, basicVotes.getVotes());		assertTrue(basicVotes.hasVoted());		assertEquals(TestUtil.toUri("http://localhost:8090/jira/rest/api/latest/issue/TST-1/votes"), basicVotes.getSelf());	}
@Test    public void shouldDeserializeCustomTrueToTrueUsingCustomBooleanFormat()throws Exception {        TypeDeserializer<Boolean> toTest = newToTest();        assertTrue(deserialize(toTest, "ffff"));    }
@Test	public void testExecuteDeleteDocumentRequest() {		DeleteDocumentRequest deleteDocumentRequest = new DeleteDocumentRequest(			null, null);		_elasticsearchDocumentRequestExecutor.executeDocumentRequest(			deleteDocumentRequest);		Mockito.verify(			_deleteDocumentRequestExecutor		).execute(			deleteDocumentRequest		);	}
@Test    public void testClear() {        BufferedImage img = GraphicsUtilities.createCompatibleImage(1, 1);        GraphicsUtilities.clear(img);        assertThat(GraphicsUtilities.getPixels(img, 0, 0, 1, 1, null)[0], is(0));    }
@Test    void decodeAndDropAuthorityRelative() {        assertThat(UriEncoderDecoder.decodeAndDropAuthority(                URI.create("%D1%83%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C1/%D1%83%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1" +                "%8C%202%3D/%26%D1%84%D0%B0%D0%B9%D0%BB%20%D0%BF%D1%80%D0%BE%D0%B1%D0%B5%D0%BB%2B" +                "%D0%BF%D0%BB%D1%8E%D1%81"))).isEqualTo("уровень1/уровень 2=/&файл пробел+плюс");    }
@Test    public void readPushIntegerMin64BitInt() throws DeserializationException {        this.arrayBuilder = new ByteArrayBuilder().setPrefix("030000000000000080");        readPushInteger();        assertThat(this.readResultInt, is(BigInteger.valueOf(-9_223_372_036_854_775_808L)));    }
@Test  public void testOffset() {    OnlineSummarizer s = new OnlineSummarizer();    Sampler<Double> sampler = new Normal(2, 5);    for (int i = 0; i < 10001; i++) {      s.add(sampler.sample());    }    assertEquals(String.format("m = %.3f, sd = %.3f", s.getMean(), s.getSD()), 2, s.getMean(), 0.04 * s.getSD());    assertEquals(5, s.getSD(), 0.12);  }
@Test    void shouldProtocolErrorWhenMoreThanOneRecord()    {        // Given        RoutingProcedureRunner mockedRunner = newProcedureRunnerMock();        Connection connection = mock( Connection.class );        ClusterCompositionProvider provider =                newClusterCompositionProvider( mockedRunner, connection );        Record aRecord = new InternalRecord( asList( "key1", "key2" ), new Value[]{ new StringValue( "a value" ) } );        RoutingProcedureResponse routingResponse = newRoutingResponse( aRecord, aRecord );        when( mockedRunner.run( eq( connection ), any( DatabaseName.class ), any(InternalBookmark.class ) ) ).thenReturn( completedFuture( routingResponse ) );        // When        ProtocolException error = assertThrows( ProtocolException.class,                () -> await( provider.getClusterComposition( connection, defaultDatabase(), empty() ) ) );        assertThat( error.getMessage(), containsString( "records received '2' is too few or too many." ) );    }
@Test    void getFields() {        assertTrue(instance().getFields().isEmpty());    }
@Test    public void setNoCache() {        servlet.setNoCache(response);        verify(response, times(3)).setHeader(Mockito.anyString(), Mockito.anyString());    }
@Test(timeout = 5000l)  public void testInvalidApplicationId() throws Exception {    Configuration conf = new YarnConfiguration();    YarnClient mockYarnClient = createMockYarnClient(YarnApplicationState.FINISHED);    LogsCLI cli = new LogsCLIForTest(mockYarnClient);    cli.setConf(conf);        int exitCode = cli.run( new String[] { "-applicationId", "not_an_app_id"});    assertTrue(exitCode == -1);    assertTrue(sysErrStream.toString().startsWith("Invalid ApplicationId specified"));  }
@Test(timeout = 10000)  public void testAddItem() throws Exception {    // Create a new inventory with a limit of 1000 items and put some load on the add method    final Inventory inventory = new Inventory(INVENTORY_SIZE);    final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);    for (int i = 0; i < THREAD_COUNT; i++) {      executorService.execute(() -> {        while (inventory.addItem(new Item())) {};      });    }    // Wait until all threads have finished    executorService.shutdown();    executorService.awaitTermination(5, TimeUnit.SECONDS);    // Check the number of items in the inventory. It should not have exceeded the allowed maximum    final List<Item> items = inventory.getItems();    assertNotNull(items);    assertEquals(INVENTORY_SIZE, items.size());    assertEquals(INVENTORY_SIZE, appender.getLogSize());    // ... and check if the inventory size is increasing continuously    for (int i = 0; i < items.size(); i++) {      assertTrue(appender.log.get(i).getFormattedMessage().contains("items.size()=" + (i + 1)));    }  }
@Test(description = "Testing get devices when user is the device admin")    public void testGetDevicesWhenUserIsAdmin() throws DeviceAccessAuthorizationException {        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceManagementService"))                .toReturn(this.deviceManagementProviderService);        PowerMockito.stub(PowerMockito.method(DeviceMgtAPIUtils.class, "getDeviceAccessAuthorizationService"))                .toReturn(this.deviceAccessAuthorizationService);        PowerMockito.stub(PowerMockito.method(MultitenantUtils.class, "getTenantAwareUsername"))                .toReturn(TENANT_AWARE_USERNAME);        PowerMockito.stub(PowerMockito.method(CarbonContext.class, "getThreadLocalCarbonContext"))                .toReturn(Mockito.mock(CarbonContext.class, Mockito.RETURNS_MOCKS));        Mockito.when(deviceAccessAuthorizationService.isDeviceAdminUser()).thenReturn(true);        Response response = this.deviceManagementService                .getDevices(null, TEST_DEVICE_TYPE, DEFAULT_USERNAME, null, DEFAULT_ROLE, DEFAULT_OWNERSHIP,                        DEFAULT_STATUS, 1, null, null, 10, 5);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode());        response = this.deviceManagementService                .getDevices(null, TEST_DEVICE_TYPE, null, DEFAULT_USERNAME, DEFAULT_ROLE, DEFAULT_OWNERSHIP,                        DEFAULT_STATUS, 1, null, null, 10, 5);        Assert.assertEquals(response.getStatus(), Response.Status.OK.getStatusCode());    }
@Test    void get0() {        assertEquals(m0, instance.get0());    }
@Test(dataProvider = "linkedList")    public void testSwapWithExtra(ListNode<Integer> original, ListNode<Integer> expected) {        TestUtilities.assertEquals(SwapPairs.swapWithExtraNode(original), expected);    }
@Test    public void testExecuteActionsOnViews2() throws Exception {        Controller controller = spy(new Controller());        TextView textView = mock(TextView.class);        doReturn("setFont(florent)").when(textView).getTag();        carpaccioManager.carpaccioViews.add(textView);        carpaccioManager.registerControllers.add(controller);        carpaccioManager.executeActionsOnViews();        verify(controller, never()).setText(eq(textView), eq("florent"));        verify(textView, never()).setText(eq("florent"));    }
@Test  public void testWithSRID() throws SchemaException {    final SimpleFeatureType type =        FeatureDataUtils.decodeType(            "http://somens.org",            "type1",            "geometry:Geometry:srid=4326,pop:java.lang.Long,when:Date,whennot:Date,pid:String",            "east");    assertEquals("type1", type.getName().getLocalPart());  }
@Test	public void handlerForRegularInterceptorsShouldBeDynamic() throws Exception {		assertThat(factory.handlerFor(RegularInterceptor.class), is(instanceOf(ToInstantiateInterceptorHandler.class)));	}
@Test	public void testNotValidatePassword(){		String password="aassasavcvcvc";		String[] invalidValues={"aa","bb","aa12345dd"};		boolean value=stringUtil.validatePassword(password, invalidValues);		Assert.assertTrue(password.length() >= 8);		Assert.assertFalse(value);	}
@Test    public void testHashcode() throws Exception    {        HostImpl host1 = new HostImpl( PEER_ID, hostInfo );        assertEquals( host1.hashCode(), host.hashCode() );    }
@Test  public void testAbortParagraphStatusOnInterpreterRestart() throws InterruptedException,      IOException {    Note note = notebook.createNote(null);    note.getNoteReplLoader().setInterpreters(factory.getDefaultInterpreterSettingList());    ArrayList<Paragraph> paragraphs = new ArrayList<>();    for (int i = 0; i < 100; i++) {      Paragraph tmp = note.addParagraph();      tmp.setText("p" + tmp.getId());      paragraphs.add(tmp);    }    for (Paragraph p : paragraphs) {      assertEquals(Job.Status.READY, p.getStatus());    }    note.runAll();    while (paragraphs.get(0).getStatus() != Status.FINISHED) Thread.yield();    factory.restart(note.getNoteReplLoader().getInterpreterSettings().get(0).id());    boolean isAborted = false;    for (Paragraph p : paragraphs) {      logger.debug(p.getStatus().name());      if (isAborted) {        assertEquals(Job.Status.ABORT, p.getStatus());      }      if (p.getStatus() == Status.ABORT) {        isAborted = true;      }    }    assertTrue(isAborted);  }
@Test  public void instantiateWithByte() {    Map<String, WorkflowStateMethod> methods = scanner.getStateMethods(ByteObjectWorkflow.class);    assertThat(methods.keySet(), hasItemsOf(asList("start", "end")));    assertNotNull(methods.get("end").params[0].nullValue);    assertThat(methods.get("end").params[0], stateParam("paramPrimitive", byte.class, true, false));    StateParameter param = methods.get("end").params[1];    assertThat(param, stateParam("paramBoxed", Byte.class, true, false));    assertEquals((byte)0, param.nullValue);  }
@Test    public void invalidateSessions()    {        Date currentDate = DateUtils.addMinutes(session.getStartDate(), sessionManager.getSessionTimeout());        System.out.println( "Session Time:" + session.getEndDate() + "\nCurrentTime:"+ currentDate);        assertTrue( session.getEndDate().getTime() <= currentDate.getTime() );        sessionManager.invalidateSessions( currentDate );        assertNull( sessionManager.getValidSession(sessionId));    }
@Test    public final void testOptimizationPolicyService() {        assertNotNull(service);    }
@Test  public void testSetAuthLevelIfSpecified_unspecified() throws Exception {    EndpointMethod method = getResultNoParamsMethod();    annotationConfig.setAuthLevelIfSpecified(AuthLevel.UNSPECIFIED);    ApiMethodConfig methodConfig = config.getApiClassConfig().getMethods().getOrCreate(method);    assertEquals(AuthLevel.NONE, methodConfig.getAuthLevel());    annotationConfig.setAuthLevelIfSpecified(AuthLevel.REQUIRED);    assertEquals(AuthLevel.REQUIRED, config.getAuthLevel());    annotationConfig.setAuthLevelIfSpecified(AuthLevel.UNSPECIFIED);    assertEquals(AuthLevel.REQUIRED, config.getAuthLevel());  }
@Test    void logon_noCallbackHandler() throws LoginException {        Assertions.assertThrows(LoginException.class, () -> {            this.loginModule.login();        });    }
@Test   public void testPut() {      Map<String, String> map = NoOpMap.instance();      assertNull(map.put("hello", "world"));      assertNull(map.put("hello", "world2"));      assertEquals(0, map.size());   }
@Test(expected = CardinalityException.class)  public void testAssignColumnCardinality() {    double[] data = {2.1, 3.2};    test.assignColumn(1, new DenseVector(data));  }
@Test  public void testExpression_Error_SubWithoutSecondArgument() {    assertThrows(JBBPEvalException.class, () -> new JBBPExpressionEvaluator("123-", null, null).eval(null, 0, null, null));  }
@Test	public void testQueryPerson() throws JAXBException, IOException {		// Arrange		final String reqMock = "reqMock";		final PRPAIN201309UV02 requestMock = mock(PRPAIN201309UV02.class);		final PRPAIN201310UV02 responseMock = mock(PRPAIN201310UV02.class);		final PixManagerBean pixMgrBean = new PixManagerBean();		sut.setPixMgrService(pixMgrServiceMock);		sut.setRequestXMLToJava(requestXMLToJavaMock);		// Act		when(				requestXMLToJavaMock.getPIXQueryReqObject(reqMock,						PixManagerConstants.ENCODE_STRING)).thenReturn(				requestMock);		when(pixMgrServiceMock.pixManagerPRPAIN201309UV02(requestMock))				.thenReturn(responseMock);		final PixManagerBean actObj = sut.queryPerson(reqMock);		// Assert		assertEquals(pixMgrBean.getQueryMessage(), actObj.getQueryMessage());	}
@Test  public void invokingRestoreCreatesNewSpan() {    commandCreatesNewSpan(RedisCommand.RESTORE,        () -> getConnection().restore("key".getBytes(), 0L, "val".getBytes()));    verify(mockRedisConnection()).restore("key".getBytes(), 0L, "val".getBytes());  }
@Test  public void testExecuteDMLUpdates() throws Exception {    Method addNewConfigurationsFromXml = AbstractUpgradeCatalog.class.getDeclaredMethod("addNewConfigurationsFromXml");    Method updateAlerts = UpgradeCatalog222.class.getDeclaredMethod("updateAlerts");    Method updateStormConfigs = UpgradeCatalog222.class.getDeclaredMethod("updateStormConfigs");    Method updateAMSConfigs = UpgradeCatalog222.class.getDeclaredMethod("updateAMSConfigs");    Method updateHiveConfigs = UpgradeCatalog222.class.getDeclaredMethod("updateHiveConfig");    Method updateHostRoleCommands = UpgradeCatalog222.class.getDeclaredMethod("updateHostRoleCommands");    Method updateHDFSWidget = UpgradeCatalog222.class.getDeclaredMethod("updateHDFSWidgetDefinition");    Method updateYARNWidget = UpgradeCatalog222.class.getDeclaredMethod("updateYARNWidgetDefinition");    Method updateHBASEWidget = UpgradeCatalog222.class.getDeclaredMethod("updateHBASEWidgetDefinition");    Method updateHbaseEnvConfig = UpgradeCatalog222.class.getDeclaredMethod("updateHbaseEnvConfig");    Method updateCorruptedReplicaWidget = UpgradeCatalog222.class.getDeclaredMethod("updateCorruptedReplicaWidget");    Method createNewSliderConfigVersion = UpgradeCatalog222.class.getDeclaredMethod("createNewSliderConfigVersion");    Method updateZookeeperConfigs = UpgradeCatalog222.class.getDeclaredMethod("updateZookeeperConfigs");    Method updateHBASEConfigs = UpgradeCatalog222.class.getDeclaredMethod("updateHBASEConfigs");    Method initializeStromAnsKafkaWidgets = UpgradeCatalog222.class.getDeclaredMethod("initializeStromAndKafkaWidgets");    UpgradeCatalog222 upgradeCatalog222 = createMockBuilder(UpgradeCatalog222.class)      .addMockedMethod(addNewConfigurationsFromXml)      .addMockedMethod(updateAlerts)      .addMockedMethod(updateStormConfigs)      .addMockedMethod(updateAMSConfigs)      .addMockedMethod(updateHiveConfigs)      .addMockedMethod(updateHostRoleCommands)      .addMockedMethod(updateHDFSWidget)      .addMockedMethod(updateYARNWidget)      .addMockedMethod(updateHBASEWidget)      .addMockedMethod(updateHbaseEnvConfig)      .addMockedMethod(updateCorruptedReplicaWidget)      .addMockedMethod(createNewSliderConfigVersion)      .addMockedMethod(updateZookeeperConfigs)      .addMockedMethod(updateHBASEConfigs)      .addMockedMethod(initializeStromAnsKafkaWidgets)      .createMock();    upgradeCatalog222.addNewConfigurationsFromXml();    upgradeCatalog222.updateAlerts();    upgradeCatalog222.updateStormConfigs();    upgradeCatalog222.updateAMSConfigs();    upgradeCatalog222.updateHostRoleCommands();    upgradeCatalog222.updateHiveConfig();    upgradeCatalog222.updateHDFSWidgetDefinition();    upgradeCatalog222.updateHbaseEnvConfig();    upgradeCatalog222.updateYARNWidgetDefinition();    upgradeCatalog222.updateHBASEWidgetDefinition();    upgradeCatalog222.updateCorruptedReplicaWidget();    upgradeCatalog222.updateZookeeperConfigs();    upgradeCatalog222.updateHBASEConfigs();    upgradeCatalog222.createNewSliderConfigVersion();    upgradeCatalog222.initializeStromAndKafkaWidgets();    replay(upgradeCatalog222);    upgradeCatalog222.executeDMLUpdates();    verify(upgradeCatalog222);  }
@Test  public void shouldNotCleanupPodBeforeNonDeletePeriod() {    // inject mock status in real instance    createdPod.setStatus(podStatus);    when(podStatus.getContainerStatuses()).thenReturn(List.of(containerStatus, keepaliveContainerStatus));    when(containerStatus.getName()).thenReturn(MAIN_CONTAINER_NAME);    when(containerStatus.getState()).thenReturn(containerState);    when(containerState.getTerminated()).thenReturn(containerStateTerminated);    when(containerStateTerminated.getFinishedAt())        .thenReturn(FIXED_INSTANT.minus(Duration.ofMinutes(1)).toString());    var runState = RunState.create(WORKFLOW_INSTANCE, State.TERMINATED);    var shouldDelete = kdr.shouldDeletePodWithRunState(WORKFLOW_INSTANCE, createdPod, runState);    assertThat(shouldDelete, is(false));  }
@Test( expected = IllegalArgumentException.class )    public void shouldFailAddingEmptyViewName() throws Exception {        this.model.addView( getTransaction(), EMPTY_STRING );    }
@Test    void get1() {        assertEquals(m1, instance.get1());    }
@Test(expected = IndexException.class)  public void testViewColumnIndexUnder() {    test.viewColumn(-1);  }
@Test    public void testTheNumberOfScannedLinesOfCode() {        sourceFile = ApexAstScanner.scanFile(new File("src/test/resources/metrics/lines.cls"));        assertThat(sourceFile.getInt(ApexMetric.LINES_OF_CODE)).isEqualTo(9);    }
@Test    public void testApply_Basic() {        int numGames = 3;        int numCards = 12;        int maxCard = numCards;        List<Player> players = new ArrayList<>();                Player p1 = new Player("p1", strategy, maxCard, new Hand());        Player p2 = new Player("p2", strategy, maxCard, new Hand());        Player p3 = new Player("p3", strategy, maxCard, new Hand());                players.add(p1);        players.add(p2);        players.add(p3);                        // test        List<Player> newPlayers = new Tourney(numCards, numGames, false).apply(players);                assertEquals(3, newPlayers.size());        assertEquals(0, newPlayers.get(0).getNumCardsInHand());        assertEquals(0, newPlayers.get(1).getNumCardsInHand());        assertEquals(0, newPlayers.get(2).getNumCardsInHand());        assertEquals(3, newPlayers.stream().map(p -> p.getPlayerStats().getNumGamesWon()).mapToInt(i->i).sum());    }
@Test	public void testReadTypedCollection() throws IOException {		Assert.assertEquals(			new ArrayList<Integer>() {				{					add(1);					add(2);				}			},			ConfigurationHandler.read(				"I( \\\r\n  \"1\", \\\r\n  \"2\", \\\r\n)"));	}
@Test    public void givenConflictingFailedParameters_whenBuild_thenThrowsException() {        // Given        final int itemId = 1;        final int failedId = 6;        // Expect exception        expectedException.expect(IllegalArgumentException.class);        expectedException.expectMessage("failedResourceId and failedViewWillBeProvided cannot both be set");        // When        SectionParameters.builder()                .itemResourceId(itemId)                .failedResourceId(failedId)                .failedViewWillBeProvided()                .build();    }
@Test    public void testToString() {        assertThat(s1.toString()).isEqualTo("Other"); //$NON-NLS-1$        assertThat(s2.toString()).isEqualTo(LocalUtil.getDateTimeFormatter().format(today));        assertThat(s3.toString()).isEqualTo("test serie 3"); //$NON-NLS-1$    }
@SuppressWarnings("deprecation")	@Test	public void shouldDelegateToStatusWhenMovingToLogic() throws Exception {		when(status.movedPermanentlyTo(RandomController.class)).thenReturn(new RandomController());		httpResult.movedPermanentlyTo(RandomController.class).method();		verify(status).movedPermanentlyTo(RandomController.class);	}
@Test    public void shouldReturnParsedPairsOutOfUrlEncodedEntity() throws IOException {        InputStream stream = new ByteArrayInputStream(URL_ENCODED_FORM.getBytes());        List<EncodedPair> actual = toTest.extract(null, UTF8, stream);        assertEquals(3, actual.size());        assertEquals("p1", actual.get(0).getName());        assertEquals("v%201", actual.get(0).getValue());        assertEquals("p1", actual.get(1).getName());        assertEquals("v%202", actual.get(1).getValue());        assertEquals("p3", actual.get(2).getName());        assertEquals("v3", actual.get(2).getValue());    }
@Test    public void testToString() throws Exception    {        String toString = resourceHostInfo.toString();        assertThat( toString, containsString( HOST_HOSTNAME ) );        assertThat( toString, containsString( HOST_ID ) );        assertThat( toString, containsString( CONTAINER_HOSTNAME ) );        assertThat( toString, containsString( CONTAINER_IP ) );        assertThat( toString, containsString( CONTAINER_ID ) );        assertThat( toString, containsString( CONTAINER_STATUS.name() ) );        assertThat( toString, containsString( ARCH.name() ) );    }
@Test    public void shouldStartMonitorRecordingWithThresholds() throws Exception    {        RemoteCallable<Void> callable = JProfiler.startMonitorRecording(123, 987);        changeClass(callable);        callable.call();        verify(ControllerStub.methodStub).method("startMonitorRecording", 123, 987);    }
@Test    public void testEmptyTagFilterValueDoesMatch() {        Map<String,String> itemtags = new HashMap<String,String>() {{            put("one","two");        }};        TagFilter tf = new TagFilter("");        assertThat(tf.matches(itemtags).matched()).isTrue();    }
@Test	public void test12DeactivateUser() {		XXPortalUser xxPUserExp = new XXPortalUser();		xxPUserExp = null;		XXPortalUserDao xxPortalUserDao = Mockito.mock(XXPortalUserDao.class);		Mockito.when(daoManager.getXXPortalUser()).thenReturn(xxPortalUserDao);		Mockito.when(xxPortalUserDao.getById(userId)).thenReturn(xxPUserExp);		Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), (MessageEnums) Mockito.any(),				Mockito.nullable(Long.class), Mockito.nullable(String.class), Mockito.anyString())).thenReturn(new WebApplicationException());		thrown.expect(WebApplicationException.class);		userREST.deactivateUser(userId);		Mockito.verify(daoManager).getXXPortalUser();		Mockito.verify(xxPortalUserDao).getById(userId);		Mockito.verify(restErrorUtil).createRESTException(Mockito.anyString(), (MessageEnums) Mockito.any(),				Mockito.anyLong(), Mockito.anyString(), Mockito.anyString());	}
@Test	public void test() throws Exception {		PublicKey decoded = decoder.decode(encoded);		assertEquals(decoded, key);	}
@Test    public void testDeadline() {        AsyncLoadingCache<String, Integer> cachedResult = new AsyncLoadingCache<>(100, 10);        final Supplier<CompletableFuture<Integer>> tooLateSupplier = () -> MoreAsyncUtil.delayedFuture(1, TimeUnit.SECONDS)                .thenApply(ignore -> 2);        final Supplier<CompletableFuture<Integer>> onTimeSupplier = () -> MoreAsyncUtil.delayedFuture(5, TimeUnit.MILLISECONDS)                .thenApply(ignore -> 3);        try {            cachedResult.orElseGet("a-key", tooLateSupplier).join();            fail("should throw CompletionException");        } catch (CompletionException ex) {            assertThat("it is caused by a deadline exception", ex.getCause(),                    is(instanceOf(DeadlineExceededException.class)));            assertThat(ex.getCause(), hasMessageContaining("deadline exceeded"));        }        assertThat("we get the value before the deadline", cachedResult.orElseGet("a-key", onTimeSupplier).join(), is(3));    }
@Test    void buildPolicyEntityTestGlobal() {        PolicyEntityBuilder policyEntityBuilder = new PolicyEntityBuilder(DocumentTools.INSTANCE, new IdGenerator(), policyXMLBuilder);        Policy policyToBuild = new Policy();        policyToBuild.setPath("my/policy/global.xml");        policyToBuild.setName("global.xml");        policyToBuild.setId("global-policy-id");        policyToBuild.setGuid("global-policy-guid-123");        policyToBuild.setTag("global-policy");        policyToBuild.setPolicyType(PolicyType.GLOBAL);        Folder myFolder = new Folder();        myFolder.setId("myId");        myFolder.setName("my");        myFolder.setParentFolder(Folder.ROOT_FOLDER);        Folder parentFolder = new Folder();        parentFolder.setId("folder-id");        parentFolder.setName("policy");        parentFolder.setParentFolder(myFolder);        policyToBuild.setParentFolder(parentFolder);        Entity policyEntity = policyEntityBuilder.buildPolicyEntity(policyToBuild, null, bundle, document);        assertEquals(policyToBuild.getId(), policyEntity.getId());        assertEquals(policyToBuild.getPath(), policyEntity.getName());        assertNotNull(policyEntity.getXml());        Element policyDetail = getSingleChildElement(policyEntity.getXml(), POLICY_DETAIL);        assertNotNull(policyDetail);        String type = getSingleChildElementTextContent(policyDetail, POLICY_TYPE);        assertNotNull(type);        assertEquals(PolicyType.GLOBAL.getType(), type);        final Map<String, Object> properties = mapPropertiesElements(getSingleChildElement(policyDetail, PROPERTIES), PROPERTIES);        assertFalse(properties.isEmpty());        assertEquals("global-policy", properties.get(PropertyConstants.PROPERTY_TAG));        assertNull(properties.get(PropertyConstants.PROPERTY_SUBTAG));    }
@Test(expected = IllegalArgumentException.class)    public void testWriteAddressToLow() throws Exception {        address = -1;        device.write(address, testData);    }
@Test    public void shouldDetermineIfACommandIsInProgress() throws Exception {        final SystemCommand commandReceivedCommand = mock(SystemCommand.class);        final SystemCommand commandInProgressCommand = mock(SystemCommand.class);        final SystemCommand commandCompleteCommand = mock(SystemCommand.class);        final SystemCommand commandFailedCommand = mock(SystemCommand.class);        final SystemCommand notFoundCommand = mock(SystemCommand.class);        final SystemCommandStatus commandReceivedStatus = mock(SystemCommandStatus.class);        final SystemCommandStatus commandInProgressStatus = mock(SystemCommandStatus.class);        final SystemCommandStatus commandCompleteStatus = mock(SystemCommandStatus.class);        final SystemCommandStatus commandFailedStatus = mock(SystemCommandStatus.class);        when(systemCommandStatusRepository.findLatestStatusByType(commandReceivedCommand)).thenReturn(of(commandReceivedStatus));        when(systemCommandStatusRepository.findLatestStatusByType(commandInProgressCommand)).thenReturn(of(commandInProgressStatus));        when(systemCommandStatusRepository.findLatestStatusByType(commandCompleteCommand)).thenReturn(of(commandCompleteStatus));        when(systemCommandStatusRepository.findLatestStatusByType(commandFailedCommand)).thenReturn(of(commandFailedStatus));        when(systemCommandStatusRepository.findLatestStatusByType(notFoundCommand)).thenReturn(empty());        when(commandReceivedStatus.getCommandState()).thenReturn(COMMAND_RECEIVED);        when(commandInProgressStatus.getCommandState()).thenReturn(COMMAND_IN_PROGRESS);        when(commandCompleteStatus.getCommandState()).thenReturn(COMMAND_COMPLETE);        when(commandFailedStatus.getCommandState()).thenReturn(COMMAND_FAILED);        assertThat(systemCommandStateBean.commandInProgress(commandReceivedCommand), is(true));        assertThat(systemCommandStateBean.commandInProgress(commandInProgressCommand), is(true));        assertThat(systemCommandStateBean.commandInProgress(commandCompleteCommand), is(false));        assertThat(systemCommandStateBean.commandInProgress(commandFailedCommand), is(false));        assertThat(systemCommandStateBean.commandInProgress(notFoundCommand), is(false));    }
@Test    public void stripConnectionHeadersAndNominees() {        HttpHeaders inHeaders = new DefaultHttpHeaders();        inHeaders.add(CONNECTION, "foo");        inHeaders.add("foo", "bar");        Http2Headers out = new DefaultHttp2Headers();        HttpConversionUtil.toHttp2Headers(inHeaders, out);        assertTrue(out.isEmpty());    }
@Test  public void resourceExists() {    final Tomcat10ContainerAdapter adapter = new Tomcat10ContainerAdapter();    assertTrue(adapter.resourceExists("name", context));  }
@Test    void nothingIsLoggedOnFatalFailure()    {        Logging logging = mock( Logging.class );        Logger logger = mock( Logger.class );        when( logging.getLog( anyString() ) ).thenReturn( logger );        ExponentialBackoffRetryLogic logic = new ExponentialBackoffRetryLogic( RetrySettings.DEFAULT, eventExecutor,                mock( Clock.class ), logging );        RuntimeException error = assertThrows( RuntimeException.class, () ->                logic.retry( () ->                {                    throw new RuntimeException( "Fatal blocking" );                } ) );        assertEquals( "Fatal blocking", error.getMessage() );        verifyZeroInteractions( logger );    }
@Test	public void shouldBeAbleToConvertNull() {		assertThat(converter.convert(null, DateMidnight.class, bundle), is(nullValue()));	}
@Test    public void testGetCell() throws Exception {        final String factType = "org.kiegroup.Car";        final String factField = "color";        final String dataType = DataType.DataTypes.STRING.name();        doReturn(factType).when(column).getFactType();        doReturn(factField).when(column).getFactField();        doReturn(dataType).when(column).getDataType();        doReturn("==").when(column).getOperator();        testedFactory.getCell(column);        verify(testedFactory, never()).makeSelectionEnumCell(factType, factField, "==", dataType);        verify(testedFactory).makeTextCellWrapper();    }
@Test    void cut() {        assertEquals("", StringUtils.cut(JOINED, 0, DELIM, 0));        for (int i = 0; i < ARRAY.length; i++) {            assertEquals(ARRAY[i], StringUtils.cut(JOINED, JOINED.length(), DELIM, i));        }        assertEquals("", StringUtils.cut(JOINED, JOINED.length(), DELIM, ARRAY.length));    }
@Test    public void equalsReturnsFalseIfReaderKeysAreDifferent() {        // given        KeySequenceConfig keySequenceConfig1 =                new KeySequenceConfig(DEFAULT_TEST_SEQUENCE_ID, RESERVED_KEYS, RESERVED_KEYS);        KeySequenceConfig keySequenceConfig2 =                new KeySequenceConfig(DEFAULT_TEST_SEQUENCE_ID, RESERVED_KEYS + 1, RESERVED_KEYS);        // when        boolean result = keySequenceConfig1.equals(keySequenceConfig2);        // then        assertFalse(result);    }
@Test    public void testEnsureCapacity() throws Exception {        final CharArrayBuffer buffer = new CharArrayBuffer(4);        buffer.ensureCapacity(2);        Assert.assertEquals(4, buffer.capacity());        buffer.ensureCapacity(8);        Assert.assertEquals(8, buffer.capacity());    }
@Test(expected = InvalidCredentialsException.class)  public void testValidateWithCredentialsForUnknownSubject() throws Exception {    setup("subject.1.name = subject");    accessController.validate(createCredentials(42));  }
@Issue("587")    @Issue("572")    @Test    void shouldSortByStartTimeAsc() {        final Category category = new Category().setName("some");        final TestResult first = new TestResult()                .setName("first")                .setStatus(Status.FAILED)                .setTime(new Time().setStart(10L));        first.addExtraBlock(CATEGORIES, singletonList(category));        final TestResult second = new TestResult()                .setName("second")                .setStatus(Status.FAILED)                .setTime(new Time().setStart(12L));        second.addExtraBlock(CATEGORIES, singletonList(category));        final TestResult timeless = new TestResult()                .setName("timeless")                .setStatus(Status.FAILED);        timeless.addExtraBlock(CATEGORIES, singletonList(category));        final Tree<TestResult> tree = CategoriesPlugin.getData(                createSingleLaunchResults(second, first, timeless)        );        assertThat(tree.getChildren())                .flatExtracting("children")                .flatExtracting("children")                .extracting("name")                .containsExactly("timeless", "first", "second");    }
@Test    public void TestNeedValidate02() {        // setup input parameters        String tokenName = "aaa";        TransactionTokenType beginToken = TransactionTokenType.IN;        // run        TransactionTokenInfo info = new TransactionTokenInfo(tokenName, beginToken);        boolean output = info.needValidate();        // assert        assertThat(output, is(true));    }
@Test	public void testClone() {		UInt16 clone = i1.clone();		assertEquals(i1.toString(), clone.toString());		assertEquals(i1.toJsonObject(), clone.toJsonObject());		assertEquals(i1.getMessageType(), clone.getMessageType());		assertEquals(i1.getData(), clone.getData());		assertNotSame(i1, clone);		assertNotSame(i1.toString(), clone.toString());		assertNotSame(i1.toJsonObject(), clone.toJsonObject());	}
@Test    public void testAnalysisBuilderHpoIdsDefault() {        assertThat(analysisBuilder.build().getHpoIds(), equalTo(Collections.<String>emptyList()));    }
@Test    public void testMergeThree() {        DatasetMetadataMerger datasetMetadataMerger = new DatasetMetadataMerger();        DatasetMetadata metadata1 = createDatasetMetadata( URL_1 );        DatasetMetadata metadata2 = createDatasetMetadata( URL_2, URL_3 );        DatasetMetadata metadata3 = createDatasetMetadata( URL_4 );        DatasetMetadata mergedMetadata = datasetMetadataMerger.merge( asList( metadata1, metadata2, metadata3 ) );        List<MetadataUrl> metadataUrls = mergedMetadata.getMetadataUrls();        assertThat( metadataUrls.size(), is( 4 ) );    }
@Test    public void executeAsyncCall_short_circuit_times_out_the_call_if_it_takes_longer_than_callTimeout() {        // given        long callTimeoutMillis = 50;        long callExecutionTimeMillis = 150;        Whitebox            .setInternalState(cbSpy, "callTimeoutNanos", Optional.of(Duration.ofMillis(callTimeoutMillis).toNanos()));        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {            try {                Thread.sleep(callExecutionTimeMillis);            }            catch (InterruptedException e) {                throw new RuntimeException(e);            }            return "foo";        });        // when        long startTimeMillis = System.currentTimeMillis();        CompletableFuture<String> result = cbSpy.executeAsyncCall(() -> future);        Exception exThrownByFuture = null;        try {            result.join();        }        catch (Exception ex) {            exThrownByFuture = ex;        }        long endTimeMillis = System.currentTimeMillis();        // then        assertThat(result.isCompletedExceptionally()).isTrue();        assertThat(exThrownByFuture)            .isNotNull()            .isInstanceOf(CompletionException.class)            .hasCauseInstanceOf(CircuitBreakerTimeoutException.class);        assertThat((endTimeMillis - startTimeMillis)).isLessThan(callExecutionTimeMillis);    }
@Test	public void testFromJsonObject() {		JsonObject jsonObject = Json.createObjectBuilder().build();		Empty data = Empty.fromJsonObject(jsonObject);		assertEquals(empty.toString(), data.toString());		assertEquals(empty.toJsonObject(), data.toJsonObject());		assertEquals(empty.getMessageType(), data.getMessageType());		assertNotSame(empty, data);		assertNotSame(empty.toString(), data.toString());		assertNotSame(empty.toJsonObject(), data.toJsonObject());	}
@Test    public void checkOnValidateWithoutErrors() {        final ObservablePath path = mock(ObservablePath.class);        final PlaceRequest placeRequest = mock(PlaceRequest.class);        final GuidedDecisionTableEditorContent content = makeDecisionTableContent();        final GuidedDecisionTableView.Presenter dtPresenter = makeDecisionTable(path,                                                                                path,                                                                                placeRequest,                                                                                content);        when(dtService.validate(any(Path.class),                                any(GuidedDecisionTable52.class))).thenReturn(Collections.emptyList());        presenter.onValidate(dtPresenter);        final ArgumentCaptor<GuidedDecisionTable52> modelCaptor = ArgumentCaptor.forClass(GuidedDecisionTable52.class);        verify(dtService,               times(1)).validate(eq(path),                                  modelCaptor.capture());        assertNotNull(modelCaptor.getValue());        assertEquals(dtPresenter.getModel(),                     modelCaptor.getValue());        verify(notification,               times(1)).fire(any(NotificationEvent.class));    }
@Test  public void testAbsDelete() throws Exception {    Random r = new Random();    long seed = r.nextLong();    r.setSeed(seed);    System.out.println("SEED: " + seed);    List<Path> dirs = buildDirs(r, base, 20);    createDirs(new Path("."), dirs);    FakeDefaultContainerExecutor exec = new FakeDefaultContainerExecutor();    Configuration conf = new Configuration();    exec.setConf(conf);    DeletionService del = new DeletionService(exec);    del.init(conf);    del.start();    try {      for (Path p : dirs) {        del.delete((Long.parseLong(p.getName()) % 2) == 0 ? null : "dingo",            p, null);      }      int msecToWait = 20 * 1000;      for (Path p : dirs) {        while (msecToWait > 0 && lfs.util().exists(p)) {          Thread.sleep(100);          msecToWait -= 100;        }        assertFalse(lfs.util().exists(p));      }    } finally {      del.stop();    }  }
@Test        public void testToRangerPolicyForResourceTypeService(){                RangerPolicy expectedRangerPolicy = new RangerPolicy();                expectedRangerPolicy.setId(1L);                expectedRangerPolicy.setName("hive Policy");                expectedRangerPolicy.setService("hive");                expectedRangerPolicy.setDescription("hive policy description");                Map<String, RangerPolicyResource> expectedMap = new HashMap<String, RangerPolicyResource>();                List<String> valuesList = new ArrayList<String>();                valuesList.add("service");                VXAuditMap vXAuditMap = new VXAuditMap();                vXAuditMap.setId(1L);                vXAuditMap.setOwner("rangerAdmin");                List<VXAuditMap> vXAuditMapList = new ArrayList<VXAuditMap>();                vXAuditMapList.add(vXAuditMap);                RangerPolicyResource rangerPolicyResource = new RangerPolicyResource();                rangerPolicyResource.setIsExcludes(false);                rangerPolicyResource.setIsRecursive(false);                rangerPolicyResource.setValue("service");                rangerPolicyResource.setValues(valuesList);                expectedMap.put("service", rangerPolicyResource);                expectedRangerPolicy.setResources(expectedMap);                RangerService rangerService = new RangerService();                rangerService.setName("hive");                VXResource resource = new VXResource();                resource.setId(1L);                resource.setServices("service");                resource.setUpdateDate(new Date());                resource.setCreateDate(new Date());                resource.setOwner("rangerAdmin");                resource.setUpdatedBy("rangerAdmin");                resource.setPolicyName("hive Policy");                resource.setDescription("hive policy description");                resource.setResourceStatus(RangerCommonEnums.STATUS_ENABLED);                resource.setIsRecursive(1);                resource.setTableType(1);                resource.setColumnType(1);                RangerPolicy actualRangerPolicy = serviceUtil.toRangerPolicy(resource, rangerService);                Assert.assertNotNull(actualRangerPolicy);                Assert.assertEquals(expectedRangerPolicy.getId(), actualRangerPolicy.getId());                Assert.assertEquals(expectedRangerPolicy.getName(), actualRangerPolicy.getName());                Assert.assertEquals(expectedRangerPolicy.getService(), actualRangerPolicy.getService());                Assert.assertEquals(expectedRangerPolicy.getDescription(), actualRangerPolicy.getDescription());                Assert.assertEquals(expectedRangerPolicy.getResources(), actualRangerPolicy.getResources());        }
@Test  public void testIsKIllable() {    assertTrue(DockerCommandExecutor.isKillable(        DockerContainerStatus.RUNNING));    assertTrue(DockerCommandExecutor.isKillable(        DockerContainerStatus.RESTARTING));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.EXITED));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.CREATED));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.DEAD));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.NONEXISTENT));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.REMOVING));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.STOPPED));    assertFalse(DockerCommandExecutor.isKillable(        DockerContainerStatus.UNKNOWN));  }
@Test  public void testGetPatientLatestEncounterInvalidEncounterType()  {    expectedException.expect(SystemException.class);    expectedException.expectMessage(        "FHIR validation failed - Invalid Encounter.class: home");    final Bundle result = new Bundle();    final Bundle.Entry entry = getEncounterResultBundleEntry(        "encounter1",        "patient1",        EncounterClassEnum.HOME,        EncounterStateEnum.IN_PROGRESS,        new DateTime(2016, 10, 1, 12, 0),        null,        null,        null,        null,        null);    result.addEntry(entry);    mockFhirClientResult(result);    fhirEncounterProvider.getPatientLatestEncounter("patient1");  }
@Test  public void concatWithNewItemsAndNulls() {    ArrayList<String> originalList = new ArrayList<>();    originalList.add("hi");    originalList.add("sup");    List<String> result = CollectionUtil.concatList(originalList, "nice", null, "dog", null);    assertThat(result)        .containsExactly("hi", "sup", "nice", "dog");  }
@Test  public void testGetClusterNodes() throws Exception {    MockRM rm = new MockRM() {      protected ClientRMService createClientRMService() {        return new ClientRMService(this.rmContext, scheduler,          this.rmAppManager, this.applicationACLsManager, this.queueACLsManager,          this.getRMContext().getRMDelegationTokenSecretManager());      };    };    rm.start();    // Add a healthy node    MockNM node = rm.registerNode("host1:1234", 1024);    rm.sendNodeStarted(node);    node.nodeHeartbeat(true);        // Add and lose a node    MockNM lostNode = rm.registerNode("host2:1235", 1024);    rm.sendNodeStarted(lostNode);    lostNode.nodeHeartbeat(true);    rm.NMwaitForState(lostNode.getNodeId(), NodeState.RUNNING);    rm.sendNodeLost(lostNode);    // Create a client.    Configuration conf = new Configuration();    YarnRPC rpc = YarnRPC.create(conf);    InetSocketAddress rmAddress = rm.getClientRMService().getBindAddress();    LOG.info("Connecting to ResourceManager at " + rmAddress);    ApplicationClientProtocol client =        (ApplicationClientProtocol) rpc          .getProxy(ApplicationClientProtocol.class, rmAddress, conf);    // Make call    GetClusterNodesRequest request =        GetClusterNodesRequest.newInstance(EnumSet.of(NodeState.RUNNING));    List<NodeReport> nodeReports =        client.getClusterNodes(request).getNodeReports();    Assert.assertEquals(1, nodeReports.size());    Assert.assertNotSame("Node is expected to be healthy!", NodeState.UNHEALTHY,        nodeReports.get(0).getNodeState());    // Now make the node unhealthy.    node.nodeHeartbeat(false);    // Call again    nodeReports = client.getClusterNodes(request).getNodeReports();    Assert.assertEquals("Unhealthy nodes should not show up by default", 0,        nodeReports.size());        // Now query for UNHEALTHY nodes    request = GetClusterNodesRequest.newInstance(EnumSet.of(NodeState.UNHEALTHY));    nodeReports = client.getClusterNodes(request).getNodeReports();    Assert.assertEquals(1, nodeReports.size());    Assert.assertEquals("Node is expected to be unhealthy!", NodeState.UNHEALTHY,        nodeReports.get(0).getNodeState());        // Query all states should return all nodes    rm.registerNode("host3:1236", 1024);    request = GetClusterNodesRequest.newInstance(EnumSet.allOf(NodeState.class));    nodeReports = client.getClusterNodes(request).getNodeReports();    Assert.assertEquals(3, nodeReports.size());  }
@Test    public void testParseStringChromosomeX() {        String interval = "chrX:123-456";        GeneticInterval expResult = new GeneticInterval(23, 123, 456);        GeneticInterval result = GeneticInterval.parseString(interval);        assertThat(result, equalTo(expResult));    }
@Test    public void testRemove() {        Metadata meta = new Metadata();        meta.remove("name-one");        assertEquals(0, meta.size());        meta.add("name-one", "value-1.1");        meta.add("name-one", "value-1.2");        meta.add("name-two", "value-2.2");        assertEquals(2, meta.size());        assertNotNull(meta.get("name-one"));        assertNotNull(meta.get("name-two"));        meta.remove("name-one");        assertEquals(1, meta.size());        assertNull(meta.get("name-one"));        assertNotNull(meta.get("name-two"));        meta.remove("name-two");        assertEquals(0, meta.size());        assertNull(meta.get("name-one"));        assertNull(meta.get("name-two"));    }
@Test    public void testRetrievingAnnotatedImageWhenTriggerTypeIsGreaterThan() {        Double triggerThreshold = 1D;        Long triggerFiredTime = 1563692460000L;        Long inertia = 1800*1000L;        ImageDataRetrievalContext context = getImageDataRetrievalContext(Trigger.TriggerType.GREATER_THAN, triggerFiredTime, inertia, triggerThreshold, NotificationStatus.TRIGGERED);        ArgumentMatcher<ImageProperties> imageProperties = new ArgumentMatcher<ImageProperties>() {            @Override            public boolean matches(ImageProperties imageProperties) {                return imageProperties.getShadeXAxisArea().size() == 1 && imageProperties.getShadeYAxisArea().size() == 1;            }        };        ArgumentMatcher<List<Metric>> metricList = new ArgumentMatcher<List<Metric>>() {            @Override            public boolean matches(List<Metric> metricList) {                return metricList.size() == 1;            }        };        when(imageServiceMock.generateAndStoreImage(argThat(metricList), argThat(imageProperties),                eq(true))).thenReturn(Pair.of("1", "TestString".getBytes()));        Pair<String, byte[]> imageDetails = imageDataRetriever.getAnnotatedImage(context);        verify(imageServiceMock, times(1)).generateAndStoreImage(argThat(metricList),                argThat(imageProperties), eq(true));    }
@Test    void shouldReturnEmptyOptionalIfNoMatchedFormat() {        final CompositeDateTimeParser parser = new CompositeDateTimeParser(                new ZonedDateTimeParser(),                new LocalDateTimeParser(ZoneOffset.UTC)        );        final Optional<Long> parsed = parser.getEpochMilli("2017-10-05T10:36:22UTC");        assertThat(parsed)                .isEmpty();    }
@Test	public final void testIsValid_happyPath() throws Exception {		// valid policy has valid non-empty name and service name		when(_policy.getService()).thenReturn("service-name");		// service name exists		RangerService service = mock(RangerService.class);		when(service.getType()).thenReturn("service-type");		when(service.getId()).thenReturn(2L);		when(_store.getServiceByName("service-name")).thenReturn(service);		// service points to a valid service-def		_serviceDef = _utils.createServiceDefWithAccessTypes(accessTypes);		when(_serviceDef.getName()).thenReturn("service-type");		when(_store.getServiceDefByName("service-type")).thenReturn(_serviceDef);		// a matching policy should exist for create when checked by id and not exist when checked by name.		when(_store.getPolicy(7L)).thenReturn(null);		RangerPolicy existingPolicy = mock(RangerPolicy.class);		when(existingPolicy.getId()).thenReturn(8L);		when(existingPolicy.getService()).thenReturn("service-name");		when(_store.getPolicy(8L)).thenReturn(existingPolicy);		// a matching policy should not exist for update.		// valid policy can have empty set of policy items if audit is turned on		// null value for audit is treated as audit on.		// for now we want to turn any resource related checking off		when(_policy.getResources()).thenReturn(null);		for (Action action : cu) {			for (Boolean auditEnabled : new Boolean[] { null, true } ) {				for (boolean isAdmin : new boolean[] { true, false }) {					when(_policy.getIsAuditEnabled()).thenReturn(auditEnabled);					if (action == Action.CREATE) {						when(_policy.getId()).thenReturn(7L);						when(_policy.getName()).thenReturn("policy-name-1");						when(_store.getPolicyId(service.getId(), _policy.getName(), _zoneId)).thenReturn(null);						Assert.assertTrue("" + action + ", " + auditEnabled, _validator.isValid(_policy, action, isAdmin, _failures));						Assert.assertTrue(_failures.isEmpty());					} else {						// update should work both when by-name is found or not, since nothing found by-name means name is being updated.						when(_policy.getId()).thenReturn(8L);						when(_policy.getName()).thenReturn("policy-name-1");						Assert.assertTrue("" + action + ", " + auditEnabled, _validator.isValid(_policy, action, isAdmin, _failures));						Assert.assertTrue(_failures.isEmpty());							when(_policy.getName()).thenReturn("policy-name-2");						when(_store.getPolicyId(service.getId(), _policy.getName(), _zoneId)).thenReturn(null);						Assert.assertTrue("" + action + ", " + auditEnabled, _validator.isValid(_policy, action, isAdmin, _failures));						Assert.assertTrue(_failures.isEmpty());					}				}			}		}		// if audit is disabled then policy should have policy items and all of them should be valid		List<RangerPolicyItem> policyItems = _utils.createPolicyItems(policyItemsData);		when(_policy.getPolicyItems()).thenReturn(policyItems);		when(_policy.getIsAuditEnabled()).thenReturn(false);		for (Action action : cu) {			for (boolean isAdmin : new boolean[] { true, false}) {				if (action == Action.CREATE) {					when(_policy.getId()).thenReturn(7L);					when(_policy.getName()).thenReturn("policy-name-1");				} else {					when(_policy.getId()).thenReturn(8L);					when(_policy.getName()).thenReturn("policy-name-2");				}				Assert.assertTrue("" + action , _validator.isValid(_policy, action, isAdmin, _failures));				Assert.assertTrue(_failures.isEmpty());			}		}				// above succeeded as service def did not have any resources on it, mandatory or otherwise.		// policy should have all mandatory resources specified, and they should conform to the validation pattern in resource definition		List<RangerResourceDef> resourceDefs = _utils.createResourceDefs(resourceDefData);		when(_serviceDef.getResources()).thenReturn(resourceDefs);		Map<String, RangerPolicyResource> resourceMap = _utils.createPolicyResourceMap(policyResourceMap_good);		when(_policy.getResources()).thenReturn(resourceMap);		// let's add some other policies in the store for this service that have a different signature		// setup the signatures on the policies		RangerPolicyResourceSignature policySignature = mock(RangerPolicyResourceSignature.class);		when(_factory.createPolicyResourceSignature(_policy)).thenReturn(policySignature);		// setup the store to indicate that no other policy exists with matching signature		when(policySignature.getSignature()).thenReturn("hash-1");		when(_store.getPoliciesByResourceSignature("service-name", "hash-1", true)).thenReturn(null);		// we are reusing the same policies collection here -- which is fine		for (Action action : cu) {			if (action == Action.CREATE) {				when(_policy.getId()).thenReturn(7L);				when(_policy.getName()).thenReturn("policy-name-1");			} else {				when(_policy.getId()).thenReturn(8L);				when(_policy.getName()).thenReturn("policy-name-2");			}			Assert.assertTrue("" + action , _validator.isValid(_policy, action, true, _failures)); // since policy resource has excludes admin privilages would be required			Assert.assertTrue(_failures.isEmpty());		}	}
@Test    public void testGetMethods01() throws Exception {        // 前処理(試験対象)        String fileName = "fileName";        Class<AbstractFileLineWriter_Stub01> clazz = AbstractFileLineWriter_Stub01.class;        Map<String, ColumnFormatter> columnFormatterMap = new HashMap<String, ColumnFormatter>();        columnFormatterMap.put("int", new IntColumnFormatter());        columnFormatterMap.put("java.lang.String", new NullColumnFormatter());        AbstractFileLineWriter<AbstractFileLineWriter_Stub01> fileLineWriter = new AbstractFileLineWriterImpl01<AbstractFileLineWriter_Stub01>(fileName, clazz, columnFormatterMap);        // 前処理(フィールド)        Method[] methods = new Method[] { null, null, null };        ReflectionTestUtils.setField(fileLineWriter, "methods", methods);        // テスト実施        Method[] result = fileLineWriter.getMethods();        // 判定(戻り値)        assertNotNull(result);        assertSame(methods, result);    }
@Test    public void testExecuteActionsOnViews() throws Exception {        Controller controller = spy(new Controller());        TextView textView = mock(TextView.class);        doReturn("setText(florent)").when(textView).getTag();        doReturn("setText(florent)").when(textView).getTag();        carpaccioManager.carpaccioViews.add(textView);        carpaccioManager.registerControllers.add(controller);        carpaccioManager.executeActionsOnViews();        verify(controller, atLeastOnce()).setText(eq(textView), eq("florent"));        verify(textView, atLeastOnce()).setText(eq("florent"));    }
@Test  @PrepareForTest(TerrapinUploaderOptions.class)  public void testInitFromSystemProperties() {    PowerMockito.mockStatic(System.class);    Properties props = new Properties();    props.put("terrapin.zk_quorum", "test_quorum");    props.put("terrapin.namenode", "test_namenode");    props.put("terrapin.cluster", "test_cluster");    props.put("terrapin.fileset", "test_fileset");    props.put("terrapin.num_versions", "4");    props.put("terrapin.partitioner", PartitionerType.CASCADING.name());    when(System.getProperties()).thenReturn(props);    TerrapinUploaderOptions options = TerrapinUploaderOptions.initFromSystemProperties();    options.validate();    assertEquals(props.get("terrapin.zk_quorum"), options.terrapinZkQuorum);    assertEquals(props.get("terrapin.namenode"), options.terrapinNamenode);    assertEquals(props.get("terrapin.cluster"), options.terrapinCluster);    assertEquals(props.get("terrapin.fileset"), options.terrapinFileSet);    assertEquals(Integer.valueOf((String) props.get("terrapin.num_versions")),        Integer.valueOf(options.loadOptions.getNumVersionsToKeep()));    assertEquals(props.get("terrapin.partitioner"), options.loadOptions.partitioner.name());  }
@Test    public void serializeRequestWrapsSource() {        // given        ByteBuf buffer = mock(ByteBuf.class);        IndexTemplateRequest request = createDefaultTestObjectBuilder()                .withSource(buffer)                .build();        // when        ItemSource<ByteBuf> itemSource = request.serialize();        // then        assertEquals(buffer, itemSource.getSource());    }
@Test  public void testDoFilterNthApplies() throws Exception {    HttpServletRequest httpServletRequest = createMock(HttpServletRequest.class);    HttpServletResponse httpServletResponse = createMock(HttpServletResponse.class);    FilterChain filterChain = createMock(FilterChain.class);    AmbariAuthenticationFilter filter1 = createMock(AmbariAuthenticationFilter.class);    expect(filter1.shouldApply(httpServletRequest)).andReturn(false).once();    AmbariAuthenticationFilter filter2 = createMock(AmbariAuthenticationFilter.class);    expect(filter2.shouldApply(httpServletRequest)).andReturn(false).once();    AmbariAuthenticationFilter filterN = createMock(AmbariAuthenticationFilter.class);    expect(filterN.shouldApply(httpServletRequest)).andReturn(true).once();    filterN.doFilter(httpServletRequest, httpServletResponse, filterChain);    expectLastCall().once();    AmbariAuthenticationFilter filter3 = createMock(AmbariAuthenticationFilter.class);    replayAll();    Filter filter = new AmbariDelegatingAuthenticationFilter(Arrays.asList(filter1, filter2, filterN, filter3));    filter.doFilter(httpServletRequest, httpServletResponse, filterChain);    verifyAll();  }
@Test    void apply() {        assertEquals(Tuples.of(0, 1), instance.apply(0));    }
@Test    public void objectWithSchemaDep() {        ObjectSchema actual = (ObjectSchema) SchemaLoader.load(get("objectWithSchemaDep"));        assertEquals(1, actual.getSchemaDependencies().size());    }
@Test  public void testGetQueueInfo() throws Exception {    YarnScheduler yarnScheduler = mock(YarnScheduler.class);    RMContext rmContext = mock(RMContext.class);    mockRMContext(yarnScheduler, rmContext);    ClientRMService rmService = new ClientRMService(rmContext, yarnScheduler,        null, null, null, null);    GetQueueInfoRequest request = recordFactory        .newRecordInstance(GetQueueInfoRequest.class);    request.setQueueName("testqueue");    request.setIncludeApplications(true);    GetQueueInfoResponse queueInfo = rmService.getQueueInfo(request);    List<ApplicationReport> applications = queueInfo.getQueueInfo()        .getApplications();    Assert.assertEquals(2, applications.size());    request.setQueueName("nonexistentqueue");    request.setIncludeApplications(true);    // should not throw exception on nonexistent queue    queueInfo = rmService.getQueueInfo(request);  }
@Test    public void testCustomData() {        PerMessageDeflateClientExtensionHandshaker handshaker =                new PerMessageDeflateClientExtensionHandshaker(6, true, 10, true, true);        WebSocketExtensionData data = handshaker.newRequestData();        assertEquals(PERMESSAGE_DEFLATE_EXTENSION, data.name());        assertTrue(data.parameters().containsKey(CLIENT_MAX_WINDOW));        assertTrue(data.parameters().containsKey(SERVER_MAX_WINDOW));        assertEquals("10", data.parameters().get(SERVER_MAX_WINDOW));        assertTrue(data.parameters().containsKey(CLIENT_MAX_WINDOW));        assertTrue(data.parameters().containsKey(SERVER_MAX_WINDOW));    }
@Test    public void testPurgeExpiredMessage() throws Exception    {        messageSender.purgeExpiredMessages();        verify( messengerDataService ).purgeExpiredMessages();    }
@Test  public void testIsReadyReturnsTrueForClearSampleAndPlayClearSamplesWithoutKeysIsTrue() {    when(mockDrmSession.playClearSamplesWithoutKeys()).thenReturn(true);    // We recreate the queue to ensure the mock DRM session manager flags are taken into account.    sampleQueue = new SampleQueue(allocator, mockDrmSessionManager);    writeTestDataWithEncryptedSections();    assertThat(sampleQueue.isReady(/* loadingFinished= */ false)).isTrue();  }
@Test	public void testNextButton(){		WicketTester tester = createTester();		final Boxed<Integer> pageBox = new Boxed<Integer>();				BootstrapPaginator paginator = new BootstrapPaginator("paginator", Model.of(100)) {			private static final long serialVersionUID = -4486050808642574868L;			@Override			public void onPageChange(AjaxRequestTarget target, IModel<Integer> page) {				pageBox.value=page.getObject();			}		};		paginator.setTotalResults(Model.of(100));		tester.startComponentInPage(paginator);		tester.clickLink("paginator:next:link");		assertEquals(1, (int) pageBox.value);		tester.assertEnabled("paginator:last:link");		tester.assertEnabled("paginator:next:link");		tester.assertEnabled("paginator:previous:link");		tester.assertEnabled("paginator:first:link");	}
@Test    public void testOnDecisionTableSelectedEvent() {        final DecisionTableSelectedEvent event = new DecisionTableSelectedEvent(dtPresenter);        builder.onDecisionTableSelectedEvent(event);        verify(view,               times(1)).setEnabled(true);    }
@Test  public void testSetIsDefaultVersionIfSpecified() {    annotationConfig.setIsDefaultVersionIfSpecified(AnnotationBoolean.TRUE);    assertEquals(true, config.getIsDefaultVersion());  }
@Test    void validateInfo() {        assertThatThrownBy(() -> validator.validateInfo(Map.of("key", "value"), 7))                .isInstanceOf(BadRequestException.class)                .hasMessageContaining("too long");    }
@Test    public void getCompositeLogs() {        SwarmDockerClientFacade facade = new SwarmDockerClientFacade(dockerClient);        TestDockerClient.Service service = new TestDockerClient.Service().tty(true);        service.getLogStreamHandler().                fragment("txt on stdout, ", StdioType.STDOUT).                fragment("txt on stdin, ", StdioType.STDIN).                fragment("txt unknown std type", null);        dockerClient.service(service);        CharSequence logs = facade.getLogs(service.getId());        assertThat(logs.toString()).isEqualTo("txt on stdout, txt on stdin, txt unknown std type");    }
@Test(expected = JsonSyntaxException.class)    public void propagateExceptionWhenTheResponseIsNotJson2() {        new DummyAction.Builder().build().parseResponseBody("banana");    }
@Test    public void testExecuteQuery() throws SQLException {        TGroupConnection conn = null;        PreparedStatement stat = null;        try {            conn = tgds.getConnection();            stat = conn.prepareStatement("select * from xxx where id=?");            stat.setByte(1, (byte) 5);            MockDataSource.addPreData("id:1,name:2");            ResultSet result = stat.executeQuery();            Assert.assertEquals(result.next(), true);            Assert.assertEquals(result.getLong(1), 1L);            Assert.assertEquals(result.getLong(2), 2L);            MockDataSource.showTrace();        } finally {            if (conn != null) {                try {                    conn.close();                } catch (SQLException e) {                }                if (stat != null) {                    try {                        stat.close();                    } catch (SQLException e) {                    }                }            }        }    }
@Test  public void testExecuteDDLUpdates() throws Exception {    Module module = new Module() {      @Override      public void configure(Binder binder) {        binder.bind(DBAccessor.class).toInstance(dbAccessor);        binder.bind(OsFamily.class).toInstance(osFamily);        binder.bind(EntityManager.class).toInstance(entityManager);        binder.bind(Configuration.class).toInstance(configuration);      }    };    Capture<DBAccessor.DBColumnInfo> clusterConfigSelectedColumn = newCapture();    Capture<DBAccessor.DBColumnInfo> clusterConfigSelectedTimestampColumn = newCapture();    dbAccessor.addColumn(eq(UpgradeCatalog300.CLUSTER_CONFIG_TABLE), capture(clusterConfigSelectedColumn));    dbAccessor.addColumn(eq(UpgradeCatalog300.CLUSTER_CONFIG_TABLE), capture(clusterConfigSelectedTimestampColumn));    replay(dbAccessor, configuration);    Injector injector = Guice.createInjector(module);    UpgradeCatalog300 upgradeCatalog300 = injector.getInstance(UpgradeCatalog300.class);    upgradeCatalog300.executeDDLUpdates();    DBAccessor.DBColumnInfo capturedSelectedColumn = clusterConfigSelectedColumn.getValue();    Assert.assertNotNull(capturedSelectedColumn);    Assert.assertEquals(UpgradeCatalog300.CLUSTER_CONFIG_SELECTED_COLUMN, capturedSelectedColumn.getName());    Assert.assertEquals(Short.class, capturedSelectedColumn.getType());    DBAccessor.DBColumnInfo capturedSelectedTimestampColumn = clusterConfigSelectedTimestampColumn.getValue();    Assert.assertNotNull(capturedSelectedTimestampColumn);    Assert.assertEquals(UpgradeCatalog300.CLUSTER_CONFIG_SELECTED_TIMESTAMP_COLUMN, capturedSelectedTimestampColumn.getName());    Assert.assertEquals(Long.class, capturedSelectedTimestampColumn.getType());    verify(dbAccessor);  }
@Test    public void testFindPatientProfileById_Use_Client_Credentials_False_Throws_RuntimeException() throws Exception {        // Arrange        final boolean useClientCredentials = false;        final Long patientId = 5L;        final PatientDto patientDto = mock(PatientDto.class);        when(phrServiceDefault.findPatientProfileById(patientId)).thenThrow(RuntimeException.class);        thrown.expect(RuntimeException.class);        // Act        final PatientDto response = sut.findPatientProfileById(patientId, useClientCredentials);        // Assert        assertEquals(patientDto, response);        verify(phrServiceDefault, times(1)).findPatientProfileById(patientId);        verify(phrServiceClientCredentials, times(0)).findPatientProfileById(patientId);    }
@Test  public void testCopyBytesShouldNotCloseStreamsWhenCloseIsFalse()      throws Exception {    InputStream inputStream = Mockito.mock(InputStream.class);    OutputStream outputStream = Mockito.mock(OutputStream.class);    Mockito.doReturn(-1).when(inputStream).read(new byte[1]);    IOUtils.copyBytes(inputStream, outputStream, 1, false);    Mockito.verify(inputStream, Mockito.atMost(0)).close();    Mockito.verify(outputStream, Mockito.atMost(0)).close();  }
@Test  public void testNewTableName() throws Exception {    TableCache tableCache = new TableCache(schemaManager, OVERRIDING_DATABASE_NAME);    String newTable = "new_table";    when(schemaManager.getTableColumns(DATABASE_NAME, TABLE_NAME)).thenReturn(TABLE_COLUMNS);    List<ColumnDataType> columnTypes =        Arrays.asList(            ColumnDataType.TINY, ColumnDataType.STRING, ColumnDataType.FLOAT, ColumnDataType.LONG);    tableCache.addOrUpdate(TABLE_ID, TABLE_NAME, DATABASE_NAME, columnTypes);    verify(schemaManager, times(1)).getTableColumns(DATABASE_NAME, TABLE_NAME);    when(schemaManager.getTableColumns(DATABASE_NAME, newTable)).thenReturn(TABLE_COLUMNS_UPDATED);    columnTypes = Arrays.asList(ColumnDataType.TINY, ColumnDataType.STRING, ColumnDataType.FLOAT);    tableCache.addOrUpdate(TABLE_ID, newTable, DATABASE_NAME, columnTypes);    verify(schemaManager, times(1)).getTableColumns(DATABASE_NAME, newTable);    verifyZeroInteractions(metrics);  }
@Test    public void makeCameraPhotoFile() {        assertEquals(                SCRATCH_DIR + "/camera_0033.jpg",                mBitMapper.makeCameraPhotoFile(33).toString());    }
@Test	public void readStringFields() {		try {			final String fileContent = "abc|def|ghijk\nabc||hhg\n|||";			final FileInputSplit split = createTempFile(fileContent);						final CsvInputFormat<Tuple3<String, String, String>> format = new CsvInputFormat<Tuple3<String, String, String>>(PATH, "\n", '|', String.class, String.class, String.class);					final Configuration parameters = new Configuration();			format.configure(parameters);			format.open(split);						Tuple3<String, String, String> result = new Tuple3<String, String, String>();						result = format.nextRecord(result);			assertNotNull(result);			assertEquals("abc", result.f0);			assertEquals("def", result.f1);			assertEquals("ghijk", result.f2);						result = format.nextRecord(result);			assertNotNull(result);			assertEquals("abc", result.f0);			assertEquals("", result.f1);			assertEquals("hhg", result.f2);						result = format.nextRecord(result);			assertNotNull(result);			assertEquals("", result.f0);			assertEquals("", result.f1);			assertEquals("", result.f2);						result = format.nextRecord(result);			assertNull(result);			assertTrue(format.reachedEnd());		}		catch (Exception ex) {			ex.printStackTrace();			fail("Test failed due to a " + ex.getClass().getName() + ": " + ex.getMessage());		}	}
@Test    public void register() {        rules.register(new DummyRule());        assertThat(rules).hasSize(1);    }
@Test    public void trunc_LoremIpsum_ReturnsSubstring() {        final String RESULT = "Lorem ipsum dolor sit amet";        assertThat(H.trunc(LOREMIPSUM, 26), equalTo(RESULT));    }
@Test  public void receiveString() throws Exception {    Message<String> event = new Message<String>(0, 1L, 2, 3L, "message");    String input = mapper.writeValueAsString(event);    underTest.receiveString(input);    verify(eventHandler).onEvent(event);  }
@Test  public void testClone() {    assertEquals(createResource(1, 1), Resources.clone(createResource(1, 1)));    assertEquals(createResource(1, 1, 0),        Resources.clone(createResource(1, 1)));    assertEquals(createResource(1, 1),        Resources.clone(createResource(1, 1, 0)));    assertEquals(createResource(1, 1, 2),        Resources.clone(createResource(1, 1, 2)));  }
@Test    void evaluateWithStopCommand() throws Exception    {        this.engine.initialize(new Properties());        assertEvaluate("hello world", "hello world#stop", DEFAULT_TEMPLATE_NAME);    }
@Test    public void setHttp2AuthorityWithUserInfo() {        Http2Headers headers = new DefaultHttp2Headers();        HttpConversionUtil.setHttp2Authority("info@foo", headers);        assertEquals(new AsciiString("foo"), headers.authority());        HttpConversionUtil.setHttp2Authority("@foo.bar", headers);        assertEquals(new AsciiString("foo.bar"), headers.authority());    }
@Test  @DatabaseSetup("HibernateMedicationsDaoTest.testGetRoutes.xml")  public void testGetRoutes()  {    final List<MedicationRouteDto> routes = medicationsDao.getRoutes(new DateTime(2013, 10, 28, 12, 0, 0));    assertEquals(3L, (long)routes.size());    assertEquals("1", routes.get(0).getCode());    assertEquals("po", routes.get(0).getName());    assertNull(routes.get(0).getType());    assertEquals("4", routes.get(1).getCode());    assertEquals("ivk", routes.get(1).getName());    assertEquals(MedicationRouteTypeEnum.IV, routes.get(1).getType());    assertEquals("5", routes.get(2).getCode());    assertEquals("im", routes.get(2).getName());    assertEquals(MedicationRouteTypeEnum.IV, routes.get(2).getType());  }
@Test    public void testGetUnicodeEmojis_withException() throws Exception {        ObjectMapper objectMapper = mock(ObjectMapper.class);        IOException exception = new IOException("test");        when(objectMapper.readValue(any(URL.class), any(JavaType.class))).thenThrow(exception);        try {            LocalEmojiUtils.getUnicodeEmojis(objectMapper);            fail();        } catch (RuntimeException e) {            assertEquals(exception, e.getCause());        }    }
@Test    public void testReadTrackMidiParameter() throws Exception {        instance.openFile(simpleFile);        Mockito.verify(listener).readTrackMidiParameter(0, 1, 1, 2, 24, 0, 255, 0, 0);    }
@Test    public void nickShouldChangeNickNameAndShowSystemMessageAndUpdateUserInterface() throws CommandException {        doAnswer(withSetNickNameOnMe()).when(controller).changeMyNick(anyString());        parser.parse("/nick NewNick");        verify(messageController).showSystemMessage("You changed nick to NewNick");        verify(controller).changeMyNick("NewNick");        verify(userInterface).showTopic();    }
@Test    public void testBasicInput2() {        List<SugiliteTextParentAnnotator.AnnotatingResult> results =                annotator.annotate("Current time: 13:59");        assertTrue(results.size() == 1);        assertEquals(results.get(0).getNumericValue().intValue(), (13*3600)+(59*60));//(13*60+59)*1000);        assertTrue(results.get(0).getRelation().equals(SugiliteRelation.CONTAINS_TIME));    }
@Test    public void shouldNotifyOnDestroyView() {        dispatcher.onDestroyView(fragment);        verify(lifeCycleComponent1).onDestroyView(fragment);        verify(lifeCycleComponent2).onDestroyView(fragment);    }
@Test    public void testCall() throws Exception    {        doReturn( RegistrationStatus.APPROVED ).when( peer ).getStatus();        task.call();        verify( peer ).resetSwarmSecretKey( p2PCredentials );        doReturn( RegistrationStatus.CANCELLED ).when( peer ).getStatus();        task.call();        verify( trackerOperation ).addLog( anyString() );    }
@Test(expected = IllegalArgumentException.class)	public void testInvalid1() throws Exception {		RetryPolicyFactory.create(null);	}
@Test    void test() {        assertThatThrownBy(() -> {            final SecurityContext securityContext = new SecurityContextImpl(null, null, null, null, null);            securityContext.secure(Assertions::fail);        }).isInstanceOf(AuthenticationException.class);    }
@Test  public void testUpdateHBaseAdnClusterConfigs() throws Exception {    setupIoCContext();    EasyMockSupport easyMockSupport = new EasyMockSupport();    final AmbariManagementController mockAmbariManagementController = easyMockSupport.createNiceMock(AmbariManagementController.class);    final ConfigHelper mockConfigHelper = easyMockSupport.createMock(ConfigHelper.class);    final Clusters mockClusters = easyMockSupport.createStrictMock(Clusters.class);    final Cluster mockClusterExpected = easyMockSupport.createNiceMock(Cluster.class);    final Map<String, String> propertiesHbaseSite = new HashMap<String, String>() {      {        put("hbase.bucketcache.size", "1024m");      }    };    final Map<String, String> propertiesHbaseEnv = new HashMap<String, String>() {      {        put("override_hbase_uid", "false");      }    };    final Config mockHbaseEnv = easyMockSupport.createNiceMock(Config.class);    expect(mockHbaseEnv.getProperties()).andReturn(propertiesHbaseEnv).once();    final Config mockHbaseSite = easyMockSupport.createNiceMock(Config.class);    expect(mockHbaseSite.getProperties()).andReturn(propertiesHbaseSite).once();    final Config mockClusterEnv = easyMockSupport.createNiceMock(Config.class);    final Map<String, String> propertiesExpectedHbaseEnv = new HashMap<String, String>();    final Map<String, String> propertiesExpectedClusterEnv = new HashMap<String, String>() {{      put("override_uid", "false");    }};    final Map<String, String> propertiesExpectedHbaseSite = new HashMap<String, String>() {{      put("hbase.bucketcache.size", "1024");    }};    final Injector mockInjector = Guice.createInjector(new AbstractModule() {      @Override      protected void configure() {        bind(AmbariManagementController.class).toInstance(mockAmbariManagementController);        bind(ConfigHelper.class).toInstance(mockConfigHelper);        bind(Clusters.class).toInstance(mockClusters);        bind(DBAccessor.class).toInstance(createNiceMock(DBAccessor.class));        bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class));      }    });    expect(mockAmbariManagementController.getClusters()).andReturn(mockClusters).once();    expect(mockClusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{      put("normal", mockClusterExpected);    }}).once();    expect(mockClusterExpected.getDesiredConfigByType("cluster-env")).andReturn(mockClusterEnv).atLeastOnce();    expect(mockClusterExpected.getDesiredConfigByType("hbase-env")).andReturn(mockHbaseEnv).atLeastOnce();    expect(mockClusterExpected.getDesiredConfigByType("hbase-site")).andReturn(mockHbaseSite).atLeastOnce();    expect(mockClusterEnv.getProperties()).andReturn(propertiesExpectedClusterEnv).atLeastOnce();    expect(mockHbaseEnv.getProperties()).andReturn(propertiesExpectedHbaseEnv).atLeastOnce();    expect(mockHbaseSite.getProperties()).andReturn(propertiesExpectedHbaseSite).atLeastOnce();    easyMockSupport.replayAll();    mockInjector.getInstance(UpgradeCatalog212.class).updateHbaseAndClusterConfigurations();    easyMockSupport.verifyAll();  }
@Test(expected = IllegalArgumentException.class)  public void testHasPermissionForOrganizationNamedFunctionWithOrganizationOfWrongType() throws Exception {    String content = "" +            "subject.1.name = subject\n" +            "organization.1.name = organization\n" +            "subject.1.permission.1 = function" +            "";    setup(content);    accessController.hasPermission(createCredentials(1), () -> "function", new OrganizationIdentity() {    });  }
@Test(expected = UnsupportedOperationException.class)    public void setAttribute() {        request.setAttribute(null, "");    }
@Test    void testRequireNonNegative3() {        assertEquals(0.0, DoubleRangeUtil.requireNonNegative(0.0, RuntimeException::new));    }
@Test  public void testCampaign() {    String expected = "customers/1234/campaigns/5678";    assertEquals(expected, ResourceNames.campaign(1234L, 5678L));  }
@Test	public void shouldNotRollbackIfTxnIsNotOpen() {		EntityTransaction txn = mockTransaction(context, false);		context.closeTxn(false);		verify(txn, never()).rollback();	}
@Test public void testOnCreate() {		// Arrange:		final FragmentActivity activity = Robolectric.buildActivity(TestCompatActivity.class).create().start().resume().get();		final FragmentManager fragmentManager = activity.getSupportFragmentManager();		final ActionBarFragment fragment = new TestFragment();		// Act:		fragmentManager.beginTransaction().add(fragment, null).commit();		fragmentManager.executePendingTransactions();	}
@Test  public void testInterpret() {    final E expression = this.factory.apply(this.first, this.second);    assertNotNull(expression);    assertEquals(this.result, expression.interpret());  }
@Test    public void testIsCarpaccioControlledView_false() throws Exception {        View view = mock(View.class);        doReturn("setColor").when(view).getTag();        assertFalse(carpaccioManager.isCarpaccioControlledView(view));    }
@Test    public void getSignatureTest01() {        try {            Class<?> clazz = Class.forName("com.credits.scapi.v0.SmartContract");            Map<Method, String> methods = JavaReflect.getDeclaredMethods(clazz);            methods.forEach((k, v) -> {                LOGGER.info(v);            });        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }
@Test  public void testAuthWithoutId() throws Exception {    Authentication auth = new UsernamePasswordAuthenticationToken("admin", null);    SecurityContextHolder.getContext().setAuthentication(auth);    Integer userId = AuthorizationHelper.getAuthenticatedId();    Assert.assertEquals(Integer.valueOf(-1), userId);  }
@Test	public void getContractClassShouldReturnNullForStub() {		final Class<?> result = OperatorUtil.getContractClass(Function.class);		assertEquals(null, result);	}
@Test  public void testLdapAuthenticates() {    Authentication authentication = new TestingAuthenticationToken("principal", "credentials");    expect(mockLdapProvider.authenticate(authentication)).andReturn(SUCCESSFUL_AUTHENTICATION);        replay(mockLdapProvider, mockFileProvider, mockSimpleProvider, mockExternalServerProvider);        Authentication authenticationResult = provider.authenticate(authentication);    assertSame(authenticationResult, SUCCESSFUL_AUTHENTICATION);        verify(mockLdapProvider, mockFileProvider, mockSimpleProvider, mockExternalServerProvider);  }
@Test    void setTypeMapper() {        assertDoesNotThrow(() -> getMutatorInstance().setTypeMapper(String.class));    }
@Test(timeout = 3000)    public void testConnectFutureBeforeChannelActive() throws Exception {        Bootstrap cb = new Bootstrap();        ServerBootstrap sb = new ServerBootstrap();        cb.group(group1)                .channel(LocalChannel.class)                .handler(new ChannelInboundHandlerAdapter());        sb.group(group2)                .channel(LocalServerChannel.class)                .childHandler(new ChannelInitializer<LocalChannel>() {                    @Override                    public void initChannel(LocalChannel ch) throws Exception {                        ch.pipeline().addLast(new TestHandler());                    }                });        Channel sc = null;        Channel cc = null;        try {            // Start server            sc = sb.bind(TEST_ADDRESS).sync().channel();            cc = cb.register().sync().channel();            final ChannelPromise promise = cc.newPromise();            final Promise<Void> assertPromise = cc.eventLoop().newPromise();            cc.pipeline().addLast(new TestHandler() {                @Override                public void channelActive(ChannelHandlerContext ctx) throws Exception {                    // Ensure the promise was done before the handler method is triggered.                    if (promise.isDone()) {                        assertPromise.setSuccess(null);                    } else {                        assertPromise.setFailure(new AssertionError("connect promise should be done"));                    }                }            });            // Connect to the server            cc.connect(sc.localAddress(), promise).sync();            assertPromise.syncUninterruptibly();            assertTrue(promise.isSuccess());        } finally {            closeChannel(cc);            closeChannel(sc);        }    }
@Test    public void shouldReturnZeroAsLastAppliedIndexAfterInitialization() throws Exception {        long lastAppliedIndex = localStore.getLastAppliedIndex();        assertThat(lastAppliedIndex, equalTo(0L));    }
@Test    public void testBucketCreatedEvent() {        final Event event = EventFactory.bucketCreated(bucket);        event.validate();        assertEquals(EventType.CREATE_BUCKET, event.getEventType());        assertEquals(2, event.getFields().size());        assertEquals(bucket.getIdentifier(), event.getField(EventFieldName.BUCKET_ID).getValue());        assertEquals("unknown", event.getField(EventFieldName.USER).getValue());    }
@Test    void investmentMade() {        final InvestmentMadeEvent e = EventFactory.investmentMade(MockLoanBuilder.fresh(), Money.from(200),                mockPortfolioOverview());        assertSoftly(softly -> {            softly.assertThat(e.getLoan())                .isNotNull();            softly.assertThat(e.getInvestedAmount())                .isEqualTo(Money.from(200));            softly.assertThat(e.getPortfolioOverview())                .isNotNull();        });    }
@Test    public void literalsMustNotContainCloseBrace() {        Throwable thrown = Assertions.assertThrows(InvalidPatternException.class, () -> {            EndpointTrait.builder()                    .hostPrefix("foo-}baz")                    .build();        });        assertThat(thrown.getMessage(), containsString("Literal segments must not contain `}`"));    }
@Test    void contains() {        assertThat(Range.of(10L, 20L).contains(9)).isFalse();        assertThat(Range.of(10L, 20L).contains(10)).isTrue();        assertThat(Range.of(10L, 20L).contains(15)).isTrue();        assertThat(Range.of(10L, 20L).contains(19)).isTrue();        assertThat(Range.of(10L, 20L).contains(20)).isFalse();    }
@Test	public void test17populateRangerEnumDefToXXnullValue() {		RangerEnumDef rangerEnumDefObj = null;		XXEnumDef enumDefObj = null;		XXServiceDef serviceDefObj = null;		Mockito.when(				restErrorUtil.createRESTException(						"RangerServiceDef cannot be null.",						MessageEnums.DATA_NOT_FOUND)).thenThrow(				new WebApplicationException());		thrown.expect(WebApplicationException.class);		XXEnumDef dbEnumDef = rangerServiceDefService				.populateRangerEnumDefToXX(rangerEnumDefObj, enumDefObj,						serviceDefObj, 1);		Assert.assertNull(dbEnumDef);	}
@Test  public void testThatNameChangeIsCalledInitiallyButNotAgainIfNameIsSame() {    final String name = "QUACKERY!";    final int[] publishNameChangedCallCount = {0};    final TestNetworkPublisher publisher = new TestNetworkPublisher() {      @Override      protected void publishNameChanged(Optional<String> oldName, String newName) {        publishNameChangedCallCount[0]++;        assertEquals("Name was not the new name", name, newName);      }    };    publisher.setName(name);    assertEquals("publishNameChanged was called an unexpected number of times", 1,        publishNameChangedCallCount[0]);    publisher.setName(name);    assertEquals("publishNameChanged should not have been called agian", 1,        publishNameChangedCallCount[0]);  }
@Test    public void testGetJobStartParamsPreviousMonths() {        int month = 3;        int year = 2014;        List<JobStartParams> jobStartParamsPreviousMonths = jobResultsService.getJobStartParamsPreviousMonths(year, month);        assertThat(jobStartParamsPreviousMonths.size()).isEqualTo(6);        assertThat(jobStartParamsPreviousMonths.get(0).getMonth()).isEqualTo(month);        assertThat(jobStartParamsPreviousMonths.get(0).getYear()).isEqualTo(year);        assertThat(jobStartParamsPreviousMonths.get(1).getMonth()).isEqualTo(month - 1);        assertThat(jobStartParamsPreviousMonths.get(1).getYear()).isEqualTo(year);        assertThat(jobStartParamsPreviousMonths.get(2).getMonth()).isEqualTo(month - 2);        assertThat(jobStartParamsPreviousMonths.get(2).getYear()).isEqualTo(year);        assertThat(jobStartParamsPreviousMonths.get(3).getMonth()).isEqualTo(12);        assertThat(jobStartParamsPreviousMonths.get(3).getYear()).isEqualTo(year - 1);        assertThat(jobStartParamsPreviousMonths.get(4).getMonth()).isEqualTo(11);        assertThat(jobStartParamsPreviousMonths.get(4).getYear()).isEqualTo(year - 1);        assertThat(jobStartParamsPreviousMonths.get(5).getMonth()).isEqualTo(10);        assertThat(jobStartParamsPreviousMonths.get(5).getYear()).isEqualTo(year - 1);    }
@Test    @Parameters({"false", "true"})    public void eventPlace(boolean experimentalMode) throws Exception {        CSLItemData item = new CSLItemDataBuilder()                .type(CSLType.PAPER_CONFERENCE)                .title("The Paper")                .author("The", "Author")                .event("Conference")                .eventPlace("The Place")                .build();        String bib = CSL.makeAdhocBibliography("ieee", "text", experimentalMode, item).makeString();        assertEquals("[1]T. Author, \u201cThe Paper,\u201d presented at the Conference, The Place.\n", bib);    }
@Test    void forEachRemainingConsumer() {        instance.forEachRemaining((Consumer<Integer>) i -> cnt.incrementAndGet());        assertEquals(1, cnt.get());    }
@Test    public void testAAAAAPossiblePrefixes() throws Exception {        assertFalse(spelling.possiblePrefixes("aaaaa"));    }
@Test  public void versionPng() throws Exception {    mockMvc.perform(get(CONTEXT_PATH + "/version.png")).andExpect(status().is3xxRedirection()).andExpect(        redirectedUrl(String.format(PNG_URL_FORMAT, VERSION)));  }
@Test(expected = BundleException.class)    public void testExtractFromNarMissingManifest() throws IOException {        try (final InputStream in = new FileInputStream("src/test/resources/nars/nifi-missing-manifest.nar")) {            extractor.extract(in);            fail("Should have thrown exception");        }    }
@Test  public void testAccept() {    KlvProcessor.Visitor visitor = mock(KlvProcessor.Visitor.class);    setDatesKlvProcessor.accept(visitor);    verify(visitor).visit(setDatesKlvProcessor);  }
@Test	public void testGetTitleWithoutAttribute() {		DLEditFileShortcutDisplayContext dlEditFileShortcutDisplayContext =			_getDLEditFileShortcutDisplayContext(new MockHttpServletRequest());		Mockito.when(			_language.get(				Mockito.any(HttpServletRequest.class),				Mockito.eq("new-file-shortcut"))		).thenReturn(			"New"		);		Assert.assertEquals("New", dlEditFileShortcutDisplayContext.getTitle());	}
@Test    void helpWithNonexistentSubcommand() {        final int exit = Cli.parse("help", UUID.randomUUID()            .toString());        assertThat(exit).isEqualTo(CommandLine.ExitCode.USAGE);    }
@Test    public void formattersMustNotBeLowercase() {        Assertions.assertThrows(IllegalArgumentException.class, () -> {            CodeFormatter formatter = new CodeFormatter();            formatter.putFormatter('a', CodeFormatterTest::valueOf);        });    }
@Test public void txn_basic_01() {        long v1 = counter.get() ;        assertEquals(0, v1) ;        Txn.executeRead(counter, () -> {            assertEquals(0, counter.get()) ;        }) ;    }
@Test    public void testDenied() {        final AuthorizerConfigurationContext configurationContext = createMockConfigContext();        setup(mock(NiFiRegistryProperties.class), mock(UserGroupProvider.class), configurationContext);        final String systemResource = "/system";        final RequestAction action = RequestAction.WRITE;        final String user = "admin";        // the incoming NiFi request to test        final AuthorizationRequest request = new AuthorizationRequest.Builder()                .resource(new MockResource(systemResource, systemResource))                .action(action)                .identity(user)                .resourceContext(new HashMap<>())                .accessAttempt(true)                .anonymous(false)                .build();        // the expected Ranger resource and request that are created        final RangerAccessResourceImpl resource = new RangerAccessResourceImpl();        resource.setValue(RangerAuthorizer.RANGER_NIFI_REG_RESOURCE_NAME, systemResource);        final RangerAccessRequestImpl expectedRangerRequest = new RangerAccessRequestImpl();        expectedRangerRequest.setResource(resource);        expectedRangerRequest.setAction(request.getAction().name());        expectedRangerRequest.setAccessType(request.getAction().name());        expectedRangerRequest.setUser(request.getIdentity());        // no result processor should be provided used non-direct access        when(rangerBasePlugin.isAccessAllowed(                argThat(new RangerAccessRequestMatcher(expectedRangerRequest)))        ).thenReturn(notAllowedResult);        // return true when checking if a policy exists for the resource        when(rangerBasePlugin.doesPolicyExist(systemResource, action)).thenReturn(true);        final AuthorizationResult result = authorizer.authorize(request);        assertEquals(AuthorizationResult.denied().getResult(), result.getResult());    }
@Test    public void howLongFromNowShouldReturnCorrectWhenDays() {        final DateTime then = new DateTime()                .minusSeconds(6)                .minusMinutes(44)                .minusHours(14)                .minusDays(2);        final String howLongFromNow = dateTools.howLongFromNow(then.toDate().getTime());        // Note: this might fail when logonTime is summer time and current time is not        assertEquals("2 days, 14:44:06", howLongFromNow);    }
@Test(dataProvider = "inOrderTree")    public void testInOrder(BinaryTreeNode head, List<Integer> expectedResult){        Traversal traversal = new Traversal();        assertEquals(traversal.inOrderTraverse(head), expectedResult);    }
@Test    public void testRemoveServiceGroupDictionary() {        jsonString = "{\"userid\":\"demo\",\"data\":{\"id\":1,\"description\":\"test\",\"name\":\"Test\"}}";        testRemove(GroupServiceList.class, "serviceGroupDictionaryDatas",                () -> controller.removeServiceGroupDictionary(request, response));    }
@Test    public void testSetContext_historyShapeIsSetFromDimensionMap() {        final Map<String, Integer> dimensionConfiguration = new HashMap<>();        dimensionConfiguration.put(Constants.DIMENSION_NAME_INSITU_NTIME, 53);        final Context context = new ContextBuilder().dimensionConfiguration(dimensionConfiguration).build();        final InsituTime insituTime = new InsituTime();        insituTime.setContext(context);        assertNotNull(insituTime.historyShape);        assertArrayEquals(new int[]{1, 53}, insituTime.historyShape);    }
@Test    public void prioritisedGeneWithKnownDiseaseNoInheritanceModes() {        Gene gene = newGeneCompatibleWith(ModeOfInheritance.X_RECESSIVE);        addHiPhiveResultWithScore(gene, PHENOTYPE_SCORE);        //this is currently the case with Orphanet        InheritanceMode[] inheritanceModes = {InheritanceMode.UNKNOWN};        Map<ModeOfInheritance, Double> scores = new EnumMap<>(ModeOfInheritance.class);        addOmimResultToGene(gene, scores, inheritanceModes);        double score = instance.calculateGenePriorityScoreForMode(gene, ModeOfInheritance.X_RECESSIVE);        assertThat(score, equalTo(PHENOTYPE_SCORE));    }
@Test    public void testGetPathogenicityScoreNonMissenseVariantNoPredictions() {        VariantEffect type = VariantEffect.DOWNSTREAM_GENE_VARIANT;        instance = testVariantBuilder().variantEffect(type).build();        float expected = VariantEffectPathogenicityScore.getPathogenicityScoreOf(type);        assertThat(instance.getPathogenicityScore(), equalTo(expected));    }
@Test(expected = IllegalStateException.class)    public void TooShortSTLTest() {        constant = "2";        constants.add(constant);        datapoints.put(1000L, 1000.0);        datapoints.put(2000L, 1000.0);        datapoints.put(3000L, 1000.0);        metric.setDatapoints(datapoints);        metrics.add(metric);        List<Metric> transformedMetrics = anomalySTLTransform.transform(null, metrics, constants);    }
@Test    void testFlatMapToLong() {        final long expected = refStream().flatMapToLong(e -> LongStream.range(0, e.getValue())).sum();        final long actual = instance.flatMapToLong((k, v) -> LongStream.range(0, v)).sum();        assertEquals(expected, actual);    }
@Test  public void testGetAzkabanURL() {    final CommonMetrics commonMetrics = new CommonMetrics(new MetricsManager(new MetricRegistry()));    final Emailer emailer = new Emailer(this.props, commonMetrics, this.messageCreator,        this.executorLoader);    assertThat(emailer.getAzkabanURL()).isEqualTo("http://localhost:8786");  }
@Test    public void testHasText() throws Exception {    }
@Test    public void getSupplier_empty() {        final KafkaProducerFactory kafkaProducerFactory = new KafkaProducerFactoryImpl(kafkaConfigDocCache);        final KafkaConfigDoc kafkaConfigDoc = createKafkaConfigDoc("Config1", "v1");        final DocRef docRef = DocRefUtil.create(kafkaConfigDoc);        final SharedKafkaProducer sharedKafkaProducer = kafkaProducerFactory.getSharedProducer(docRef);        // Cache knows nothing of the doc so there cannot be a producer        assertThat(sharedKafkaProducer.getKafkaProducer()).isEmpty();        assertThat(sharedKafkaProducer.hasKafkaProducer()).isFalse();        // Check we can still close with an empty supplier        sharedKafkaProducer.close();    }
@Test    public void testPermittedTopology_linestring_polygon() {        DimensionInfo sourceDimensionInfo = DimensionInfo.XY_LINESTRING;        DimensionInfo targetDimensionInfo = DimensionInfo.XY_POLYGON;        SfEqualsFF instance = new SfEqualsFF();        boolean expResult = true;        boolean result = instance.permittedTopology(sourceDimensionInfo, targetDimensionInfo);        assertEquals(expResult, result);    }
@Test    void assumeRolePolicy() {        IAM iam = new IAM(new DefaultAWSCredentialsProviderChain(), Regions.US_EAST_1);        String document = iam.assumeRolePolicyDocument();        assertThat(document).contains("\"Service\":\"ec2.amazonaws.com\"");    }
@Test    public void testSetValue() {        mKeyValue = new KeyValue<>(KEY, DOUBLE_VALUE_1);        mKeyValue.setValue(DOUBLE_VALUE_2);        assertEquals(DOUBLE_VALUE_2, mKeyValue.getValue(), 0);    }
@Test  void getPathFromHeaders_withQueryString() {    headers.path("/foo/extracted?query1=abc&query2=123");    String path = Http2Handler.getPathFromHeaders(headers);    assertEquals("/foo/extracted", path);  }
@Test    public void test_createRole() throws Exception {        AWSLoginRole awsLoginRole = new AWSLoginRole("ec2", "mytestawsrole", "ami-fce3c696",                "1234567890123", "us-east-2", "vpc-2f09a348", "subnet-1122aabb",                "arn:aws:iam::8987887:role/test-role", "arn:aws:iam::877677878:instance-profile/exampleinstanceprofile",                "\"[prod, dev\"]");        String inputJson =new ObjectMapper().writeValueAsString(awsLoginRole);        String responseMessage = "{\"messages\":[\"AWS Role created \"]}";        ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseMessage);        UserDetails userDetails = getMockUser(false);        when(selfSupportService.createRole(eq(userDetails), eq("5PDrOhsy4ig8L3EpsJZSLAMg"),Mockito.any(AWSLoginRole.class), eq("users/mysafe01"))).thenReturn(responseEntityExpected);        mockMvc.perform(MockMvcRequestBuilders.post("/v2/ss/auth/aws/role?path=users/mysafe01").requestAttr("UserDetails", userDetails)                .header("vault-token", "5PDrOhsy4ig8L3EpsJZSLAMg")                .header("Content-Type", "application/json;charset=UTF-8")                .content(inputJson))                .andExpect(status().isOk())                .andExpect(content().string(containsString(responseMessage)));    }
@Test  public void isWildcardType() {    assertThat(Types.isWildcardType(STRING)).isFalse();    TypeToken<?> t = new TypeToken<Collection<?>>() {};    assertThat(Types.isWildcardType(        t.resolveType(((ParameterizedType) t.getType()).getActualTypeArguments()[0]))).isTrue();    t = new TypeToken<Collection<? extends String>>() {};    assertThat(Types.isWildcardType(        t.resolveType(((ParameterizedType) t.getType()).getActualTypeArguments()[0]))).isTrue();  }
@Test    public void intropectorCanAccessActionPayload() {        // given        BatchItemIntrospector<AbstractDocumentTargetedAction<DocumentResult>> introspector = new JestActionIntrospector();        String testPayload = "testPayload";        AbstractDocumentTargetedAction<DocumentResult> action = new Index.Builder(testPayload).build();        // when        String payload = (String) introspector.getPayload(action);        // then        Assert.assertEquals(testPayload, payload);    }
@Test  public void unionValue() throws Exception {    doReturn(TextNode.valueOf("bar")).when(obfuscator).apply(TextNode.valueOf("foo"));    JsonNode result = underTest.transform(f1Unnested, singletonList("/0/f1"));    assertThat(result, is(mapper.createObjectNode().put("f1", "bar")));  }
@Test    public void getLabel() {        assertEquals("Replicate Page", validator.getLabel());    }
@Test  public void breadthFirst_oneEdge() {    Walker<String> walker = dataType.newWalker(ImmutableListMultimap.of("foo", "bar"));    assertThat(walker.breadthFirstFrom("foo")).containsExactly("foo", "bar").inOrder();  }
@Test    public void testBind() throws Exception {        Map<String, Object> o = newLinkedHashMap();        o.put("host", "localhost");        o.put("port", 2);        o.put("auto", true);        Config c = ConfigFactory.fromMap(o);        Example e = ConfigFactory.bind(c, Example.class);        assertEquals(2, e.getPort());        String host = e.getHost().get();        assertEquals("localhost", host);        assertEquals(true, e.isAuto());        try {            e.getUser();            fail("user");        } catch (IllegalStateException se) {        }        BindConfig bc = new BindConfig();        bc.setAllowMissing(true);        e = ConfigFactory.bind(c, Example.class, bc);        assertNull(e.getUser());        assertTrue(!e.alias().isPresent());        o.put("alias", "demo");        assertEquals("demo", e.alias().get());    }
@Test   public void testOfferProducerWithNoAddressDoesNotGrantNegativeCredit() {      // Mock returns to get at the runnable that grants credit.      Mockito.when(manager.getServer()).thenReturn(server);      Mockito.when(server.getPagingManager()).thenReturn(pagingManager);      // Capture credit runnable and invoke to trigger credit top off      ArgumentCaptor<Runnable> argument = ArgumentCaptor.forClass(Runnable.class);      AMQPSessionCallback session = new AMQPSessionCallback(protonSPI, manager, connection, transportConnection, executor, operationContext);      // Credit is at threshold      Mockito.when(receiver.getCredit()).thenReturn(AMQP_LOW_CREDITS_DEFAULT);      session.flow(null, ProtonServerReceiverContext.createCreditRunnable(1, AMQP_LOW_CREDITS_DEFAULT, receiver, connection));      // Run the credit refill code.      Mockito.verify(pagingManager).checkMemory(argument.capture());      assertNotNull(argument.getValue());      argument.getValue().run();      // Ensure we aren't looking at remote credit as that gives us the wrong view of what credit is at the broker      Mockito.verify(receiver, never()).getRemoteCredit();      // Credit runnable should not grant what would be negative credit here      Mockito.verify(receiver, never()).flow(anyInt());   }
@SuppressWarnings("unchecked")  @Test  public void testInitNextRecordReader() throws IOException{    JobConf conf = new JobConf();    Path[] paths = new Path[3];    long[] fileLength = new long[3];    File[] files = new File[3];    LongWritable key = new LongWritable(1);    Text value = new Text();    try {      for(int i=0;i<3;i++){        fileLength[i] = i;        File dir = new File(outDir.toString());        dir.mkdir();        files[i] = new File(dir,"testfile"+i);        FileWriter fileWriter = new FileWriter(files[i]);        fileWriter.close();        paths[i] = new Path(outDir+"/testfile"+i);      }      CombineFileSplit combineFileSplit = new CombineFileSplit(conf, paths, fileLength);      Reporter reporter = Mockito.mock(Reporter.class);      CombineFileRecordReader cfrr = new CombineFileRecordReader(conf, combineFileSplit,        reporter,  TextRecordReaderWrapper.class);      verify(reporter).progress();      Assert.assertFalse(cfrr.next(key,value));      verify(reporter, times(3)).progress();    } finally {      FileUtil.fullyDelete(new File(outDir.toString()));    }  }
@Test    public void testColumnManagementGroupTitleWorkItemInsertFactEmpty() throws Exception {        final ActionWorkItemInsertFactCol52 column = mock(ActionWorkItemInsertFactCol52.class);        doReturn(COLUMN_HEADER).when(column).getHeader();        assertEquals(COLUMN_HEADER,                     DecisionTableColumnViewUtils.getColumnManagementGroupTitle(column));    }
@Test    public void shouldNotScheduleCompletedTask() {        task1.setStatus(Task.Status.COMPLETED);        List<Task> mappedTasks = new DoWhileTaskMapper(metadataDAO).getMappedTasks(taskMapperContext);        assertNotNull(mappedTasks);        assertEquals(mappedTasks.size(), 1);    }
@Test    public void test_isValidSafe_successfully()  {        String token = "7QPMPIGiyDFlJkrK3jFykUqa";        String path = "users/safe01";        String _path = "metadata/"+path;        Response response = getMockResponse(HttpStatus.OK, true, "");        when(reqProcessor.process("/sdb","{\"path\":\""+_path+"\"}",token)).thenReturn(response);        boolean valid = ControllerUtil.isValidSafe(path, token);        assertTrue(valid);    }
@Test    public void buildInsertObservation_should_add_om_parameter_text() throws OXFException, XmlException {        addServiceAndVersion();        addObservationValues();        TextParameter parameter = new TextParameter("test-name", "test-text");        parameters.addParameterShell(new ParameterShell(OmParameter.PARAMETER, parameter));        final String insertObservation = builder.buildInsertObservationRequest(parameters);        NamedValuePropertyType[] parameterArray = InsertObservationDocument.Factory.parse(insertObservation)                .getInsertObservation().getObservationArray(0).getOMObservation().getParameterArray();        assertThat(parameterArray.length, is(1));        assertThat(parameterArray[0].getNamedValue().getName().getHref(), is("test-name"));        XmlString xb = (XmlString) parameterArray[0].getNamedValue().getValue();        assertThat(xb.getStringValue(), is("test-text"));    }
@Test    void trySplit() {        assertNull(instance.trySplit());    }
@Test    public void testSimpleClassName() throws Exception {        testSimpleClassName(String.class);    }
@Test    public void initMenu() {        super.initMenu(businessCentralGridContextMenuSpy);        verify(businessCentralGridContextMenuSpy, times(1)).addExecutableMenuItem(eq(GRIDCONTEXTMENU_RUN_SINGLE_SCENARIO), eq(ScenarioSimulationEditorConstants.INSTANCE.runSingleScenario()), eq("runSingleScenario"));    }
@Test  public void testSetCsvAvailable() throws Exception {    assertTrue( roh.isCsvAvailable() );    roh.setCsvAvailable( false );    assertFalse( roh.isCsvAvailable() );  }
@Test  public void metricsTest() throws Exception {    MetricsBean metricsBean = new MetricsBean();    metricsBean.doEventReceived();    metricsBean.doEventAccepted();    metricsBean.doEventAvgTime(5);    metricsBean.doActorReceived();    metricsBean.doActorAccepted();    metricsBean.doActorAvgTime(5);    metricsBean.doRepositoryReceived();    metricsBean.doRepositoryAccepted();    metricsBean.doRepositoryAvgTime(5);    metricsBean.doCommitted();    metricsBean.doCompensated();    metricsBean.doSuspended();    metricsBean.doSagaBeginCounter();    metricsBean.doSagaEndCounter();    metricsBean.doSagaAvgTime(5);    when(metricsService.metrics()).thenReturn(metricsBean);    when(nodeStatus.getTypeEnum()).thenReturn(TypeEnum.MASTER);    mockMvc.perform(get("/alpha/api/v1/metrics"))        .andExpect(status().isOk())        .andExpect(            MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8_VALUE))        .andExpect(jsonPath("$.metrics.eventReceived").value(1))        .andExpect(jsonPath("$.metrics.eventAccepted").value(1))        .andExpect(jsonPath("$.metrics.eventRejected").value(0))        .andExpect(jsonPath("$.metrics.eventAvgTime").value(5.0))        .andExpect(jsonPath("$.metrics.actorReceived").value(1))        .andExpect(jsonPath("$.metrics.actorAccepted").value(1))        .andExpect(jsonPath("$.metrics.actorRejected").value(0))        .andExpect(jsonPath("$.metrics.actorAvgTime").value(5.0))        .andExpect(jsonPath("$.metrics.repositoryReceived").value(1))        .andExpect(jsonPath("$.metrics.repositoryAccepted").value(1))        .andExpect(jsonPath("$.metrics.repositoryRejected").value(0))        .andExpect(jsonPath("$.metrics.repositoryAvgTime").value(5.0))        .andExpect(jsonPath("$.metrics.sagaBeginCounter").value(1))        .andExpect(jsonPath("$.metrics.sagaEndCounter").value(1))        .andExpect(jsonPath("$.metrics.sagaAvgTime").value(5.0))        .andExpect(jsonPath("$.metrics.committed").value(1))        .andExpect(jsonPath("$.metrics.compensated").value(1))        .andExpect(jsonPath("$.metrics.suspended").value(1))        .andExpect(jsonPath("$.nodeType").value(TypeEnum.MASTER.name()))        .andReturn();  }
@Test  public void testReadInt_LittleEndian_EOF() throws Exception {    assertThrows(EOFException.class, () -> asInputStream(0x12, 0x34, 0x56).readInt(JBBPByteOrder.LITTLE_ENDIAN));  }
@Test    public void testZero() {        StringCodec codec = new StringCodec();        Assert.assertEquals("", codec.zeroValue());    }
@Test    public void testDoCommand() {        FooTarget foo = new FooTarget();        BarTarget bar = new BarTarget();        TargetManager manager = TargetManager.getInstance();        // set explicit targets        manager.setTarget(foo);        assertTrue(manager.doCommand("foo", null));        assertFalse(manager.doCommand("bar", null));        manager.setTarget(bar);        assertTrue(manager.doCommand("bar", null));        assertFalse(manager.doCommand("foo", null));        // Add both of the targets all commands are valid        manager.setTarget(null);        manager.addTarget(foo);        manager.addTarget(bar);        assertTrue(manager.doCommand("bar", null));        assertTrue(manager.doCommand("foo", null));    }
@Test    void should_be_thrown_EVCacheInvalidKeyException_when_key_is_null() {        assertThatThrownBy(() -> cache.lookup(null)).isExactlyInstanceOf(EVCacheInvalidKeyException.class)                                                    .hasMessage("Key must not be null");    }
@Test    public void testSetIntervalNulls() {        try {            model.setSelectionInterval(null, null);            fail("normalizedDate must throw NPE if date is null");        } catch (NullPointerException e) {            // expected         } catch (Exception e) {            fail("unexpected exception " + e);        }            }
@Test  public void testHdfsFileStatusWithEcPolicy() throws IOException {    final long now = Time.now();    final String parent = "/dir";    ErasureCodingPolicy dummyEcPolicy = new ErasureCodingPolicy("ecPolicy1",        new ECSchema("EcSchema", 1, 1), 1024 * 2, (byte) 1);    final HdfsFileStatus status = new HdfsFileStatus.Builder()        .length(1001L)        .replication(3)        .blocksize(1L << 26)        .mtime(now)        .atime(now + 10)        .perm(new FsPermission((short) 0644))        .owner("user")        .group("group")        .symlink(DFSUtil.string2Bytes("bar"))        .path(DFSUtil.string2Bytes("foo"))        .fileId(HdfsConstants.GRANDFATHER_INODE_ID)        .ecPolicy(dummyEcPolicy)        .flags(EnumSet.allOf(Flags.class))        .build();    final FileStatus fstatus = toFileStatus(status, parent);    System.out.println("status  = " + status);    System.out.println("fstatus = " + fstatus);    final String json = JsonUtil.toJsonString(status, true);    System.out.println("json    = " + json.replace(",", ",\n  "));    final HdfsFileStatus s2 =        JsonUtilClient.toFileStatus((Map<?, ?>) READER.readValue(json), true);    final FileStatus fs2 = toFileStatus(s2, parent);    System.out.println("s2      = " + s2);    System.out.println("fs2     = " + fs2);    Assert.assertEquals(status.getErasureCodingPolicy(),        s2.getErasureCodingPolicy());    Assert.assertEquals(fstatus, fs2);  }
@Test    public void given4EmployeesOneWithTax_whenGetUnprocessedEmployeeIds_thenReturnCorrectList() {        Employee employee1 = anEmployee();        Employee employee2 = anEmployee();        Employee employee3 = anEmployee();        Employee employee4 = anEmployee();        asList(employee1, employee2, employee3, employee4).forEach(employeeRepository::save);        TaxCalculation tax = new TaxCalculationTestBuilder()                .withEmployee(employee2)                .withYear(2014)                .withMonth(5)                .build();        taxCalculationRepository.save(tax);        assertThat(taxCalculationRepository.getUnprocessedEmployeeIds(2014L, 5L, 0L)).containsOnly(                employee1.getId(),                employee3.getId(),                employee4.getId()        );    }
@Test    public void testEquals() {        TimestampSet set1 = new TimestampSet();        set1.add(6.0);        set1.add(1.0);        TimestampSet set2 = new TimestampSet();        set2.add(6.0);        set2.add(1.0);        TimestampSet set3 = new TimestampSet();        set3.add(6.0);        set3.add(2.0);        Assert.assertTrue(set1.equals(set2));        Assert.assertTrue(set2.equals(set1));        Assert.assertFalse(set1.equals(set3));        Assert.assertFalse(set3.equals(set1));        Assert.assertTrue(set1.hashCode() == set2.hashCode());        Assert.assertFalse(set1.hashCode() == set3.hashCode());    }
