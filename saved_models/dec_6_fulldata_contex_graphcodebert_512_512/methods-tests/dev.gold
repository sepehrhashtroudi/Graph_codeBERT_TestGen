@Test [EOL] public void shouldRespondToObservationRequest_notObserved() { [EOL] Callback<CoapPacket> respCallback = mock(Callback.class); [EOL] server.observe("/test", LOCAL_5683, respCallback, "aa".getBytes(), TransportContext.NULL); [EOL] [EOL] verifyMakeRequest_andThen().onSent(); [EOL] verifyMakeRequest_andThen().call(newCoapPacket().ack(Code.C205_CONTENT).build()); [EOL] [EOL] verify(respCallback).callException(isA(ObservationNotEstablishedException.class)); [EOL] } [EOL]
@Test [EOL] void singleMethod() { [EOL] Token token = parser.parse("method()"); [EOL] assertThat(token).isInstanceOf(MethodToken.class); [EOL] MethodToken methodToken = (MethodToken) token; [EOL] assertEquals("method", methodToken.name); [EOL] assertTrue(methodToken.params.isEmpty()); [EOL] assertNull(methodToken.next); [EOL] } [EOL]
@Test(expected = NullPointerException.class) [EOL] public void ensureArtistNullIdentityThrows() { [EOL] Artist a = Artist.builder().setName("Artist1").build(); [EOL] } [EOL]
@Test [EOL] public void testAppendTo() { [EOL] JobID jobId = new JobID("1234", 1); [EOL] StringBuilder builder = new StringBuilder(); [EOL] [EOL] for (TaskType type : TaskType.values()) { [EOL] builder.setLength(0); [EOL] TaskID taskId = new TaskID(jobId, type, 0); [EOL] String str = String.format("_1234_0001_%c_000000", [EOL] TaskID.getRepresentingCharacter(type)); [EOL] [EOL] assertEquals("The appendTo() method appended the wrong value", [EOL] str, taskId.appendTo(builder).toString()); [EOL] } [EOL] [EOL] try { [EOL] new TaskID().appendTo(null); [EOL] fail("The appendTo() method allowed a null builder"); [EOL] } catch (NullPointerException ex) { [EOL] // Expected [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testExecute_success() throws Exception { [EOL] [EOL] 		File tf = this.folder.newFile(); [EOL] 		Assert.assertEquals( 0, tf.length()); [EOL] [EOL] 		AppendCommandExecution exec = buildExecutor( "append this into " + tf.getAbsolutePath()); [EOL] 		exec.execute(); [EOL] [EOL] 		Assert.assertNotSame( 0, tf.length()); [EOL] 		Assert.assertEquals( "this", Utils.readFileContent( tf )); [EOL] [EOL] 		exec.execute(); [EOL] 		Assert.assertEquals( "this\nthis", Utils.readFileContent( tf )); [EOL] [EOL] 		exec = buildExecutor( "append that into " + tf.getAbsolutePath()); [EOL] 		exec.execute(); [EOL] 		Assert.assertEquals( "this\nthis\nthat", Utils.readFileContent( tf )); [EOL] 	} [EOL]
@Test [EOL] void orElseGet() { [EOL] final ToBoolean<String> toBoolean = instance.orElseGet(string -> true); [EOL] [EOL] assertNotNull(toBoolean); [EOL] assertTrue(toBoolean.applyAsBoolean("three")); [EOL] assertTrue(toBoolean.applyAsBoolean(null)); [EOL] } [EOL]
@Test [EOL] public void testInvokeOccurBusinessexception01() throws Throwable { [EOL] // do setup for test case. [EOL] BusinessException occurException = new BusinessException("testing businessexception"); [EOL] when(mockMethodInvocation.proceed()).thenThrow(occurException); [EOL] [EOL] try { [EOL] // do test. [EOL] testTarget.invoke(mockMethodInvocation); [EOL] fail("didn't occured BusinessException."); [EOL] } catch (BusinessException e) { [EOL] // do assert. [EOL] assertThat(e, is(occurException)); [EOL] verify(mockExceptionLogger, times(1)).warn(occurException); [EOL] verify(mockExceptionLogger, times(1)).warn(any(Exception.class)); [EOL] } [EOL] [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("all") [EOL] public void getExtensionFeedItemTest() { [EOL] com.google.ads.googleads.v5.services.ExtensionFeedItemName resourceName2 = [EOL] com.google.ads.googleads.v5.services.ExtensionFeedItemName.of( [EOL] "[CUSTOMER]", "[EXTENSION_FEED_ITEM]"); [EOL] ExtensionFeedItem expectedResponse = [EOL] ExtensionFeedItem.newBuilder().setResourceName(resourceName2.toString()).build(); [EOL] mockExtensionFeedItemService.addResponse(expectedResponse); [EOL] [EOL] ExtensionFeedItemName resourceName = [EOL] ExtensionFeedItemName.of("[CUSTOMER]", "[EXTENSION_FEED_ITEM]"); [EOL] [EOL] ExtensionFeedItem actualResponse = client.getExtensionFeedItem(resourceName); [EOL] Assert.assertEquals(expectedResponse, actualResponse); [EOL] [EOL] List<AbstractMessage> actualRequests = mockExtensionFeedItemService.getRequests(); [EOL] Assert.assertEquals(1, actualRequests.size()); [EOL] GetExtensionFeedItemRequest actualRequest = (GetExtensionFeedItemRequest) actualRequests.get(0); [EOL] [EOL] Assert.assertEquals(resourceName, ExtensionFeedItemName.parse(actualRequest.getResourceName())); [EOL] Assert.assertTrue( [EOL] channelProvider.isHeaderSent( [EOL] ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), [EOL] GaxGrpcProperties.getDefaultApiClientHeaderPattern())); [EOL] } [EOL]
@Test [EOL] 	public void testGetPublishedFormURL() throws Exception { [EOL] 		Assert.assertEquals( [EOL] 			getSharedFormURL() + _SHARED_FORM_INSTANCE_ID, [EOL] 			_ddmFormAdminDisplayContext.getPublishedFormURL( [EOL] 				mockDDMFormInstance(_SHARED_FORM_INSTANCE_ID, true, false))); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, [EOL] 			_ddmFormAdminDisplayContext.getPublishedFormURL( [EOL] 				mockDDMFormInstance(_SHARED_FORM_INSTANCE_ID, false, false))); [EOL] 	} [EOL]
@Test [EOL] public void testFilter() { [EOL] GenericEntityFilter genericEntityFilter = new GenericEntityFilter(); [EOL] FilterConfiguration filterConfiguration = new FilterConfiguration(); [EOL] Map<String, Collection<String>> entityFilters = new HashMap<>(); [EOL] Collection<String> entityNames = new LinkedList<>(); [EOL] entityNames.add(HTTP2_CLIENT_NAME); [EOL] entityFilters.put(genericEntityFilter.getFilterableEntityName(), entityNames); [EOL] filterConfiguration.setEntityFilters(entityFilters); [EOL] [EOL] List<GenericEntity> filteredEntities = genericEntityFilter.filter("/", filterConfiguration, getTestBundle(), new Bundle()); [EOL] assertEquals(1, filteredEntities.size()); [EOL] [EOL] entityFilters.put(genericEntityFilter.getFilterableEntityName(), Collections.emptySet()); [EOL] filterConfiguration.setEntityFilters(entityFilters); [EOL] filteredEntities = genericEntityFilter.filter("/", filterConfiguration, getTestBundle(), new Bundle()); [EOL] assertEquals(0, filteredEntities.size()); [EOL] [EOL] entityFilters.put(genericEntityFilter.getFilterableEntityName(), ImmutableSet.of("unknownClient")); [EOL] filterConfiguration.setEntityFilters(entityFilters); [EOL] try { [EOL] genericEntityFilter.filter("/", filterConfiguration, getTestBundle(), new Bundle()); [EOL] fail("Filter should have failed to validate the required generic entities"); [EOL] } catch (EntityFilterException e) { [EOL] assertEquals("Missing Generic Entity(s) with name: 'unknownClient'", e.getMessage()); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetContentSupplier() throws Exception { [EOL] [EOL] final String content = ""; [EOL] [EOL] doReturn(content).when(view).getContent(); [EOL] [EOL] final Supplier<String> contentSupplier = drlEditor.getContentSupplier(); [EOL] [EOL] assertEquals(content, contentSupplier.get()); [EOL] } [EOL]
@Test [EOL] public void testNewErrorManager() throws Exception { [EOL] try { [EOL] LogManagerProperties.newErrorManager(null); [EOL] fail("Null was allowed."); [EOL] } catch (NullPointerException expect) { [EOL] } [EOL] [EOL] try { [EOL] LogManagerProperties.newErrorManager(""); [EOL] fail("Empty class was allowed."); [EOL] } catch (ClassNotFoundException expect) { [EOL] } [EOL] [EOL] try { [EOL] LogManagerProperties.newErrorManager(Object.class.getName()); [EOL] fail("Wrong type was allowed."); [EOL] } catch (ClassCastException expect) { [EOL] } [EOL] [EOL] final Class<?> type = ErrorManager.class; [EOL] ErrorManager f = LogManagerProperties.newErrorManager(type.getName()); [EOL] assertEquals(type, f.getClass()); [EOL] [EOL] setPending(new RuntimeException()); [EOL] try { [EOL] final String name = ErrorErrorManager.class.getName(); [EOL] LogManagerProperties.newErrorManager(name); [EOL] fail("Exception was not thrown."); [EOL] } catch (InvocationTargetException expect) { [EOL] assertEquals(RuntimeException.class, expect.getCause().getClass()); [EOL] } finally { [EOL] setPending(null); [EOL] } [EOL] } [EOL]
@Test [EOL] public void removeClass() { [EOL] Model model = assertParse("module M;" [EOL] + "class C(Rat myParam) { Int myField = 99; Int myMethod(String a, Bool b) { return 88; } }" [EOL] + "delta D;" [EOL] + "uses M;" [EOL] + "removes class C;" [EOL] + "productline PL;" [EOL] + "features F;" [EOL] + "delta D when F;" [EOL] + "root FM { group allof { opt F } }"); [EOL] SemanticConditionList errors = new SemanticConditionList(); [EOL] ProductLine pl = model.getProductLine(); [EOL] DeltaTrie trie = ProductLineAnalysisHelper.buildPFGT(pl, errors); [EOL] ProgramAbstraction pa = trie.getRoot().getChildren().get("D").getProgramAbstraction(); [EOL] System.out.println("******\n" + pa); [EOL] assertFalse(pa.getClasses().containsKey("M.C")); [EOL] } [EOL]
@Test(expected = IndexOutOfBoundsException.class) [EOL] public void getChildBad() { [EOL] arrayConstructor.getChild(-1); [EOL] } [EOL]
@Test [EOL] public void testGetValue() { [EOL] final String value = new VariableName(VALID_NAME).getValue(); [EOL] assertNotNull(value); [EOL] assertSame(VALID_NAME, value); [EOL] } [EOL]
@Test [EOL] public void testGetLocalInetAddress() throws Exception { [EOL] assertNotNull(NetUtils.getLocalInetAddress("127.0.0.1")); [EOL] assertNull(NetUtils.getLocalInetAddress("invalid-address-for-test")); [EOL] assertNull(NetUtils.getLocalInetAddress(null)); [EOL] } [EOL]
@Test [EOL] public void testMonitoringServicePropertyInheritance() throws Exception{ [EOL] StackInfo stack = stackManager.getStack("HDP", "2.0.8"); [EOL] Collection<ServiceInfo> allServices = stack.getServices(); [EOL] assertEquals(14, allServices.size()); [EOL] [EOL] boolean monitoringServiceFound = false; [EOL] [EOL] for (ServiceInfo serviceInfo : allServices) { [EOL] if (serviceInfo.getName().equals("FAKENAGIOS")) { [EOL] monitoringServiceFound = true; [EOL] assertTrue(serviceInfo.isMonitoringService()); [EOL] } else { [EOL] assertNull(serviceInfo.isMonitoringService()); [EOL] } [EOL] } [EOL] [EOL] assertTrue(monitoringServiceFound); [EOL] } [EOL]
@Test [EOL] void sleepRoughly() { [EOL] Threads.sleepRoughly(Duration.ZERO); [EOL] } [EOL]
@Test [EOL] public void handleBackDefaultFalse() { [EOL] assertThat(uut.handleBack(new CommandListenerAdapter())).isFalse(); [EOL] } [EOL]
@Test [EOL] public void test_configureLdapUser_successfully() { [EOL] String token = "4EpPYDSfgN2D4Gf7UmNO3nuL"; [EOL] String jsonStr = "{ \"policies\": \"admin,default\",\"username\": \"safeadmin\"}"; [EOL] Response responseNotFound = getMockResponse(HttpStatus.NOT_FOUND, false, ""); [EOL] Response responseNoContent = getMockResponse(HttpStatus.NO_CONTENT, true, ""); [EOL] Response responseOk = getMockResponse(HttpStatus.OK, true, ""); [EOL] ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body("{\"messages\":[\"LDAP user configured\"]}"); [EOL] LDAPUser ldapUser = new LDAPUser("safeadmin", "admin,default"); [EOL] when(JSONUtil.getJSON(ldapUser)).thenReturn(jsonStr); [EOL] when(ControllerUtil.updateMetaDataOnConfigChanges(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(responseOk); [EOL] when(reqProcessor.process("/auth/ldap/users","{\"username\":\"safeadmin\"}",token)).thenReturn(responseNotFound); [EOL] when(reqProcessor.process("/auth/ldap/users/configure",jsonStr,token)).thenReturn(responseNoContent); [EOL] [EOL] ResponseEntity<String> responseEntity = ldapAuthService.configureLdapUser(token, ldapUser); [EOL] assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); [EOL] assertEquals(responseEntityExpected, responseEntity); [EOL] } [EOL]
@Test [EOL] public void testMainLocalOutputFile() throws IOException { [EOL] File file = File.createTempFile("picocli-codegen-example-interface-reflect", ".json"); [EOL] [EOL] ReflectionConfigGenerator.main("--output", file.getAbsolutePath(), ExampleInterface.class.getName()); [EOL] [EOL] String expected = read("/example-interface-reflect.json"); [EOL] expected = expected.replace("\r\n", "\n"); [EOL] expected = expected.replace("\n", System.getProperty("line.separator")); [EOL] [EOL] String actual = readAndClose(new FileInputStream(file)); [EOL] file.delete(); [EOL] [EOL] assertEquals(expected, actual); [EOL] } [EOL]
@Test [EOL] public void testOnZoom75() { [EOL] menuItemFactoryViewMocks.stream().forEach(Mockito::reset); [EOL] [EOL] builder.onZoom(75); [EOL] [EOL] verify(builder.miZoom125pct.getMenuItemView(), [EOL] times(1)).setIconType(eq(null)); [EOL] verify(builder.miZoom100pct.getMenuItemView(), [EOL] times(1)).setIconType(eq(null)); [EOL] verify(builder.miZoom75pct.getMenuItemView(), [EOL] times(1)).setIconType(eq(IconType.CHECK)); [EOL] verify(builder.miZoom50pct.getMenuItemView(), [EOL] times(1)).setIconType(eq(null)); [EOL] verify(modeller, [EOL] times(1)).setZoom(eq(75)); [EOL] } [EOL]
@Test [EOL] 	public void testListCommands() throws Exception { [EOL] [EOL] 		Application inexisting = new Application( "inexisting", this.app.getTemplate()); [EOL] 		Assert.assertEquals( 0, this.cmdMngr.listCommands( inexisting ).size()); [EOL] 		Assert.assertEquals( 0, this.cmdMngr.listCommands( this.app ).size()); [EOL] [EOL] 		this.cmdMngr.createOrUpdateCommand( this.app, "toto", "Good command"); [EOL] 		List<String> list = this.cmdMngr.listCommands( this.app ); [EOL] [EOL] 		Assert.assertEquals( 1, list.size()); [EOL] 		Assert.assertEquals( "toto", list.get( 0 )); [EOL] [EOL] 		this.cmdMngr.createOrUpdateCommand( this.app, "before", "Good command"); [EOL] 		this.cmdMngr.createOrUpdateCommand( this.app, "toto2", "Good command"); [EOL] 		list = this.cmdMngr.listCommands( this.app ); [EOL] [EOL] 		Assert.assertEquals( 3, list.size()); [EOL] 		Assert.assertEquals( "before", list.get( 0 )); [EOL] 		Assert.assertEquals( "toto", list.get( 1 )); [EOL] 		Assert.assertEquals( "toto2", list.get( 2 )); [EOL] [EOL] 		this.cmdMngr.deleteCommand( this.app, "toto" ); [EOL] 		list = this.cmdMngr.listCommands( this.app ); [EOL] [EOL] 		Assert.assertEquals( 2, list.size()); [EOL] 		Assert.assertEquals( "before", list.get( 0 )); [EOL] 		Assert.assertEquals( "toto2", list.get( 1 )); [EOL] 	} [EOL]
@Test [EOL] public void testAsXml() throws Exception { [EOL] final SchematronCriteria criteria = SchematronCriteriaGroupRepositoryTest.newSchematronCriteria(_inc); [EOL] criteria.setValue(""); [EOL] final Element xml = criteria.asXml(); [EOL] assertEquals("''", xml.getChildText("value")); [EOL] } [EOL]
@Test [EOL] public void writeArray() throws Exception { [EOL] ByteArrayOutputStream os = new ByteArrayOutputStream(); [EOL] JsonWriter writer = writer(os); [EOL] writer.writeArray() [EOL] .writeString("hello", true) [EOL] .writeString("world", false) [EOL] .writeString("again", true) [EOL] .done() [EOL] .close(); [EOL] [EOL] assertThat(os.toString(charset.name())).isEqualTo("[\"hello\",\"again\"]"); [EOL] } [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL] public void testValueOfNotSupported() { [EOL] ObjectReference or = this.getObjectReference("Foo"); [EOL] formatter.valueOf("new Foo()", or.referenceType(), new HashMap<>()); [EOL] fail("Set value for object is not supported."); [EOL] } [EOL]
@Test [EOL] public void testDispose() throws Exception [EOL] { [EOL] proxy.dispose(); [EOL] [EOL] verify( environmentManager ).dispose(); [EOL] } [EOL]
@Test [EOL] public void testCopy() throws Exception { [EOL] Format[][] formats = newFormats(2, 3); [EOL] SsManifest sourceManifest = [EOL] createSsManifest( [EOL] createStreamElement("1", formats[0]), createStreamElement("2", formats[1])); [EOL] [EOL] List<StreamKey> keys = [EOL] Arrays.asList(new StreamKey(0, 0), new StreamKey(0, 2), new StreamKey(1, 0)); [EOL] // Keys don't need to be in any particular order [EOL] Collections.shuffle(keys, new Random(0)); [EOL] [EOL] SsManifest copyManifest = sourceManifest.copy(keys); [EOL] [EOL] SsManifest expectedManifest = [EOL] createSsManifest( [EOL] createStreamElement("1", formats[0][0], formats[0][2]), [EOL] createStreamElement("2", formats[1][0])); [EOL] assertManifestEquals(expectedManifest, copyManifest); [EOL] } [EOL]
@Test [EOL] public void setPath() { [EOL] presenterSpy.setPath(observablePathMock); [EOL] assertSame(observablePathMock, presenterSpy.path); [EOL] } [EOL]
@Test [EOL] 	public void test1_11() { [EOL] 		assertEquals(0x0B01, XFSUtils.getVersion("1.11")); [EOL] 	} [EOL]
@Test [EOL] public void testCheck_noTestData() { [EOL] when(directory.listFiles()).thenReturn(new File[] {}); [EOL] try { [EOL] checker.check(directory); [EOL] Assert.fail(); [EOL] } catch (AppException e) { [EOL] Assert.assertEquals(e, new AppException("No test data.")); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testIsOdd() { [EOL] int num = -2; [EOL] System.out.print("num is: " + num + " , is odd: " + DataUtil.isOdd(num)); [EOL] } [EOL]
@Test [EOL] public void testRefresh() { [EOL] OshiPlatformCache oshi = newOshiPlatformCache(); [EOL] Object os1 = oshi.getOperatingSystem(); [EOL] Object mem1 = oshi.getMemory(); [EOL] Object fs1 = oshi.getFileStores(); [EOL] Object proc1 = oshi.getProcessor(); [EOL] Object ps1 = oshi.getPowerSources(); [EOL] [EOL] // see that they are cached - same objects as before [EOL] Object os2 = oshi.getOperatingSystem(); [EOL] Object mem2 = oshi.getMemory(); [EOL] Object fs2 = oshi.getFileStores(); [EOL] Object proc2 = oshi.getProcessor(); [EOL] Object ps2 = oshi.getPowerSources(); [EOL] Assert.assertSame(os1, os2); [EOL] Assert.assertSame(mem1, mem2); [EOL] Assert.assertSame(fs1, fs2); [EOL] Assert.assertSame(proc1, proc2); [EOL] Assert.assertSame(ps1, ps2); [EOL] [EOL] // refresh and see that they are now different [EOL] oshi.refresh(); [EOL] os2 = oshi.getOperatingSystem(); [EOL] mem2 = oshi.getMemory(); [EOL] fs2 = oshi.getFileStores(); [EOL] proc2 = oshi.getProcessor(); [EOL] ps2 = oshi.getPowerSources(); [EOL] Assert.assertNotSame(os1, os2); [EOL] Assert.assertNotSame(mem1, mem2); [EOL] Assert.assertNotSame(fs1, fs2); [EOL] Assert.assertNotSame(proc1, proc2); [EOL] Assert.assertNotSame(ps1, ps2); [EOL] } [EOL]
@Test(expected = AccessDeniedException.class) [EOL] public void testFetchFactWithoutViewPermission() throws Exception { [EOL] doThrow(AccessDeniedException.class).when(securityContext).checkPermission(TiFunctionConstants.viewThreatIntelFact); [EOL] delegate.handle(new GetFactByIdRequest()); [EOL] } [EOL]
@Test [EOL] public void testResolveExceptionCode_systemexception_exists_code() { [EOL] [EOL] // do setup. [EOL] // nothing. [EOL] [EOL] // do test. [EOL] String actualExceptionCode1 = testTarget.resolveExceptionCode( [EOL] new SystemException("testcode001", "testmessage001")); [EOL] String actualExceptionCode2 = testTarget.resolveExceptionCode( [EOL] new SystemException("testcode002", "testmessage002")); [EOL] [EOL] // do assert. [EOL] assertThat(actualExceptionCode1, is("testcode001")); [EOL] assertThat(actualExceptionCode2, is("testcode002")); [EOL] } [EOL]
@Test [EOL] 	public void shouldBeTrueIfOneExprIsTrue() { [EOL] 		final IJsonNode result = [EOL] 			new OrExpression(FALSE, BooleanExpression.ensureBooleanExpression(EvaluationExpression.VALUE), FALSE). [EOL] 				evaluate(BooleanNode.TRUE); [EOL] [EOL] 		Assert.assertEquals(BooleanNode.TRUE, result); [EOL] 	} [EOL]
@Test [EOL] public void testValidClientNoBlacklist() throws Exception { [EOL] final Supplier<Set<String>> supplier = Set::of; [EOL] RequestContext requestContext = mockRequestContext(true); [EOL] Response<Object> response = awaitResponse(Middlewares.clientValidator(supplier) [EOL] .apply(mockInnerHandler(requestContext)) [EOL] .invoke(requestContext)); [EOL] assertThat(response, hasStatus(withCode(Status.OK))); [EOL] } [EOL]
@Test [EOL] public void testArraySizeExpression() throws Exception { [EOL] final String program = "" [EOL] + "void main()\n" [EOL] + "{\n" [EOL] + " int a[3 + 4];\n" [EOL] + "}\n"; [EOL] assertEquals(program, PrettyPrinterVisitor.prettyPrintAsString(ParseHelper.parse(program [EOL] ))); [EOL] } [EOL]
@Test [EOL] public void test_V100_EXAMPLE_2() [EOL] throws Exception { [EOL] URL exampleURL = this.getClass().getResource( V100_EXAMPLE_2 ); [EOL] Map<String, String> kvpMap = KVPUtils.readFileIntoMap( exampleURL ); [EOL] [EOL] GetFeature getFeature = GetFeatureKVPAdapter.parse( kvpMap, null ); [EOL] FilterQuery filterQuery = (FilterQuery) getFeature.getQueries().get( 0 ); [EOL] assertEquals( new QName( "INWATERA_1M" ), filterQuery.getTypeNames()[0].getFeatureTypeName() ); [EOL] [EOL] assertEquals( "INWATERA_1M/WKB_GEOM", [EOL] ( (PropertyName) filterQuery.getProjectionClauses()[0] ).getPropertyName().getAsText() ); [EOL] assertEquals( "INWATERA_1M/TILE_ID", [EOL] ( (PropertyName) filterQuery.getProjectionClauses()[1] ).getPropertyName().getAsText() ); [EOL] } [EOL]
@Test [EOL] 	public void asExprTest_string() { [EOL] 		Expr e = factory.asExpr("foo"); [EOL] 		assertTrue(e instanceof NodeValueString); [EOL] 		NodeValueString n = (NodeValueString) e; [EOL] 		assertEquals("foo", n.asString()); [EOL] 	} [EOL]
@Test [EOL] void getFirstLogEvent() throws IOException [EOL] { [EOL] this.tail.initialize(new File(this.tmpDir, "log").toPath(), false); [EOL] [EOL] assertNull(this.tail.getFirstLogEvent()); [EOL] assertNull(this.tail.getFirstLogEvent(LogLevel.ERROR)); [EOL] [EOL] this.tail.info("info0"); [EOL] this.tail.info("info1"); [EOL] this.tail.warn("warn0"); [EOL] this.tail.warn("warn1"); [EOL] this.tail.error("error0"); [EOL] this.tail.error("error1"); [EOL] [EOL] assertEquals("info0", this.tail.getFirstLogEvent().getMessage()); [EOL] assertEquals("info0", this.tail.getFirstLogEvent(LogLevel.TRACE).getMessage()); [EOL] assertEquals("info0", this.tail.getFirstLogEvent(LogLevel.INFO).getMessage()); [EOL] assertEquals("warn0", this.tail.getFirstLogEvent(LogLevel.WARN).getMessage()); [EOL] assertEquals("error0", this.tail.getFirstLogEvent(LogLevel.ERROR).getMessage()); [EOL] } [EOL]
@Test [EOL] public void testGetAnnotationsForUnTrimmedInsertion() { [EOL] int pos = 118608470; [EOL] String ref = "AGT"; [EOL] String alt = "AGTT"; [EOL] [EOL] VariantAnnotations variantAnnotations = instance.annotateVariant("X", pos, ref, alt); [EOL] [EOL] assertThat(variantAnnotations.getChr(), equalTo(23)); [EOL] assertThat(variantAnnotations.getPos(), equalTo(118608470 + 2));// Jannovar trims from the left first i.e. right-shifts. [EOL] assertThat(variantAnnotations.getRef(), equalTo("")); [EOL] assertThat(variantAnnotations.getAlt(), equalTo("T")); [EOL] } [EOL]
@Test [EOL] public void testHashCode() throws Exception { [EOL] assertEquals( 0, rck.hashCode() ); [EOL] rck.addParameter( "param", "value" ); [EOL] assertEquals( 1403851013, rck.hashCode() ); [EOL] } [EOL]
@Test [EOL] public void testSoliditySha3SingleArguments() { [EOL] String sha3Hash; [EOL] try { [EOL] sha3Hash = new SoliditySha3().soliditySha3("1"); [EOL] assertEquals("0x637df1eb4c09a98dc453cdea36c6242657b34c2792a700647d14e62033140a83", sha3Hash); [EOL] } catch (Exception e) { [EOL] e.printStackTrace(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetPeriodsWeekly() { [EOL] for (int i = 0; i < repetitions; i++) { [EOL] final Instant a = randomInstant(); [EOL] final Instant b = randomInstant(); [EOL] final Instant from = Ordering.natural().min(a, b); [EOL] final Instant to = Ordering.natural().max(a, b); [EOL] logger.info("from {} to {} {}", from, to, DataResolution.WEEKLY.name()); [EOL] final List<Tuple<Instant, Instant>> periods = InfluxStatisticsProvider.getPeriods(from, to, DataResolution.WEEKLY, [EOL] ZoneId.of("Z")); [EOL] assertEquals(1, periods.size()); [EOL] assertEquals(from, periods.get(0).getA()); [EOL] assertEquals(to, periods.get(0).getB()); [EOL] } [EOL] } [EOL]
@ExtendWith({ RepositoryManagementTestExecutionListener.class, [EOL] ArtifactManagementTestExecutionListener.class }) [EOL] @Test [EOL] public void testForceDeleteArtifactNotAllowed(@MavenRepository(repositoryId = REPOSITORY_WITH_TRASH_1) [EOL] @RepositoryAttributes(trashEnabled = true) [EOL] Repository repository, [EOL] @MavenTestArtifact(repositoryId = REPOSITORY_WITH_TRASH_1, [EOL] id = "org.carlspring.strongbox:test-artifact-to-trash", [EOL] versions = "1.0") [EOL] Path artifactPath) [EOL] throws IOException [EOL] { [EOL] final String storageId = repository.getStorage().getId(); [EOL] final String repositoryId = repository.getId(); [EOL] [EOL] final RepositoryPath artifactRepositoryPath = (RepositoryPath) artifactPath.normalize(); [EOL] final String artifactRepositoryPathStr = RepositoryFiles.relativizePath(artifactRepositoryPath); [EOL] [EOL] // Delete the artifact (this one should get placed under the .trash) [EOL] client.delete(storageId, repositoryId, artifactRepositoryPathStr, false); [EOL] [EOL] final Path artifactFile = RepositoryFiles.trash(artifactRepositoryPath); [EOL] [EOL] logger.debug("Artifact file: {}", artifactFile.toAbsolutePath()); [EOL] [EOL] assertThat(Files.exists(artifactFile)) [EOL] .as("Should have moved the artifact to the trash during a force delete operation, " + [EOL] "when allowsForceDeletion is not enabled!") [EOL] .isTrue(); [EOL] [EOL] final RootRepositoryPath repositoryPath = repositoryPathResolver.resolve(repository); [EOL] final Path repositoryIndexDir = repositoryPath.resolve(MavenRepositoryFeatures.INDEX); [EOL] [EOL] assertThat(Files.exists(repositoryIndexDir)).as("Should not have deleted .index directory!").isTrue(); [EOL] } [EOL]
@Test [EOL] 	public void testNullInput() { [EOL] 		Assert.assertNull( [EOL] 			_searchPermissionChecker.getPermissionBooleanFilter( [EOL] 				0, null, 0, null, null, null)); [EOL] 	} [EOL]
@Test [EOL] 	public void testJvmFatalError() { [EOL] 		// not all errors are fatal [EOL] 		assertFalse(ExceptionUtils.isJvmFatalError(new Error())); [EOL] [EOL] 		// linkage errors are not fatal [EOL] 		assertFalse(ExceptionUtils.isJvmFatalError(new LinkageError())); [EOL] [EOL] 		// some errors are fatal [EOL] 		assertTrue(ExceptionUtils.isJvmFatalError(new InternalError())); [EOL] 		assertTrue(ExceptionUtils.isJvmFatalError(new UnknownError())); [EOL] 	} [EOL]
@Test [EOL] @SuppressWarnings("unchecked") [EOL] public void isFileFormat() { [EOL] // Mock delegate [EOL] final SparkDataSetDelegate<DataFrame> delegate = Mockito.mock(SparkDataSetDelegate.class); [EOL] Mockito.when(delegate.isFileFormat(Mockito.any(Class.class))).then(new Answer<Boolean>() { [EOL] @Nonnull [EOL] @Override [EOL] public Boolean answer(@Nonnull final InvocationOnMock invocation) { [EOL] final Class<?> clazz = invocation.getArgumentAt(0, Class.class); [EOL] return HadoopFsRelationProvider.class.isAssignableFrom(clazz); [EOL] } [EOL] }); [EOL] [EOL] // Test invalid format [EOL] final DataSetOptions options = new DataSetOptions(); [EOL] options.setFormat("invalid"); [EOL] [EOL] final KyloCatalogClient<DataFrame> client = Mockito.mock(KyloCatalogClient.class); [EOL] SparkDataSetContext<DataFrame> context = new SparkDataSetContext<>(options, client, delegate); [EOL] Assert.assertFalse("Expected 'invalid' to not be a file format", context.isFileFormat()); [EOL] [EOL] // Test non-file format [EOL] options.setFormat("jdbc"); [EOL] context = new SparkDataSetContext<>(options, client, delegate); [EOL] Assert.assertFalse("Expected 'jdbc' to not be a file format", context.isFileFormat()); [EOL] [EOL] // Test short name [EOL] options.setFormat("text"); [EOL] context = new SparkDataSetContext<>(options, client, delegate); [EOL] Assert.assertTrue("Expected 'text' to be a file format", context.isFileFormat()); [EOL] [EOL] // Test class name [EOL] options.setFormat("org.apache.spark.sql.execution.datasources.text.DefaultSource"); [EOL] context = new SparkDataSetContext<>(options, client, delegate); [EOL] Assert.assertTrue("Expected 'org.apache.spark.sql.execution.datasources.text.DefaultSource' to be a file format", context.isFileFormat()); [EOL] [EOL] // Test package name [EOL] options.setFormat("org.apache.spark.sql.execution.datasources.text"); [EOL] context = new SparkDataSetContext<>(options, client, delegate); [EOL] Assert.assertTrue("Expected 'org.apache.spark.sql.execution.datasources.text' to be a file format", context.isFileFormat()); [EOL] } [EOL]
@Test [EOL] void hasRoutersAndReadersWhenSomeReadersAndRouters() [EOL] { [EOL] ClusterComposition composition = newComposition( 1, addresses( A, B ), addresses( C, D ), addresses( E, F ) ); [EOL] [EOL] assertTrue( composition.hasRoutersAndReaders() ); [EOL] } [EOL]
@Test [EOL] public void testGetUserGroupInformation() throws IOException { [EOL] String userName = "user1"; [EOL] String currentUser = "currentUser"; [EOL] [EOL] UserGroupInformation currentUserUgi = UserGroupInformation [EOL] .createUserForTesting(currentUser, new String[0]); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(FileSystem.FS_DEFAULT_NAME_KEY, "hdfs://localhost"); [EOL] DFSClientCache cache = new DFSClientCache(conf); [EOL] UserGroupInformation ugiResult [EOL] = cache.getUserGroupInformation(userName, currentUserUgi); [EOL] [EOL] assertThat(ugiResult.getUserName(), is(userName)); [EOL] assertThat(ugiResult.getRealUser(), is(currentUserUgi)); [EOL] assertThat( [EOL] ugiResult.getAuthenticationMethod(), [EOL] is(UserGroupInformation.AuthenticationMethod.PROXY)); [EOL] } [EOL]
@Test [EOL] public void shouldHaveDefaultDistinctValuesAfterConstruction() throws Exception { [EOL] assertThat( this.column.getDistinctValues( getTransaction() ), is( Column.DEFAULT_DISTINCT_VALUES ) ); [EOL] } [EOL]
@Test [EOL] public void hasValues() throws Exception { [EOL] assertThat(snapshot.getValues()) [EOL] .containsOnly(1, 2, 3, 4, 5); [EOL] } [EOL]
@Test [EOL] 	public void whenNotExplicitlyRestfulEntityUseDefaultEtagAndLastModified() { [EOL] 		CacheableOrder cacheable = new CacheableOrder(); [EOL] [EOL] 		Calendar date = Calendar.getInstance(); [EOL] 		when(defaults.getLastModifiedFor(cacheable)).thenReturn(date); [EOL] 		when(defaults.getEtagFor(cacheable)).thenReturn("custom etag"); [EOL] [EOL] 		handler.handle(cacheable); [EOL] 		verify(response).addHeader("ETag", "custom etag"); [EOL] 		verify(response).setDateHeader("Last-modified", date.getTimeInMillis()); [EOL] 	} [EOL]
@Test [EOL] 	public void testOffsetOutisdeInstancesWithInstanceOfPrefix() throws Exception { [EOL] [EOL] 		// Expected: instance of, instance of block [EOL] 		Couple couple = prepare( "app1", "initial.instances", 43 ); [EOL] 		couple.text += "in"; [EOL] [EOL] 		List<RoboconfCompletionProposal> proposals = couple.proposer.findProposals( couple.text ); [EOL] 		Assert.assertEquals( 2, proposals.size()); [EOL] [EOL] 		Assert.assertEquals( KEYWORD_INSTANCE_OF, proposals.get( 0 ).getProposalName()); [EOL] 		Assert.assertEquals( INSTANCE_OF_PREFIX, proposals.get( 0 ).getProposalString()); [EOL] 		Assert.assertNull( proposals.get( 0 ).getProposalDescription()); [EOL] 		Assert.assertEquals( 2, proposals.get( 0 ).getReplacementOffset()); [EOL] [EOL] 		Assert.assertEquals( INSTANCE_OF_BLOCK, proposals.get( 1 ).getProposalName()); [EOL] 		Assert.assertTrue( proposals.get( 1 ).getProposalString().startsWith( INSTANCE_OF_PREFIX )); [EOL] 		Assert.assertTrue( proposals.get( 1 ).getProposalDescription().startsWith( INSTANCE_OF_BLOCK )); [EOL] 		Assert.assertEquals( 2, proposals.get( 1 ).getReplacementOffset()); [EOL] 	} [EOL]
@Test [EOL] public void testHasRole() { [EOL] [EOL] User user = new User(); [EOL] user.addRole(1, "testrole"); [EOL] [EOL] assertTrue("User should have role 'testrole'", user.hasRole("testrole")); [EOL] assertFalse("User should NOT have role 'dummyrole'", user.hasRole("dummyrole")); [EOL] [EOL] user.addRole(2, "testrole 2"); [EOL] assertTrue("User should have role 'testrole 2'", user.hasRole("testrole 2")); [EOL] assertFalse("User should NOT have role 'dummyrole'", user.hasRole("dummyrole")); [EOL] [EOL] String[] rolesArray = new String[] { "role 1", "role 2"}; [EOL] assertFalse("User should NOT have any role in given array", user.hasAnyRoleIn(rolesArray)); [EOL] [EOL] user.addRole(3, "role 2"); [EOL] assertTrue("User should have role listed in given array", user.hasAnyRoleIn(rolesArray)); [EOL] [EOL] user.addRole(4, Role.getAdminRole().getName()); [EOL] assertTrue("Admin user should have any role", user.hasRole("any role what so ever")); [EOL] } [EOL]
@Test [EOL] 	public void testSerialize() throws Exception { [EOL] 		AdaptiveMedia<AMImageProcessor> adaptiveMedia = new AMImage( [EOL] 			() -> null, [EOL] 			AMImageAttributeMapping.fromProperties( [EOL] 				HashMapBuilder.put( [EOL] 					AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT.getName(), "200" [EOL] 				).put( [EOL] 					AMImageAttribute.AM_IMAGE_ATTRIBUTE_WIDTH.getName(), "300" [EOL] 				).build()), [EOL] 			new URI("http://localhost")); [EOL] [EOL] 		AMImageSerializer amImageSerializer = new AMImageSerializerImpl(); [EOL] [EOL] 		String serialize = amImageSerializer.serialize(adaptiveMedia); [EOL] [EOL] 		JSONObject jsonObject = JSONFactoryUtil.createJSONObject(serialize); [EOL] [EOL] 		Assert.assertEquals("http://localhost", jsonObject.getString("uri")); [EOL] [EOL] 		JSONObject attributesJSONObject = jsonObject.getJSONObject( [EOL] 			"attributes"); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			"200", [EOL] 			attributesJSONObject.getString( [EOL] 				AMImageAttribute.AM_IMAGE_ATTRIBUTE_HEIGHT.getName())); [EOL] 		Assert.assertEquals( [EOL] 			"300", [EOL] 			attributesJSONObject.getString( [EOL] 				AMImageAttribute.AM_IMAGE_ATTRIBUTE_WIDTH.getName())); [EOL] [EOL] 		AMAttribute<?, Long> contentLengthAMAttribute = [EOL] 			AMAttribute.getContentLengthAMAttribute(); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, [EOL] 			attributesJSONObject.getString(contentLengthAMAttribute.getName())); [EOL] 	} [EOL]
@Test [EOL] public void testSetCopyBufferSize() { [EOL] final DistCpOptions.Builder builder = new DistCpOptions.Builder( [EOL] Collections.singletonList(new Path("hdfs://localhost:8020/source")), [EOL] new Path("hdfs://localhost:8020/target/")); [EOL] [EOL] Assert.assertEquals(DistCpConstants.COPY_BUFFER_SIZE_DEFAULT, [EOL] builder.build().getCopyBufferSize()); [EOL] [EOL] builder.withCopyBufferSize(4194304); [EOL] Assert.assertEquals(4194304, [EOL] builder.build().getCopyBufferSize()); [EOL] [EOL] builder.withCopyBufferSize(-1); [EOL] Assert.assertEquals(DistCpConstants.COPY_BUFFER_SIZE_DEFAULT, [EOL] builder.build().getCopyBufferSize()); [EOL] } [EOL]
@Test [EOL] public void testRetrieve() { [EOL] // Retrieve strings [EOL] for (int i = 0; i < str.length; i++) { [EOL] Assert.assertEquals(str[i], store.retrieve(i + 1)); [EOL] } [EOL] } [EOL]
@Test [EOL] public void shouldDeserializeTriggerWithParameters() throws Exception { [EOL] String jsonExec0 = executionJson("exec-id-0", "busybox:1.0","commit-sha0", TEST_RUNNER_ID, "09", "FAILED", [EOL] Optional.of("Exit code 1")); [EOL] String jsonExec1 = executionJson("exec-id-1", "busybox:1.1","commit-sha1", TEST_RUNNER_ID, "10", "SUCCESS", [EOL] Optional.empty()); [EOL] [EOL] String json = [EOL] "{" [EOL] + "\"trigger_id\":\"trig-0\"," [EOL] + "\"timestamp\":\"" + time("07:55") + "\"," [EOL] + "\"parameters\":{\"env\":{\"FOO\":\"foo\",\"BAR\":\"bar\"}}," [EOL] + "\"complete\":true," [EOL] + "\"executions\":[" [EOL] + jsonExec0 + "," + jsonExec1 [EOL] + "]}"; [EOL] [EOL] Trigger trigger = OBJECT_MAPPER.readValue(json, Trigger.class); [EOL] Trigger expected = Trigger.create( [EOL] "trig-0", [EOL] time("07:55"), [EOL] TriggerParameters.builder() [EOL] .env("FOO", "foo", [EOL] "BAR", "bar") [EOL] .build(), [EOL] true, [EOL] Arrays.asList( [EOL] Execution.create( [EOL] Optional.of("exec-id-0"), [EOL] Optional.of("busybox:1.0"), [EOL] Optional.of("commit-sha0"), [EOL] Optional.of("test"), [EOL] Arrays.asList( [EOL] ExecStatus.create(Instant.parse("2016-08-03T09:56:03.607Z"), "STARTED", Optional.empty()), [EOL] ExecStatus.create(Instant.parse("2016-08-03T09:57:03.607Z"), "RUNNING", Optional.empty()), [EOL] ExecStatus.create(Instant.parse("2016-08-03T09:58:03.607Z"), "FAILED", Optional.of("Exit code 1")) [EOL] ) [EOL] ), [EOL] Execution.create( [EOL] Optional.of("exec-id-1"), [EOL] Optional.of("busybox:1.1"), [EOL] Optional.of("commit-sha1"), [EOL] Optional.of("test"), [EOL] Arrays.asList( [EOL] ExecStatus.create(Instant.parse("2016-08-03T10:56:03.607Z"), "STARTED", Optional.empty()), [EOL] ExecStatus.create(Instant.parse("2016-08-03T10:57:03.607Z"), "RUNNING", Optional.empty()), [EOL] ExecStatus.create(Instant.parse("2016-08-03T10:58:03.607Z"), "SUCCESS", Optional.empty()) [EOL] ) [EOL] ) [EOL] ) [EOL] ); [EOL] assertThat(trigger, is(expected)); [EOL] } [EOL]
@Test [EOL] public void testAcceptType() throws Exception { [EOL] Value boolVar = getVM().mirrorOf(true); [EOL] assertTrue("Should accept any type.", formatter.acceptType(boolVar.type(), new HashMap<>())); [EOL] [EOL] ObjectReference or = this.getObjectReference("Foo"); [EOL] [EOL] assertTrue("Should accept any type.", formatter.acceptType(null, new HashMap<>())); [EOL] assertTrue("Should accept any type.", formatter.acceptType(or.type(), new HashMap<>())); [EOL] [EOL] ObjectReference str = this.getObjectReference("java.lang.String"); [EOL] assertTrue("Should accept String type.", formatter.acceptType(str.referenceType(), new HashMap<>())); [EOL] } [EOL]
@Test [EOL] public void appliesCertInfoIfConfigured() { [EOL] [EOL] // given [EOL] CertInfo<Settings.Builder> certInfo = Mockito.mock(CertInfo.class); [EOL] [EOL] Settings.Builder settingsBuilder = Settings.builder(); [EOL] [EOL] ShieldAuth shieldAuth = createTestBuilder() [EOL] .withCertInfo(certInfo) [EOL] .build(); [EOL] [EOL] // when [EOL] shieldAuth.configure(settingsBuilder); [EOL] [EOL] // then [EOL] Mockito.verify(certInfo).applyTo(builderArgumentCaptor.capture()); [EOL] Assert.assertEquals(settingsBuilder, builderArgumentCaptor.getValue()); [EOL] [EOL] } [EOL]
@Test [EOL] void shouldHaveBytesType() [EOL] { [EOL] InternalValue value = new BytesValue( TEST_BYTES ); [EOL] assertThat( value.type(), equalTo( InternalTypeSystem.TYPE_SYSTEM.BYTES() ) ); [EOL] } [EOL]
@Test [EOL] @DatabaseSetup("HibernateMedicationsDaoTest.testFindSimilarMedications.xml") [EOL] public void testFindSimilarMedications() [EOL] { [EOL] final List<Long> routeIds = Collections.singletonList(11L); [EOL] [EOL] final Set<Long> medicationIds = medicationsDao.findSimilarMedicationsIds( [EOL] 1L, [EOL] routeIds, [EOL] new DateTime(2013, 1, 1, 10, 15)); [EOL] [EOL] assertEquals(4L, (long)medicationIds.size()); [EOL] assertTrue(medicationIds.contains(1L)); [EOL] assertTrue(medicationIds.contains(2L)); [EOL] assertTrue(medicationIds.contains(4L)); [EOL] assertTrue(medicationIds.contains(7L)); [EOL] } [EOL]
@Test [EOL] public void testReadFeatureAsMultiPolygon() throws [EOL] Exception { [EOL] // given a JSON Feature as MultiPolygon [EOL] final StringReader reader = new StringReader(TestHelper.getFixture("feature_multipolygon.json")); [EOL] [EOL] // when read the JSON as Feature [EOL] final Feature feature = geoJsonReader.readFeature(reader); [EOL] [EOL] // then [EOL] assertNotNull(feature); [EOL] assertEquals("id1", [EOL] feature.getId()); [EOL] assertEquals("Feature", [EOL] feature.getType()); [EOL] assertNotNull(feature.getGeometry()); [EOL] assertEquals(createMultiPolygon(gf, [EOL] createPolygon(gf, [EOL] createCoordinate(gf, [EOL] 47.226116d, [EOL] -1.554169d), [EOL] createCoordinate(gf, [EOL] 47.226126d, [EOL] -1.554097d), [EOL] createCoordinate(gf, [EOL] 47.225527d, [EOL] -1.553986d), [EOL] createCoordinate(gf, [EOL] 47.225519d, [EOL] -1.554061d), [EOL] createCoordinate(gf, [EOL] 47.226116d, [EOL] -1.554169d)), [EOL] createPolygon(gf, [EOL] createLinearRing(gf, [EOL] createCoordinate(gf, [EOL] 47.226257d, [EOL] -1.554564d), [EOL] createCoordinate(gf, [EOL] 47.226295d, [EOL] -1.554202d), [EOL] createCoordinate(gf, [EOL] 47.226075d, [EOL] -1.554169d), [EOL] createCoordinate(gf, [EOL] 47.226049d, [EOL] -1.554496d), [EOL] createCoordinate(gf, [EOL] 47.226257d, [EOL] -1.554564d)), [EOL] createLinearRing(gf, [EOL] createCoordinate(gf, [EOL] 47.226219d, [EOL] -1.554430d), [EOL] createCoordinate(gf, [EOL] 47.226237d, [EOL] -1.554261d), [EOL] createCoordinate(gf, [EOL] 47.226122d, [EOL] -1.554245d), [EOL] createCoordinate(gf, [EOL] 47.226106d, [EOL] -1.554411d), [EOL] createCoordinate(gf, [EOL] 47.226219d, [EOL] -1.554430d)))), [EOL] feature.getGeometry()); [EOL] } [EOL]
@Test [EOL] public void testCreateNew() { [EOL] hash.update(DATA); [EOL] assertEquals(0xd0ee1ee0bb3bb65eL, hash.getLong()); [EOL] final StatefulHash other = hash.createNew(); [EOL] assertEquals(0x04b2008fd98c1dd4L, other.getLong()); [EOL] assertEquals(0xd0ee1ee0bb3bb65eL, hash.getLong()); [EOL] } [EOL]
@Test [EOL] public void smallerNested() throws InvalidKeyPathException { [EOL] Path path = KeyPathParser.parse("$[\"a\"][\"b\"]"); [EOL] Schema schema = SchemaBuilder [EOL] .record("X") [EOL] .fields() [EOL] .name("a") [EOL] .type(SchemaBuilder.record("Y").fields().name("b").type(Schema.create(Type.STRING)).noDefault().endRecord()) [EOL] .noDefault() [EOL] .endRecord(); [EOL] new KeyPathValidator(path, schema).validate(); [EOL] } [EOL]
@Test [EOL] public void createLoggerTail() throws Exception [EOL] { [EOL] this.mocker.registerMockComponent(SafeXStream.class); [EOL] [EOL] File logFile = new File(XWikiTempDirUtil.createTemporaryDirectory(), "log"); [EOL] [EOL] assertTrue( [EOL] !(this.loggerManager.createLoggerTail(logFile.toPath(), true) instanceof XStreamFileLoggerTail)); [EOL] [EOL] assertTrue(this.loggerManager.createLoggerTail(logFile.toPath(), false) instanceof XStreamFileLoggerTail); [EOL] [EOL] assertTrue(this.loggerManager.createLoggerTail(logFile.toPath(), true) instanceof XStreamFileLoggerTail); [EOL] } [EOL]
@Test [EOL] void randomAlphaNumeric() { [EOL] assertThat(Randoms.alphaNumeric(3)).hasSize(3); [EOL] assertThat(Randoms.alphaNumeric(5)).hasSize(5); [EOL] assertThat(Randoms.alphaNumeric(10)).hasSize(10); [EOL] } [EOL]
@Test [EOL] public void testBlockingDrain() throws InterruptedException { [EOL] final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>(); [EOL] for (int i = 0; i < Random.getScaleCount(); ++i) { [EOL] queue.add(Random.getObject()); [EOL] } [EOL] queue.drainTo(Lists.newArrayList()); [EOL] List<Object> buffer = Lists.newArrayList(); [EOL] final AtomicInteger expected = new AtomicInteger(0); [EOL] final CountDownLatch latch = new CountDownLatch(1); [EOL] Thread t = new Thread(new Runnable() { [EOL] [EOL] @Override [EOL] public void run() { [EOL] List<Object> objects = Lists.newArrayList(); [EOL] for (int i = 0; i < Random.getScaleCount(); ++i) { [EOL] objects.add(Random.getObject()); [EOL] } [EOL] expected.set(objects.size()); [EOL] queue.addAll(objects); [EOL] latch.countDown(); [EOL] } [EOL] [EOL] }); [EOL] Random.sleep(); [EOL] t.start(); [EOL] latch.await(); [EOL] int actual = Queues.blockingDrain(queue, buffer); [EOL] Assert.assertEquals(expected.get(), actual); [EOL] Assert.assertNull(queue.poll()); [EOL] } [EOL]
@Test [EOL] public void testConvertBatchJobData07() throws Exception { [EOL] [EOL] BatchJobData batchJobData; [EOL] try { [EOL] SystemEnvUtils.setEnv("JOB_APP_CD", "envJobAppCd"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM1", "env1"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM2", "env2"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM3", "env3"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM4", "env4"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM5", "env5"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM6", "env6"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM7", "env7"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM8", "env8"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM9", "env9"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM10", "env10"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM11", "env11"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM12", "env12"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM13", "env13"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM14", "env14"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM15", "env15"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM16", "env16"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM17", "env17"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM18", "env18"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM19", "env19"); [EOL] SystemEnvUtils.setEnv("JOB_ARG_NM20", "env20"); [EOL] [EOL] // テスト実行 [EOL] batchJobData = target.convertBatchJobData(new String[] {}); [EOL] } finally { [EOL] SystemEnvUtils.restoreEnv(); [EOL] } [EOL] [EOL] assertThat(batchJobData.getJobAppCd(), is("envJobAppCd")); [EOL] assertThat(batchJobData.getJobArgNm1(), is("env1")); [EOL] assertThat(batchJobData.getJobArgNm2(), is("env2")); [EOL] assertThat(batchJobData.getJobArgNm3(), is("env3")); [EOL] assertThat(batchJobData.getJobArgNm4(), is("env4")); [EOL] assertThat(batchJobData.getJobArgNm5(), is("env5")); [EOL] assertThat(batchJobData.getJobArgNm6(), is("env6")); [EOL] assertThat(batchJobData.getJobArgNm7(), is("env7")); [EOL] assertThat(batchJobData.getJobArgNm8(), is("env8")); [EOL] assertThat(batchJobData.getJobArgNm9(), is("env9")); [EOL] assertThat(batchJobData.getJobArgNm10(), is("env10")); [EOL] assertThat(batchJobData.getJobArgNm11(), is("env11")); [EOL] assertThat(batchJobData.getJobArgNm12(), is("env12")); [EOL] assertThat(batchJobData.getJobArgNm13(), is("env13")); [EOL] assertThat(batchJobData.getJobArgNm14(), is("env14")); [EOL] assertThat(batchJobData.getJobArgNm15(), is("env15")); [EOL] assertThat(batchJobData.getJobArgNm16(), is("env16")); [EOL] assertThat(batchJobData.getJobArgNm17(), is("env17")); [EOL] assertThat(batchJobData.getJobArgNm18(), is("env18")); [EOL] assertThat(batchJobData.getJobArgNm19(), is("env19")); [EOL] assertThat(batchJobData.getJobArgNm20(), is("env20")); [EOL] assertThat(batchJobData.getAddDateTime(), is(nullValue())); [EOL] assertThat(batchJobData.getBLogicAppStatus(), is("")); [EOL] assertThat(batchJobData.getCurAppStatus(), is("")); [EOL] assertThat(batchJobData.getJobSequenceId(), is("")); [EOL] assertThat(batchJobData.getUpdDateTime(), is(nullValue())); [EOL] } [EOL]
@Override [EOL] @Test(expected = FederationPolicyException.class) [EOL] public void testNullQueueRouting() throws YarnException { [EOL] FederationRouterPolicy localPolicy = (FederationRouterPolicy) getPolicy(); [EOL] ApplicationSubmissionContext applicationSubmissionContext = [EOL] ApplicationSubmissionContext.newInstance(null, null, null, null, null, [EOL] false, false, 0, Resources.none(), null, false, null, null); [EOL] localPolicy.getHomeSubcluster(applicationSubmissionContext, null); [EOL] } [EOL]
@Test [EOL] public void testGetConflictMedicationsFromComplexTherapy2() [EOL] { [EOL] final ConstantComplexTherapyDto therapy = new ConstantComplexTherapyDto(); [EOL] [EOL] final MedicationDto medication1 = new MedicationDto(); [EOL] medication1.setId(1L); [EOL] medication1.setName("medication1"); [EOL] final InfusionIngredientDto ingredient1 = new InfusionIngredientDto(); [EOL] ingredient1.setMedication(medication1); [EOL] therapy.getIngredientsList().add(ingredient1); [EOL] [EOL] final MedicationDto medication2 = new MedicationDto(); [EOL] medication2.setId(2L); [EOL] medication2.setName("medication2"); [EOL] therapy.getMedications().add(medication2); [EOL] final InfusionIngredientDto ingredient2 = new InfusionIngredientDto(); [EOL] ingredient2.setMedication(medication2); [EOL] therapy.getIngredientsList().add(ingredient2); [EOL] [EOL] final List<MedicationRouteDto> routes = new ArrayList<>(); [EOL] therapy.setRoutes(routes); [EOL] [EOL] final MedicationRouteDto route1 = new MedicationRouteDto(); [EOL] route1.setId(1L); [EOL] route1.setName("route1"); [EOL] routes.add(route1); [EOL] [EOL] final MedicationRouteDto route2 = new MedicationRouteDto(); [EOL] route2.setId(2L); [EOL] route2.setName("route2"); [EOL] routes.add(route2); [EOL] [EOL] final MedicationRouteDto route3 = new MedicationRouteDto(); [EOL] route3.setId(3L); [EOL] route3.setName("route3"); [EOL] routes.add(route3); [EOL] [EOL] final SetMultimap<Long, Long> medicationsWithRoutes = HashMultimap.create(); [EOL] medicationsWithRoutes.put(1L, 4L); [EOL] medicationsWithRoutes.put(1L, 5L); [EOL] medicationsWithRoutes.put(1L, 6L); [EOL] [EOL] medicationsWithRoutes.put(2L, 4L); [EOL] [EOL] medicationsWithRoutes.put(3L, 1L); [EOL] medicationsWithRoutes.put(3L, 2L); [EOL] [EOL] medicationsWithRoutes.put(4L, 3L); [EOL] medicationsWithRoutes.put(4L, 4L); [EOL] [EOL] final List<NamedExternalDto> conflictMedicationIds = mentalHealthAdditionalWarningsProvider.getConflictMedications( [EOL] therapy, [EOL] new MentalHealthAllowedMedicationsDo(medicationsWithRoutes, Collections.emptySet())); [EOL] [EOL] Assert.assertEquals(2, conflictMedicationIds.size()); [EOL] Assert.assertTrue(conflictMedicationIds.contains(new NamedExternalDto("1", "medication1"))); [EOL] Assert.assertTrue(conflictMedicationIds.contains(new NamedExternalDto("2", "medication2"))); [EOL] } [EOL]
@Test [EOL] 	public void testSecureClinicalDocumentsUploadWhenClamAVNotWork() throws Exception { [EOL] 		MockMultipartFile file = new MockMultipartFile("file", "orig", null, "bar".getBytes()); [EOL] 		doReturn("error").when(sut).scanMultipartFile(file); [EOL] 		doReturn(false).when(clinicalDocumentService).isDocumentOversized(file); [EOL] 		doReturn(true).when(clinicalDocumentService).isDocumentExtensionPermitted(file); [EOL] 		doReturn(true).when(recaptchaUtil).checkAnswer(anyString(), anyString(), anyString()); [EOL] 		mockMvc.perform(fileUpload("/patients/clinicaldocuments.html").file(file) [EOL] 				.param("name", "mocked_name") [EOL] 				.param("description", "mocked_description") [EOL] 				.param("documentType", "mocked_type")) [EOL] 			.andExpect(view().name("redirect:/patients/clinicaldocuments.html?notify=error")); [EOL] 	} [EOL]
@Test [EOL] public void testGetRelativePathFileToDirectory() { [EOL] String target = "C:\\Windows\\Boot\\Fonts"; [EOL] String base = "C:\\Windows\\Speech\\Common\\foo.txt"; [EOL] [EOL] String relPath = FileSyncUtils.getRelativePath(target, base, "\\"); [EOL] assertEquals("..\\..\\Boot\\Fonts", relPath); [EOL] } [EOL]
@Test [EOL] public void testOkWithVersion() { [EOL] YamlSchemeValidator<String> validator = new YamlSchemeValidator<> ("root", List.of("element1", "element2"), List.of(), [EOL] SEE_MORE_INFO, List.of("1"),"the config file test.yaml",(es)-> es); [EOL] [EOL] String cfg="root:\n - element1: 1\n element2: 2\nversion: 1"; [EOL] assertNull(validator.validateStructureOfDispatcherYaml(cfg)); [EOL] } [EOL]
@Test [EOL] public void testULong2Str_UnsignedHex() throws Exception { [EOL] assertEquals("12345678ABCD", JBBPUtils.ulong2str(0x12345678ABCDL, 16, null)); [EOL] assertEquals("7FFFFFFFFFFFFFFF", JBBPUtils.ulong2str(0x7FFFFFFFFFFFFFFFL, 16, null)); [EOL] assertEquals("8000000000000000", JBBPUtils.ulong2str(0x8000000000000000L, 16, null)); [EOL] assertEquals("8FFFFFFFFFFFFFFF", JBBPUtils.ulong2str(0x8FFFFFFFFFFFFFFFL, 16, null)); [EOL] assertEquals("8100000000000000", JBBPUtils.ulong2str(0x8100000000000000L, 16, null)); [EOL] assertEquals("F23418824AB12342", JBBPUtils.ulong2str(0xF23418824AB12342L, 16, null)); [EOL] } [EOL]
@Test [EOL] 	public void testCopyScriptsInTargetDirectory() throws IOException { [EOL] [EOL] 		File f = new File( this.folder.newFolder(), "toto.properties" ); [EOL] 		Assert.assertTrue( new File( f.getParentFile(), "toto" ).mkdir()); [EOL] [EOL] 		Utils.writeStringInto( "id: tid\nprop: value\nhandler: h", f ); [EOL] 		Utils.writeStringInto( "#!/bin/bash\necho Bonjour le monde cruel > toto.txt", new File( f.getParentFile(), "toto/toto.sh" )); [EOL] 		Utils.writeStringInto( "#!/bin/bash\ntouch titi.txt", new File( f.getParentFile(), "titi.sh" )); [EOL] 		Utils.writeStringInto( "#!/bin/bash\necho tototo", new File( f.getParentFile(), "toto/script.sh" )); [EOL] [EOL] 		File targetDir = new File( this.configurationMngr.getWorkingDirectory(), ConfigurationUtils.TARGETS + "/tid" ); [EOL] 		Assert.assertFalse( targetDir.exists()); [EOL] [EOL] 		TestApplicationTemplate appT = new TestApplicationTemplate(); [EOL] 		String targetId = this.mngr.createTarget( f, appT ); [EOL] 		Assert.assertEquals( "tid", targetId ); [EOL] 		Assert.assertTrue( targetDir.exists()); [EOL] 		Assert.assertEquals( 3, targetDir.list().length); [EOL] [EOL] 		Assert.assertTrue( new File( targetDir, "target.properties" ).exists()); [EOL] 		Assert.assertTrue( new File( targetDir, "created.from" ).exists()); [EOL] 		Assert.assertTrue( new File( targetDir, Constants.PROJECT_SUB_DIR_SCRIPTS ).isDirectory()); [EOL] [EOL] 		targetDir = new File( targetDir, Constants.PROJECT_SUB_DIR_SCRIPTS ); [EOL] 		Assert.assertEquals( 2, targetDir.list().length); [EOL] [EOL] 		Assert.assertTrue( new File( targetDir, "toto.sh" ).exists()); [EOL] 		Assert.assertTrue( new File( targetDir, "script.sh" ).exists()); [EOL] 		Assert.assertFalse( new File( targetDir, "titi.sh").exists()); [EOL] 	} [EOL]
@Test [EOL] public void optional_nullValueIsTranslatedToEmpty() { [EOL] assertThat(optional(true, null)).isEmpty(); [EOL] } [EOL]
@Test [EOL] public void test05() { [EOL] List<Object> expectedResult = new ArrayList<>(); [EOL] expectedResult.add("\'"); [EOL] expectedResult.add("\""); [EOL] expectedResult.add(1); [EOL] expectedResult.add(2); [EOL] expectedResult.add("3"); [EOL] expectedResult.add("a"); [EOL] expectedResult.add("b"); [EOL] expectedResult.add("c"); [EOL] expectedResult.add("d"); [EOL] expectedResult.add("ef\\"); [EOL] expectedResult.add("gh"); [EOL] final List<Object> result = new ArrayList<>(); [EOL] new RangeExpressionParser("['\\'',\"\\\"\",1..2,'3','a'..'b',\"c\"..\"d\",'\\ef\\\\',\"\\gh\"]").visit(new RangeExpressionItemVisitor() { [EOL] [EOL] @Override [EOL] public void visit(Object val) { [EOL] result.add(val); [EOL] } [EOL] }); [EOL] Assert.equals(result, expectedResult); [EOL] } [EOL]
@Test [EOL] public void testOriginResolutionWithAllPlugins() { [EOL] //given [EOL] EC2Plugin ec2Plugin = Mockito.mock(EC2Plugin.class); [EOL] ECSPlugin ecsPlugin = Mockito.mock(ECSPlugin.class); [EOL] ElasticBeanstalkPlugin ebPlugin = Mockito.mock(ElasticBeanstalkPlugin.class); [EOL] EKSPlugin eksPlugin = Mockito.mock(EKSPlugin.class); [EOL] [EOL] List<Plugin> plugins = new ArrayList<>(); [EOL] plugins.add(ec2Plugin); [EOL] plugins.add(ecsPlugin); [EOL] plugins.add(ebPlugin); [EOL] plugins.add(eksPlugin); [EOL] [EOL] List<String> origins = new ArrayList<>(); [EOL] origins.add(EC2Plugin.ORIGIN); [EOL] origins.add(ECSPlugin.ORIGIN); [EOL] origins.add(ElasticBeanstalkPlugin.ORIGIN); [EOL] origins.add(EKSPlugin.ORIGIN); [EOL] [EOL] Map<String, Object> runtimeContext = new HashMap<>(); [EOL] runtimeContext.put("key", "value"); [EOL] [EOL] for (int i = 0; i < 4; i++) { [EOL] Mockito.doReturn(true).when(plugins.get(i)).isEnabled(); [EOL] Mockito.doReturn(runtimeContext).when(plugins.get(i)).getRuntimeContext(); [EOL] Mockito.doReturn("serviceName").when(plugins.get(i)).getServiceName(); [EOL] Mockito.doReturn(origins.get(i)).when(plugins.get(i)).getOrigin(); [EOL] } [EOL] [EOL] AWSXRayRecorder recorder = AWSXRayRecorderBuilder.standard() [EOL] .withPlugin(ec2Plugin) [EOL] .withPlugin(ecsPlugin) [EOL] .withPlugin(ebPlugin) [EOL] .withPlugin(eksPlugin) [EOL] .build(); [EOL] [EOL] // when [EOL] Assert.assertEquals(ElasticBeanstalkPlugin.ORIGIN, recorder.getOrigin()); [EOL] } [EOL]
@Test [EOL] public void testNewAuthenticator() throws Exception { [EOL] try { [EOL] LogManagerProperties.newAuthenticator(null); [EOL] fail("Null was allowed."); [EOL] } catch (NullPointerException expect) { [EOL] } [EOL] [EOL] try { [EOL] LogManagerProperties.newAuthenticator(""); [EOL] fail("Empty class was allowed."); [EOL] } catch (ClassNotFoundException expect) { [EOL] } [EOL] [EOL] try { [EOL] LogManagerProperties.newAuthenticator(Object.class.getName()); [EOL] fail("Wrong type was allowed."); [EOL] } catch (ClassCastException expect) { [EOL] } [EOL] [EOL] final Class<?> type = ErrorAuthenticator.class; [EOL] final javax.mail.Authenticator a [EOL] = LogManagerProperties.newAuthenticator(type.getName()); [EOL] assertEquals(type, a.getClass()); [EOL] [EOL] setPending(new RuntimeException()); [EOL] try { [EOL] LogManagerProperties.newAuthenticator(type.getName()); [EOL] fail("Exception was not thrown."); [EOL] } catch (InvocationTargetException expect) { [EOL] assertEquals(RuntimeException.class, expect.getCause().getClass()); [EOL] } finally { [EOL] setPending(null); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testCreateEndDocument() throws XMLStreamException { [EOL] 		EndDocument event = factory.createEndDocument(); [EOL] 		verify(event, XMLStreamConstants.END_DOCUMENT, ""); [EOL] 	} [EOL]
@Test [EOL] public void testStreamingCopies() throws IOException { [EOL] DefaultBinaryManager binaryManager = new DefaultBinaryManager(); [EOL] binaryManager.initialize(new BinaryManagerDescriptor()); [EOL] assertEquals(0, countFiles(binaryManager.getStorageDir())); [EOL] File file = File.createTempFile("test-", ".data", binaryManager.getStorageDir()); [EOL] FileUtils.writeFile(file, CONTENT.getBytes("UTF-8")); [EOL] FileSource source = new FileSource(file); [EOL] binaryManager.storeAndDigest(source); [EOL] assertFalse(file.exists()); [EOL] assertTrue(source.getFile().exists()); [EOL] [EOL] binaryManager.close(); [EOL] } [EOL]
@Test [EOL] void evaluateWithString() throws Exception [EOL] { [EOL] this.engine.initialize(new Properties()); [EOL] [EOL] assertEvaluate("hello World", "#set($foo='hello')$foo World", DEFAULT_TEMPLATE_NAME); [EOL] } [EOL]
@Test [EOL] public void testUnmodifiableMap() { [EOL] final Map<String,Integer> one = B2Collections.unmodifiableMap(B2Collections.mapOf("a", 1)); [EOL] [EOL] thrown.expect(UnsupportedOperationException.class); [EOL] one.put("mutation", 666); [EOL] } [EOL]
@Test [EOL] public void add_converts_to_replace() throws Exception { [EOL] PatchOperation operation = mapping.convertOperation(road, PatchOperation.add("/metadata", emptyMap())); [EOL] [EOL] assertThat(operation, is(PatchOperation.replace("/metadata", emptyMap()))); [EOL] } [EOL]
@Test [EOL] public void subjectHasLessElemsThanTupleEntries() { [EOL] ArraySchema subject = buildWithLocation(ArraySchema.builder() [EOL] .addItemSchema(NullSchema.INSTANCE) [EOL] .addItemSchema(TrueSchema.INSTANCE)); [EOL] subject.validate(ARRAYS.get("subjectHasLessElemsThanTupleEntries")); [EOL] } [EOL]
@Test [EOL] public void generateSeedShouldGenerateExpectedSeeds() { [EOL] byte[] actualSeed = MnemonicUtils.generateSeed(mnemonic, "TREZOR"); [EOL] [EOL] assertArrayEquals(seed, actualSeed); [EOL] } [EOL]
@Test [EOL] public void multipleElements() { [EOL] Path path = KeyPathParser.parse("$[\"a\"][\"bc\"][\"d\"]"); [EOL] assertThat(path.elements().size(), is(4)); [EOL] assertThat(path.elements().get(0).isRoot(), is(true)); [EOL] assertThat(path.elements().get(0).id(), is("$")); [EOL] assertThat(path.elements().get(1).isRoot(), is(false)); [EOL] assertThat(path.elements().get(1).id(), is("a")); [EOL] assertThat(path.elements().get(2).isRoot(), is(false)); [EOL] assertThat(path.elements().get(2).id(), is("bc")); [EOL] assertThat(path.elements().get(3).isRoot(), is(false)); [EOL] assertThat(path.elements().get(3).id(), is("d")); [EOL] } [EOL]
@Test [EOL] public void testCreateResources() throws Exception { [EOL] [EOL] AmbariManagementController managementController = createMock(AmbariManagementController.class); [EOL] RequestStatusResponse response = createNiceMock(RequestStatusResponse.class); [EOL] [EOL] managementController.createConfiguration(AbstractResourceProviderTest.Matcher.getConfigurationRequest( [EOL] "Cluster100", "type", "tag", new HashMap<String, String>(), null)); [EOL] expectLastCall().andReturn(null); [EOL] [EOL] // replay [EOL] replay(managementController, response); [EOL] [EOL] ConfigurationResourceProvider provider = new ConfigurationResourceProvider( [EOL] managementController); [EOL] [EOL] Set<Map<String, Object>> propertySet = new LinkedHashSet<Map<String, Object>>(); [EOL] [EOL] Map<String, Object> properties = new LinkedHashMap<String, Object>(); [EOL] [EOL] properties.put(ConfigurationResourceProvider.CONFIGURATION_CLUSTER_NAME_PROPERTY_ID, "Cluster100"); [EOL] properties.put(ConfigurationResourceProvider.CONFIGURATION_CONFIG_TAG_PROPERTY_ID, "tag"); [EOL] properties.put(ConfigurationResourceProvider.CONFIGURATION_CONFIG_TYPE_PROPERTY_ID, "type"); [EOL] [EOL] propertySet.add(properties); [EOL] [EOL] // create the request [EOL] Request request = PropertyHelper.getCreateRequest(propertySet, null); [EOL] [EOL] provider.createResources(request); [EOL] [EOL] // verify [EOL] verify(managementController, response); [EOL] } [EOL]
@Test [EOL] public void testToRangerPolicy(){ [EOL] Date date = new Date(); [EOL] [EOL] List<String> userList = new ArrayList<String>(); [EOL] userList.add("rangerAdmin"); [EOL] [EOL] List<String> groupList = new ArrayList<String>(); [EOL] groupList.add("rangerGroup"); [EOL] [EOL] List<String> permObjList = new ArrayList<String>(); [EOL] permObjList.add("Admin"); [EOL] [EOL] Map<String, RangerPolicyResource> resourceMap = new HashMap<String, RangerPolicyResource>(); [EOL] List<String> valuesList = new ArrayList<String>(); [EOL] valuesList.add("resource"); [EOL] [EOL] RangerPolicyResource rangerPolicyResource = new RangerPolicyResource(); [EOL] rangerPolicyResource.setIsExcludes(false); [EOL] rangerPolicyResource.setIsRecursive(true); [EOL] rangerPolicyResource.setValues(valuesList); [EOL] [EOL] resourceMap.put("path", rangerPolicyResource); [EOL] [EOL] List<RangerPolicyItem> rangerPolicyItemList = new ArrayList<RangerPolicy.RangerPolicyItem>(); [EOL] RangerPolicyItem rangerPolicyItem = new RangerPolicyItem(); [EOL] rangerPolicyItem.setUsers(userList); [EOL] rangerPolicyItem.setGroups(groupList); [EOL] [EOL] List<RangerPolicyItemCondition> rangerPolicyItemConditionList = new ArrayList<RangerPolicy.RangerPolicyItemCondition>(); [EOL] RangerPolicyItemCondition rangerPolicyItemCondition = new RangerPolicyItemCondition(); [EOL] rangerPolicyItemCondition.setType("ipaddress"); [EOL] List<String> conditionValueList = new ArrayList<String>(); [EOL] conditionValueList.add("10.129.35.86"); [EOL] rangerPolicyItemCondition.setValues(conditionValueList); [EOL] rangerPolicyItemConditionList.add(rangerPolicyItemCondition); [EOL] rangerPolicyItem.setConditions(rangerPolicyItemConditionList); [EOL] rangerPolicyItem.setDelegateAdmin(true); [EOL] [EOL] rangerPolicyItemList.add(rangerPolicyItem); [EOL] [EOL] RangerPolicy expectedRangerPolicy = new RangerPolicy(); [EOL] expectedRangerPolicy.setId(1L); [EOL] expectedRangerPolicy.setName("hdfs"); [EOL] expectedRangerPolicy.setCreatedBy("rangerAdmin"); [EOL] expectedRangerPolicy.setCreateTime(date); [EOL] expectedRangerPolicy.setDescription("hdfs policy description"); [EOL] expectedRangerPolicy.setIsAuditEnabled(true); [EOL] expectedRangerPolicy.setResources(resourceMap); [EOL] expectedRangerPolicy.setPolicyItems(rangerPolicyItemList); [EOL] [EOL] VXPolicy vXPolicy = new VXPolicy(); [EOL] vXPolicy.setId(1L); [EOL] vXPolicy.setCreateDate(date); [EOL] vXPolicy.setUpdateDate(date); [EOL] vXPolicy.setOwner("rangerAdmin"); [EOL] vXPolicy.setUpdatedBy("rangerAdmin"); [EOL] vXPolicy.setPolicyName("hdfs"); [EOL] vXPolicy.setDescription("hdfs policy description"); [EOL] vXPolicy.setIsEnabled(true); [EOL] vXPolicy.setIsAuditEnabled(true); [EOL] vXPolicy.setIsRecursive(true); [EOL] vXPolicy.setResourceName("resource"); [EOL] [EOL] RangerService service = new RangerService(); [EOL] service.setId(1L); [EOL] service.setName("hdfsService"); [EOL] service.setType("hdfs"); [EOL] [EOL] List<VXPermObj> vXPermObjList = new ArrayList<VXPermObj>(); [EOL] VXPermObj vXPermObj = new VXPermObj(); [EOL] vXPermObj.setUserList(userList); [EOL] vXPermObj.setGroupList(groupList); [EOL] vXPermObj.setPermList(permObjList); [EOL] [EOL] vXPermObj.setIpAddress("10.129.35.86"); [EOL] [EOL] vXPermObjList.add(vXPermObj); [EOL] [EOL] vXPolicy.setPermMapList(vXPermObjList); [EOL] [EOL] RangerPolicy actualRangerPolicy = serviceUtil.toRangerPolicy(vXPolicy, service); [EOL] [EOL] Assert.assertNotNull(actualRangerPolicy); [EOL] Assert.assertEquals(expectedRangerPolicy.getId(), actualRangerPolicy.getId()); [EOL] Assert.assertEquals(expectedRangerPolicy.getName(), actualRangerPolicy.getName()); [EOL] Assert.assertEquals(expectedRangerPolicy.getDescription(), actualRangerPolicy.getDescription()); [EOL] Assert.assertEquals(expectedRangerPolicy.getCreatedBy(), actualRangerPolicy.getCreatedBy()); [EOL] Assert.assertTrue(actualRangerPolicy.getIsAuditEnabled()); [EOL] Assert.assertEquals(expectedRangerPolicy.getResources(), actualRangerPolicy.getResources()); [EOL] Assert.assertEquals(expectedRangerPolicy.getPolicyItems(), actualRangerPolicy.getPolicyItems()); [EOL] } [EOL]
@Ignore [EOL] @Test [EOL] public void testPageNotInCache() throws PlatformInitializationException, ContentIOException, [EOL] ReportProcessingException, IOException, [EOL] ResourceException { [EOL] ClassicEngineBoot.getInstance().start(); [EOL] [EOL] MicroPlatform microPlatform = MicroPlatformFactory.create(); [EOL] [EOL] try { [EOL] microPlatform.define( ReportOutputHandlerFactory.class, FastExportReportOutputHandlerFactory.class ); [EOL] final IReportContentCache mockCache = mock( IReportContentCache.class ); [EOL] final IReportContent iReportContent = mock( IReportContent.class ); [EOL] when( iReportContent.getPageData( 3 ) ).thenReturn( null ); [EOL] [EOL] final String key = "test"; [EOL] when( mockCache.get( key ) ).thenReturn( iReportContent ); [EOL] final IPluginCacheManager iPluginCacheManager = [EOL] new PluginCacheManagerImpl( mockCache ); [EOL] microPlatform.define( "IPluginCacheManager", iPluginCacheManager ); [EOL] microPlatform.start(); [EOL] [EOL] final IPentahoSession session = new StandaloneSession(); [EOL] PentahoSessionHolder.setSession( session ); [EOL] [EOL] [EOL] final CachingPageableHTMLOutput cachingPageableHTMLOutput = spy( new CachingPageableHTMLOutput() ); [EOL] final ResourceManager mgr = new ResourceManager(); [EOL] final File src = new File( "target/test/resource/solution/test/reporting/report1.prpt" ); [EOL] final MasterReport r = (MasterReport) mgr.createDirectly( src, MasterReport.class ).getResource(); [EOL] r.setContentCacheKey( key ); [EOL] [EOL] cachingPageableHTMLOutput.generate( r, 3, mock( OutputStream.class ), 1 ); [EOL] [EOL] verify( cachingPageableHTMLOutput, times( 1 ) ).regenerateCache( r, 1, key, 3 ); [EOL] } finally { [EOL] microPlatform.stop(); [EOL] microPlatform = null; [EOL] } [EOL] } [EOL]
@Test [EOL] void get2Test() { [EOL] assertEquals(2, (int) instance.get2()); [EOL] } [EOL]
@Test [EOL] void propertyDescriptorbackwardCompatible() [EOL] { [EOL] PropertyDescriptor propertyDescriptor = [EOL] new BackwardCompatiblePropertyDescriptor(this.beanDescriptor.getProperty("lowerprop")); [EOL] [EOL] assertFalse(propertyDescriptor.isDeprecated()); [EOL] assertFalse(propertyDescriptor.isAdvanced()); [EOL] assertNull(propertyDescriptor.getGroupDescriptor().getGroup()); [EOL] assertNull(propertyDescriptor.getGroupDescriptor().getFeature()); [EOL] } [EOL]
@Test [EOL] void get9Test() { [EOL] assertEquals(9, (int) instance.get9().orElseThrow(NoSuchElementException::new)); [EOL] } [EOL]
@Test [EOL] public void testConvertFSConfigurationWithConsoleParam() [EOL] throws Exception { [EOL] setupFSConfigConversionFiles(true); [EOL] [EOL] ArgumentCaptor<FSConfigToCSConfigConverterParams> conversionParams = [EOL] ArgumentCaptor.forClass(FSConfigToCSConfigConverterParams.class); [EOL] [EOL] FSConfigToCSConfigArgumentHandler argumentHandler = [EOL] createArgumentHandler(); [EOL] [EOL] String[] args = getArgumentsAsArrayWithDefaults("-f", [EOL] FSConfigConverterTestCommons.FS_ALLOC_FILE, [EOL] "-r", FSConfigConverterTestCommons.CONVERSION_RULES_FILE, "-p"); [EOL] argumentHandler.parseAndConvert(args); [EOL] [EOL] // validate params [EOL] verify(mockConverter).convert(conversionParams.capture()); [EOL] FSConfigToCSConfigConverterParams params = conversionParams.getValue(); [EOL] LOG.info("FS config converter parameters: " + params); [EOL] [EOL] assertEquals("Yarn site config", [EOL] FSConfigConverterTestCommons.YARN_SITE_XML, [EOL] params.getYarnSiteXmlConfig()); [EOL] assertEquals("FS xml", FSConfigConverterTestCommons.FS_ALLOC_FILE, [EOL] params.getFairSchedulerXmlConfig()); [EOL] assertEquals("Conversion rules config", [EOL] FSConfigConverterTestCommons.CONVERSION_RULES_FILE, [EOL] params.getConversionRulesConfig()); [EOL] assertTrue("Console mode", params.isConsole()); [EOL] } [EOL]
@Test [EOL] public void onChildDestroyed() { [EOL] Component childView = (Component) child2.getView(); [EOL] uut.onChildDestroyed(childView); [EOL] verify(presenter).onChildDestroyed(childView); [EOL] } [EOL]
@Test [EOL] public void testRangeWithCount() { [EOL] assertEquals(Arrays.asList(1, 2, 3, 4, 5), toList(Range.createWithCount(1, 5))); [EOL] } [EOL]
@SuppressWarnings("unchecked") [EOL] 	@Test [EOL] public void visit() throws PersistenceException { [EOL] when(resourceResolver.create(any(), anyString(), any())).thenThrow(PersistenceException.class); [EOL] assertNull(model.visit("0", new HashMap<>(), cache)); [EOL] } [EOL]
@Test [EOL] public void natural_order_tuple_value() { [EOL] ExprValueOrdering ordering = ExprValueOrdering.natural(); [EOL] assertEquals( [EOL] 1, [EOL] ordering.compare( [EOL] tupleValue(ImmutableMap.of("v1", 1, "v2", 2)), tupleValue(ImmutableMap.of("v1", 3)))); [EOL] assertEquals( [EOL] 0, [EOL] ordering.compare( [EOL] tupleValue(ImmutableMap.of("v1", 1, "v2", 2)), [EOL] tupleValue(ImmutableMap.of("v1", 3, "v2", 4)))); [EOL] assertEquals( [EOL] -1, [EOL] ordering.compare( [EOL] tupleValue(ImmutableMap.of("v1", 3)), tupleValue(ImmutableMap.of("v1", 1, "v2", 2)))); [EOL] } [EOL]
@Test [EOL] public void onClickEvent() { [EOL] ClickEvent mockClickEvent = mock(ClickEvent.class); [EOL] executableMenuItemPresenter.onClickEvent(mockClickEvent, mockLIElement); [EOL] verify(mockClickEvent, times(1)).preventDefault(); [EOL] verify(mockClickEvent, times(1)).stopPropagation(); [EOL] verify(mockparent, times(1)).hide(); [EOL] verify(executableMenuItemPresenter, times(1)).fireEvent(eq(mockLIElement)); [EOL] } [EOL]
@Test [EOL] public void test_less_missing() { [EOL] FunctionExpression less = dsl.less(DSL.literal(1), [EOL] DSL.ref(INT_TYPE_MISSING_VALUE_FIELD, INTEGER)); [EOL] assertEquals(BOOLEAN, less.type()); [EOL] assertEquals(LITERAL_MISSING, less.valueOf(valueEnv())); [EOL] [EOL] less = dsl.less(DSL.ref(INT_TYPE_MISSING_VALUE_FIELD, INTEGER), DSL.literal(1)); [EOL] assertEquals(BOOLEAN, less.type()); [EOL] assertEquals(LITERAL_MISSING, less.valueOf(valueEnv())); [EOL] [EOL] less = dsl.less(DSL.ref(INT_TYPE_MISSING_VALUE_FIELD, INTEGER), [EOL] DSL.ref(INT_TYPE_MISSING_VALUE_FIELD, INTEGER)); [EOL] assertEquals(BOOLEAN, less.type()); [EOL] assertEquals(LITERAL_MISSING, less.valueOf(valueEnv())); [EOL] } [EOL]
@Test [EOL] public void testMutateRowAsync() throws Exception { [EOL] RowMutation rowMutation = RowMutation.create(TABLE_ID, ROW_KEY); [EOL] when(mockDataClient.mutateRowAsync(rowMutation)) [EOL] .thenReturn(ApiFutures.<Void>immediateFuture(null)); [EOL] dataClientWrapper.mutateRowAsync(rowMutation).get(); [EOL] verify(mockDataClient).mutateRowAsync(rowMutation); [EOL] } [EOL]
@Test [EOL] void shouldNotAllowBasicAuthTokenWithNullPassword() [EOL] { [EOL] NullPointerException e = assertThrows( NullPointerException.class, () -> AuthTokens.basic( "username", null ) ); [EOL] assertEquals( "Password can't be null", e.getMessage() ); [EOL] } [EOL]
@Test [EOL] public void testGet() throws IOException, JsonReferenceException { [EOL] [EOL] String refString = "http://localhost:8080/a.json#/a"; [EOL] [EOL] JsonReference ref = JsonReference.fromString(refString); [EOL] [EOL] JsonNode jsonNode = (new JsonReferenceProcessor()).get(ref); [EOL] [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = mapper.writeValueAsString(jsonNode); [EOL] [EOL] assertThat(json, equalTo("3")); [EOL] } [EOL]
@Test [EOL] void newBuilder() { [EOL] assertNotNull(injector.newBuilder()); [EOL] injector.newBuilder(); [EOL] } [EOL]
@Test [EOL] public void deserializesHashSets() { [EOL] Node value = Node.fromStrings("a", "b"); [EOL] NodeMapper mapper = new NodeMapper(); [EOL] [EOL] Set<String> result = mapper.deserializeCollection(value, HashSet.class, String.class); [EOL] assertThat(result, instanceOf(HashSet.class)); [EOL] assertThat(result, contains("a", "b")); [EOL] } [EOL]
@Test [EOL] public void testUpdateHbaseEnvConfig() throws AmbariException { [EOL] EasyMockSupport easyMockSupport = new EasyMockSupport(); [EOL] final AmbariManagementController mockAmbariManagementController = easyMockSupport.createNiceMock(AmbariManagementController.class); [EOL] final Clusters mockClusters = easyMockSupport.createStrictMock(Clusters.class); [EOL] final Cluster mockClusterExpected = easyMockSupport.createNiceMock(Cluster.class); [EOL] final Map<String, String> propertiesHbaseEnv = new HashMap<String, String>() { [EOL] { [EOL] put("content", "test"); [EOL] } [EOL] }; [EOL] [EOL] final Config mockHbaseEnv = easyMockSupport.createNiceMock(Config.class); [EOL] expect(mockHbaseEnv.getProperties()).andReturn(propertiesHbaseEnv).once(); [EOL] [EOL] final Injector mockInjector = Guice.createInjector(new AbstractModule() { [EOL] @Override [EOL] protected void configure() { [EOL] bind(AmbariManagementController.class).toInstance(mockAmbariManagementController); [EOL] bind(Clusters.class).toInstance(mockClusters); [EOL] bind(EntityManager.class).toInstance(entityManager); [EOL] [EOL] bind(DBAccessor.class).toInstance(createNiceMock(DBAccessor.class)); [EOL] bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class)); [EOL] } [EOL] }); [EOL] [EOL] expect(mockAmbariManagementController.getClusters()).andReturn(mockClusters).once(); [EOL] expect(mockClusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{ [EOL] put("normal", mockClusterExpected); [EOL] }}).atLeastOnce(); [EOL] expect(mockClusterExpected.getCurrentStackVersion()).andReturn(new StackId("HDP", "2.2")); [EOL] [EOL] expect(mockClusterExpected.getDesiredConfigByType("hbase-env")).andReturn(mockHbaseEnv).atLeastOnce(); [EOL] expect(mockHbaseEnv.getProperties()).andReturn(propertiesHbaseEnv).atLeastOnce(); [EOL] [EOL] easyMockSupport.replayAll(); [EOL] mockInjector.getInstance(UpgradeCatalog220.class).updateHbaseEnvConfig(); [EOL] easyMockSupport.verifyAll(); [EOL] [EOL] } [EOL]
@Test [EOL] 	public void testKeySet() { [EOL] 		Set<Key> keySet = _concurrentMap.keySet(); [EOL] [EOL] 		Assert.assertSame(keySet, _concurrentMap.keySet()); [EOL] 		Assert.assertTrue(keySet.toString(), keySet.isEmpty()); [EOL] 		Assert.assertFalse(keySet.toString(), keySet.contains(_testKey)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertFalse(keySet.remove(_testKey)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertNull(_concurrentMap.put(_testKey, _testValue1)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY, Event.MAP_VALUE); [EOL] [EOL] 		String keySetString = keySet.toString(); [EOL] [EOL] 		_assertEventQueue(Event.UNMAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertEquals(keySetString, 1, keySet.size()); [EOL] 		Assert.assertTrue(keySetString, keySet.contains(_testKey)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertTrue(keySet.remove(_testKey)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY_FOR_QUERY, Event.UNMAP_VALUE); [EOL] [EOL] 		Assert.assertNull(_concurrentMap.put(_testKey, _testValue1)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY, Event.MAP_VALUE); [EOL] [EOL] 		keySetString = keySet.toString(); [EOL] [EOL] 		_assertEventQueue(Event.UNMAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertEquals(keySetString, 1, keySet.size()); [EOL] 		Assert.assertEquals(Collections.singleton(_testKey), keySet); [EOL] [EOL] 		_assertEventQueue(Event.UNMAP_KEY_FOR_QUERY); [EOL] [EOL] 		Iterator<Key> iterator = keySet.iterator(); [EOL] [EOL] 		Assert.assertTrue(iterator.hasNext()); [EOL] [EOL] 		Key key = iterator.next(); [EOL] [EOL] 		_assertEventQueue(Event.UNMAP_KEY_FOR_QUERY); [EOL] [EOL] 		keySetString = keySet.toString(); [EOL] [EOL] 		_assertEventQueue(Event.UNMAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertEquals(_testKey, key); [EOL] 		Assert.assertFalse(iterator.hasNext()); [EOL] 		Assert.assertTrue(keySetString, keySet.contains(key)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY_FOR_QUERY); [EOL] [EOL] 		iterator.remove(); [EOL] [EOL] 		Assert.assertTrue(keySet.toString(), keySet.isEmpty()); [EOL] 		Assert.assertFalse(keySet.toString(), keySet.contains(key)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY_FOR_QUERY); [EOL] [EOL] 		Assert.assertNull(_concurrentMap.put(_testKey, _testValue1)); [EOL] [EOL] 		_assertEventQueue(Event.MAP_KEY, Event.MAP_VALUE); [EOL] [EOL] 		Assert.assertEquals(keySet.toString(), 1, keySet.size()); [EOL] [EOL] 		keySet.clear(); [EOL] [EOL] 		Assert.assertTrue(_concurrentMap.isEmpty()); [EOL] 	} [EOL]
@Test [EOL] 	public void shouldUseSpringContainerAsDefaultProvider() throws ServletException { [EOL] 	when(context.getInitParameter(BasicConfiguration.CONTAINER_PROVIDER)).thenReturn(null); [EOL] [EOL] 	assertThat(config.getProvider().getClass(), is(typeCompatibleWith(SpringProvider.class))); [EOL] 	} [EOL]
@Test(expected = Http2Exception.class) [EOL] public void nullHeaderNameValidated() { [EOL] ReadOnlyHttp2Headers.trailers(true, null, new AsciiString("foo")); [EOL] } [EOL]
@Test [EOL] void get10Test() { [EOL] assertEquals(10, (int) instance.get10()); [EOL] } [EOL]
@Test [EOL] public void initialBitrateEstimateOverwrite_for2G_whileConnectedTo2G_setsInitialEstimate() { [EOL] setActiveNetworkInfo(networkInfo2g); [EOL] DefaultBandwidthMeter bandwidthMeter = [EOL] new DefaultBandwidthMeter.Builder(ApplicationProvider.getApplicationContext()) [EOL] .setInitialBitrateEstimate(C.NETWORK_TYPE_2G, 123456789) [EOL] .build(); [EOL] long initialEstimate = bandwidthMeter.getBitrateEstimate(); [EOL] [EOL] assertThat(initialEstimate).isEqualTo(123456789); [EOL] } [EOL]
@Test [EOL] public void duplicateColumnValues() { [EOL] abstractScesimGridModelSpy.duplicateColumnValues(COLUMN_INDEX, COLUMN_INDEX - 1); [EOL] verify(abstractScesimGridModelSpy, times(abstractScesimGridModelSpy.getRowCount())).getCell(anyInt(), eq(COLUMN_INDEX)); [EOL] verify(abstractScesimGridModelSpy, times(abstractScesimGridModelSpy.getRowCount())).setCellValue(anyInt(), eq(COLUMN_INDEX - 1), any()); [EOL] assertTrue(IntStream.range(0, abstractScesimGridModelSpy.getRowCount()) [EOL] .allMatch(i -> abstractScesimGridModelSpy.getCell(i, COLUMN_INDEX).getValue().equals(abstractScesimGridModelSpy.getCell(i, COLUMN_INDEX).getValue()))); [EOL] } [EOL]
@Test [EOL] public void testMP4ParsingAudio() throws Exception { [EOL] Metadata metadata = new Metadata(); [EOL] String content = getText("testMP4.m4a", metadata); [EOL] [EOL] // Check core properties [EOL] assertEquals("audio/mp4", metadata.get(Metadata.CONTENT_TYPE)); [EOL] assertEquals("Test Title", metadata.get(TikaCoreProperties.TITLE)); [EOL] assertEquals("Test Artist", metadata.get(TikaCoreProperties.CREATOR)); [EOL] assertEquals("2012-01-28T18:39:18Z", metadata.get(TikaCoreProperties.CREATED)); [EOL] assertEquals("2012-01-28T18:40:25Z", metadata.get(TikaCoreProperties.MODIFIED)); [EOL] [EOL] // Check the textual contents [EOL] assertContains("Test Title", content); [EOL] assertContains("Test Artist", content); [EOL] assertContains("Test Album", content); [EOL] assertContains("2008", content); [EOL] assertContains("Test Comment", content); [EOL] assertContains("Test Genre", content); [EOL] [EOL] // Check XMPDM-typed audio properties [EOL] assertEquals("Test Album", metadata.get(XMPDM.ALBUM)); [EOL] assertEquals("Test Artist", metadata.get(XMPDM.ARTIST)); [EOL] assertEquals("Test Composer", metadata.get(XMPDM.COMPOSER)); [EOL] assertEquals("2008", metadata.get(XMPDM.RELEASE_DATE)); [EOL] assertEquals("Test Genre", metadata.get(XMPDM.GENRE)); [EOL] assertEquals("Test Comments", metadata.get(XMPDM.LOG_COMMENT.getName())); [EOL] assertEquals("1", metadata.get(XMPDM.TRACK_NUMBER)); [EOL] assertEquals("Test Album Artist", metadata.get(XMPDM.ALBUM_ARTIST)); [EOL] assertEquals("6", metadata.get(XMPDM.DISC_NUMBER)); [EOL] assertEquals("0", metadata.get(XMPDM.COMPILATION)); [EOL] [EOL] [EOL] assertEquals("44100", metadata.get(XMPDM.AUDIO_SAMPLE_RATE)); [EOL] assertEquals("Stereo", metadata.get(XMPDM.AUDIO_CHANNEL_TYPE)); [EOL] assertEquals("M4A", metadata.get(XMPDM.AUDIO_COMPRESSOR)); [EOL] assertEquals("0.07", metadata.get(XMPDM.DURATION)); [EOL] [EOL] assertEquals("iTunes 10.5.3.3", metadata.get(XMP.CREATOR_TOOL)); [EOL] [EOL] [EOL] // Check again by file, rather than stream [EOL] TikaInputStream tstream = TikaInputStream.get( [EOL] MP4ParserTest.class.getResourceAsStream("/test-documents/testMP4.m4a")); [EOL] tstream.getFile(); [EOL] ContentHandler handler = new BodyContentHandler(); [EOL] try { [EOL] AUTO_DETECT_PARSER.parse(tstream, handler, metadata, new ParseContext()); [EOL] } finally { [EOL] tstream.close(); [EOL] } [EOL] //TODO: why don't we check the output here? [EOL] } [EOL]
@Test [EOL] public void info() throws Exception { [EOL] StaticLogger.info(TAG, MESSAGE); [EOL] verify(logger).info(eq(TAG), eq(MESSAGE)); [EOL] } [EOL]
@Test [EOL] public void testExceptionAndRequestIdHandlerAcceptsRequestIdHeader() [EOL] throws InterruptedException, ExecutionException, TimeoutException { [EOL] final RequestContext requestContext = mock(RequestContext.class); [EOL] final String requestId = UUID.randomUUID().toString(); [EOL] final Request request = Request.forUri("/", "GET") [EOL] .withHeader("X-Request-Id", requestId); [EOL] final AtomicReference<String> propagatedRequestId = new AtomicReference<>(); [EOL] when(requestContext.request()).thenReturn(request); [EOL] [EOL] Response<Object> response = Middlewares.exceptionAndRequestIdHandler() [EOL] .apply(rc -> { [EOL] propagatedRequestId.set(MDC.get("request-id")); [EOL] LoggerFactory.getLogger(MiddlewaresTest.class).info("I'm OK!"); [EOL] return completedFuture(Response.forStatus(Status.OK)); [EOL] }) [EOL] .invoke(requestContext) [EOL] .toCompletableFuture().get(5, SECONDS); [EOL] [EOL] assertThat(response, hasStatus(withCode(Status.OK))); [EOL] assertThat(response, hasHeader("X-Request-Id", is(requestId))); [EOL] assertThat(propagatedRequestId.get(), is(requestId)); [EOL] } [EOL]
@Test [EOL] public void shouldNotTriggerExecutionOnDisabledGlobally() throws IOException { [EOL] when(config.globalEnabled()).thenReturn(false); [EOL] triggerManager.tick(); [EOL] verify(triggerListener, never()).event(any(), any(), any(), any()); [EOL] verify(storage, never()).updateNextNaturalTrigger(any(), any()); [EOL] } [EOL]
@Test [EOL] public void testPrefixedElement() { [EOL] Matcher matcher = parser.parse("/prefix:name"); [EOL] assertFalse(matcher.matchesText()); [EOL] assertFalse(matcher.matchesElement()); [EOL] assertFalse(matcher.matchesAttribute(null, "name")); [EOL] assertFalse(matcher.matchesAttribute(NS, "name")); [EOL] assertFalse(matcher.matchesAttribute(NS, "eman")); [EOL] assertEquals(Matcher.FAIL, matcher.descend(null, "name")); [EOL] assertEquals(Matcher.FAIL, matcher.descend(NS, "enam")); [EOL] matcher = matcher.descend(NS, "name"); [EOL] assertFalse(matcher.matchesText()); [EOL] assertTrue(matcher.matchesElement()); [EOL] assertFalse(matcher.matchesAttribute(null, "name")); [EOL] assertFalse(matcher.matchesAttribute(NS, "name")); [EOL] assertFalse(matcher.matchesAttribute(NS, "eman")); [EOL] } [EOL]
@Test [EOL] 	public void testGetByFirstAndLastName() throws Exception { [EOL] 		List<PatientAdminDto> PatientAdminDtos = new ArrayList<PatientAdminDto>(); [EOL] 		PatientAdminDto patientAdminDto = new PatientAdminDto(); [EOL] 		patientAdminDto.setFirstName("Mary"); [EOL] 		patientAdminDto.setLastName("Doe"); [EOL] 		patientAdminDto.setId((long) 1); [EOL] 		PatientAdminDtos.add(patientAdminDto); [EOL] 		when( [EOL] 				patientService [EOL] 						.findAllPatientByFirstNameAndLastName(any(String[].class))) [EOL] 				.thenReturn(PatientAdminDtos); [EOL] 		mockMvc.perform( [EOL] 				get("/Administrator//patientlookup/query?token=mary%2C+doe")) [EOL] 				.andExpect(status().isOk()) [EOL] 				.andExpect( [EOL] 						content().contentType("application/json;charset=UTF-8")) [EOL] 				// Subject to change when PatientAdminDto is changed [EOL] 				.andExpect( [EOL] 						content() [EOL] 								.string("[{\"firstName\":\"Mary\",\"lastName\":\"Doe\",\"id\":1,\"birthDay\":null,\"socialSecurityNumber\":null}]")); [EOL] [EOL] 	} [EOL]
@Test [EOL] public void testExecute01() throws Exception { [EOL] // テスト対象のインスタンス化 [EOL] FixedFileUpdateDAO fileUpdateDAO = new FixedFileUpdateDAO(); [EOL] [EOL] // 引数の設定 [EOL] String fileName = "aaa"; [EOL] Class<FixedFileUpdateDAO_Stub01> clazz = FixedFileUpdateDAO_Stub01.class; [EOL] [EOL] // 前提条件の設定 [EOL] Map<String, ColumnFormatter> columnFormatterMap = new HashMap<String, ColumnFormatter>(); [EOL] columnFormatterMap.put("java.lang.String", new NullColumnFormatter()); [EOL] ReflectionTestUtils.setField(fileUpdateDAO, "columnFormatterMap", [EOL] columnFormatterMap); [EOL] [EOL] // テスト実施 [EOL] FileLineWriter<FixedFileUpdateDAO_Stub01> fileLineWriter = fileUpdateDAO [EOL] .execute(fileName, clazz); [EOL] [EOL] // 返却値の確認 [EOL] assertEquals(FixedFileLineWriter.class.getName(), fileLineWriter [EOL] .getClass().getName()); [EOL] [EOL] // 状態変化の確認 [EOL] assertSame(fileName, ReflectionTestUtils.getField(fileLineWriter, [EOL] "fileName")); [EOL] assertSame(clazz, ReflectionTestUtils.getField(fileLineWriter, [EOL] "clazz")); [EOL] assertSame(columnFormatterMap, ReflectionTestUtils.getField( [EOL] fileLineWriter, "columnFormatterMap")); [EOL] [EOL] // 後処理 [EOL] fileLineWriter.closeFile(); [EOL] // テスト後ファイルを削除 [EOL] File file = new File("aaa"); [EOL] file.delete(); [EOL] } [EOL]
@Test(timeout = 30000) [EOL] public void testStartLocalizer() throws IOException, InterruptedException, [EOL] YarnException { [EOL] [EOL] final Path firstDir = new Path(BASE_TMP_PATH, "localDir1"); [EOL] List<String> localDirs = new ArrayList<String>(); [EOL] final Path secondDir = new Path(BASE_TMP_PATH, "localDir2"); [EOL] List<String> logDirs = new ArrayList<String>(); [EOL] final Path logDir = new Path(BASE_TMP_PATH, "logDir"); [EOL] final Path tokenDir = new Path(BASE_TMP_PATH, "tokenDir"); [EOL] FsPermission perms = new FsPermission((short)0770); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] [EOL] final FileContext mockLfs = spy(FileContext.getLocalFSFileContext(conf)); [EOL] final FileContext.Util mockUtil = spy(mockLfs.util()); [EOL] doAnswer(new Answer() { [EOL] @Override [EOL] public Object answer(InvocationOnMock invocationOnMock) [EOL] throws Throwable { [EOL] return mockUtil; [EOL] } [EOL] }).when(mockLfs).util(); [EOL] doAnswer(new Answer() { [EOL] @Override [EOL] public Object answer(InvocationOnMock invocationOnMock) [EOL] throws Throwable { [EOL] Path dest = (Path) invocationOnMock.getArguments()[1]; [EOL] if (dest.toString().contains(firstDir.toString())) { [EOL] // throw an Exception when copy token to the first local dir [EOL] // to simulate no space on the first drive [EOL] throw new IOException("No space on this drive " + [EOL] dest.toString()); [EOL] } else { [EOL] // copy token to the second local dir [EOL] DataOutputStream tokenOut = null; [EOL] try { [EOL] Credentials credentials = new Credentials(); [EOL] tokenOut = mockLfs.create(dest, [EOL] EnumSet.of(CREATE, OVERWRITE)); [EOL] credentials.writeTokenStorageToStream(tokenOut); [EOL] } finally { [EOL] if (tokenOut != null) { [EOL] tokenOut.close(); [EOL] } [EOL] } [EOL] } [EOL] return null; [EOL] }}).when(mockUtil).copy(any(Path.class), any(Path.class), [EOL] anyBoolean(), anyBoolean()); [EOL] [EOL] doAnswer(new Answer() { [EOL] @Override [EOL] public Object answer(InvocationOnMock invocationOnMock) [EOL] throws Throwable { [EOL] Path p = (Path) invocationOnMock.getArguments()[0]; [EOL] // let second local directory return more free space than [EOL] // first local directory [EOL] if (p.toString().contains(firstDir.toString())) { [EOL] return new FsStatus(2000, 2000, 0); [EOL] } else { [EOL] return new FsStatus(1000, 0, 1000); [EOL] } [EOL] } [EOL] }).when(mockLfs).getFsStatus(any(Path.class)); [EOL] [EOL] DefaultContainerExecutor mockExec = [EOL] spy(new DefaultContainerExecutor(mockLfs) { [EOL] @Override [EOL] public ContainerLocalizer createContainerLocalizer(String user, [EOL] String appId, String locId, String tokenFileName, [EOL] List<String> localDirs, FileContext localizerFc) [EOL] throws IOException { [EOL] [EOL] // Spy on the localizer and make it return valid heart-beat [EOL] // responses even though there is no real NodeManager. [EOL] ContainerLocalizer localizer = [EOL] super.createContainerLocalizer(user, appId, locId, [EOL] tokenFileName, localDirs, localizerFc); [EOL] ContainerLocalizer spyLocalizer = spy(localizer); [EOL] LocalizationProtocol nmProxy = mock(LocalizationProtocol.class); [EOL] try { [EOL] when(nmProxy.heartbeat(isA(LocalizerStatus.class))).thenReturn( [EOL] new MockLocalizerHeartbeatResponse(LocalizerAction.DIE, [EOL] new ArrayList<ResourceLocalizationSpec>())); [EOL] } catch (YarnException e) { [EOL] throw new IOException(e); [EOL] } [EOL] when(spyLocalizer.getProxy(any())) [EOL] .thenReturn(nmProxy); [EOL] [EOL] return spyLocalizer; [EOL] } [EOL] }); [EOL] mockExec.setConf(conf); [EOL] localDirs.add(mockLfs.makeQualified(firstDir).toString()); [EOL] localDirs.add(mockLfs.makeQualified(secondDir).toString()); [EOL] logDirs.add(mockLfs.makeQualified(logDir).toString()); [EOL] conf.setStrings(YarnConfiguration.NM_LOCAL_DIRS, [EOL] localDirs.toArray(new String[localDirs.size()])); [EOL] conf.set(YarnConfiguration.NM_LOG_DIRS, logDir.toString()); [EOL] mockLfs.mkdir(tokenDir, perms, true); [EOL] Path nmPrivateCTokensPath = new Path(tokenDir, "test.tokens"); [EOL] String appSubmitter = "nobody"; [EOL] String appId = "APP_ID"; [EOL] String locId = "LOC_ID"; [EOL] [EOL] LocalDirsHandlerService dirsHandler = mock(LocalDirsHandlerService.class); [EOL] when(dirsHandler.getLocalDirs()).thenReturn(localDirs); [EOL] when(dirsHandler.getLogDirs()).thenReturn(logDirs); [EOL] [EOL] try { [EOL] mockExec.startLocalizer(new LocalizerStartContext.Builder() [EOL] .setNmPrivateContainerTokens(nmPrivateCTokensPath) [EOL] .setNmAddr(null) [EOL] .setUser(appSubmitter) [EOL] .setAppId(appId) [EOL] .setLocId(locId) [EOL] .setDirsHandler(dirsHandler) [EOL] .build()); [EOL] [EOL] } catch (IOException e) { [EOL] Assert.fail("StartLocalizer failed to copy token file: " [EOL] + StringUtils.stringifyException(e)); [EOL] } finally { [EOL] mockExec.deleteAsUser(new DeletionAsUserContext.Builder() [EOL] .setUser(appSubmitter) [EOL] .setSubDir(firstDir) [EOL] .build()); [EOL] mockExec.deleteAsUser(new DeletionAsUserContext.Builder() [EOL] .setUser(appSubmitter) [EOL] .setSubDir(secondDir) [EOL] .build()); [EOL] mockExec.deleteAsUser(new DeletionAsUserContext.Builder() [EOL] .setUser(appSubmitter) [EOL] .setSubDir(logDir) [EOL] .build()); [EOL] deleteTmpFiles(); [EOL] } [EOL] [EOL] // Verify that the calls happen the expected number of times [EOL] verify(mockUtil, times(1)).copy(any(Path.class), any(Path.class), [EOL] anyBoolean(), anyBoolean()); [EOL] verify(mockLfs, times(2)).getFsStatus(any(Path.class)); [EOL] } [EOL]
@Test [EOL] 	public void testHexArrayToString() { [EOL] 		byte[] byteArray = new byte[]{1, -97, 49, 74 }; [EOL] 		String hex = StringUtils.byteToHexString(byteArray); [EOL] 		assertEquals("019f314a", hex); [EOL] 	} [EOL]
@Test [EOL] public void testConvertToStringInvalid() [EOL] { [EOL] InPlaceMsAdObjectSidValueEditor editor = new InPlaceMsAdObjectSidValueEditor(); [EOL] [EOL] // test too short [EOL] byte[] bytes = new byte[] [EOL] { ( byte ) 0x00 }; [EOL] String displayValue = editor.convertToString( bytes ); [EOL] assertEquals( Messages.getString( "InPlaceMsAdObjectSidValueEditor.InvalidSid" ), displayValue ); //$NON-NLS-1$ [EOL] [EOL] // test missing sub aurhority byte [EOL] byte[] bytes2 = new byte[] [EOL] { [EOL] // 01 05 00 00 00 00 00 05 15 00 00 00 af 6e b6 27 [EOL] // 0c f5 77 a0 a7 10 df 6e f4 01 00 00 [EOL] ( byte ) 0x01, // [EOL] ( byte ) 0x05, // [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x05, // [EOL] ( byte ) 0x15, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, // [EOL] ( byte ) 0xaf, [EOL] ( byte ) 0x6e, [EOL] ( byte ) 0xb6, [EOL] ( byte ) 0x27, // [EOL] ( byte ) 0x0c, [EOL] ( byte ) 0xf5, [EOL] ( byte ) 0x77, [EOL] ( byte ) 0xa0, // [EOL] ( byte ) 0xa7, [EOL] ( byte ) 0x10, [EOL] ( byte ) 0xdf, [EOL] ( byte ) 0x6e, // [EOL] ( byte ) 0xf4, [EOL] ( byte ) 0x01, [EOL] ( byte ) 0x00, /*( byte ) 0x00*/// [EOL] }; [EOL] String displayValue2 = editor.convertToString( bytes2 ); [EOL] assertEquals( Messages.getString( "InPlaceMsAdObjectSidValueEditor.InvalidSid" ), displayValue2 ); //$NON-NLS-1$ [EOL] [EOL] // test additional sub authority byte [EOL] byte[] bytes3 = new byte[] [EOL] { [EOL] // 01 05 00 00 00 00 00 05 15 00 00 00 af 6e b6 27 [EOL] // 0c f5 77 a0 a7 10 df 6e f4 01 00 00 [EOL] ( byte ) 0x01, // [EOL] ( byte ) 0x05, // [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x05, // [EOL] ( byte ) 0x15, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, // [EOL] ( byte ) 0xaf, [EOL] ( byte ) 0x6e, [EOL] ( byte ) 0xb6, [EOL] ( byte ) 0x27, // [EOL] ( byte ) 0x0c, [EOL] ( byte ) 0xf5, [EOL] ( byte ) 0x77, [EOL] ( byte ) 0xa0, // [EOL] ( byte ) 0xa7, [EOL] ( byte ) 0x10, [EOL] ( byte ) 0xdf, [EOL] ( byte ) 0x6e, // [EOL] ( byte ) 0xf4, [EOL] ( byte ) 0x01, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00, [EOL] ( byte ) 0x00 // [EOL] }; [EOL] String displayValue3 = editor.convertToString( bytes3 ); [EOL] assertEquals( Messages.getString( "InPlaceMsAdObjectSidValueEditor.InvalidSid" ), displayValue3 ); //$NON-NLS-1$ [EOL] } [EOL]
@Test [EOL] public void testToArray() { [EOL] ColumnStore<Node> store = new ColumnStore<Node>(Node.class, false); [EOL] [EOL] Assert.assertEquals(store.toArray().length, 0); [EOL] [EOL] ColumnImpl col11 = new ColumnImpl("0", Integer.class, null, null, Origin.DATA, false, false); [EOL] ColumnImpl col12 = new ColumnImpl("1", String.class, "title", "default", Origin.PROPERTY, false, false); [EOL] store.addColumn(col11); [EOL] store.addColumn(col12); [EOL] [EOL] Column[] cols = store.toArray(); [EOL] Assert.assertEquals(cols.length, 2); [EOL] Assert.assertSame(cols[0], col11); [EOL] Assert.assertEquals(cols[1], col12); [EOL] } [EOL]
@Test [EOL] public void canStartCollectingParameters() { [EOL] String trailingString = "});\n"; [EOL] JsArriveHandlerBuilder jsArriveHandlerBuilder = mock(JsArriveHandlerBuilder.class); [EOL] JsEventListenerBodyBuilder jsEventListenerBodyBuilder = new JsEventListenerBodyBuilder(trailingString, jsArriveHandlerBuilder); [EOL] [EOL] assertNotNull(jsEventListenerBodyBuilder.startCollectingParameters("something")); [EOL] } [EOL]
@Test [EOL] void fromStringNull() [EOL] { [EOL] assertNull(this.tool.fromString(null)); [EOL] } [EOL]
@Test [EOL] 	public final void test() { [EOL] 		String[] expecteds = new String[] { "Value 1", "Value 2" }; [EOL] 		LPZZSTR p = new LPZZSTR(expecteds); [EOL] 		assertArrayEquals(expecteds, p.get()); [EOL] 	} [EOL]
@Test [EOL] public void deserializeCertificates() throws Exception { [EOL] String tlvString = "EAACycECAtADATQwggEwMIHVoAMCAQICAQEwDAYIKoZIzj0EAwIFADAQMQ4wDAYDVQQDDAVOU1AtMTAeFw0xNDA1MTMwNzQ2NDdaFw0xNDA1MjYwNzQ2NDdaMDAxDTALBgNVBAcTBE91bHUxETAPBgNVBAMTCG5vZGUtMDAxMQwwCgYDVQQKEwNBUk0wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAT+MqviUOwxcdmY1EEjtJ6abf4Q1zSrp8vlYgAJD2j6a+ksLie/GHyon/8403pXaor+IfLRU0KuLb20+47CyoFLMAwGCCqGSM49BAMCBQADSAAwRQIgCHCKSRjEhChhCvO4njwanjpZh7qBlGAVwjRvE+m8SRACIQDvEvlUVSGNnHRvw6PTi+tae6HXX40L9HZEUJ4reBHuNdAEAS4wggEqMIHRoAMCAQICAQEwCgYIKoZIzj0EAwIwLjERMA8GA1UEAwwIQVJNLVRFU1QxDDAKBgNVBAoMA0FSTTELMAkGA1UEBhMCRkkwHhcNMTQwNDAzMDgxODE4WhcNMTYwNDAyMDgxODE4WjAQMQ4wDAYDVQQDDAVOU1AtMTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABLOijdGrCNkRYl2p5A7wxO0ZiUb+NmvGh0B7gULpi77fZqE1qR8kMxIScsBCtG+d1PwUYMvp5qmmlHWdStHQuBMwCgYIKoZIzj0EAwIDSAAwRQIhAK2GhhmBF3hiJPlXNqER3vIgWEPbkM4OM6UjgSfphgeiAiALm+ou5x2voDQcZmWvfxV10bDlWDae0Px29sTJcEiuWMgFQzBBAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBCcwJQIBAQQg6Pu7QIblW3dF+C995TkThuTr0FA/MetQmqxZRVRCP3TIABNjb2FwczovL1s6OjFdOjYxNjE2"; [EOL] byte[] tlv = Base64.getDecoder().decode(tlvString); [EOL] List<LWM2MObjectInstance> decoded = TLVDeserializer.deserialiseObjectInstances(tlv); [EOL] assertThat(decoded, hasSize(1)); [EOL] List<LWM2MResource> resources = decoded.get(0).getResources(); [EOL] assertThat(resources, hasSize(5)); [EOL] assertThat(resources.get(0).getId().intValue(), equalTo(2)); [EOL] assertThat(resources.get(1).getId().intValue(), equalTo(3)); [EOL] assertThat(resources.get(2).getId().intValue(), equalTo(4)); [EOL] assertThat(resources.get(3).getId().intValue(), equalTo(5)); [EOL] assertThat(resources.get(4).getId().intValue(), equalTo(0)); [EOL] assertThat(resources.get(1).getValue().length, equalTo(308)); [EOL] assertThat(resources.get(2).getValue().length, equalTo(302)); [EOL] assertThat(resources.get(3).getValue().length, equalTo(67)); [EOL] } [EOL]
@Test [EOL] public void testAddDescriptor() { [EOL] URI type = URI.create("urn:alert:test"); [EOL] Map<Alert.State, String> states = new HashMap<>(); [EOL] states.put(Alert.State.UNHANDLED, "application/json"); [EOL] states.put(Alert.State.HANDLED, "application/json"); [EOL] AlertDescriptor descr = new AlertDescriptor(URI.create("urn:alert:test"), "application/json", "description", true, states); [EOL] [EOL] assertThat(this.manager.addDescriptor(descr)).isTrue(); [EOL] [EOL] Set<AlertDescriptor> descrSet = this.manager.getAlertDescriptors(); [EOL] [EOL] assertThat(descrSet).hasSize(1).extracting("alertType").contains(type); [EOL] assertThat(descrSet).extracting("contentType").contains("application/json"); [EOL] assertThat(descrSet).extracting("description").contains("description"); [EOL] assertThat(descrSet).extracting("respondable").contains(true); [EOL] } [EOL]
@SuppressWarnings("unchecked") [EOL] @Test [EOL] public void testTimeoutAfterDeadline() { [EOL] HttpJsonChannel mockChannel = Mockito.mock(HttpJsonChannel.class); [EOL] [EOL] String expectedRequest = "fake"; [EOL] [EOL] HttpJsonDirectCallable<String, String> callable = new HttpJsonDirectCallable<>(API_DESCRIPTOR); [EOL] [EOL] // Mock the channel that captures the call options [EOL] ArgumentCaptor<HttpJsonCallOptions> capturedCallOptions = [EOL] ArgumentCaptor.forClass(HttpJsonCallOptions.class); [EOL] [EOL] Mockito.when( [EOL] mockChannel.issueFutureUnaryCall( [EOL] capturedCallOptions.capture(), [EOL] Mockito.anyString(), [EOL] Mockito.any(ApiMethodDescriptor.class))) [EOL] .thenReturn(SettableApiFuture.create()); [EOL] [EOL] // Compose the call context [EOL] Instant priorDeadline = Instant.now().plusSeconds(5); [EOL] Duration timeout = Duration.ofSeconds(10); [EOL] [EOL] HttpJsonCallContext callContext = [EOL] HttpJsonCallContext.createDefault() [EOL] .withChannel(mockChannel) [EOL] .withDeadline(priorDeadline) [EOL] .withTimeout(timeout); [EOL] [EOL] callable.futureCall(expectedRequest, callContext); [EOL] [EOL] // Verify that the timeout was ignored [EOL] assertThat(capturedCallOptions.getValue().getDeadline()).isEqualTo(priorDeadline); [EOL] } [EOL]
@Test [EOL] public void testCopy() throws Exception { [EOL] Representation[][][] representations = newRepresentations(3, 2, 3); [EOL] DashManifest sourceManifest = [EOL] newDashManifest( [EOL] 10, [EOL] newPeriod( [EOL] "1", [EOL] 1, [EOL] newAdaptationSet(2, representations[0][0]), [EOL] newAdaptationSet(3, representations[0][1])), [EOL] newPeriod( [EOL] "4", [EOL] 4, [EOL] newAdaptationSet(5, representations[1][0]), [EOL] newAdaptationSet(6, representations[1][1])), [EOL] newPeriod( [EOL] "7", [EOL] 7, [EOL] newAdaptationSet(8, representations[2][0]), [EOL] newAdaptationSet(9, representations[2][1]))); [EOL] [EOL] List<StreamKey> keys = [EOL] Arrays.asList( [EOL] new StreamKey(0, 0, 0), [EOL] new StreamKey(0, 0, 1), [EOL] new StreamKey(0, 1, 2), [EOL] new StreamKey(1, 0, 1), [EOL] new StreamKey(1, 1, 0), [EOL] new StreamKey(1, 1, 2), [EOL] new StreamKey(2, 0, 1), [EOL] new StreamKey(2, 0, 2), [EOL] new StreamKey(2, 1, 0)); [EOL] // Keys don't need to be in any particular order [EOL] Collections.shuffle(keys, new Random(0)); [EOL] [EOL] DashManifest copyManifest = sourceManifest.copy(keys); [EOL] [EOL] DashManifest expectedManifest = [EOL] newDashManifest( [EOL] 10, [EOL] newPeriod( [EOL] "1", [EOL] 1, [EOL] newAdaptationSet(2, representations[0][0][0], representations[0][0][1]), [EOL] newAdaptationSet(3, representations[0][1][2])), [EOL] newPeriod( [EOL] "4", [EOL] 4, [EOL] newAdaptationSet(5, representations[1][0][1]), [EOL] newAdaptationSet(6, representations[1][1][0], representations[1][1][2])), [EOL] newPeriod( [EOL] "7", [EOL] 7, [EOL] newAdaptationSet(8, representations[2][0][1], representations[2][0][2]), [EOL] newAdaptationSet(9, representations[2][1][0]))); [EOL] assertManifestEquals(expectedManifest, copyManifest); [EOL] } [EOL]
@Test [EOL] public void failureHandlerExecutesFailoverForEachBatchItemSeparately() { [EOL] [EOL] // given [EOL] Builder builder = createTestObjectFactoryBuilder(); [EOL] ClientObjectFactory<TransportClient, BulkRequest> config = builder.build(); [EOL] [EOL] FailoverPolicy failoverPolicy = spy(new NoopFailoverPolicy()); [EOL] [EOL] String payload1 = "test1"; [EOL] String payload2 = "test2"; [EOL] BulkRequest bulk = new BulkRequest() [EOL] .add(spy(new IndexRequest().source(payload1))) [EOL] .add(spy(new IndexRequest().source(payload2))); [EOL] [EOL] // when [EOL] config.createFailureHandler(failoverPolicy).apply(bulk); [EOL] [EOL] // then [EOL] ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class); [EOL] verify(failoverPolicy, times(2)).deliver((String) captor.capture()); [EOL] [EOL] assertTrue(captor.getAllValues().contains(payload1)); [EOL] assertTrue(captor.getAllValues().contains(payload2)); [EOL] } [EOL]
@Test [EOL] public void testRollBackTransaction() throws Exception [EOL] { [EOL] when( transaction.isActive() ).thenReturn( true ); [EOL] [EOL] assertEquals( 1, daoManager.rollBackTransaction( entityManager ) ); [EOL] } [EOL]
@Test [EOL] public void testSplitIntoMap() throws Exception { [EOL] String[] configurations = new String[] { "data.json=example/components/page|per:Template","infinity.json=per:Object","html=per:Page|per:Template","*~raw=nt:file" }; [EOL] Map<String, List<String>> answer = PerUtil.splitIntoMap(configurations, "=", "\\|"); [EOL] Map<String, List<String>> expected = new HashMap<>(); [EOL] expected.put("data.json", Arrays.asList("example/components/page", "per:Template")); [EOL] expected.put("infinity.json", Arrays.asList("per:Object")); [EOL] expected.put("html", Arrays.asList("per:Page", "per:Template")); [EOL] expected.put("*~raw", Arrays.asList("nt:file")); [EOL] assertNotNull("Returned Map was null", answer); [EOL] assertFalse("Returned Map was empty", answer.isEmpty()); [EOL] assertEquals("Map did not map", expected, answer); [EOL] } [EOL]
@Test [EOL] public void testFinalizeProperties__instance_subResource_noProperties() { [EOL] SchemaFactory schemaFactory = createNiceMock(SchemaFactory.class); [EOL] Schema serviceSchema = createNiceMock(Schema.class); [EOL] Schema componentSchema = createNiceMock(Schema.class); [EOL] [EOL] // schema expectations [EOL] expect(schemaFactory.getSchema(Resource.Type.Service)).andReturn(serviceSchema).anyTimes(); [EOL] expect(serviceSchema.getKeyPropertyId(Resource.Type.Service)).andReturn("ServiceInfo/service_name").anyTimes(); [EOL] expect(serviceSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn("ServiceInfo/cluster_name").anyTimes(); [EOL] expect(schemaFactory.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes(); [EOL] expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn("ServiceComponentInfo/service_name").anyTimes(); [EOL] expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn("ServiceComponentInfo/component_name").anyTimes(); [EOL] [EOL] replay(schemaFactory, serviceSchema, componentSchema); [EOL] [EOL] HashSet<String> serviceProperties = new HashSet<String>(); [EOL] QueryInfo rootQuery = new QueryInfo(new ServiceResourceDefinition(), serviceProperties); [EOL] TreeNode<QueryInfo> queryTree = new TreeNodeImpl<QueryInfo>(null, rootQuery, "Service"); [EOL] queryTree.addChild(new QueryInfo(new ComponentResourceDefinition(), new HashSet<String>()), "Component"); [EOL] [EOL] DefaultRenderer renderer = new DefaultRenderer(); [EOL] renderer.init(schemaFactory); [EOL] TreeNode<Set<String>> propertyTree = renderer.finalizeProperties(queryTree, false); [EOL] [EOL] assertEquals(1, propertyTree.getChildren().size()); [EOL] assertEquals(2, propertyTree.getObject().size()); [EOL] assertTrue(propertyTree.getObject().contains("ServiceInfo/service_name")); [EOL] assertTrue(propertyTree.getObject().contains("ServiceInfo/cluster_name")); [EOL] [EOL] [EOL] TreeNode<Set<String>> componentNode = propertyTree.getChild("Component"); [EOL] assertEquals(0, componentNode.getChildren().size()); [EOL] assertEquals(2, componentNode.getObject().size()); [EOL] assertTrue(componentNode.getObject().contains("ServiceComponentInfo/service_name")); [EOL] assertTrue(componentNode.getObject().contains("ServiceComponentInfo/component_name")); [EOL] [EOL] verify(schemaFactory, serviceSchema, componentSchema); [EOL] } [EOL]
@Test(description = "This test case tests handling ProfileManagerDAOException when deleting a profile", [EOL] dependsOnMethods = "testGetProfilesOfDeviceTypeThrowingIllegalTransactionStateException") [EOL] public void testDeleteProfileThrowingProfileManagerDAOException() throws Exception { [EOL] ProfileDAO profileDAO = mock(ProfileDAOImpl.class); [EOL] when(profileDAO.deleteProfile(any(Profile.class))).thenThrow(new ProfileManagerDAOException()); [EOL] testThrowingException(profileManager, profile1, p -> profileManager.deleteProfile(profile1), "profileDAO", [EOL] profileDAO, [EOL] ProfileManagerDAOException.class); [EOL] } [EOL]
@Test [EOL] public void ofTwoIsTwo() { [EOL] Map<String, String> map = MapUtils.of("1", "A", "2", "B"); [EOL] assertThat(map, hasEntry("1", "A")); [EOL] assertThat(map, hasEntry("2", "B")); [EOL] } [EOL]
@Test [EOL] public void serverShouldNeverSend431IfHeadersAlreadySent() throws Exception { [EOL] int padding = 0; [EOL] handler = newHandler(); [EOL] Http2Exception e = new Http2Exception.HeaderListSizeException(STREAM_ID, PROTOCOL_ERROR, [EOL] "Header size exceeded max allowed size 8196", true); [EOL] [EOL] when(stream.id()).thenReturn(STREAM_ID); [EOL] when(connection.isServer()).thenReturn(true); [EOL] when(stream.isHeadersSent()).thenReturn(true); [EOL] when(remote.lastStreamCreated()).thenReturn(STREAM_ID); [EOL] when(frameWriter.writeRstStream(eq(ctx), eq(STREAM_ID), [EOL] eq(PROTOCOL_ERROR.code()), eq(promise))).thenReturn(future); [EOL] handler.exceptionCaught(ctx, e); [EOL] [EOL] verify(encoder, never()).writeHeaders(eq(ctx), eq(STREAM_ID), [EOL] any(Http2Headers.class), eq(padding), eq(true), eq(promise)); [EOL] [EOL] verify(frameWriter).writeRstStream(ctx, STREAM_ID, PROTOCOL_ERROR.code(), promise); [EOL] } [EOL]
@Test [EOL] public void isTypeVariable_notGeneric() { [EOL] assertThat(Types.isTypeVariable(TypeToken.of(Integer.class))).isFalse(); [EOL] assertThat(Types.isTypeVariable(TypeToken.of(String.class))).isFalse(); [EOL] assertThat(Types.isTypeVariable(TypeToken.of(Object.class))).isFalse(); [EOL] assertThat(Types.isTypeVariable(TypeToken.of(String[].class))).isFalse(); [EOL] assertThat(Types.isTypeVariable(TypeToken.of(Collection.class))).isFalse(); [EOL] } [EOL]
@Test [EOL] public void ofEmptyIsEmpty() { [EOL] assertThat(ListUtils.of(), empty()); [EOL] } [EOL]
@Test [EOL] public void test_updateOnboardedServiceAccount_failure_invalid_ttl() throws Exception { [EOL] [EOL] ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.BAD_REQUEST).body("{\"errors\":[\"Invalid value provided for Password Expiration Time. This can't be more than 31536000 for this Service Account\"]}"); [EOL] String token = "5PDrOhsy4ig8L3EpsJZSLAMg"; [EOL] UserDetails userDetails = getMockUser(true); [EOL] ServiceAccount serviceAccount = new ServiceAccount(); [EOL] serviceAccount.setName("testacc02"); [EOL] serviceAccount.setAutoRotate(true); [EOL] serviceAccount.setTtl(TVaultConstants.PASSWORD_AUTOROTATE_TTL_MAX_VALUE); [EOL] serviceAccount.setMax_ttl(TVaultConstants.PASSWORD_AUTOROTATE_TTL_MAX_VALUE); [EOL] serviceAccount.setOwner("testacc0`"); [EOL] [EOL] Response response = getMockResponse(HttpStatus.OK, true, "{\"keys\":[\"testacc02\"]}"); [EOL] when(reqProcessor.process("/ad/serviceaccount/onboardedlist","{}",token)).thenReturn(response); [EOL] List<ADServiceAccount> allServiceAccounts = new ArrayList<>(); [EOL] allServiceAccounts.add(generateADServiceAccount("testacc02")); [EOL] ReflectionTestUtils.setField(serviceAccountsService, "ldapTemplate", ldapTemplate); [EOL] when(ldapTemplate.search(Mockito.anyString(), Mockito.any(), Mockito.any(AttributesMapper.class))).thenReturn(allServiceAccounts); [EOL] ResponseEntity<String> responseEntityActual = serviceAccountsService.updateOnboardedServiceAccount(token, serviceAccount, userDetails); [EOL] [EOL] assertEquals(HttpStatus.BAD_REQUEST, responseEntityActual.getStatusCode()); [EOL] assertEquals(responseEntityExpected, responseEntityActual); [EOL] } [EOL]
@Test [EOL] void testForEach() { [EOL] final Set<Map.Entry<String, Integer>> entries = new HashSet<>(); [EOL] instance [EOL] .forEach((k, v) -> entries.add(entry(k, v))); [EOL] assertEquals(refStream().collect(Collectors.toSet()), entries); [EOL] } [EOL]
@Test [EOL] 	public void alpha_bravonLF_xyz_IS_recognized_for_start_a_end_o() { [EOL] 		/* prepare */ [EOL] 		FormattedTextFinder finderToTest = new FormattedTextFinder("a","o"); [EOL] 		String text = "alpha bravo\nxyz"; [EOL] 		TestStringScanner scanner = new TestStringScanner(text); [EOL] 		 [EOL] 		/* execute */ [EOL] 		boolean found = finderToTest.isFound(scanner); [EOL] 		 [EOL] 		/* test */ [EOL] 		assertTrue(found); [EOL] 		assertEquals(text.length()-4,scanner.pos); [EOL] 		 [EOL] 	} [EOL]
@Test [EOL] public void testDecodeTextInformationFrame() { [EOL] byte[] rawId3 = buildSingleFrameTag("TIT2", new byte[] {3, 72, 101, 108, 108, 111, 32, 87, 111, [EOL] 114, 108, 100, 0}); [EOL] Id3Decoder decoder = new Id3Decoder(); [EOL] Metadata metadata = decoder.decode(rawId3, rawId3.length); [EOL] assertThat(metadata.length()).isEqualTo(1); [EOL] TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0); [EOL] assertThat(textInformationFrame.id).isEqualTo("TIT2"); [EOL] assertThat(textInformationFrame.description).isNull(); [EOL] assertThat(textInformationFrame.value).isEqualTo("Hello World"); [EOL] [EOL] // Test empty. [EOL] rawId3 = buildSingleFrameTag("TIT2", new byte[0]); [EOL] metadata = decoder.decode(rawId3, rawId3.length); [EOL] assertThat(metadata.length()).isEqualTo(0); [EOL] [EOL] // Test encoding byte only. [EOL] rawId3 = buildSingleFrameTag("TIT2", new byte[] {ID3_TEXT_ENCODING_UTF_8}); [EOL] metadata = decoder.decode(rawId3, rawId3.length); [EOL] assertThat(metadata.length()).isEqualTo(1); [EOL] textInformationFrame = (TextInformationFrame) metadata.get(0); [EOL] assertThat(textInformationFrame.id).isEqualTo("TIT2"); [EOL] assertThat(textInformationFrame.description).isNull(); [EOL] assertThat(textInformationFrame.value).isEmpty(); [EOL] } [EOL]
@Test [EOL] public void testFunctionThrowsError() { [EOL] Subscription s = mock(Subscription.class); [EOL] TestObservable w = new TestObservable(s, "one"); [EOL] Func1<Throwable, Observable<String>> resume = new Func1<Throwable, Observable<String>>() { [EOL] [EOL] @Override [EOL] public Observable<String> call(Throwable t1) { [EOL] throw new RuntimeException("exception from function"); [EOL] } [EOL] [EOL] }; [EOL] Observable<String> observable = Observable.create(onErrorResumeNextViaFunction(Observable.create(w), resume)); [EOL] [EOL] @SuppressWarnings("unchecked") [EOL] Observer<String> observer = mock(Observer.class); [EOL] observable.subscribe(observer); [EOL] [EOL] try { [EOL] w.t.join(); [EOL] } catch (InterruptedException e) { [EOL] fail(e.getMessage()); [EOL] } [EOL] [EOL] // we should get the "one" value before the error [EOL] verify(observer, times(1)).onNext("one"); [EOL] [EOL] // we should have received an onError call on the Observer since the resume function threw an exception [EOL] verify(observer, times(1)).onError(any(Throwable.class)); [EOL] verify(observer, times(0)).onCompleted(); [EOL] } [EOL]
@Test [EOL] public void testCreateString03() { [EOL] // 初期設定 [EOL] String input = "javax.swing.AbstractAction"; [EOL] [EOL] try { [EOL] // テスト実行 [EOL] ClassUtil.create(input); [EOL] fail(); [EOL] } catch (ClassLoadException e) { [EOL] if (e.getMessage().indexOf("InstantiationException") == -1) { [EOL] // 結果確認 [EOL] fail(); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void serializerSupportedFormats() throws SerializerException { [EOL] assertNotNull(odata.createSerializer(ContentType.JSON_NO_METADATA)); [EOL] assertNotNull(odata.createSerializer(ContentType.JSON)); [EOL] assertNotNull(odata.createSerializer(ContentType.APPLICATION_JSON)); [EOL] assertNotNull(odata.createSerializer(ContentType.JSON_FULL_METADATA)); [EOL] List<String> versions = new ArrayList<String>(); [EOL] versions.add("4.01"); [EOL] assertNotNull(odata.createSerializer(ContentType.JSON_FULL_METADATA, versions)); [EOL] } [EOL]
@Test [EOL] // Test short-circuiting the if -> else [EOL] public void testIfBlockElse() throws Exception { [EOL] Piece piece1 = new Piece(); [EOL] Piece piece2 = new Piece(); [EOL] Block ifBlock = new IfBlock( [EOL] FALSE_SUPPLIER, [EOL] new EmptyBlock(), [EOL] new SequenceBlock(piece1, piece2) [EOL] ); [EOL] [EOL] BlockTestingUtils.testIndependence( [EOL] Arrays.asList(piece1, piece2), [EOL] ifBlock); [EOL] Assert.assertFalse(ifBlock.getPieceCount().isKnown()); [EOL] } [EOL]
@Test [EOL] public void breadthFirst_rightNodeIsNull() { [EOL] Tree<String> tree = tree("foo").setLeft("left"); [EOL] assertThat(Tree.<String>walker().breadthFirstFrom(tree).map(Tree::value)) [EOL] .containsExactly("foo", "left") [EOL] .inOrder(); [EOL] } [EOL]
@Test [EOL] public void testGetExecutionCommand() throws JSONException, AmbariException { [EOL] [EOL] [EOL] Map<String, Map<String, String>> confs = new HashMap<String, Map<String, String>>(); [EOL] Map<String, String> configurationsGlobal = new HashMap<String, String>(); [EOL] configurationsGlobal.put(GLOBAL_NAME1, GLOBAL_VAL1); [EOL] confs.put(GLOBAL_CONFIG, configurationsGlobal); [EOL] [EOL] Map<String, Map<String, String>> confTags = new HashMap<String, Map<String, String>>(); [EOL] Map<String, String> confTagServiceSite = new HashMap<String, String>(); [EOL] [EOL] confTagServiceSite.put("tag", CLUSTER_VERSION_TAG); [EOL] confTagServiceSite.put("service_override_tag", SERVICE_VERSION_TAG); [EOL] confTagServiceSite.put("host_override_tag", HOST_VERSION_TAG); [EOL] [EOL] confTags.put(SERVICE_SITE_CONFIG, confTagServiceSite); [EOL] [EOL] Map<String, String> confTagGlobal = Collections.singletonMap("tag", CLUSTER_VERSION_TAG); [EOL] [EOL] confTags.put(GLOBAL_CONFIG, confTagGlobal); [EOL] [EOL] [EOL] ExecutionCommand executionCommand = new ExecutionCommand(); [EOL] [EOL] [EOL] executionCommand.setClusterName(CLUSTER1); [EOL] executionCommand.setTaskId(1); [EOL] executionCommand.setRequestAndStage(1, 1); [EOL] executionCommand.setHostname(HOST1); [EOL] executionCommand.setRole("NAMENODE"); [EOL] executionCommand.setRoleParams(Collections.<String, String>emptyMap()); [EOL] executionCommand.setRoleCommand(RoleCommand.START); [EOL] executionCommand.setConfigurations(confs); [EOL] executionCommand.setConfigurationTags(confTags); [EOL] executionCommand.setServiceName("HDFS"); [EOL] executionCommand.setCommandType(AgentCommandType.EXECUTION_COMMAND); [EOL] executionCommand.setCommandParams(Collections.<String, String>emptyMap()); [EOL] [EOL] String json = StageUtils.getGson().toJson(executionCommand, ExecutionCommand.class); [EOL] [EOL] ExecutionCommandWrapper execCommWrap = new ExecutionCommandWrapper(json); [EOL] injector.injectMembers(execCommWrap); [EOL] [EOL] ExecutionCommand processedExecutionCommand = execCommWrap.getExecutionCommand(); [EOL] [EOL] Map<String, String> serviceSiteConfig = processedExecutionCommand.getConfigurations().get(SERVICE_SITE_CONFIG); [EOL] [EOL] Assert.assertEquals(SERVICE_SITE_VAL1_S, serviceSiteConfig.get(SERVICE_SITE_NAME1)); [EOL] Assert.assertEquals(SERVICE_SITE_VAL2_H, serviceSiteConfig.get(SERVICE_SITE_NAME2)); [EOL] Assert.assertEquals(SERVICE_SITE_VAL3, serviceSiteConfig.get(SERVICE_SITE_NAME3)); [EOL] Assert.assertEquals(SERVICE_SITE_VAL4, serviceSiteConfig.get(SERVICE_SITE_NAME4)); [EOL] Assert.assertEquals(SERVICE_SITE_VAL5_S, serviceSiteConfig.get(SERVICE_SITE_NAME5)); [EOL] Assert.assertEquals(SERVICE_SITE_VAL6_H, serviceSiteConfig.get(SERVICE_SITE_NAME6)); [EOL] [EOL] Map<String, String> globalConfig = processedExecutionCommand.getConfigurations().get(GLOBAL_CONFIG); [EOL] [EOL] Assert.assertEquals(GLOBAL_VAL1, globalConfig.get(GLOBAL_NAME1)); [EOL] Assert.assertEquals(GLOBAL_CLUSTER_VAL2, globalConfig.get(GLOBAL_NAME2)); [EOL] [EOL] [EOL] //Union of all keys of service site configs [EOL] Set<String> serviceSiteKeys = new HashSet<String>(); [EOL] serviceSiteKeys.addAll(SERVICE_SITE_CLUSTER.keySet()); [EOL] serviceSiteKeys.addAll(SERVICE_SITE_SERVICE.keySet()); [EOL] serviceSiteKeys.addAll(SERVICE_SITE_HOST.keySet()); [EOL] [EOL] Assert.assertEquals(serviceSiteKeys.size(), serviceSiteConfig.size()); [EOL] [EOL] } [EOL]
@Test [EOL] void shouldBeValidFrameWithNoFragmentation() { [EOL] int maxFrameLength = [EOL] ThreadLocalRandom.current().nextInt(64, FrameLengthCodec.FRAME_LENGTH_MASK); [EOL] byte[] data = new byte[maxFrameLength - FRAME_LENGTH_SIZE - FrameHeaderCodec.size()]; [EOL] ThreadLocalRandom.current().nextBytes(data); [EOL] final Payload payload = DefaultPayload.create(data); [EOL] [EOL] Assertions.assertThat(PayloadValidationUtils.isValid(0, maxFrameLength, payload, false)) [EOL] .isTrue(); [EOL] Assertions.assertThat(PayloadValidationUtils.isValid(0, maxFrameLength, payload, true)) [EOL] .isFalse(); [EOL] } [EOL]
@Test [EOL] public void validateBooleanResource() throws Exception { [EOL] ResourceModel bolRes = createResourceModel(Type.BOOLEAN, ""); [EOL] assertTrue(bolRes.isValid(0)); [EOL] assertTrue(bolRes.isValid(1)); [EOL] assertTrue(bolRes.isValid("0")); [EOL] assertTrue(bolRes.isValid("1")); [EOL] assertFalse(bolRes.isValid(2)); [EOL] } [EOL]
@Test [EOL] void shouldCombineNullAndNullErrors() [EOL] { [EOL] assertNull( Futures.combineErrors( null, null ) ); [EOL] } [EOL]
@Test(invocationCount = 20, successPercentage = 95) [EOL] 	public void newInstanceDistribution() { [EOL] 		using(new Random(12345), r -> { [EOL] 			final int min = 0; [EOL] 			final int max = 10000000; [EOL] [EOL] 			final MinMax<Integer> mm = MinMax.of(); [EOL] 			final Histogram<Integer> histogram = Histogram.ofInteger(min, max, 10); [EOL] [EOL] 			for (int i = 0; i < 1000; ++i) { [EOL] 				final IntegerChromosome chromosome = IntegerChromosome.of(min, max, 500); [EOL] [EOL] 				chromosome.forEach(g -> { [EOL] 					mm.accept(g.allele()); [EOL] 					histogram.accept(g.allele()); [EOL] 				}); [EOL] 			} [EOL] [EOL] 			Assert.assertTrue(mm.min().compareTo(0) >= 0); [EOL] 			Assert.assertTrue(mm.max().compareTo(100) <= 100); [EOL] 			assertUniformDistribution(histogram); [EOL] 		}); [EOL] 	} [EOL]
@Test [EOL] public void testReadAheadManagerForSuccessfulReadAhead() throws Exception { [EOL] // Mock failure for client.read() [EOL] AbfsClient client = getMockAbfsClient(); [EOL] [EOL] // Success operation mock [EOL] AbfsRestOperation op = getMockRestOp(); [EOL] [EOL] // Stub : [EOL] // Pass all readAheads and fail the post eviction request to [EOL] // prove ReadAhead buffer is used [EOL] doReturn(op) [EOL] .doReturn(op) [EOL] .doReturn(op) [EOL] .doThrow(new TimeoutException("Internal Server error for RAH-X")) // for post eviction request [EOL] .doThrow(new TimeoutException("Internal Server error for RAH-Y")) [EOL] .doThrow(new TimeoutException("Internal Server error for RAH-Z")) [EOL] .when(client) [EOL] .read(any(String.class), any(Long.class), any(byte[].class), [EOL] any(Integer.class), any(Integer.class), any(String.class), [EOL] any(String.class)); [EOL] [EOL] AbfsInputStream inputStream = getAbfsInputStream(client, "testSuccessfulReadAhead.txt"); [EOL] [EOL] queueReadAheads(inputStream); [EOL] [EOL] // AbfsInputStream Read would have waited for the read-ahead for the requested offset [EOL] // as we are testing from ReadAheadManager directly, sleep for a sec to [EOL] // get the read ahead threads to complete [EOL] Thread.sleep(1000); [EOL] [EOL] // Only the 3 readAhead threads should have triggered client.read [EOL] verifyReadCallCount(client, 3); [EOL] [EOL] // getBlock for a new read should return the buffer read-ahead [EOL] int bytesRead = ReadBufferManager.getBufferManager().getBlock( [EOL] inputStream, [EOL] ONE_KB, [EOL] ONE_KB, [EOL] new byte[ONE_KB]); [EOL] [EOL] Assert.assertTrue("bytesRead should be non-zero from the " [EOL] + "buffer that was read-ahead", bytesRead > 0); [EOL] [EOL] // Once created, mock will remember all interactions. [EOL] // As the above read should not have triggered any server calls, total [EOL] // number of read calls made at this point will be same as last. [EOL] verifyReadCallCount(client, 3); [EOL] [EOL] // Stub will throw exception for client.read() for 4th and later calls [EOL] // if not using the read-ahead buffer exception will be thrown on read [EOL] checkEvictedStatus(inputStream, 0, true); [EOL] } [EOL]
@Test [EOL] public void shouldReturnEmptyListForEmptyEntity() throws IOException { [EOL] InputStream stream = new ByteArrayInputStream("".getBytes()); [EOL] assertTrue(toTest.extract(null, UTF8, stream).isEmpty()); [EOL] } [EOL]
@Test [EOL] public void testGetUniqueNonEmptyTrimmedStrings (){ [EOL] final String TO_SPLIT = ",foo, bar,baz,,blah,blah,bar,"; [EOL] Collection<String> col = StringUtils.getTrimmedStringCollection(TO_SPLIT); [EOL] assertEquals(4, col.size()); [EOL] assertTrue(col.containsAll(Arrays.asList(new String[]{"foo","bar","baz","blah"}))); [EOL] } [EOL]
@Test [EOL] public void toString_uri_noPointer() { [EOL] SchemaLocation underTest = new SchemaLocation(uri("http://example.com/hello"), emptyList()); [EOL] assertEquals("http://example.com/hello", underTest.toString()); [EOL] } [EOL]
@Test [EOL] 	public void testGetURLBackURLWithBackURLParameter() { [EOL] 		MockLiferayPortletRenderRequest mockLiferayPortletRenderRequest = [EOL] 			new MockLiferayPortletRenderRequest(); [EOL] [EOL] 		mockLiferayPortletRenderRequest.setAttribute( [EOL] 			"null" + StringPool.DASH + WebKeys.CURRENT_PORTLET_URL, [EOL] 			new MockLiferayPortletURL()); [EOL] [EOL] 		String backURL = RandomTestUtil.randomString(); [EOL] [EOL] 		mockLiferayPortletRenderRequest.setParameter("backURL", backURL); [EOL] [EOL] 		ContentDashboardDropdownItemsProvider [EOL] 			contentDashboardDropdownItemsProvider = [EOL] 				new ContentDashboardDropdownItemsProvider( [EOL] 					_http, _language, mockLiferayPortletRenderRequest, [EOL] 					new MockLiferayPortletRenderResponse(), new PortalImpl()); [EOL] [EOL] 		ContentDashboardItem contentDashboardItem = _getContentDashboardItem( [EOL] 			Collections.singletonList( [EOL] 				_getContentDashboardItemAction( [EOL] 					"view", ContentDashboardItemAction.Type.VIEW, "validURL"))); [EOL] [EOL] 		List<DropdownItem> dropdownItems = [EOL] 			contentDashboardDropdownItemsProvider.getDropdownItems( [EOL] 				contentDashboardItem); [EOL] [EOL] 		Stream<DropdownItem> stream = dropdownItems.stream(); [EOL] [EOL] 		DropdownItem viewDropdownItem = stream.filter( [EOL] 			dropdownItem -> Objects.equals( [EOL] 				String.valueOf(dropdownItem.get("label")), "view") [EOL] 		).findFirst( [EOL] 		).orElseThrow( [EOL] 			() -> new AssertionError() [EOL] 		); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			backURL, [EOL] 			_http.getParameter( [EOL] 				String.valueOf(viewDropdownItem.get("href")), "p_l_back_url")); [EOL] 	} [EOL]
@Test [EOL] 	public void testGetDDMStorageAdapter() { [EOL] 		DDMStorageAdapterTrackerImpl ddmStorageAdapterTrackerImpl = [EOL] 			new DDMStorageAdapterTrackerImpl(); [EOL] [EOL] 		ddmStorageAdapterTrackerImpl.ddmStorageAdapterServiceTrackerMap = [EOL] 			_ddmStorageAdapterServiceTrackerMap; [EOL] [EOL] 		ddmStorageAdapterTrackerImpl.getDDMStorageAdapter("json"); [EOL] [EOL] 		Mockito.verify( [EOL] 			_ddmStorageAdapterServiceTrackerMap, Mockito.times(1) [EOL] 		).getService( [EOL] 			"json" [EOL] 		); [EOL] 	} [EOL]
@Test [EOL] public void testMissingHeader() { [EOL] final MockHttpServletRequest request = new MockHttpServletRequest(); [EOL] [EOL] assertThatThrownBy(() -> lineBotCallbackRequestParser.handle(request)) [EOL] .isInstanceOf(LineBotCallbackException.class) [EOL] .hasMessage("Missing 'X-Line-Signature' header"); [EOL] } [EOL]
@Test [EOL] public void testEquals() [EOL] throws Exception [EOL] { [EOL] Artifact artifact = new DefaultArtifact( "gid", "aid", "ext", "cla", "ver" ); [EOL] [EOL] assertTrue( artifact.equals( artifact ) ); [EOL] assertFalse( artifact.equals( null ) ); [EOL] assertFalse( artifact.equals( 42 ) ); [EOL] [EOL] Artifact artifact0 = new DefaultArtifact( "gid:aid:ext:cla:ver" ); [EOL] [EOL] assertTrue( artifact.equals( artifact0 ) ); [EOL] [EOL] Artifact artifact1 = new DefaultArtifact( "gidX", "aid", "ext", "cla", "ver" ); [EOL] Artifact artifact2 = new DefaultArtifact( "gid", "aidX", "ext", "cla", "ver" ); [EOL] Artifact artifact3 = new DefaultArtifact( "gid", "aid", "extX", "cla", "ver" ); [EOL] Artifact artifact4 = new DefaultArtifact( "gid", "aid", "ext", "claX", "ver" ); [EOL] Artifact artifact5 = new DefaultArtifact( "gid", "aid", "ext", "cla", "verX" ); [EOL] [EOL] assertFalse( artifact.equals( artifact1 ) ); [EOL] assertFalse( artifact.equals( artifact2 ) ); [EOL] assertFalse( artifact.equals( artifact3 ) ); [EOL] assertFalse( artifact.equals( artifact4 ) ); [EOL] assertFalse( artifact.equals( artifact5 ) ); [EOL] } [EOL]
@Test [EOL] public void testEqualsObjects0023() { [EOL] [EOL] Calendar cal = Calendar.getInstance(); [EOL] [EOL] java.sql.Date value1 = new java.sql.Date(cal.getTimeInMillis()); [EOL] java.sql.Date value2 = null; [EOL] [EOL] // テスト [EOL] boolean result = ControlBreakChecker.equalsObjects(value1, value2, null); [EOL] [EOL] // 検証 [EOL] assertFalse(result); [EOL] } [EOL]
@Test [EOL] public void testIsReadyToAcceptOversize() throws Exception { [EOL] expect(serviceRegistry.getRegistryHostname()).andReturn("test").anyTimes(); [EOL] expect(serviceRegistry.getMaxLoadOnNode("test")).andReturn(new NodeLoad("test", 0.0f, 4.0f)).anyTimes(); [EOL] //Initially zero load + 1.0f [EOL] expect(serviceRegistry.getOwnLoad()).andReturn(1.0f); [EOL] //Initially 4.0 load + 1.0f [EOL] expect(serviceRegistry.getOwnLoad()).andReturn(5.0f); [EOL] //Initially zero load + 10.0f [EOL] expect(serviceRegistry.getOwnLoad()).andReturn(10.0f); [EOL] replayAll(); [EOL] [EOL] jobProducer.setAcceptOversizeJobs(true); [EOL] [EOL] Job job = new JobImpl(3); [EOL] job.setJobType("test"); [EOL] job.setStatus(Status.DISPATCHING); [EOL] job.setProcessingHost("same"); [EOL] [EOL] // Job load lower than max load and enough free load available [EOL] job.setJobLoad(1.0f); [EOL] assertTrue("Job load + current load < max load, so accept job", jobProducer.isReadyToAccept(job)); [EOL] [EOL] job.setJobLoad(1.0f); [EOL] assertFalse("Job load + current load >= max load, so accept job", jobProducer.isReadyToAccept(job)); [EOL] [EOL] // Job load higher than max load but some load on host [EOL] job.setJobLoad(10.0f); [EOL] assertTrue("Job load >= max load, but accepting oversize jobs is true so accept job", jobProducer.isReadyToAccept(job)); [EOL] } [EOL]
@Test [EOL] public void shouldHandleNonExistingSystemProperty() throws LifecycleExecutionException { [EOL] System.setProperty(ExtensionSettings.REPOSITORIES_SETTING_KEY, ""); [EOL] List<Repository> repositoryList = loader.load(logger); [EOL] Assertions.assertThat(repositoryList).isEmpty(); [EOL] } [EOL]
@Test [EOL] public void sendsTxAbortedEventOnError() throws Exception { [EOL] interceptor.onError(parentTxId, compensationMethod, new RuntimeException("oops")); [EOL] [EOL] TxEvent event = messages.get(0); [EOL] [EOL] assertThat(event.globalTxId(), is(globalTxId)); [EOL] assertThat(event.localTxId(), is(localTxId)); [EOL] assertThat(event.parentTxId(), is(parentTxId)); [EOL] assertThat(event.type(), is(EventType.TxAbortedEvent)); [EOL] assertThat(event.compensationMethod(), is(compensationMethod)); [EOL] } [EOL]
@Test [EOL] 	public void testTopologicalSort3() { [EOL] 		// --> op1 -- [EOL] 		// / \ [EOL] 		// (source) - +-> op2 -> op3 [EOL] 		// \ / [EOL] 		// --------- [EOL] 		 [EOL] 		try { [EOL] 			JobVertex source = new JobVertex("source"); [EOL] 			JobVertex op1 = new JobVertex("op4"); [EOL] 			JobVertex op2 = new JobVertex("op2"); [EOL] 			JobVertex op3 = new JobVertex("op3"); [EOL] 			 [EOL] 			op1.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED); [EOL] 			op2.connectNewDataSetAsInput(op1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED); [EOL] 			op2.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED); [EOL] 			op3.connectNewDataSetAsInput(op2, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED); [EOL] [EOL] 			JobGraph graph = new JobGraph("TestGraph", source, op1, op2, op3); [EOL] 			List<JobVertex> sorted = graph.getVerticesSortedTopologicallyFromSources(); [EOL] 			 [EOL] 			assertEquals(4, sorted.size()); [EOL] 			 [EOL] 			assertBefore(source, op1, sorted); [EOL] 			assertBefore(source, op2, sorted); [EOL] 			assertBefore(op1, op2, sorted); [EOL] 			assertBefore(op2, op3, sorted); [EOL] 		} [EOL] 		catch (Exception e) { [EOL] 			e.printStackTrace(); [EOL] 			fail(e.getMessage()); [EOL] 		} [EOL] 	} [EOL]
@Test [EOL] void putEvents_multipleEvents() { [EOL] final HBaseStatisticsConfig hBaseStatisticsConfig = new HBaseStatisticsConfig(); [EOL] hBaseStatisticsConfig.setDocRefType(DOC_REF_TYPE_1); [EOL] hBaseStatisticsConfig.getKafkaTopicsConfig().setCount("MyTopic"); [EOL] [EOL] initMocks(); [EOL] [EOL] StroomStatsInternalStatisticsService stroomStatsInternalStatisticsService = [EOL] new StroomStatsInternalStatisticsService( [EOL] mockStroomKafkaProducerFactory, [EOL] hBaseStatisticsConfig); [EOL] [EOL] //assemble test data [EOL] InternalStatisticEvent event1 = InternalStatisticEvent.createPlusOneCountStat( [EOL] InternalStatisticKey.MEMORY, 0, Collections.emptyMap()); [EOL] InternalStatisticEvent event2 = InternalStatisticEvent.createPlusOneCountStat( [EOL] InternalStatisticKey.MEMORY, 1, Collections.emptyMap()); [EOL] InternalStatisticEvent event3 = InternalStatisticEvent.createPlusOneCountStat( [EOL] InternalStatisticKey.MEMORY, 1, Collections.emptyMap()); [EOL] DocRef docRefA = new DocRef(DOC_REF_TYPE_1, UUID.randomUUID().toString(), "myStat1"); [EOL] DocRef docRefB = new DocRef(DOC_REF_TYPE_2, UUID.randomUUID().toString(), "myStat2"); [EOL] Map<DocRef, List<InternalStatisticEvent>> map = Map.of( [EOL] docRefA, Arrays.asList(event1, event2), [EOL] docRefB, Collections.singletonList(event3)); [EOL] [EOL] stroomStatsInternalStatisticsService.putEvents(map); [EOL] [EOL] //two different doc refs so two calls to producer [EOL] Mockito.verify(mockKafkaProducer, Mockito.times(2)) [EOL] .send(Mockito.any(ProducerRecord.class)); [EOL] } [EOL]
@Test [EOL] public void pbkdf2SerializationDeserializationTest() throws Exception [EOL] { [EOL] byte[] password = PasswordToByteConverter.convert("password"); [EOL] KeyDerivationFunction kdf = getKDFInstance(new PBKDF2Parameters(32, 1000)); [EOL] KeyWithIVParameters params = kdf.derive(password, 8); [EOL] [EOL] KeyDerivationFunction kdf2 = factory.getInstance(kdf.getEncoded()); [EOL] KeyWithIVParameters params2 = kdf2.derive(password, 8); [EOL] [EOL] assertThat(params.getKey(), equalTo(params2.getKey())); [EOL] assertThat(params2.getIV(), equalTo(params2.getIV())); [EOL] } [EOL]
@Test [EOL] public void testMergeFile09() throws Exception { [EOL] // 引数の設定 [EOL] String classFileName = this.getClass().getSimpleName() + ".class"; [EOL] URL url = this.getClass().getResource(classFileName); [EOL] String directoryPath = url.getPath().substring(0, [EOL] url.getPath().length() - classFileName.length()); [EOL] List<String> fileList = new ArrayList<String>(); [EOL] [EOL] String srcFile1 = directoryPath + "testMergeFile09_src1.txt"; [EOL] fileList.add(srcFile1); [EOL] String srcFile2 = directoryPath + "testMergeFile09_src2.txt"; [EOL] fileList.add(srcFile2); [EOL] String srcFile3 = directoryPath + "testMergeFile09_src3.txt"; [EOL] fileList.add(srcFile3); [EOL] [EOL] String newFile = directoryPath + "testMergeFile09_new.txt"; [EOL] [EOL] // 前提条件の設定 [EOL] Field field = FileUtility.class.getDeclaredField("checkFileExist"); [EOL] field.setAccessible(true); [EOL] field.set(FileUtility.class, true); [EOL] [EOL] // テスト対象ファイルを初期化する。 [EOL] File testSrcFile1 = new File(srcFile1); [EOL] testSrcFile1.delete(); [EOL] testSrcFile1.createNewFile(); [EOL] [EOL] File testSrcFile2 = new File(srcFile2); [EOL] testSrcFile2.delete(); [EOL] testSrcFile2.createNewFile(); [EOL] [EOL] File testSrcFile3 = new File(srcFile3); [EOL] testSrcFile3.delete(); [EOL] testSrcFile3.createNewFile(); [EOL] [EOL] File testNewFile = new File(newFile); [EOL] testNewFile.delete(); [EOL] testNewFile.createNewFile(); [EOL] [EOL] IOException ioException = new IOException("testMergeFile09例外"); [EOL] [EOL] FileOutputStream fos = Mockito.mock(FileOutputStream.class, Mockito.RETURNS_MOCKS); [EOL] Mockito.doThrow(ioException).when(fos).close(); [EOL] PowerMockito.spy(FileOutputStream.class); [EOL] PowerMockito.whenNew(FileOutputStream.class).withArguments(testNewFile, true).thenReturn(fos); [EOL] [EOL] FileWriter testSrcFile1FileWriter = null; [EOL] FileWriter testSrcFile2FileWriter = null; [EOL] FileWriter testSrcFile3FileWriter = null; [EOL] FileWriter testNewFileFileWriter = null; [EOL] BufferedReader postReader = null; [EOL] try { [EOL] testSrcFile1FileWriter = new FileWriter(testSrcFile1); [EOL] testSrcFile1FileWriter.write("testMergeFile09_src1.txtデータ"); [EOL] testSrcFile1FileWriter.flush(); [EOL] testSrcFile1FileWriter.close(); [EOL] [EOL] testSrcFile2FileWriter = new FileWriter(testSrcFile2); [EOL] testSrcFile2FileWriter.write("testMergeFile09_src2.txtデータ"); [EOL] testSrcFile2FileWriter.flush(); [EOL] testSrcFile2FileWriter.close(); [EOL] [EOL] testSrcFile3FileWriter = new FileWriter(testSrcFile3); [EOL] testSrcFile3FileWriter.write("testMergeFile09_src3.txtデータ"); [EOL] testSrcFile3FileWriter.flush(); [EOL] testSrcFile3FileWriter.close(); [EOL] [EOL] testNewFileFileWriter = new FileWriter(testNewFile); [EOL] testNewFileFileWriter.write("testMergeFile09_new.txtデータ"); [EOL] testNewFileFileWriter.flush(); [EOL] testNewFileFileWriter.close(); [EOL] [EOL] PowerMockito.mockStatic(FileUtility.class, Mockito.CALLS_REAL_METHODS); [EOL] [EOL] // テスト実施 [EOL] FileUtility.mergeFile(fileList, newFile); [EOL] [EOL] // 状態変化の確認 [EOL] PowerMockito.verifyPrivate(FileUtility.class, Mockito.times(4)).invoke("checkAbsolutePath", Mockito.anyString()); [EOL] PowerMockito.verifyPrivate(FileUtility.class).invoke("checkAbsolutePath", newFile); [EOL] PowerMockito.verifyPrivate(FileUtility.class).invoke("checkAbsolutePath", srcFile1); [EOL] PowerMockito.verifyPrivate(FileUtility.class).invoke("checkAbsolutePath", srcFile2); [EOL] PowerMockito.verifyPrivate(FileUtility.class).invoke("checkAbsolutePath", srcFile3); [EOL] [EOL] // マージ先のファイル内容確認 [EOL] // FileOutputStream#close()時のIOException発生確認のため、FileOutputStreamをモック化している。 [EOL] // ここではマージファイルは出力されない。 [EOL] // File mergeFile = new File(newFile); [EOL] // assertTrue(mergeFile.exists()); [EOL] // postReader = new BufferedReader(new InputStreamReader( [EOL] // new FileInputStream(mergeFile))); [EOL] // assertTrue(postReader.ready()); [EOL] // String expectationResultData = "testMergeFile09_src1.txtデータ" [EOL] // + "testMergeFile09_src2.txtデータtestMergeFile09_src3.txtデータ"; [EOL] // String data = ""; [EOL] // for (int i = 0; i < expectationResultData.length(); i++) { [EOL] // assertTrue(i + "回目の判定で失敗しました。", postReader.ready()); [EOL] // data += (char) postReader.read(); [EOL] // } [EOL] // assertEquals(expectationResultData, data); [EOL] // assertFalse(postReader.ready()); [EOL] [EOL] } finally { [EOL] if (testSrcFile1FileWriter != null) { [EOL] testSrcFile1FileWriter.close(); [EOL] } [EOL] if (testSrcFile2FileWriter != null) { [EOL] testSrcFile2FileWriter.close(); [EOL] } [EOL] if (testSrcFile3FileWriter != null) { [EOL] testSrcFile3FileWriter.close(); [EOL] } [EOL] if (testNewFileFileWriter != null) { [EOL] testNewFileFileWriter.close(); [EOL] } [EOL] if (postReader != null) { [EOL] postReader.close(); [EOL] } [EOL] // テスト後ファイルを削除 [EOL] File file = new File(srcFile1); [EOL] file.delete(); [EOL] file = new File(srcFile2); [EOL] file.delete(); [EOL] file = new File(srcFile3); [EOL] file.delete(); [EOL] file = new File(newFile); [EOL] file.delete(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetCurrentHashCode() { [EOL] [EOL] final GuidedDecisionTableView.Presenter activeDocument1 = mock(GuidedDecisionTableView.Presenter.class); [EOL] final GuidedDecisionTableView.Presenter activeDocument2 = mock(GuidedDecisionTableView.Presenter.class); [EOL] final Integer activeDocument1Hashcode = 123; [EOL] final Integer activeDocument2Hashcode = 456; [EOL] final Integer expectedHashcode = 789; [EOL] [EOL] doReturn(asSet(activeDocument1, activeDocument2)).when(presenter).getAvailableDecisionTables(); [EOL] doReturn(123).when(presenter).currentHashCode(activeDocument1); [EOL] doReturn(456).when(presenter).currentHashCode(activeDocument2); [EOL] doReturn(expectedHashcode).when(presenter).combineHashCodes(asList(activeDocument1Hashcode, activeDocument2Hashcode)); [EOL] doReturn(expectedHashcode).when(presenter).combineHashCodes(asList(activeDocument2Hashcode, activeDocument1Hashcode)); [EOL] [EOL] final Integer actualHashcode = presenter.getCurrentHashCodeSupplier().get(); [EOL] [EOL] assertEquals(expectedHashcode, actualHashcode); [EOL] } [EOL]
@Test [EOL] public void fallbackToRemoteAddress() throws Exception { [EOL] underTest.doFilter(request, response, chain); [EOL] [EOL] verify(chain).doFilter(captor.capture(), eq(response)); [EOL] [EOL] HttpServletRequest captured = captor.getValue(); [EOL] [EOL] when(request.getRemoteAddr()).thenReturn("4.3.2.1"); [EOL] [EOL] assertThat(captured.getRemoteAddr(), is("4.3.2.1")); [EOL] } [EOL]
@Test [EOL] public void bufferWithBOEmptyLastViaBoundary() { [EOL] PublishSubject<Integer> source = PublishSubject.create(); [EOL] PublishSubject<Integer> boundary = PublishSubject.create(); [EOL] [EOL] @SuppressWarnings("unchecked") [EOL] Observer<Object> o = mock(Observer.class); [EOL] InOrder inOrder = Mockito.inOrder(o); [EOL] [EOL] source.buffer(boundary).subscribe(o); [EOL] [EOL] boundary.onCompleted(); [EOL] [EOL] inOrder.verify(o, times(1)).onNext(Arrays.asList()); [EOL] [EOL] inOrder.verify(o).onCompleted(); [EOL] [EOL] verify(o, never()).onError(any(Throwable.class)); [EOL] } [EOL]
@Test [EOL] public void test_areAWSIAMRoleInputsValid_invalid_authType() { [EOL] [EOL] AWSIAMRole awsiamRole = new AWSIAMRole(); [EOL] awsiamRole.setAuth_type("ec2"); [EOL] String[] arns = {"arn:aws:iam::123456789012:user/tst"}; [EOL] awsiamRole.setBound_iam_principal_arn(arns); [EOL] String[] policies = {"default"}; [EOL] awsiamRole.setPolicies(policies); [EOL] awsiamRole.setResolve_aws_unique_ids(true); [EOL] awsiamRole.setRole("string"); [EOL] try { [EOL] boolean valid = ControllerUtil.areAWSIAMRoleInputsValid(awsiamRole); [EOL] } catch (TVaultValidationException e) { [EOL] assertTrue(true); [EOL] } [EOL] } [EOL]
@Test(expected=NumberFormatException.class) [EOL] public void testValueOfBlockStartsNumberFormatException() { [EOL] valueOf("chr1\t11873\t14409\tuc001aaa.3\t0\t+\t11873\t11873\t0\t3\t354,109,1189,\t0,739,not a number,"); [EOL] } [EOL]
@Test [EOL] public void testCheckAndMutateRow() { [EOL] ConditionalRowMutation checkAndMutate = [EOL] ConditionalRowMutation.create(TABLE_ID, ROW_KEY) [EOL] .then(Mutation.create().setCell(COL_FAMILY, QUALIFIER_1, VALUE_1)); [EOL] when(dataClientV2.checkAndMutateRow(checkAndMutate)).thenReturn(Boolean.TRUE); [EOL] assertTrue(dataGCJClient.checkAndMutateRow(checkAndMutate)); [EOL] verify(dataClientV2).checkAndMutateRow(checkAndMutate); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void whenGenerateNoEmployees_thenThrowException() { [EOL] employeeGeneratorService.resetEmployees(TEST_ZERO_EMPLOYEES); [EOL] } [EOL]
@Test [EOL] public void testRemoveAllColumnsExt() { [EOL] TableColumnModelExt model = createTableColumnModelExt(); [EOL] TableUtilities.clear(model, true); [EOL] assertEquals(0, model.getColumnCount()); [EOL] } [EOL]
@Test(expected = NoSuchTableException.class) [EOL] public void get_onNonExistingIndex_throwsException() throws Exception { [EOL] engine.get(testIndex); [EOL] } [EOL]
@Test [EOL] 	public void test() throws Exception { [EOL] 		String[] args = {}; [EOL] 		App.main(args); [EOL] 	} [EOL]
@Test [EOL] public void should_start_widget_live_migration() throws Exception { [EOL] workspaceInitializer.contextInitialized(); [EOL] verify(widgetRepositoryLiveUpdate).start(); [EOL] } [EOL]
@Test [EOL] public void testGetStatus() throws Exception { [EOL] String id = "application 1"; [EOL] AppDetailsController ac = Mockito.mock(AppDetailsController.class); [EOL] [EOL] Service yarnfile = new Service(); [EOL] Component comp = new Component(); [EOL] Container c = new Container(); [EOL] c.setId("container-1"); [EOL] List<Container> containers = new ArrayList<Container>(); [EOL] containers.add(c); [EOL] comp.setContainers(containers); [EOL] yarnfile.addComponent(comp); [EOL] AppEntry actual = new AppEntry(); [EOL] actual.setName(id); [EOL] actual.setYarnfile(yarnfile); [EOL] when(ac.getStatus(id)).thenReturn(actual); [EOL] final AppEntry result = ac.getStatus(id); [EOL] assertEquals(result, actual); [EOL] } [EOL]
@Test [EOL] 	public void testAllCommands() throws Exception { [EOL] [EOL] 		// Before [EOL] 		File f = TestUtils.findTestFile( "/commands/create-and-delete.commands" ); [EOL] 		CommandsExecutor executor = new CommandsExecutor( this.manager, this.app, f ); [EOL] [EOL] 		String targetId = this.manager.targetsMngr().createTarget( "id: tid\nhandler: h" ); [EOL] 		Assert.assertEquals( "tid", targetId ); [EOL] [EOL] 		List<String> instancePaths = new ArrayList<> (); [EOL] 		for( Instance inst : InstanceHelpers.getAllInstances( this.app )) [EOL] 			instancePaths.add( InstanceHelpers.computeInstancePath( inst )); [EOL] [EOL] 		int instancesCount = InstanceHelpers.getAllInstances( this.app ).size(); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat-vm" )); [EOL] [EOL] 		// Execute [EOL] 		executor.execute(); [EOL] [EOL] 		// After [EOL] 		instancePaths.clear();; [EOL] 		for( Instance inst : InstanceHelpers.getAllInstances( this.app )) [EOL] 			instancePaths.add( InstanceHelpers.computeInstancePath( inst )); [EOL] [EOL] 		Assert.assertEquals( instancesCount + 5, instancePaths.size()); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 1" )); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 1/tomcat-server" )); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 1/tomcat-server/hello-world" )); [EOL] [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 2" )); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 2/tomcat-server" )); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 2/tomcat-server/hello-world" )); [EOL] [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 3" )); [EOL] 		Assert.assertTrue( instancePaths.contains( "/tomcat 3/my-tomcat-server" )); [EOL] [EOL] 		Assert.assertFalse( instancePaths.contains( "/tomcat 3/tomcat-server/hello-world" )); [EOL] 		Assert.assertFalse( instancePaths.contains( "/tomcat 3/my-tomcat-server/hello-world" )); [EOL] 		Assert.assertFalse( instancePaths.contains( "/tomcat-vm" )); [EOL] [EOL] 		Instance instance = InstanceHelpers.findInstanceByPath( this.app, "/tomcat 1" ); [EOL] 		Assert.assertNotNull( instance ); [EOL] 		Assert.assertNull( this.manager.targetsMngr().findTargetId( this.app, "/tomcat 1" )); [EOL] [EOL] 		instance = InstanceHelpers.findInstanceByPath( this.app, "/tomcat 2" ); [EOL] 		Assert.assertNotNull( instance ); [EOL] 		Assert.assertNull( this.manager.targetsMngr().findTargetId( this.app, "/tomcat 2" )); [EOL] [EOL] 		instance = InstanceHelpers.findInstanceByPath( this.app, "/tomcat 3" ); [EOL] 		Assert.assertNotNull( instance ); [EOL] 		Assert.assertEquals( targetId, this.manager.targetsMngr().findTargetId( this.app, "/tomcat 3" )); [EOL] 	} [EOL]
@Test [EOL] 	public void testEndpointsWithoutTargetRefs() { [EOL] [EOL] 		EndpointsList endpoints = createSingleEndpointEndpointListByPodName("api-pod"); [EOL] 		endpoints.getItems().get(0).getSubsets().get(0).getAddresses().get(0).setTargetRef(null); [EOL] [EOL] 		when(this.endpointsOperation.list()).thenReturn(endpoints); [EOL] 		when(this.kubernetesClient.endpoints()).thenReturn(this.endpointsOperation); [EOL] 		when(this.kubernetesClient.endpoints().withLabels(anyMap())).thenReturn(this.endpointsOperation); [EOL] [EOL] 		this.underTest.catalogServicesWatch(); [EOL] 		// second execution on shuffleServices [EOL] 		this.underTest.catalogServicesWatch(); [EOL] [EOL] 		verify(this.applicationEventPublisher).publishEvent(any(HeartbeatEvent.class)); [EOL] 	} [EOL]
@Test [EOL] public void testRequestValidationSucceeds() { [EOL] assertTrue(getValidator().validate(new GetObjectTypeByIdRequest().setId(UUID.randomUUID())).isEmpty()); [EOL] } [EOL]
@Test [EOL] public void testCombinePaths() { [EOL] [EOL] String expected = "/1/2/3/4/5"; [EOL] [EOL] // Deal with OS differences [EOL] expected = expected.replace("/", File.separator); [EOL] [EOL] // Probably not really nice to do multiple tests at once, but they are [EOL] // almost trivial anyway.. [EOL] [EOL] Assert.assertEquals(expected, Utils.combinePaths("/1/2/3", "4/5")); [EOL] Assert.assertEquals(expected, Utils.combinePaths("/1/2", "3", "4/5")); [EOL] [EOL] } [EOL]
@Test(expected=NoSuchUserException.class) [EOL] 	public void testGetPreferencesForNonExistingUser() throws TasteException { [EOL] 		PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10); [EOL] 		// Exception is expected since such user does not exist [EOL] 		instance.getPreferencesFromUser(1); [EOL] 	} [EOL]
@Test [EOL] public void testGetAsLong() { [EOL] final long[] etalon = new long[] {-27834L & 0xFFFFL, 23423L, 0L, -2L & 0xFFFFL, 3L}; [EOL] for (int i = 0; i < etalon.length; i++) { [EOL] assertEquals(etalon[i], test.getAsLong(i)); [EOL] } [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("unchecked") [EOL] public void decorateCanInvoke() throws Exception { [EOL] BundleContext bc = setUpMocksForDecorate(); [EOL] RBACDecorator decorator = new RBACDecorator(bc); [EOL] decorator.setVerify(true); [EOL] [EOL] Map<String, Object> result = readInput(); [EOL] [EOL] LOG.info("In: {}", result); [EOL] decorator.decorate(result); [EOL] LOG.info("Out: {}", result); [EOL] [EOL] Map<String, Map<String, Object>> domains = (Map<String, Map<String, Object>>) result.get("domains"); [EOL] Map<String, Object> domain = domains.get("org.apache.activemq"); [EOL] Map<String, Object> mbean = (Map<String, Object>) domain.get("type=Broker,brokerName=amq"); [EOL] assertThat(mbean.get("canInvoke"), equalTo(false)); [EOL] [EOL] // op [EOL] Map<String, Object> op = (Map<String, Object>) mbean.get("op"); [EOL] LOG.info("op = {}", op); [EOL] assertThat(((Map<String, Object>) op.get("removeQueue")).get("canInvoke"), equalTo(false)); [EOL] assertThat(((Map<String, Object>) op.get("addQueue")).get("canInvoke"), equalTo(false)); [EOL] assertThat(((Map<String, Object>) op.get("stop")).get("canInvoke"), equalTo(true)); [EOL] assertThat(((Map<String, Object>) op.get("start")).get("canInvoke"), equalTo(true)); [EOL] assertThat(((List<Map<String, Object>>) op.get("overloadedMethod")).get(0).get("canInvoke"), equalTo(true)); [EOL] assertThat(((List<Map<String, Object>>) op.get("overloadedMethod")).get(1).get("canInvoke"), equalTo(false)); [EOL] assertThat(((List<Map<String, Object>>) op.get("overloadedMethod")).get(2).get("canInvoke"), equalTo(true)); [EOL] [EOL] // opByString [EOL] Map<String, Map<String, Boolean>> opByString = (Map<String, Map<String, Boolean>>) mbean.get("opByString"); [EOL] assertThat(opByString, notNullValue()); [EOL] LOG.info("opByString = {}", opByString); [EOL] assertThat(opByString.keySet(), containsInAnyOrder( [EOL] "removeQueue(java.lang.String)", [EOL] "addQueue(java.lang.String)", [EOL] "stop()", [EOL] "start()", [EOL] "overloadedMethod(java.lang.String)", [EOL] "overloadedMethod(java.lang.String,java.lang.Object)", [EOL] "overloadedMethod()")); [EOL] assertThat(opByString.get("removeQueue(java.lang.String)").get("canInvoke"), equalTo(false)); [EOL] assertThat(opByString.get("addQueue(java.lang.String)").get("canInvoke"), equalTo(false)); [EOL] assertThat(opByString.get("stop()").get("canInvoke"), equalTo(true)); [EOL] assertThat(opByString.get("start()").get("canInvoke"), equalTo(true)); [EOL] assertThat(opByString.get("overloadedMethod(java.lang.String)").get("canInvoke"), equalTo(true)); [EOL] assertThat(opByString.get("overloadedMethod(java.lang.String,java.lang.Object)").get("canInvoke"), equalTo(false)); [EOL] assertThat(opByString.get("overloadedMethod()").get("canInvoke"), equalTo(true)); [EOL] } [EOL]
@Test [EOL] public void testNormalize() { [EOL] Vector val = test.normalize(); [EOL] double mag = Math.sqrt(1.1 * 1.1 + 2.2 * 2.2 + 3.3 * 3.3); [EOL] for (int i = 0; i < test.size(); i++) { [EOL] if (i % 2 == 0) { [EOL] assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON); [EOL] } else { [EOL] assertEquals("dot", values[i/2] / mag, val.get(i), EPSILON); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testDeleteJob_error() throws Exception { [EOL] [EOL] 		Mockito [EOL] 			.doThrow( new IOException( "For test" )) [EOL] 			.when( this.scheduler ).deleteJob( Mockito.anyString()); [EOL] [EOL] 		Response resp = this.resource.deleteJob( "job" ); [EOL] 		Assert.assertEquals( Status.INTERNAL_SERVER_ERROR.getStatusCode(), resp.getStatus()); [EOL] 	} [EOL]
@Test [EOL] public void canFactoryProcessViewsShouldWorkWithEngineName() { [EOL] Dictionary<String, String> headers = new Hashtable<>(2); [EOL] headers.put(BundleScriptingConfigurationConstants.JAHIA_MODULE_SCRIPTING_VIEWS, "js,test,groovy"); [EOL] headers.put("color", "black"); [EOL] [EOL] assertTrue(ScriptEngineUtils.canFactoryProcessViews(new TestScriptEngineFactory(), headers)); [EOL] } [EOL]
@Test [EOL] public void testRegister() { [EOL] AuthProviderRegistry.register("apiKey", apiKeyAllAuthProvider); [EOL] AuthProviderRegistry.register("dummy", apiKeyDummyAuthProvider); [EOL] [EOL] Assert.assertEquals(2, AuthProviderRegistry.getAuthProviderFactory().getAuthProviders().size()); [EOL] [EOL] Assert.assertEquals(apiKeyAllAuthProvider, AuthProviderRegistry.getAuthProviderFactory().getAuthProviderByName("apiKey")); [EOL] [EOL] AuthProviderRegistry.clearRegistry(); [EOL] Assert.assertEquals(0, AuthProviderRegistry.getAuthProviderFactory().getAuthProviders().size()); [EOL] [EOL] TestAuthProviderFactory anotherFactory = new TestAuthProviderFactory(); [EOL] anotherFactory.register("apiKey", apiKeyAllAuthProvider); [EOL] anotherFactory.register("dummy", apiKeyDummyAuthProvider); [EOL] [EOL] AuthProviderRegistry.register(anotherFactory); [EOL] Assert.assertEquals(2, AuthProviderRegistry.getAuthProviderFactory().getAuthProviders().size()); [EOL] Assert.assertEquals(apiKeyAllAuthProvider, AuthProviderRegistry.getAuthProviderFactory().getAuthProviderByName("apiKey")); [EOL] [EOL] } [EOL]
@Test [EOL] public void handleInterfaceAnnotationShouldSetMethodsType() throws Exception { [EOL] toTest.handleInterfaceAnnotation(mockAnnotation, mockInterfaceConfigBuilder); [EOL] [EOL] verify(mockInterfaceConfigBuilder).setMethodsType(MethodType.PUT); [EOL] } [EOL]
@Test [EOL] void fromString() { [EOL] TraceID traceID = TraceID.fromString("1-57ff426a-80c11c39b0c928905eb0828d"); [EOL] assertThat(traceID.getStartTimeAsHex()).isEqualTo("57ff426a"); [EOL] assertThat(traceID.getNumberAsHex()).isEqualTo("80c11c39b0c928905eb0828d"); [EOL] } [EOL]
@Test [EOL] public void shouldSuccessfullyDeserializeStringToList() { [EOL] String jsonString = getJsonStrings(); [EOL] GsonSerializationStrategy<Cinema[]> [EOL] serializationStrategy = new GsonSerializationStrategy<>(new Gson(), Cinema[].class); [EOL] List<Cinema> cinemas = Arrays.asList(serializationStrategy.deserialize(jsonString)); [EOL] assertNotNull(cinemas); [EOL] assertEquals(1, cinemas.size()); [EOL] assertCinema(cinemas.get(0)); [EOL] } [EOL]
@Test [EOL] public void testIgnorePrivateStaticInnerClass() { [EOL] CompactFormatter cf = new CompactFormatter(); [EOL] String n = Collections.emptySet().getClass().getName(); [EOL] assertTrue(n, n.contains("$")); [EOL] [EOL] String f = n.concat(".java"); [EOL] StackTraceElement s = new StackTraceElement(n, "size", f, 20); [EOL] assertFalse(s.toString(), cf.ignore(s)); [EOL] } [EOL]
@Test public void testLabel() { [EOL] 		// Arrange: [EOL] 		final MapIntent intent = new MapIntent(); [EOL] 		// Act: [EOL] 		intent.label("Venice"); [EOL] 		// Assert: [EOL] 		assertThat(intent.label(), is("Venice")); [EOL] 	} [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] 	public void handleCallback_NullParamToken() throws IOException { [EOL] 		OAuthAuthenticateValidatorCallbackHandler loginCallbackHandler = Mockito.spy(new OAuthAuthenticateValidatorCallbackHandler()); [EOL] [EOL] 		OAuthBearerValidatorCallback oauthBearerTokenCallback = Mockito.spy(new OAuthBearerValidatorCallback("test")); [EOL] 		Mockito.doReturn(null).when(oauthBearerTokenCallback).tokenValue(); [EOL] 		loginCallbackHandler.handleCallback(oauthBearerTokenCallback); [EOL] [EOL] 	} [EOL]
@Test [EOL] public void shouldHandleDouble() { [EOL] Codec<Double> doubleCodec = mapper.codecFor(primitive(DOUBLE)); [EOL] assertThat(doubleCodec).isSameAs(mapper.cdouble); [EOL] [EOL] encodeAndDecode(doubleCodec, 0.0, "0x0000000000000000"); [EOL] encodeAndDecode(doubleCodec, 86.765309, "0x4055b0fad2999568"); [EOL] encodeAndDecode(doubleCodec, Double.MIN_VALUE, "0x0000000000000001"); [EOL] encodeAndDecode(doubleCodec, Double.MAX_VALUE, "0x7fefffffffffffff"); [EOL] encodeAndDecode(doubleCodec, null, null, 0.0); [EOL] [EOL] encodeObjectAndDecode(doubleCodec, 86.765309, "0x4055b0fad2999568", 86.765309); [EOL] // precision loss [EOL] encodeObjectAndDecode(doubleCodec, 86.765309f, "0x4055b0fae0000000", 86.76531219482422); [EOL] encodeObjectAndDecode(doubleCodec, "86.765309", "0x4055b0fad2999568", 86.765309); [EOL] encodeObjectAndDecode(doubleCodec, null, null, 0.0); [EOL] encodeObjectAndDecode(doubleCodec, Optional.of(12), null, 0.0); [EOL] [EOL] try { [EOL] // not enough bytes. [EOL] doubleCodec.decode(Bytes.fromHexString("0x00ffef")); [EOL] } catch (InvalidTypeException e) { [EOL] // expected [EOL] } [EOL] } [EOL]
@Test [EOL] public void testRequestToWhitelist() throws Exception { [EOL] final String token = new Base64(0).encodeToString(new byte[]{0, 1, 2}); [EOL] final HttpServletRequest request = Mockito.mock(HttpServletRequest.class); [EOL] final HttpServletResponse response = [EOL] Mockito.mock(HttpServletResponse.class); [EOL] Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)) [EOL] .thenReturn(KerberosAuthenticator.NEGOTIATE + token); [EOL] Mockito.when(request.getServletPath()).thenReturn("/white"); [EOL] handler.authenticate(request, response); [EOL] Mockito.when(request.getServletPath()).thenReturn("/white4"); [EOL] try { [EOL] handler.authenticate(request, response); [EOL] Assert.fail(); [EOL] } catch (AuthenticationException ex) { [EOL] // Expected [EOL] } catch (Exception ex) { [EOL] Assert.fail(); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void getEventType_Returns_EventType() { [EOL] 		final String expected = eventType; [EOL] 		final String actual = evnt.getEventType(); [EOL] 		 [EOL] 		Assert.assertEquals(actual, expected); [EOL] 	} [EOL]
@Test [EOL] public void uploadRichMenuImageTest() throws Exception { [EOL] whenCall(retrofitMock.uploadRichMenuImage(any(), any()), [EOL] null); [EOL] [EOL] // Do [EOL] final BotApiResponse botApiResponse = [EOL] target.setRichMenuImage("ID", "image/jpeg", ZERO_BYTES).get(); [EOL] [EOL] // Verify [EOL] verify(retrofitMock, only()) [EOL] .uploadRichMenuImage(eq("ID"), any()); [EOL] assertThat(botApiResponse).isEqualTo(BOT_API_SUCCESS_RESPONSE); [EOL] [EOL] } [EOL]
@Test [EOL] public void testGetSeaCloudsInformation() throws Exception { [EOL] assertNotNull(coreResource.getSeaCloudsInformation().getEntity()); [EOL] } [EOL]
@Test [EOL] public void testUsingWithObservableFactoryError() { [EOL] final Action0 unsubscribe = mock(Action0.class); [EOL] Func0<Subscription> resourceFactory = new Func0<Subscription>() { [EOL] @Override [EOL] public Subscription call() { [EOL] return Subscriptions.create(unsubscribe); [EOL] } [EOL] }; [EOL] [EOL] Func1<Subscription, Observable<Integer>> observableFactory = new Func1<Subscription, Observable<Integer>>() { [EOL] @Override [EOL] public Observable<Integer> call(Subscription subscription) { [EOL] throw new TestException(); [EOL] } [EOL] }; [EOL] [EOL] try { [EOL] Observable.create(using(resourceFactory, observableFactory)) [EOL] .toBlockingObservable().last(); [EOL] fail("Should throw a TestException when the observableFactory throws it"); [EOL] } catch (TestException e) { [EOL] // Make sure that unsubscribe is called so that users can close [EOL] // the resource if some error happens. [EOL] verify(unsubscribe, times(1)).call(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void dataPayloadPadding() { [EOL] ByteBuffer buffer = ByteBuffer.wrap(TestMessages.DATA_PAYLOAD_PADDING_BUFFER); [EOL] Http2DataFrame frame = (Http2DataFrame) decoder.decode(buffer, context); [EOL] assertNotNull(frame); [EOL] assertEquals(13, frame.getLength()); [EOL] assertEquals(0, frame.getType()); [EOL] assertEquals(0x08, frame.getFlags()); [EOL] assertEquals(50, frame.getStreamID()); [EOL] assertEquals(10, frame.getData().length); [EOL] assertArrayEquals(new byte[] {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A}, frame.getData()); [EOL] assertEquals(2, frame.getPadding().length); [EOL] assertArrayEquals(new byte[] {0x0E, 0x28}, frame.getPadding()); [EOL] } [EOL]
@Test [EOL] public void testCopyBytesShouldNotCloseStreamsWhenCloseIsFalse() [EOL] throws Exception { [EOL] InputStream inputStream = Mockito.mock(InputStream.class); [EOL] OutputStream outputStream = Mockito.mock(OutputStream.class); [EOL] Mockito.doReturn(-1).when(inputStream).read(new byte[1]); [EOL] IOUtils.copyBytes(inputStream, outputStream, 1, false); [EOL] Mockito.verify(inputStream, Mockito.atMost(0)).close(); [EOL] Mockito.verify(outputStream, Mockito.atMost(0)).close(); [EOL] } [EOL]
@Test [EOL] public void testNoDelete() throws Exception { [EOL] Random r = new Random(); [EOL] long seed = r.nextLong(); [EOL] r.setSeed(seed); [EOL] System.out.println("SEED: " + seed); [EOL] List<Path> dirs = buildDirs(r, base, 20); [EOL] createDirs(new Path("."), dirs); [EOL] FakeDefaultContainerExecutor exec = new FakeDefaultContainerExecutor(); [EOL] Configuration conf = new Configuration(); [EOL] conf.setInt(YarnConfiguration.DEBUG_NM_DELETE_DELAY_SEC, -1); [EOL] exec.setConf(conf); [EOL] DeletionService del = new DeletionService(exec); [EOL] try { [EOL] del.init(conf); [EOL] del.start(); [EOL] for (Path p : dirs) { [EOL] del.delete((Long.parseLong(p.getName()) % 2) == 0 ? null : "dingo", p, [EOL] null); [EOL] } [EOL] int msecToWait = 20 * 1000; [EOL] for (Path p : dirs) { [EOL] while (msecToWait > 0 && lfs.util().exists(p)) { [EOL] Thread.sleep(100); [EOL] msecToWait -= 100; [EOL] } [EOL] assertTrue(lfs.util().exists(p)); [EOL] } [EOL] } finally { [EOL] del.stop(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testOptional() { [EOL] assertEquals((Object) 12, INTEGER.optional().parse("12", mode)); [EOL] assertEquals(null, INTEGER.optional().parse("", mode)); [EOL] assertFailure(mode, areChars("ab").optional(), "a", 1, 2); [EOL] } [EOL]
@Test [EOL] public void testClear() { [EOL] FoldedTreeSet<String> instance = new FoldedTreeSet<>(); [EOL] instance.clear(); [EOL] assertEquals(true, instance.isEmpty()); [EOL] instance.add("apa"); [EOL] assertEquals(false, instance.isEmpty()); [EOL] instance.clear(); [EOL] assertEquals(true, instance.isEmpty()); [EOL] } [EOL]
@Test [EOL] public void testOr_8Parsers() { [EOL] Parser<Character> parser = Parsers.or( [EOL] isChar('a'), isChar('b'), isChar('c'), isChar('d'), isChar('e'), isChar('f'), isChar('g'), [EOL] isChar('h')); [EOL] assertEquals("or", parser.toString()); [EOL] assertEquals((Object) 'a', parser.parse("a", mode)); [EOL] assertEquals((Object) 'b', parser.parse("b", mode)); [EOL] assertEquals((Object) 'c', parser.parse("c", mode)); [EOL] assertEquals((Object) 'd', parser.parse("d", mode)); [EOL] assertEquals((Object) 'e', parser.parse("e", mode)); [EOL] assertEquals((Object) 'f', parser.parse("f", mode)); [EOL] assertEquals((Object) 'g', parser.parse("g", mode)); [EOL] assertEquals((Object) 'h', parser.parse("h", mode)); [EOL] assertEquals((Object) 'a', Parsers.or(areChars("ab"), isChar('b'), isChar('c'), [EOL] isChar('d'), isChar('e'), isChar('f'), isChar('g'), isChar('a')).parse("a", mode)); [EOL] } [EOL]
@Test [EOL] public void testRefreshAll() throws IOException, FlumeSpecException { [EOL] [EOL] ConfigurationManager parent = new ConfigManager(); [EOL] ConfigurationManager self = new ConfigManager(); [EOL] ConfigurationManager trans = new NullDecoTranslator(parent, self); [EOL] [EOL] trans.setConfig("foo", DEFAULTFLOW, "null", "null"); [EOL] [EOL] trans.refreshAll(); [EOL] [EOL] FlumeConfigData transData = trans.getConfig("foo"); [EOL] assertEquals("null", transData.getSourceConfig()); [EOL] assertEquals("{ nullDeco => null }", transData.getSinkConfig()); [EOL] [EOL] FlumeConfigData selfData = self.getConfig("foo"); [EOL] assertEquals("null", selfData.getSourceConfig()); [EOL] assertEquals("{ nullDeco => null }", selfData.getSinkConfig()); [EOL] [EOL] FlumeConfigData origData = parent.getConfig("foo"); [EOL] assertEquals("null", origData.getSourceConfig()); [EOL] assertEquals("null", origData.getSinkConfig()); [EOL] } [EOL]
@Test [EOL] public void testAllocateRecycle() throws Exception { [EOL] final int countThreshold = 4; [EOL] final int countLimit = 8; [EOL] final long countResetTimePeriodMs = 200L; [EOL] final ByteArrayManager.Impl bam = new ByteArrayManager.Impl( [EOL] new ByteArrayManager.Conf( [EOL] countThreshold, countLimit, countResetTimePeriodMs)); [EOL] [EOL] final CounterMap counters = bam.getCounters(); [EOL] final ManagerMap managers = bam.getManagers(); [EOL] [EOL] final int[] uncommonArrays = {0, 1, 2, 4, 8, 16, 32, 64}; [EOL] final int arrayLength = 1024; [EOL] [EOL] [EOL] final Allocator allocator = new Allocator(bam); [EOL] final Recycler recycler = new Recycler(bam); [EOL] try { [EOL] { // allocate within threshold [EOL] for(int i = 0; i < countThreshold; i++) { [EOL] allocator.submit(arrayLength); [EOL] } [EOL] waitForAll(allocator.futures); [EOL] [EOL] Assert.assertEquals(countThreshold, [EOL] counters.get(arrayLength, false).getCount()); [EOL] Assert.assertNull(managers.get(arrayLength, false)); [EOL] for(int n : uncommonArrays) { [EOL] Assert.assertNull(counters.get(n, false)); [EOL] Assert.assertNull(managers.get(n, false)); [EOL] } [EOL] } [EOL] [EOL] { // recycle half of the arrays [EOL] for(int i = 0; i < countThreshold/2; i++) { [EOL] recycler.submit(removeLast(allocator.futures)); [EOL] } [EOL] [EOL] for(Future<Integer> f : recycler.furtures) { [EOL] Assert.assertEquals(-1, f.get().intValue()); [EOL] } [EOL] recycler.furtures.clear(); [EOL] } [EOL] [EOL] { // allocate one more [EOL] allocator.submit(arrayLength).get(); [EOL] [EOL] Assert.assertEquals(countThreshold + 1, counters.get(arrayLength, false).getCount()); [EOL] Assert.assertNotNull(managers.get(arrayLength, false)); [EOL] } [EOL] [EOL] { // recycle the remaining arrays [EOL] final int n = allocator.recycleAll(recycler); [EOL] [EOL] recycler.verify(n); [EOL] } [EOL] [EOL] { [EOL] // allocate until the maximum. [EOL] for(int i = 0; i < countLimit; i++) { [EOL] allocator.submit(arrayLength); [EOL] } [EOL] waitForAll(allocator.futures); [EOL] [EOL] // allocate one more should be blocked [EOL] final AllocatorThread t = new AllocatorThread(arrayLength, bam); [EOL] t.start(); [EOL] [EOL] // check if the thread is waiting, timed wait or runnable. [EOL] for(int i = 0; i < 5; i++) { [EOL] Thread.sleep(100); [EOL] final Thread.State threadState = t.getState(); [EOL] if (threadState != Thread.State.RUNNABLE [EOL] && threadState != Thread.State.WAITING [EOL] && threadState != Thread.State.TIMED_WAITING) { [EOL] Assert.fail("threadState = " + threadState); [EOL] } [EOL] } [EOL] [EOL] // recycle an array [EOL] recycler.submit(removeLast(allocator.futures)); [EOL] Assert.assertEquals(1, removeLast(recycler.furtures).intValue()); [EOL] [EOL] // check if the thread is unblocked [EOL] Thread.sleep(100); [EOL] Assert.assertEquals(Thread.State.TERMINATED, t.getState()); [EOL] [EOL] // recycle the remaining, the recycle should be full. [EOL] Assert.assertEquals(countLimit-1, allocator.recycleAll(recycler)); [EOL] recycler.submit(t.array); [EOL] recycler.verify(countLimit); [EOL] [EOL] // recycle one more; it should not increase the free queue size [EOL] Assert.assertEquals(countLimit, bam.release(new byte[arrayLength])); [EOL] } [EOL] } finally { [EOL] allocator.pool.shutdown(); [EOL] recycler.pool.shutdown(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testParseAndPrintLayout() throws Exception { [EOL] // This test deliberately exposes that we presently do not dig into the inside of layout [EOL] // qualifiers. When we do, we will ditch this test and replace it with some tests that [EOL] // check we are handling the internals properly. [EOL] final String program = "" [EOL] + "layout(location = 0) out vec4 color;\n\n" [EOL] + "layout(anything=3, we, like=4, aswearenotyethandlingtheinternals) out vec2 blah;\n\n" [EOL] + "void main()\n" [EOL] + "{\n" [EOL] + "}\n"; [EOL] assertEquals(program, PrettyPrinterVisitor.prettyPrintAsString(ParseHelper.parse(program [EOL] ))); [EOL] } [EOL]
@Test [EOL] public void testArraySizeExpressionInParameter() throws Exception { [EOL] final String program = "" [EOL] + "void foo(int A[3 + 4])\n" [EOL] + "{\n" [EOL] + "}\n" [EOL] + "void main()\n" [EOL] + "{\n" [EOL] + " int a[7];\n" [EOL] + " foo(a);\n" [EOL] + "}\n"; [EOL] assertEquals(program, PrettyPrinterVisitor.prettyPrintAsString(ParseHelper.parse(program [EOL] ))); [EOL] } [EOL]
@Test [EOL] public void testSetHideColumn() throws Exception { [EOL] final boolean hideColumn = false; [EOL] [EOL] plugin.setHideColumn(hideColumn); [EOL] [EOL] verify(editingWrapper).setHideColumn(hideColumn); [EOL] } [EOL]
@Test [EOL] public void testRelate_polygon_polygon_false() throws FactoryException, MismatchedDimensionException, TransformException { [EOL] [EOL] [EOL] GeometryWrapper subjectGeometryWrapper = GeometryWrapper.extract(ResourceFactory.createTypedLiteral("<http://www.opengis.net/def/crs/EPSG/0/27700> POLYGON((80 15, 80 45, 140 45, 140 15, 80 15))", WKTDatatype.INSTANCE)); [EOL] GeometryWrapper objectGeometryWrapper = GeometryWrapper.extract(ResourceFactory.createTypedLiteral("<http://www.opengis.net/def/crs/EPSG/0/27700> POLYGON((140 15, 140 45, 200 45, 200 15, 140 15))", WKTDatatype.INSTANCE)); [EOL] [EOL] RccNonTangentialProperPartFF instance = new RccNonTangentialProperPartFF(); [EOL] [EOL] Boolean expResult = false; [EOL] Boolean result = instance.relate(subjectGeometryWrapper, objectGeometryWrapper); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test [EOL] public void testNewListBox() { [EOL] final ListBox listBox = page.newListBox(); [EOL] [EOL] assertNotNull(listBox); [EOL] } [EOL]
@Test [EOL] public void testBinarySearch() [EOL] { [EOL] long a[] = new long[] [EOL] { [EOL] 9, 53, 100 [EOL] }; [EOL] assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 3, 50)); [EOL] assertEquals(~2, SparseLongLongArray.binarySearch(a, 0, 3, 55)); [EOL] assertEquals(~3, SparseLongLongArray.binarySearch(a, 0, 3, 155)); [EOL] [EOL] a = new long[] [EOL] { [EOL] 9 [EOL] }; [EOL] assertEquals(~0, SparseLongLongArray.binarySearch(a, 0, 1, 5)); [EOL] assertEquals(~1, SparseLongLongArray.binarySearch(a, 0, 1, 50)); [EOL] } [EOL]
@Test [EOL] 	public void testIsProviderCombomatch_alldiffpermittedto(){ [EOL] 		//Arrange [EOL] 		Consent consent = new Consent(); [EOL] 		 [EOL] 		setConsentProvidersMatchData(consent); [EOL] 		 [EOL] 		// providers Permitted to disclose [EOL] 		Set<String> selIsMadeToNpi = new HashSet<String>(); [EOL] 		selIsMadeToNpi.add("12312314"); [EOL] 		// organizations Permitted to disclose [EOL] 		Set<String> selIsMadeToOrgNpi = new HashSet<String>(); [EOL] 		selIsMadeToOrgNpi.add("5757556756"); [EOL] 		 [EOL] 		selIsMadeToNpi.addAll(selIsMadeToOrgNpi); [EOL] 		 [EOL] 		consentDto.setProvidersPermittedToDisclose(selIsMadeToNpi); [EOL] 		 [EOL] 		// providers to disclose [EOL] 		Set<String> selToDiscloseNpi = new HashSet<String>(); [EOL] 		selToDiscloseNpi.add("1346575297"); [EOL] 		// organizations to disclose [EOL] 		Set<String> selToDiscloseOrgNpi = new HashSet<String>(); [EOL] 		selToDiscloseOrgNpi.add("1174858088"); [EOL] 		 [EOL] 		selToDiscloseNpi.addAll(selToDiscloseOrgNpi); [EOL] 		 [EOL] 		consentDto.setProvidersDisclosureIsMadeTo(selToDiscloseNpi); [EOL] [EOL] 		//Act [EOL] 		boolean isProviderComboMatch = cst.isProviderComboMatch(consent, consentDto); [EOL] 		 [EOL] 		 [EOL] 		//Assert [EOL] 		assertEquals(isProviderComboMatch, false);			 [EOL] 		 [EOL] 	} [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testSignatureParamCreationFromNoHexString() { [EOL] String sig = "d8485d4771e9112cca6ac7e6b75fc52585t2e7ee9a702db4a39dfad0f888ea6c22b6185ceab" + [EOL] "38d8322b67737a5574d8b63f4e27b0d208f3f9efcdbf56093f213"; [EOL] ContractParameter.signature(sig); [EOL] } [EOL]
@Test [EOL] public void testBadDataFollowedByGoodData() throws ParseException { [EOL] [EOL] Attribute attribute = [EOL] new AttributeImpl( [EOL] FIELD, [EOL] Arrays.asList( [EOL] "POLYGON (( x 0, 10 0, 10 10, 0 10, 0 0))", [EOL] "POLYGON (( 5 5, 15 5, 15 15, 5 15, 5 5))")); [EOL] [EOL] Optional<String> optionalWkt = [EOL] GeometryUtility.createUnionOfGeometryAttribute( [EOL] wktReader, wktWriter, attribute, new GeometryOperator.Context()); [EOL] [EOL] Geometry actual = wktReader.read(optionalWkt.get()).norm(); [EOL] [EOL] Geometry expected = wktReader.read("POLYGON (( 5 5, 15 5, 15 15, 5 15, 5 5))").norm(); [EOL] [EOL] assertThat(actual, is(expected)); [EOL] } [EOL]
@Test [EOL] public void testLoadNonExistentSession() throws Exception { [EOL] when(datastore.run(any())).thenReturn(new IteratorQueryResults<>(Collections.emptyIterator())); [EOL] [EOL] Session session = store.load("456"); [EOL] verify(manager, never()).createEmptySession(); [EOL] assertNull(session); [EOL] } [EOL]
@Test [EOL] public void testJmx() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, [EOL] InvocationTargetException { [EOL] try { [EOL] Monitor.main(new String[]{"-ss", "-si", "10", "-main", [EOL] MonitorTest.class.getName()}); [EOL] } catch (ExitException ex) { [EOL] Assert.assertEquals(0, ex.getExitCode()); [EOL] } [EOL] } [EOL]
@Test public void testCaptureEndValues() { [EOL] 		// Arrange: [EOL] 		final int[] mockLocationOnScreen = new int[]{100, 300}; [EOL] 		final View mockView = new View(context) { [EOL] [EOL] 			@Override public void getLocationOnScreen(@Size(value = 2) final int[] outLocation) { [EOL] 				outLocation[0] = mockLocationOnScreen[0]; [EOL] 				outLocation[1] = mockLocationOnScreen[1]; [EOL] 			} [EOL] 		}; [EOL] 		final TransitionValues values = new TransitionValues(); [EOL] 		values.view = mockView; [EOL] 		final Translate translate = new Translate(); [EOL] 		// Act: [EOL] 		translate.captureEndValues(values); [EOL] 		// Assert: [EOL] 		final int[] locationOnScreen = (int[]) values.values.get(Translate.PROPERTY_TRANSITION_LOCATION_ON_SCREEN); [EOL] 		assertThat(locationOnScreen, is(notNullValue())); [EOL] 		assertThat(locationOnScreen.length, is(2)); [EOL] 		assertThat(locationOnScreen[0], is(mockLocationOnScreen[0])); [EOL] 		assertThat(locationOnScreen[1], is(mockLocationOnScreen[1])); [EOL] 	} [EOL]
@Test [EOL] public void testIllegalNameOnlyNull() throws Exception { [EOL] ByteBuf headerBlock = Unpooled.buffer(18); [EOL] headerBlock.writeInt(1); [EOL] headerBlock.writeInt(1); [EOL] headerBlock.writeByte(0); [EOL] headerBlock.writeInt(5); [EOL] headerBlock.writeBytes(valueBytes); [EOL] decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame); [EOL] [EOL] assertFalse(headerBlock.isReadable()); [EOL] assertTrue(frame.isInvalid()); [EOL] assertEquals(0, frame.headers().names().size()); [EOL] headerBlock.release(); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testInvalidRuleMechanism() throws Exception { [EOL] KerberosName.setRuleMechanism("INVALID_MECHANISM"); [EOL] } [EOL]
@Test [EOL] public void findBestSampleSize() { [EOL] // desired == actual == 1 [EOL] assertEquals(1, ImageRequest.findBestSampleSize(100, 150, 100, 150)); [EOL] [EOL] // exactly half == 2 [EOL] assertEquals(2, ImageRequest.findBestSampleSize(280, 160, 140, 80)); [EOL] [EOL] // just over half == 1 [EOL] assertEquals(1, ImageRequest.findBestSampleSize(1000, 800, 501, 401)); [EOL] [EOL] // just under 1/4 == 4 [EOL] assertEquals(4, ImageRequest.findBestSampleSize(100, 200, 24, 50)); [EOL] } [EOL]
@Test [EOL] public void testReplaceLabelsOnNode() throws Exception { [EOL] // Successfully replace labels [EOL] dummyNodeLabelsManager.addToCluserNodeLabels(ImmutableSet.of("x", "y")); [EOL] String[] args = [EOL] { "-replaceLabelsOnNode", "node1,x node2,y", [EOL] "-directlyAccessNodeLabelStore" }; [EOL] assertEquals(0, rmAdminCLI.run(args)); [EOL] assertTrue(dummyNodeLabelsManager.getNodeLabels().containsKey( [EOL] NodeId.newInstance("node1", 0))); [EOL] assertTrue(dummyNodeLabelsManager.getNodeLabels().containsKey( [EOL] NodeId.newInstance("node2", 0))); [EOL] [EOL] // no labels, should fail [EOL] args = new String[] { "-replaceLabelsOnNode" }; [EOL] assertTrue(0 != rmAdminCLI.run(args)); [EOL] [EOL] // no labels, should fail [EOL] args = [EOL] new String[] { "-replaceLabelsOnNode", [EOL] "-directlyAccessNodeLabelStore" }; [EOL] assertTrue(0 != rmAdminCLI.run(args)); [EOL] } [EOL]
@Test [EOL] public void testSoliditySha3MultipleArguments() { [EOL] [EOL] String sha3Hash = null; [EOL] [EOL] try { [EOL] sha3Hash = new SoliditySha3().soliditySha3( [EOL] new JSONObject("{ t: 'bytes', v: '0x19' }"), [EOL] new JSONObject("{ t: 'bytes', v: '0x00' }"), [EOL] new JSONObject("{ t: 'address', v: '0x5a85a1e5a749a76ddf378ec2a0a2ac310ca86ba8' }"), [EOL] new JSONObject("{ t: 'address', v: '0xf281e85a0b992efa5fda4f52b35685dc5ee67bea' }"), [EOL] new JSONObject("{ t: 'uint8', v: '1' }"), [EOL] new JSONObject("{ t: 'bytes', v:'0x70de87124c30996cba71d1ee38150c289d019c50d7cfeb71c6b3194e9cfda5c9' }"), [EOL] new JSONObject("{ t: 'uint256', v: '1' }"), [EOL] new JSONObject("{ t: 'uint8', v: '0' }"), [EOL] new JSONObject("{ t: 'uint8', v: '0' }"), [EOL] new JSONObject("{ t: 'uint8', v: '0' }"), [EOL] new JSONObject("{ t: 'bytes4', v: '0x' }"), [EOL] new JSONObject("{ t: 'uint8', v: '0' }"), [EOL] new JSONObject("{ t: 'bytes32', v: '0x00' }") [EOL] ); [EOL] } catch (Exception e) { [EOL] e.printStackTrace(); [EOL] } [EOL] [EOL] assertEquals(MSG_HASH, sha3Hash); [EOL] } [EOL]
@Test [EOL] public void testNullItem() throws Exception { [EOL] String itemKey = "item"; [EOL] final String expr = itemKey + ".other.name"; [EOL] try { [EOL] final TestObj item = new TestObj(); [EOL] final Map<String, Object> model = Collections.<String, Object>singletonMap(itemKey, item); [EOL] final TRenderContext context = new TRenderContext(new ByteArrayOutputStream(), model); [EOL] context.getModelValue(expr); [EOL] fail("Expected an exception"); [EOL] } catch (TemplateException e) { [EOL] assertTrue(e.getMessage(), e.getMessage().contains(expr)); [EOL] assertTrue(e.getMessage(), e.getMessage().contains("value of the property")); [EOL] assertTrue(e.getMessage(), e.getMessage().contains("is null")); [EOL] } [EOL] } [EOL]
@Test [EOL] void getOrComputeSlow() throws InterruptedException { [EOL] final LongCache<String> lc = new LongCache<>(10); [EOL] Thread t1 = new Thread(() -> lc.getOrCompute("t1", () -> { [EOL] pause(1000); [EOL] return 1L; [EOL] })); [EOL] [EOL] t1.start(); [EOL] pause(100); [EOL] lc.getOrCompute("main", () -> 2L); [EOL] t1.join(); [EOL] } [EOL]
@Test [EOL] public void onEditTabSelected() { [EOL] presenterSpy.onEditTabSelected(); [EOL] InOrder inOrder = inOrder(presenterSpy, scenarioGridWidgetSpy, backgroundGridWidgetSpy); [EOL] inOrder.verify(presenterSpy, times(1)).setItemMenuEnabled(eq(true)); [EOL] inOrder.verify(presenterSpy, times(1)).populateRightDocks(eq(TestToolsPresenter.IDENTIFIER)); [EOL] inOrder.verify(scenarioGridWidgetSpy, times(1)).selectAndFocus(); [EOL] inOrder.verify(backgroundGridWidgetSpy, times(1)).deselectAndUnFocus(); [EOL] } [EOL]
@Test [EOL] public void onExecutorAdded() { [EOL] TriConsumer<Long, Header, Object> handlerMock = mock(TriConsumer.class); [EOL] SparkListener listener = new GarmadonSparkListener(handlerMock, DUMMY_HEADER.toSerializeHeader()); [EOL] [EOL] listener.onExecutorAdded(new SparkListenerExecutorAdded(1, "invokationExecutorId", [EOL] new ExecutorInfo("infoHost", 12, new HashMap<>()))); [EOL] checkExecutorEventHeader(handlerMock, DUMMY_HEADER.cloneAndOverride(Header.newBuilder() [EOL] .withExecutorId("invokationExecutorId").build())); [EOL] } [EOL]
@Test [EOL] 	public void getDescription_Returns_Description() { [EOL] 		final String expected = description; [EOL] 		final String actual = evnt.getDescription(); [EOL] 		 [EOL] 		Assert.assertEquals(actual, expected); [EOL] 	} [EOL]
@Test [EOL] 	public void testGetPIXUpdateReqObject_by_ValidDomainXMLFile() [EOL] 			throws JAXBException, IOException { [EOL] 		// Arrange [EOL] 		// PRPAIN201301UV02 pRPAIN201301UV02Mock = mock(PRPAIN201301UV02.class); [EOL] 		String expectedItVersion = "XML_1.0"; [EOL] 		String expectedFirstName = "WILMA"; [EOL] [EOL] 		// Act [EOL] 		PRPAIN201302UV02 pRPAIN201302UV02 = cstl.getPIXUpdateReqObject( [EOL] 				"xml/PRPA_IN201302UV02_PIXUpdate_Addr_Req.xml", encodeString); [EOL] 		String actualItversion = pRPAIN201302UV02.getITSVersion(); [EOL] 		JXPathContext context = JXPathContext.newContext(pRPAIN201302UV02); [EOL] 		String actualFirstName = (String) context [EOL] 				.getValue("controlActProcess/subject[1]/registrationEvent/subject1/patient/patientPerson/value/name[1]/content[2]/value/content"); [EOL] [EOL] 		// Assert [EOL] 		assertEquals(expectedItVersion, actualItversion); [EOL] 		assertEquals(expectedFirstName, actualFirstName); [EOL] 	} [EOL]
@Test [EOL] public void testToSnapshotHumanReadable() { [EOL] long snapshotLength = Long.MAX_VALUE; [EOL] long snapshotFileCount = 222222222; [EOL] long snapshotDirectoryCount = 33333; [EOL] long snapshotSpaceConsumed = 222256578; [EOL] [EOL] ContentSummary contentSummary = new ContentSummary.Builder() [EOL] .snapshotLength(snapshotLength).snapshotFileCount(snapshotFileCount) [EOL] .snapshotDirectoryCount(snapshotDirectoryCount) [EOL] .snapshotSpaceConsumed(snapshotSpaceConsumed).build(); [EOL] String expected = [EOL] " 8.0 E 211.9 M 32.6 K " [EOL] + " 212.0 M "; [EOL] assertEquals(expected, contentSummary.toSnapshot(true)); [EOL] } [EOL]
@Test [EOL] public void testNotDestroyViewModelOnConfigurationChange() { [EOL] activityDelegate.viewModel = viewModel; [EOL] when(activity.isChangingConfigurations()).thenReturn(true); [EOL] activityDelegate.onRetainCustomNonConfigurationInstance(); [EOL] verify(viewModel, never()).onDestroy(); [EOL] } [EOL]
@Test [EOL] public void testNamePatternEnvironmentInvalidTruncation_3() { [EOL] expectedException.expect(IllegalArgumentException.class); [EOL] expectedException.expectMessage(is("the token '%env:abc[,%' (position 4 to 14) has invalid " [EOL] + "configuration: it must match the '(?:(\\w+)(?:\\[(\\d+)?,(\\d+)?])?)?' pattern")); [EOL] [EOL] HeapDumpNameFormatter.validate("hda_%env:abc[,%.hprof"); [EOL] } [EOL]
@Test [EOL] 	public void testRetryCancellation() throws Exception { [EOL] 		final int retries = 10; [EOL] 		final AtomicInteger atomicInteger = new AtomicInteger(0); [EOL] 		final OneShotLatch notificationLatch = new OneShotLatch(); [EOL] 		final OneShotLatch waitLatch = new OneShotLatch(); [EOL] 		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null); [EOL] [EOL] 		CompletableFuture<?> retryFuture = FutureUtils.retry( [EOL] 			() -> [EOL] 				CompletableFuture.supplyAsync( [EOL] 					() -> { [EOL] 						if (atomicInteger.incrementAndGet() == 2) { [EOL] 							notificationLatch.trigger(); [EOL] 							try { [EOL] 								waitLatch.await(); [EOL] 							} catch (InterruptedException e) { [EOL] 								atomicThrowable.compareAndSet(null, e); [EOL] 							} [EOL] 						} [EOL] [EOL] 						throw new CompletionException(new FlinkException("Test exception")); [EOL] 					}, [EOL] 					TestingUtils.defaultExecutor()), [EOL] 			retries, [EOL] 			TestingUtils.defaultExecutor()); [EOL] [EOL] 		// await that we have failed once [EOL] 		notificationLatch.await(); [EOL] [EOL] 		assertFalse(retryFuture.isDone()); [EOL] [EOL] 		// cancel the retry future [EOL] 		retryFuture.cancel(false); [EOL] [EOL] 		// let the retry operation continue [EOL] 		waitLatch.trigger(); [EOL] [EOL] 		assertTrue(retryFuture.isCancelled()); [EOL] 		assertEquals(2, atomicInteger.get()); [EOL] [EOL] 		if (atomicThrowable.get() != null) { [EOL] 			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get()); [EOL] 		} [EOL] 	} [EOL]
@Test [EOL] public void testSingleSubpolygon() throws ParseException { [EOL] [EOL] String wkt = "POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))"; [EOL] [EOL] WKTReader wktReader = new WKTReader(); [EOL] [EOL] Geometry geometry = wktReader.read(wkt); [EOL] [EOL] Geometry actual = convertSubpolygonsToEnvelopes.apply(geometry, new GeometryOperator.Context()); [EOL] [EOL] assertThat(actual, is(geometry)); [EOL] } [EOL]
@Test [EOL] public void match2() { [EOL] CompletionMatcher matcher = new FuzzyMatcher("Map"); [EOL] ClassIndex c = new ClassIndex("MallocParser", Collections.emptyList(), Collections.emptyList()); [EOL] boolean b = matcher.match(c); [EOL] assertTrue(b); [EOL] [EOL] c = new ClassIndex("AbstractMap", Collections.emptyList(), Collections.emptyList()); [EOL] b = matcher.match(c); [EOL] assertFalse(b); [EOL] [EOL] matcher = new FuzzyMatcher("Map", true, null); [EOL] b = matcher.match(c); [EOL] assertTrue(b); [EOL] } [EOL]
@Test [EOL] public void testToMultimapWithCollectionFactory() { [EOL] Observable<String> source = Observable.from("cc", "dd", "eee", "eee"); [EOL] [EOL] Func1<Integer, Collection<String>> collectionFactory = new Func1<Integer, Collection<String>>() { [EOL] [EOL] @Override [EOL] public Collection<String> call(Integer t1) { [EOL] if (t1 == 2) { [EOL] return new ArrayList<String>(); [EOL] } else { [EOL] return new HashSet<String>(); [EOL] } [EOL] } [EOL] }; [EOL] [EOL] Observable<Map<Integer, Collection<String>>> mapped = Observable.create( [EOL] OperationToMultimap.toMultimap( [EOL] source, lengthFunc, Functions.<String> identity(), [EOL] new DefaultToMultimapFactory<Integer, String>(), collectionFactory)); [EOL] [EOL] Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); [EOL] expected.put(2, Arrays.asList("cc", "dd")); [EOL] expected.put(3, new HashSet<String>(Arrays.asList("eee"))); [EOL] [EOL] mapped.subscribe(objectObserver); [EOL] [EOL] verify(objectObserver, never()).onError(any(Throwable.class)); [EOL] verify(objectObserver, times(1)).onNext(expected); [EOL] verify(objectObserver, times(1)).onCompleted(); [EOL] } [EOL]
@Test [EOL] public void traverse_many() throws PersistenceException, AecuException { [EOL] List<Resource> results = new ArrayList<>(); [EOL] for (int i = 0; i < 1500; i++) { [EOL] results.add(resource); [EOL] } [EOL] when(resolver.findResources(QUERY, TYPE)).thenReturn(results.iterator()); [EOL] ForQuery traverser = new ForQuery(QUERY, TYPE); [EOL] [EOL] traverser.traverse(context, null, actions, output, false); [EOL] [EOL] verify(action, times(1500)).doAction(resource); [EOL] verify(resolver, times(1)).commit(); [EOL] } [EOL]
@Test [EOL] public void testRdef02() throws Exception { [EOL] Xsd2AvroTranslator cob2Avro = new Xsd2AvroTranslator(); [EOL] Map<String, String> mapSchemas = cob2Avro.translate(new File( [EOL] TEST_XSD_FOLDER, "rdef02.xsd"), "legstar.avro.test"); [EOL] assertEquals(1, mapSchemas.size()); [EOL] check(mapSchemas.get("rdef02"), "rdef02.avsc"); [EOL] checkSchema(mapSchemas.get("rdef02"), 3); [EOL] } [EOL]
@Test [EOL] public void testGetVCores() { [EOL] [EOL] ResourceCalculatorPlugin plugin = new TestResourceCalculatorPlugin(); [EOL] YarnConfiguration conf = new YarnConfiguration(); [EOL] [EOL] conf.setFloat(YarnConfiguration.NM_PCORES_VCORES_MULTIPLIER, 1.25f); [EOL] [EOL] int ret = NodeManagerHardwareUtils.getVCores(plugin, conf); [EOL] Assert.assertEquals(YarnConfiguration.DEFAULT_NM_VCORES, ret); [EOL] [EOL] conf.setBoolean(YarnConfiguration.NM_ENABLE_HARDWARE_CAPABILITY_DETECTION, [EOL] true); [EOL] ret = NodeManagerHardwareUtils.getVCores(plugin, conf); [EOL] Assert.assertEquals(5, ret); [EOL] [EOL] conf.setBoolean(YarnConfiguration.NM_COUNT_LOGICAL_PROCESSORS_AS_CORES, [EOL] true); [EOL] ret = NodeManagerHardwareUtils.getVCores(plugin, conf); [EOL] Assert.assertEquals(10, ret); [EOL] [EOL] conf.setInt(YarnConfiguration.NM_VCORES, 10); [EOL] ret = NodeManagerHardwareUtils.getVCores(plugin, conf); [EOL] Assert.assertEquals(10, ret); [EOL] [EOL] YarnConfiguration conf1 = new YarnConfiguration(); [EOL] conf1.setBoolean(YarnConfiguration.NM_ENABLE_HARDWARE_CAPABILITY_DETECTION, [EOL] false); [EOL] conf.setInt(YarnConfiguration.NM_VCORES, 10); [EOL] ret = NodeManagerHardwareUtils.getVCores(plugin, conf); [EOL] Assert.assertEquals(10, ret); [EOL] } [EOL]
@Test [EOL] void testClean() throws IOException { [EOL] final String repoDir = FileUtil.getCanonicalPath(Files.createTempDirectory("stroom").resolve("repo2")); [EOL] [EOL] StroomZipRepository stroomZipRepository = new StroomZipRepository(repoDir, null, false, 10000, 0, false); [EOL] [EOL] StroomZipOutputStreamImpl out1; [EOL] try (final StroomZipOutputStreamImpl out = (StroomZipOutputStreamImpl) stroomZipRepository.getStroomZipOutputStream()) { [EOL] StroomZipOutputStreamUtil.addSimpleEntry(out, new StroomZipEntry(null, "file", StroomZipFileType.Data), [EOL] "SOME_DATA".getBytes(CharsetConstants.DEFAULT_CHARSET)); [EOL] assertThat(Files.isRegularFile(out.getFile())).isFalse(); [EOL] out1 = out; [EOL] } [EOL] assertThat(Files.isRegularFile(out1.getFile())).isTrue(); [EOL] [EOL] final StroomZipOutputStreamImpl out2 = (StroomZipOutputStreamImpl) stroomZipRepository.getStroomZipOutputStream(); [EOL] StroomZipOutputStreamUtil.addSimpleEntry(out2, new StroomZipEntry(null, "file", StroomZipFileType.Data), [EOL] "SOME_DATA".getBytes(CharsetConstants.DEFAULT_CHARSET)); [EOL] assertThat(Files.isRegularFile(out2.getFile())).isFalse(); [EOL] assertThat(Files.isRegularFile(out2.getLockFile())).isTrue(); [EOL] [EOL] // Leave open [EOL] [EOL] stroomZipRepository = new StroomZipRepository(repoDir, null, false, 1000, 0, false); [EOL] assertThat(Files.isRegularFile(out1.getFile())).as("Expecting pucker file to be left").isTrue(); [EOL] assertThat(Files.isRegularFile(out2.getLockFile())).as("Expecting lock file to not be deleted").isTrue(); [EOL] [EOL] final StroomZipOutputStreamImpl out3 = (StroomZipOutputStreamImpl) stroomZipRepository.getStroomZipOutputStream(); [EOL] StroomZipOutputStreamUtil.addSimpleEntry(out3, new StroomZipEntry(null, "file", StroomZipFileType.Data), [EOL] "SOME_DATA".getBytes(CharsetConstants.DEFAULT_CHARSET)); [EOL] final Path lockFile3 = out3.getLockFile(); [EOL] assertThat(Files.isRegularFile(lockFile3)).isTrue(); [EOL] [EOL] stroomZipRepository.clean(true); [EOL] assertThat(Files.isRegularFile(lockFile3)).isTrue(); [EOL] [EOL] try { [EOL] Files.setLastModifiedTime(lockFile3, FileTime.fromMillis(System.currentTimeMillis() - (48 * 60 * 60 * 1000))); [EOL] } catch (final RuntimeException e) { [EOL] fail("Unable to set LastModified"); [EOL] } [EOL] stroomZipRepository.clean(true); [EOL] assertThat(Files.isRegularFile(lockFile3)).as("Expecting old lock file to be deleted").isFalse(); [EOL] } [EOL]
@Test [EOL] public void testTextFormatArg() throws RecognitionException, FlumeSpecException { [EOL] String s = "text(\"filename\", raw)"; [EOL] TextFileSink snk = (TextFileSink) FlumeBuilder.buildSink(new Context(), s); [EOL] assertTrue(snk.getFormat() instanceof RawOutputFormat); [EOL] [EOL] s = "text(\"filename\", avrodata)"; [EOL] snk = (TextFileSink) FlumeBuilder.buildSink(new Context(), s); [EOL] assertTrue(snk.getFormat() instanceof AvroDataFileOutputFormat); [EOL] [EOL] s = "text(\"filename\", avrojson)"; [EOL] snk = (TextFileSink) FlumeBuilder.buildSink(new Context(), s); [EOL] assertTrue(snk.getFormat() instanceof AvroJsonOutputFormat); [EOL] [EOL] s = "text(\"filename\", seqfile)"; [EOL] snk = (TextFileSink) FlumeBuilder.buildSink(new Context(), s); [EOL] assertTrue(snk.getFormat() instanceof SequenceFileOutputFormat); [EOL] } [EOL]
@Test [EOL] public void getAudienceData() throws Exception { [EOL] final GetAudienceDataResponse response = GetAudienceDataResponse [EOL] .builder() [EOL] .build(); [EOL] whenCall(retrofitMock.getAudienceData(anyLong()), response); [EOL] final GetAudienceDataResponse actual = [EOL] target.getAudienceData(4649L).get(); [EOL] verify(retrofitMock, only()).getAudienceData(4649L); [EOL] assertThat(actual).isEqualTo(response); [EOL] } [EOL]
@Test [EOL] public void transfersShouldShowSystemMessageWithBothActiveSenderAndReceiver() { [EOL] final FileSender fileSender = createFileSender(1, "image1.png", 501L, 11, 81L, "Amber"); [EOL] when(transferList.getFileSenders()).thenReturn(Arrays.asList(fileSender)); [EOL] [EOL] final FileReceiver fileReceiver = createFileReceiver(2, "image2.png", 502L, 12, 82L, "Donna"); [EOL] when(transferList.getFileReceivers()).thenReturn(Arrays.asList(fileReceiver)); [EOL] [EOL] parser.parse("/transfers"); [EOL] [EOL] verify(messageController).showSystemMessage("File transfers:\n" + [EOL] "- Sending:\n" + [EOL] " #1 image1.png [501.00KB] (11%, 81.00KB/s) to Amber\n" + [EOL] "- Receiving:\n" + [EOL] " #2 image2.png [502.00KB] (12%, 82.00KB/s) from Donna"); [EOL] } [EOL]
@Test [EOL] public void multipleWhereWithTwoValuesInSliceTest() throws QueryBuilderException { [EOL] // GIVEN [EOL] UiAnalysis analysis = createAnalysis("select a, count() group by a order by a asc", null, Arrays.asList( [EOL] new UiSliceDisjunction("a", Arrays.asList("5", "6")), new UiSliceDisjunction("b", Arrays.asList("3", "4")))); [EOL] [EOL] // WHEN [EOL] String queryBuilderDiql = generateQueryBuilder(analysis).build(); [EOL] ExecutionRequest queryBuilderRequest = parse(queryBuilderDiql); [EOL] [EOL] // THEN [EOL] String expectedDiql = [EOL] "select a, count() from " + TABLE + " where (a = 5 or a = 6) and (b = 3 or b = 4) group by a order by a asc"; [EOL] ExecutionRequest expectedRequest = parse(expectedDiql); [EOL] [EOL] Assert.assertEquals(queryBuilderRequest, expectedRequest, [EOL] "Built query found to be not equal to the genrated one. Expected: '" + expectedDiql + "' but was '" [EOL] + queryBuilderDiql + "'"); [EOL] } [EOL]
@Test [EOL] public void wrongReadPreferenceTest() { [EOL] Map<String, String> properties = new HashMap<String, String>(); [EOL] properties.put(READ_PREFERENCE.getOptionName(), "falseReadPreference"); [EOL] [EOL] ConnectorClusterConfig wrongConfig = new ConnectorClusterConfig(CLUSTER_NAME, null, properties); [EOL] [EOL] MongoClientConfiguration config = new MongoClientConfiguration(wrongConfig); [EOL] try { [EOL] config.getMongoClientOptions(); [EOL] fail("A exception must be thrown when no match any option"); [EOL] } catch (MongoValidationException e) { [EOL] } [EOL] [EOL] } [EOL]
@Test [EOL] public void shouldProcessParamEncodingThem() throws Exception { [EOL] Serializer serializer = new ToStringSerializer(); [EOL] ParamConfig paramConfig = mock(ParamConfig.class); [EOL] when(paramConfig.getSerializer()).thenReturn(serializer); [EOL] when(paramConfig.isEncoded()).thenReturn(false); [EOL] when(paramConfig.getName()).thenReturn("p1"); [EOL] [EOL] Param param = mock(Param.class); [EOL] when(param.getParamConfig()).thenReturn(paramConfig); [EOL] when(param.getValue()).thenReturn((Collection) asList("v 11", "v 12")); [EOL] [EOL] List<EncodedPair> actual = toTest.process(param, UTF8, true); [EOL] assertEquals(1, actual.size()); [EOL] assertEquals("Cookie", actual.get(0).getName()); [EOL] assertEquals("p1=v%2011,p1=v%2012", actual.get(0).getValue()); [EOL] } [EOL]
@Test [EOL] void testDeepCopyDontCopyNulls() throws NoSuchFieldException, IllegalAccessException { [EOL] // The dest [EOL] final MyParent parent1 = new MyParent(); [EOL] System.out.println("parent1 " + System.identityHashCode(parent1)); [EOL] System.out.println("parent1 child " + System.identityHashCode(parent1.child)); [EOL] [EOL] int parent1Id = System.identityHashCode(parent1); [EOL] int parent1ChildId = System.identityHashCode(parent1.child); [EOL] [EOL] // the source [EOL] final MyParent parent2 = new MyParent(); [EOL] parent2.setMyInt(99); [EOL] parent2.setMyString("changed"); [EOL] parent2.setChild(null); [EOL] [EOL] assertThat(parent1) [EOL] .isNotEqualTo(parent2); [EOL] assertThat(parent1.getChild()) [EOL] .isNotEqualTo(parent2.getChild()); [EOL] [EOL] System.out.println("parent2 " + System.identityHashCode(parent2)); [EOL] System.out.println("parent2 child " + System.identityHashCode(parent2.child)); [EOL] [EOL] assertThat(System.identityHashCode(parent1)) [EOL] .isNotEqualTo(System.identityHashCode(parent2)); [EOL] [EOL] System.out.println("parent1: " + parent1); [EOL] System.out.println("parent2: " + parent2); [EOL] [EOL] FieldMapper.copyNonNulls(parent2, parent1); [EOL] System.out.println("parent1: " + parent1); [EOL] System.out.println("parent2: " + parent2); [EOL] [EOL] System.out.println(); [EOL] System.out.println("parent1 " + System.identityHashCode(parent1)); [EOL] System.out.println("parent1 child " + System.identityHashCode(parent1.child)); [EOL] System.out.println("parent2 " + System.identityHashCode(parent2)); [EOL] System.out.println("parent2 child " + System.identityHashCode(parent2.child)); [EOL] [EOL] assertThat(System.identityHashCode(parent1)) [EOL] .isNotEqualTo(System.identityHashCode(parent2)); [EOL] assertThat(System.identityHashCode(parent1.child)) [EOL] .isNotEqualTo(System.identityHashCode(parent2.child)); [EOL] [EOL] assertThat(parent1.myInt) [EOL] .isEqualTo(parent2.myInt); [EOL] assertThat(parent1.myString) [EOL] .isEqualTo(parent2.myString); [EOL] [EOL] assertThat(parent1.getChild()) [EOL] .isEqualTo(new MyChild()); [EOL] [EOL] assertThat(System.identityHashCode(parent1)) [EOL] .isEqualTo(parent1Id); [EOL] assertThat(System.identityHashCode(parent1.child)) [EOL] .isEqualTo(parent1ChildId); [EOL] } [EOL]
@Test [EOL] public void testChannelSortingOneErrors() { [EOL] List<NodeChannel> channels = new ArrayList<NodeChannel>(); [EOL] NodeChannel channelA = new NodeChannel("a"); [EOL] channelA.setProcessingOrder(1); [EOL] [EOL] NodeChannel channelB = new NodeChannel("b"); [EOL] channelB.setProcessingOrder(2); [EOL] [EOL] NodeChannel channelC = new NodeChannel("c"); [EOL] channelC.setProcessingOrder(3); [EOL] [EOL] channels.add(channelC); [EOL] channels.add(channelB); [EOL] channels.add(channelA); [EOL] [EOL] List<OutgoingBatch> batches = new ArrayList<OutgoingBatch>(); [EOL] OutgoingBatch batch1 = new OutgoingBatch("1", channelA.getChannelId(), Status.NE); [EOL] batch1.setStatus(OutgoingBatch.Status.ER); [EOL] batch1.setErrorFlag(true); [EOL] batches.add(batch1); [EOL] [EOL] OutgoingBatch batch2 = new OutgoingBatch("1", channelB.getChannelId(), Status.NE); [EOL] batches.add(batch2); [EOL] [EOL] OutgoingBatch batch3 = new OutgoingBatch("1", channelC.getChannelId(), Status.NE); [EOL] batches.add(batch3); [EOL] [EOL] OutgoingBatches outgoingBatches = new OutgoingBatches(batches); [EOL] [EOL] outgoingBatches.sortChannels(channels); [EOL] [EOL] assertEquals(channelB, channels.get(0)); [EOL] assertEquals(channelC, channels.get(1)); [EOL] assertEquals(channelA, channels.get(2)); [EOL] } [EOL]
@Test [EOL] public void testGetState() throws Exception [EOL] { [EOL] doReturn( CONTAINER_HOST_STATE ).when( peer ).getContainerState( any( ContainerId.class ) ); [EOL] [EOL] assertEquals( CONTAINER_HOST_STATE, containerHostEntity.getState() ); [EOL] } [EOL]
@Test [EOL] 	public void test54createXAuditMapVxResourceNull() { [EOL] [EOL] 		VXAuditMap testvXAuditMap = createVXAuditMapObj(); [EOL] 		testvXAuditMap.setResourceId(null); [EOL] 		 [EOL] 		Mockito.when(xResourceService.readResource(testvXAuditMap.getResourceId())).thenReturn(null); [EOL] [EOL] 		Mockito.when(restErrorUtil.createRESTException(Mockito.anyString(), (MessageEnums)Mockito.any())).thenThrow(new WebApplicationException()); [EOL] 		thrown.expect(WebApplicationException.class); [EOL] 		 [EOL] 		VXAuditMap retvXAuditMap= xUserRest.createXAuditMap(testvXAuditMap); [EOL] 		assertEquals(testvXAuditMap.getId(),retvXAuditMap.getId()); [EOL] 		assertEquals(testvXAuditMap.getClass(),retvXAuditMap.getClass()); [EOL] 		assertNotNull(retvXAuditMap); [EOL] 		 [EOL] 		Mockito.verify(xUserMgr).createXAuditMap(testvXAuditMap); [EOL] 		Mockito.verify(xResourceService).readResource(testvXAuditMap.getResourceId()); [EOL] 		Mockito.verify(restErrorUtil.createRESTException(Mockito.anyString(), (MessageEnums)Mockito.any())); [EOL] 		 [EOL] 	} [EOL]
@Test [EOL] void convertPomToExtension() throws SecurityException [EOL] { [EOL] Model model = new Model(); [EOL] [EOL] model.setGroupId("groupid"); [EOL] model.setArtifactId("artifactid"); [EOL] model.setVersion("version"); [EOL] model.setPackaging("pom"); [EOL] [EOL] Extension extension = this.converter.convert(Extension.class, model); [EOL] [EOL] assertNull(extension.getType()); [EOL] } [EOL]
@Test [EOL] public void secureTransportIsSetupByDefaultWhenAuthIsConfigured() { [EOL] [EOL] // given [EOL] Builder builder = createTestObjectFactoryBuilder(); [EOL] builder.withAuth(XPackAuthTest.createTestBuilder().build()); [EOL] [EOL] BulkProcessorObjectFactory factory = builder.build(); [EOL] [EOL] // when [EOL] ClientProvider clientProvider = factory.getClientProvider(); [EOL] [EOL] // then [EOL] Assert.assertTrue(clientProvider instanceof SecureClientProvider); [EOL] [EOL] } [EOL]
@Test [EOL] public void shouldLaunchIntentForPassedActivity() { [EOL] AuthenticationRequest authenticationRequest = mock(AuthenticationRequest.class); [EOL] Activity activity = mock(Activity.class); [EOL] [EOL] when(authenticationRequest.toUri()).thenReturn(Uri.parse("to://me")); [EOL] Mockito.doNothing().when(activity).startActivity(any(Intent.class)); [EOL] ArgumentCaptor<Intent> captor = ArgumentCaptor.forClass(Intent.class); [EOL] [EOL] AuthenticationClient.openLoginInBrowser(activity, authenticationRequest); [EOL] [EOL] verify(activity, times(1)).startActivity(captor.capture()); [EOL] assertEquals(Intent.ACTION_VIEW, captor.getValue().getAction()); [EOL] assertEquals("to://me", captor.getValue().getData().toString()); [EOL] } [EOL]
@Test [EOL] public void setInstanceHeaderMetaData() { [EOL] ((AbstractSelectedColumnCommand) commandSpy).setInstanceHeaderMetaData(gridColumnMock, FACT_NAME, factIdentifierMock); [EOL] verify(((AbstractSelectedColumnCommand) commandSpy)).setInstanceHeaderMetaData(eq(gridColumnMock), eq(FACT_NAME), eq(factIdentifierMock)); [EOL] verify(gridColumnMock, times(1)).setInstanceAssigned(true); [EOL] verify(gridColumnMock, times(1)).setFactIdentifier(eq(factIdentifierMock)); [EOL] verify(informationHeaderMetaDataMock, times(1)).setTitle(eq(FACT_NAME)); [EOL] } [EOL]
@Test [EOL] public void testFindFirstFieldForType() { [EOL] final JBBPNamedNumericFieldMap map = new JBBPNamedNumericFieldMap(); [EOL] final JBBPNumericField field1 = new JBBPFieldInt(new JBBPNamedFieldInfo("test.test", "test", 0), 123); [EOL] final JBBPNumericField field2 = new JBBPFieldInt(new JBBPNamedFieldInfo("test.test2", "test2", 0), 123); [EOL] final JBBPNumericField field3 = new JBBPFieldByte(new JBBPNamedFieldInfo("test.test3", "test3", 0), (byte) 123); [EOL] [EOL] map.putField(field1); [EOL] map.putField(field2); [EOL] map.putField(field3); [EOL] [EOL] assertSame(field1, map.findFirstFieldForType(JBBPFieldInt.class)); [EOL] assertNull(map.findFirstFieldForType(JBBPFieldLong.class)); [EOL] [EOL] try { [EOL] map.findFirstFieldForType(null); [EOL] fail("Must throw NPE"); [EOL] } catch (NullPointerException ex) { [EOL] } [EOL] } [EOL]
@Test [EOL] void connectionInvalidation() throws Exception { [EOL] when(plcDriver.getConnection(anyString())).then(invocationOnMock -> new DummyPlcConnection(invocationOnMock.getArgument(0))); [EOL] [EOL] PlcConnection connection = SUT.getConnection("dummydummy:single/socket1/socket2?fancyOption=true"); [EOL] assertThat(connection.isConnected()).isEqualTo(true); [EOL] assertThat(connection.getMetadata().canRead()).isEqualTo(false); [EOL] assertThat(connection.getMetadata().canWrite()).isEqualTo(false); [EOL] assertThat(connection.getMetadata().canSubscribe()).isEqualTo(false); [EOL] [EOL] connection.close(); [EOL] assertThatThrownBy(connection::connect).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::isConnected).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::close).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::getMetadata).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::readRequestBuilder).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::writeRequestBuilder).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::subscriptionRequestBuilder).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] assertThatThrownBy(connection::unsubscriptionRequestBuilder).isInstanceOf(IllegalStateException.class).hasMessage("Proxy not valid anymore"); [EOL] } [EOL]
@Test [EOL] void nameOfIllegalFileName() { [EOL] final File file = File.of("com.company.module.Foo.c++"); [EOL] final Class clazz = Class.of("Bar"); [EOL] assertThrows(RuntimeException.class, () -> SimpleTypeUtil.nameOf(file, clazz)); [EOL] } [EOL]
@Test [EOL] public void testPreserveTimestampOnDirectory() throws IOException { [EOL] FileSystem fs = FileSystem.get(config); [EOL] EnumSet<FileAttribute> attributes = EnumSet.of(FileAttribute.TIMES); [EOL] [EOL] Path dst = new Path("/tmp/abc"); [EOL] Path src = new Path("/tmp/src"); [EOL] [EOL] createDirectory(fs, src); [EOL] createDirectory(fs, dst); [EOL] [EOL] fs.setPermission(src, fullPerm); [EOL] fs.setOwner(src, "somebody", "somebody-group"); [EOL] fs.setTimes(src, 0, 0); [EOL] [EOL] fs.setPermission(dst, noPerm); [EOL] fs.setOwner(dst, "nobody", "nobody-group"); [EOL] fs.setTimes(dst, 100, 100); [EOL] [EOL] CopyListingFileStatus srcStatus = new CopyListingFileStatus(fs.getFileStatus(src)); [EOL] [EOL] DistCpUtils.preserve(fs, dst, srcStatus, attributes, false); [EOL] [EOL] CopyListingFileStatus dstStatus = new CopyListingFileStatus(fs.getFileStatus(dst)); [EOL] [EOL] // FileStatus.equals only compares path field, must explicitly compare all fields [EOL] Assert.assertFalse(srcStatus.getPermission().equals(dstStatus.getPermission())); [EOL] Assert.assertFalse(srcStatus.getOwner().equals(dstStatus.getOwner())); [EOL] Assert.assertFalse(srcStatus.getGroup().equals(dstStatus.getGroup())); [EOL] Assert.assertTrue(srcStatus.getAccessTime() == dstStatus.getAccessTime()); [EOL] Assert.assertTrue(srcStatus.getModificationTime() == dstStatus.getModificationTime()); [EOL] } [EOL]
@Test [EOL] public void testNonSerializedEnumShouldAlwaysBeString() throws Exception { [EOL] class StringToIntegerSerializer extends DefaultValueSerializer<String, Integer> { [EOL] } [EOL] @Api(transformers = {StringToIntegerSerializer.class}) [EOL] class EnumParameter { [EOL] @SuppressWarnings("unused") [EOL] public void foo(@Named("outcome") Outcome outcome) { } [EOL] } [EOL] String apiConfigSource = g.generateConfig(EnumParameter.class).get("myapi-v1.api"); [EOL] ObjectNode root = objectMapper.readValue(apiConfigSource, ObjectNode.class); [EOL] [EOL] JsonNode request = root.path("methods").path("myapi.enumParameter.foo").path("request"); [EOL] verifyMethodRequestParameter(request, "outcome", "string", true, false, "WON", "LOST", "TIE"); [EOL] assertTrue(root.path("descriptor").path("schemas").path("Outcome").isMissingNode()); [EOL] verifyEmptyMethodRequest(root, EnumParameter.class.getName() + ".pick"); [EOL] } [EOL]
@Test [EOL] public void testThatCompositeReturnsASumOfViewManagers() { [EOL] // Given [EOL] CompositeReactPackage composite = new CompositeReactPackage(packageNo1, packageNo2); [EOL] [EOL] ViewManager managerNo1 = mock(ViewManager.class); [EOL] when(managerNo1.getName()).thenReturn("ManagerNo1"); [EOL] [EOL] // managerNo2 and managerNo3 will share same name, composite should return only the latter one [EOL] final String sameModuleName = "SameModuleName"; [EOL] [EOL] ViewManager managerNo2 = mock(ViewManager.class); [EOL] when(managerNo2.getName()).thenReturn(sameModuleName); [EOL] [EOL] ViewManager managerNo3 = mock(ViewManager.class); [EOL] when(managerNo3.getName()).thenReturn(sameModuleName); [EOL] [EOL] ViewManager managerNo4 = mock(ViewManager.class); [EOL] when(managerNo4.getName()).thenReturn("ManagerNo4"); [EOL] [EOL] when(packageNo1.createViewManagers(reactContext)).thenReturn( [EOL] Arrays.asList(new ViewManager[]{managerNo1, managerNo2})); [EOL] [EOL] when(packageNo2.createViewManagers(reactContext)).thenReturn( [EOL] Arrays.asList(new ViewManager[]{managerNo3, managerNo4})); [EOL] [EOL] // When [EOL] List<ViewManager> compositeModules = composite.createViewManagers(reactContext); [EOL] [EOL] // Then [EOL] [EOL] // Wrapping lists into sets to be order-independent. [EOL] // Note that there should be no managerNo2 returned. [EOL] Set<ViewManager> expected = new HashSet<>( [EOL] Arrays.asList(new ViewManager[]{managerNo1, managerNo3, managerNo4}) [EOL] ); [EOL] Set<ViewManager> actual = new HashSet<>(compositeModules); [EOL] [EOL] assertEquals(expected, actual); [EOL] } [EOL]
@Test [EOL] public void setMethodsProducesShouldSetProducesOnAllMethodConfigs(){ [EOL] assertSame(toTest, toTest.setMethodsProduces("a")); [EOL] verify(mockM1MethodConfigBuilder).setProduces("a"); [EOL] verify(mockM2MethodConfigBuilder).setProduces("a"); [EOL] } [EOL]
@Test [EOL] public void testEnsureCapacity() throws Exception { [EOL] final CharArrayBuffer buffer = new CharArrayBuffer(4); [EOL] buffer.ensureCapacity(2); [EOL] Assert.assertEquals(4, buffer.capacity()); [EOL] buffer.ensureCapacity(8); [EOL] Assert.assertEquals(8, buffer.capacity()); [EOL] } [EOL]
@Test [EOL] public void testModifyCurrentUser() { [EOL] UserModifyRequest req = UserModifyRequest.builder() [EOL] .username("Discord4J 3 Test Bot") [EOL] .build(); [EOL] userService.modifyCurrentUser(req).block(); [EOL] } [EOL]
@Test [EOL] public void refreshAndRetryIfViewChanged() throws ViewChangedException { [EOL] setupViewChangedScenario(true, false); [EOL] [EOL] AxeView axeView = testSubject.createAxeViews(rootNodeMock); [EOL] Assert.assertNotNull(axeView); [EOL] Assert.assertEquals(axeView, rootViewMock); [EOL] [EOL] verify(rootNodeMock, times(1)).refresh(); [EOL] verify(queueBuilderMock, times(2)).buildPriorityQueue(rootNodeMock); [EOL] verify(rootNodeMock, times(2)).getChildCount(); [EOL] verify(rootNodeMock, times(2)).getChild(0); [EOL] } [EOL]
@Test(expected=IOException.class) [EOL] public void testHeaderEmptyReadable() throws Exception { [EOL] header(emptyReadable); [EOL] } [EOL]
@Test [EOL] public void handleMethodAnnotationShouldMergePlaceholdersAndSetParamsTypeAndNameAndDefaultValue() throws Exception { [EOL] when(mockMethodConfigBuilder.startExtraParamConfig()).thenReturn(mockParamConfigBuilder); [EOL] when(mockParamConfigBuilder.setType(any(ParamType.class))).thenReturn(mockParamConfigBuilder); [EOL] when(mockParamConfigBuilder.setName(any(String.class))).thenReturn(mockParamConfigBuilder); [EOL] when(mockAnnotation.value()).thenReturn(VAL_WITH_PH + "a"); [EOL] when(mockAnnotation.defaultValue()).thenReturn(VAL_WITH_PH + "b"); [EOL] toTest.handleMethodAnnotation(mockAnnotation, mockMethodConfigBuilder); [EOL] verify(mockMethodConfigBuilder).startExtraParamConfig(); [EOL] verify(mockParamConfigBuilder).setType(ParamType.HEADER); [EOL] verify(mockParamConfigBuilder).setName(EXPECTED_MERGE_VAL + "a"); [EOL] verify(mockParamConfigBuilder).setDefaultValue(EXPECTED_MERGE_VAL + "b"); [EOL] verify(mockAnnotation).value(); [EOL] verify(mockAnnotation).defaultValue(); [EOL] } [EOL]
@Test [EOL] 	public void onHttpResultShouldNotThrowExceptionsOnHeaders() throws Exception { [EOL] 		HttpResult httpResult = mock(HttpResult.class); [EOL] [EOL] 		when(result.use(HttpResult.class)).thenReturn(httpResult); [EOL] [EOL] 		factory.instanceFor(HttpResult.class, errors); [EOL] 		factory.instanceFor(HttpResult.class, errors).addDateHeader("abc", 123l); [EOL] 		factory.instanceFor(HttpResult.class, errors).addHeader("def", "ghi"); [EOL] 		factory.instanceFor(HttpResult.class, errors).addIntHeader("jkl", 456); [EOL] 		factory.instanceFor(HttpResult.class, errors).addIntHeader("jkl", 456); [EOL] 	} [EOL]
@Test [EOL] public void natural() { [EOL] ExprValueOrdering ordering = ExprValueOrdering.natural(); [EOL] assertEquals(1, ordering.compare(integerValue(5), integerValue(4))); [EOL] assertEquals(0, ordering.compare(integerValue(5), integerValue(5))); [EOL] assertEquals(-1, ordering.compare(integerValue(4), integerValue(5))); [EOL] } [EOL]
@Test [EOL] public void should_fail_when_executing_a_removed_prepared_statement() throws Exception { [EOL] //Given [EOL] String prepare_first = "@prepare[to_be_removed]=INSERT INTO zeppelin.users(login,deceased) VALUES(?,?)"; [EOL] interpreter.interpret(prepare_first, intrContext); [EOL] String remove_prepared = "@remove_prepare[to_be_removed]\n" + [EOL] "@bind[to_be_removed]='bind_bool'"; [EOL] [EOL] //When [EOL] final InterpreterResult actual = interpreter.interpret(remove_prepared, intrContext); [EOL] [EOL] //Then [EOL] assertThat(actual.code()).isEqualTo(Code.ERROR); [EOL] assertThat(actual.message()).isEqualTo("The statement 'to_be_removed' can not be bound to values. " + [EOL] "Are you sure you did prepare it with @prepare[to_be_removed] ?"); [EOL] } [EOL]
@Test [EOL] public void testGetValidator() throws Exception { [EOL] ViewConfig config = getConfig(); [EOL] Assert.assertEquals("org.apache.ambari.server.view.configuration.ViewConfigTest$MyValidator", config.getValidator()); [EOL] } [EOL]
@Test [EOL] public void testSeparateColumns04() throws Exception { [EOL] // テスト対象のインスタンス化 [EOL] URL url = FixedFileLineIteratorTest.class.getResource("/aaa.txt"); [EOL] String fileName = url.getPath(); [EOL] Class<FixedFileLineIterator_Stub03> clazz = FixedFileLineIterator_Stub03.class; [EOL] Map<String, ColumnParser> columnParserMap = new HashMap<String, ColumnParser>(); [EOL] ColumnParser columnParser = new FixedFileLineIterator_ColumnParserStub01(); [EOL] columnParserMap.put("java.lang.String", columnParser); [EOL] columnParserMap.put("java.util.Date", columnParser); [EOL] columnParserMap.put("java.math.BigDecimal", columnParser); [EOL] columnParserMap.put("java.lang.int", columnParser); [EOL] FixedFileLineIterator<FixedFileLineIterator_Stub03> lineIterator = new FixedFileLineIterator<FixedFileLineIterator_Stub03>(fileName, clazz, columnParserMap); [EOL] [EOL] // 引数の設定 [EOL] String fileLineString = "12345"; [EOL] [EOL] // 前提条件の設定 [EOL] ReflectionTestUtils.setField(lineIterator, "fileEncoding", "aaa"); [EOL] [EOL] // テスト実施 [EOL] try { [EOL] lineIterator.separateColumns(fileLineString); [EOL] fail("FileExceptionがスローされませんでした。"); [EOL] } catch (FileException e) { [EOL] // 返却値なし [EOL] [EOL] // 状態変化の確認 [EOL] assertEquals(UnsupportedEncodingException.class, e.getCause() [EOL] .getClass()); [EOL] assertEquals(fileName, e.getFileName()); [EOL] assertEquals("fileEncoding which isn't supported was set.", e [EOL] .getMessage()); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void overwrite_staticField() throws Exception { [EOL] 		assertNotEquals("hogehogehogehoge", Build.BRAND); [EOL] 		Intenso.overwrite(Build.class, "BRAND", "hogehogehogehoge"); [EOL] 		assertEquals("hogehogehogehoge", Build.BRAND); [EOL] 	} [EOL]
@Test [EOL] public void disposeShouldDelegates() throws Exception { [EOL] toTest.dispose(); [EOL] verify(mockResponse).dispose(); [EOL] } [EOL]
@Test [EOL] public void throwsIfExpectedPropertyIsNotPresent() { [EOL] Assertions.assertThrows(IllegalArgumentException.class, () -> { [EOL] Symbol symbol = Symbol.builder().name("foo").build(); [EOL] [EOL] symbol.expectProperty("baz"); [EOL] }); [EOL] } [EOL]
@Test [EOL] 	public void testErrorExit() throws Exception { [EOL] 		Future<?> future = ProcessUtil.execute( [EOL] 			ConsumerOutputProcessor.INSTANCE, _buildArguments(ErrorExit.class)); [EOL] [EOL] 		try { [EOL] 			future.get(); [EOL] [EOL] 			Assert.fail(); [EOL] 		} [EOL] 		catch (ExecutionException executionException) { [EOL] 			Throwable throwable = executionException.getCause(); [EOL] [EOL] 			Assert.assertSame( [EOL] 				TerminationProcessException.class, throwable.getClass()); [EOL] 			Assert.assertEquals( [EOL] 				"Subprocess terminated with exit code " + ErrorExit.EXIT_CODE, [EOL] 				throwable.getMessage()); [EOL] [EOL] 			TerminationProcessException terminationProcessException = [EOL] 				(TerminationProcessException)throwable; [EOL] [EOL] 			Assert.assertEquals( [EOL] 				ErrorExit.EXIT_CODE, terminationProcessException.getExitCode()); [EOL] 		} [EOL] 	} [EOL]
@Test [EOL] public void testEncodeToJsonString() { [EOL] LOG.info("testEncodeToJsonString"); [EOL] [EOL] String json = "\"\""; // JSON string. [EOL] String java = ""; // Java string. [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\""; [EOL] java = "a"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"ab\""; [EOL] java = "ab"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\\"a\""; [EOL] java = "\"a"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\\\"\""; [EOL] java = "a\""; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\\\"b\""; [EOL] java = "a\"b"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\\\\""; [EOL] java = "\\"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\\\a\""; [EOL] java = "\\a"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\\\\\""; [EOL] java = "a\\"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\\\\b\""; [EOL] java = "a\\b"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\\\\\\\a\""; [EOL] java = "\\\\a"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\\\\\\\\\""; [EOL] java = "a\\\\"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"a\\\\\\\\b\""; [EOL] java = "a\\\\b"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\\"\""; [EOL] java = "\""; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\b\""; [EOL] java = "\b"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\t\""; [EOL] java = "\t"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\n\""; [EOL] java = "\n"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\f\""; [EOL] java = "\f"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] json = "\"\\r\""; [EOL] java = "\r"; [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] [EOL] final String controlChars = "\b\t\n\f\r"; [EOL] for (int i = 0; i < 32; ++i) { [EOL] //noinspection NumericCastThatLosesPrecision [EOL] final char ch = (char) i; [EOL] final String code = ("000" + Integer.toHexString(i)); [EOL] if (controlChars.indexOf(ch) == -1) { [EOL] json = "\"\\u" + code.substring(code.length() - 4) + '"'; [EOL] java = String.valueOf(ch); [EOL] Assert.assertEquals(json, StringUtils.encodeToJsonString(java)); [EOL] Assert.assertEquals(java, StringUtils.decodeFromJsonString(json)); [EOL] } [EOL] } [EOL] [EOL] // Failing decoder test. [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"x")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("x\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"\\\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"\\u\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"\\u0\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"\\u00\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"\\u000\"")); [EOL] Assert.assertNull(StringUtils.decodeFromJsonString("\"\\u000X\"")); [EOL] } [EOL]
@Test(expected = IllegalStateException.class) [EOL] public void shouldFailToCreateTimeoutIfTimerNotRunning() throws Exception { [EOL] timer.newTimeout(new Timer.TimeoutTask() { [EOL] @Override [EOL] public void run(Timer.TimeoutHandle timeoutHandle) { [EOL] // empty [EOL] } [EOL] }, 5, TimeUnit.SECONDS); [EOL] } [EOL]
@Test [EOL] public void testXLIFF12() throws Exception { [EOL] try (InputStream input = XLIFF12ParserTest.class.getResourceAsStream("/test-documents/testXLIFF12.xlf")) { [EOL] Metadata metadata = new Metadata(); [EOL] ContentHandler handler = new BodyContentHandler(); [EOL] new XLIFF12Parser().parse(input, handler, metadata, new ParseContext()); [EOL] String content = handler.toString(); [EOL] assertContains("Hooray", content); [EOL] assertEquals("2", metadata.get("file-count")); [EOL] assertEquals("4", metadata.get("tu-count")); [EOL] assertEquals("en", metadata.get("source-language")); [EOL] assertEquals("fr", metadata.get("target-language")); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testEmbulkPartitioningMapperReducer() [EOL] throws Exception [EOL] { [EOL] new File("tmp/embulk_mapred_partitioning_output.000.00.csv").delete(); [EOL] new File("tmp/embulk_mapred_partitioning_output.001.00.csv").delete(); [EOL] ConfigSource config = loadConfigSource(configLoader, "config/embulk_mapred_partitioning_config.yml") [EOL] .merge(configLoader.newConfigSource().set("exec", ImmutableMap.of("type", getPluginName()))); [EOL] embulk.run(config); [EOL] assertFileContent( [EOL] Lists.newArrayList( [EOL] RESOURCES_PATH + "fixtures/csv/sample1.csv", [EOL] RESOURCES_PATH + "fixtures/csv/sample1.csv"), [EOL] Lists.newArrayList( [EOL] "tmp/embulk_mapred_partitioning_output.000.00.csv", [EOL] "tmp/embulk_mapred_partitioning_output.001.00.csv")); [EOL] } [EOL]
@Test [EOL] public void testGetAMContainer() throws Exception { [EOL] final ApplicationAttemptId appAttemptId = [EOL] ApplicationAttemptId.newInstance(ApplicationId.newInstance(0, 1), 1); [EOL] ContainerReport container; [EOL] if (callerUGI == null) { [EOL] container = historyManager.getAMContainer(appAttemptId); [EOL] } else { [EOL] try { [EOL] container = [EOL] callerUGI.doAs(new PrivilegedExceptionAction<ContainerReport> () { [EOL] @Override [EOL] public ContainerReport run() throws Exception { [EOL] return historyManager.getAMContainer(appAttemptId); [EOL] } [EOL] }); [EOL] if (callerUGI != null && callerUGI.getShortUserName().equals("user3")) { [EOL] // The exception is expected [EOL] Assert.fail(); [EOL] } [EOL] } catch (AuthorizationException e) { [EOL] if (callerUGI != null && callerUGI.getShortUserName().equals("user3")) { [EOL] // The exception is expected [EOL] return; [EOL] } [EOL] throw e; [EOL] } [EOL] } [EOL] Assert.assertNotNull(container); [EOL] Assert.assertEquals(appAttemptId, container.getContainerId() [EOL] .getApplicationAttemptId()); [EOL] } [EOL]
@Test [EOL] public void testSomeMethod() throws Exception { [EOL] LogAssert expect = TestLoggers.sys().expect("org.spf4j.perf.PerformanceMonitor", [EOL] Level.ERROR, [EOL] LogMatchers.hasFormat("Execution time {} ms for {} exceeds error threshold of {} ms, detail: {}")); [EOL] String result = PerformanceMonitor.callAndMonitor( [EOL] 1, 2, new Callable<String>() { [EOL] [EOL] @Override [EOL] @SuppressFBWarnings("MDM_THREAD_YIELD") [EOL] public String call() throws Exception { [EOL] LOG.debug("testing"); [EOL] Thread.sleep(3); [EOL] return "test"; [EOL] } [EOL] [EOL] @Override [EOL] public String toString() { [EOL] return "test"; [EOL] } [EOL] [EOL] }); [EOL] Assert.assertEquals("test", result); [EOL] expect.assertObservation(); [EOL] } [EOL]
@Test [EOL] public void should_create_dimension_map() throws Exception { [EOL] DimensionFactory dimensionFactory = new DimensionFactory(); [EOL] [EOL] Map<String, Integer> dimensions = dimensionFactory.create(12); [EOL] [EOL] assertThat(dimensions).containsOnlyKeys("xs"); [EOL] assertThat(dimensions).containsValue(12); [EOL] } [EOL]
@Test(expected = AllocationConfigurationException.class) [EOL] public void testGibberish() throws Exception { [EOL] parseResourceConfigValue("1o24vc0res"); [EOL] } [EOL]
@Test [EOL] public void testConcurrentChangeToGetChildQueue() { [EOL] [EOL] queueManager.getLeafQueue("parent.child", true); [EOL] queueManager.getLeafQueue("parent.child2", true); [EOL] FSParentQueue test = queueManager.getParentQueue("parent", false); [EOL] assertEquals(2, test.getChildQueues().size()); [EOL] [EOL] boolean first = true; [EOL] int childQueuesFound = 0; [EOL] for (FSQueue childQueue:test.getChildQueues()) { [EOL] if (first) { [EOL] first = false; [EOL] queueManager.getLeafQueue("parent.child3", true); [EOL] } [EOL] childQueuesFound++; [EOL] } [EOL] [EOL] assertEquals(2, childQueuesFound); [EOL] assertEquals(3, test.getChildQueues().size()); [EOL] } [EOL]
@Test [EOL] public void testParamsFormatting() throws Exception { [EOL] final NameValuePair param1 = new BasicNameValuePair("param", "regular_stuff"); [EOL] final NameValuePair param2 = new BasicNameValuePair("param", "this\\that"); [EOL] final NameValuePair param3 = new BasicNameValuePair("param", "this,that"); [EOL] final NameValuePair[] params = new NameValuePair[] {param1, param2, param3}; [EOL] [EOL] final CharArrayBuffer buf = new CharArrayBuffer(64); [EOL] [EOL] buf.clear(); [EOL] this.formatter.formatParameters(buf, params, false); [EOL] Assert.assertEquals("param=regular_stuff; param=\"this\\\\that\"; param=\"this,that\"", [EOL] buf.toString()); [EOL] buf.clear(); [EOL] this.formatter.formatParameters(buf, params, true); [EOL] Assert.assertEquals("param=\"regular_stuff\"; param=\"this\\\\that\"; param=\"this,that\"", [EOL] buf.toString()); [EOL] } [EOL]
@Test [EOL] public void testGet() { [EOL] Metadata meta = new Metadata(); [EOL] assertNull(meta.get("a-name")); [EOL] meta.add("a-name", "value-1"); [EOL] assertEquals("value-1", meta.get("a-name")); [EOL] meta.add("a-name", "value-2"); [EOL] assertEquals("value-1", meta.get("a-name")); [EOL] } [EOL]
@Test [EOL] public void throwsExceptionWithNullGenomeDataSourcePath() { [EOL] assertThrows(NullPointerException.class, () -> GenomeDataSources.builder() [EOL] .genomeDataSource(null) [EOL] .build() [EOL] ); [EOL] } [EOL]
@Test [EOL] 	public void testLogExceptionsOnlyFalse() throws Throwable { [EOL] 		expectedException.expect(SearchException.class); [EOL] 		expectedException.expectMessage("some other random message"); [EOL] [EOL] 		ElasticsearchExceptionHandler elasticsearchExceptionHandler = [EOL] 			new ElasticsearchExceptionHandler(_log, false); [EOL] [EOL] 		elasticsearchExceptionHandler.logOrThrow( [EOL] 			new SearchException("some other random message")); [EOL] 	} [EOL]
@Test [EOL] public void onCloseCollectionEditorButtonClick() { [EOL] collectionEditorViewImplSpy.onCloseCollectionEditorButtonClick(clickEventMock); [EOL] verify(collectionEditorViewImplSpy, times(1)).fireEvent(isA(CloseCompositeEvent.class)); [EOL] } [EOL]
@Test [EOL] public void logicalRelationHasNoInput() { [EOL] LogicalPlan relation = LogicalPlanDSL.relation("index"); [EOL] assertEquals(0, relation.getChild().size()); [EOL] } [EOL]
@Test [EOL] public void requireBooleanFailure() { [EOL] exc.expect(SchemaException.class); [EOL] exc.expectMessage("#: expected type: Boolean, found: String"); [EOL] STR.requireBoolean(); [EOL] } [EOL]
@SuppressWarnings("unchecked") [EOL] @Test [EOL] public void testLogEvent() { [EOL] // Arrange [EOL] [EOL] HashMap<String, Object> eventValue = new HashMap<>(); [EOL] eventValue.put(EVENT_CATEGORY, "testCategory"); [EOL] eventValue.put(EVENT_ACTION, "testAction"); [EOL] eventValue.put(EVENT_LABEL, "testLabel"); [EOL] ArgumentCaptor<HashMap> event = ArgumentCaptor.forClass(HashMap.class); [EOL] [EOL] // Act [EOL] [EOL] this.subject.logEvent(eventValue); [EOL] // Assert [EOL] [EOL] verify(this.tracker).send(event.capture()); [EOL] [EOL] eventValue = event.getValue(); [EOL] assertTrue(eventValue.containsValue("testCategory")); [EOL] assertTrue(eventValue.containsValue("testLabel")); [EOL] assertTrue(eventValue.containsValue("testAction")); [EOL] [EOL] } [EOL]
@Test(expected = XMLStreamException.class) [EOL] 	public void testElementScopeUnboundPrefix() throws XMLStreamException { [EOL] 		TestScope scope = new TestScope(new TestScope("http://foo"), "bar", "test", null); [EOL] 		scope.setStartTagClosed(true); [EOL] 	} [EOL]
@Test [EOL] public void validLegacyOcid() { [EOL] assertTrue( [EOL] OCID.isValid( [EOL] "ocidv1:tenancy:oc1:phx:1829406592360:aaaaaaaab4faaopv32ecohhklpvjq463pu")); [EOL] } [EOL]
@Test [EOL] public void testNoInputDir() { [EOL] dependencyGraph = DependencyGraphFactory.createGraph(); [EOL] Map<String, String> parameters = Maps.newHashMap(); [EOL] parameters.put("baseDir", "src/test/resources/something.txt"); [EOL] new JavaScopeReader(dependencyGraph, true).read(parameters); [EOL] [EOL] assertThat(dependencyGraph.getAllNodes(), hasSize(0)); [EOL] } [EOL]
@Test(expected=NumberFormatException.class) [EOL] public void testValueOfStartNumberFormatException() { [EOL] valueOf("chr1\tnot a number\t14409"); [EOL] } [EOL]
@Test [EOL] public void getPrecedence() { [EOL] int precedence = 12345; [EOL] when(expr.getPrecedence()).thenReturn(precedence); [EOL] assertEquals(precedence, test.getPrecedence()); [EOL] verify(expr).getPrecedence(); [EOL] verifyNoMoreInteractions(expr); [EOL] } [EOL]
@Test [EOL] void getToolsReturnsDefaultTools() [EOL] { [EOL] // Verify for example that the number tool is present. [EOL] assertEquals(NumberTool.class.getName(), this.configuration.getTools().get("numbertool")); [EOL] } [EOL]
@Test [EOL] 	public final void test_getPoliciesForResourceSignature() throws Exception { [EOL] 		// return null if store returns null or throws an exception [EOL] 		String hexSignature = "aSignature"; [EOL] 		String serviceName = "service-name"; [EOL] 		boolean isPolicyEnabled = true; [EOL] 		when(_store.getPoliciesByResourceSignature(serviceName, hexSignature, isPolicyEnabled)).thenReturn(null); [EOL] 		Assert.assertNull(_validator.getPoliciesForResourceSignature(serviceName, hexSignature)); [EOL] 		when(_store.getPoliciesByResourceSignature(serviceName, hexSignature, isPolicyEnabled)).thenThrow(new Exception()); [EOL] 		Assert.assertNull(_validator.getPoliciesForResourceSignature(serviceName, hexSignature)); [EOL] [EOL] 		// what ever store returns should come back [EOL] 		hexSignature = "anotherSignature"; [EOL] 		List<RangerPolicy> policies = new ArrayList<>(); [EOL] 		RangerPolicy policy1 = mock(RangerPolicy.class); [EOL] 		policies.add(policy1); [EOL] 		RangerPolicy policy2 = mock(RangerPolicy.class); [EOL] 		policies.add(policy2); [EOL] 		when(_store.getPoliciesByResourceSignature(serviceName, hexSignature, isPolicyEnabled)).thenReturn(policies); [EOL] 		List<RangerPolicy> result = _validator.getPoliciesForResourceSignature(serviceName, hexSignature); [EOL] 		Assert.assertTrue(result.contains(policy1) && result.contains(policy2)); [EOL] 	} [EOL]
@Test [EOL] 	public void testFromMessage() { [EOL] 		Message m = new Message(a1.toString()); [EOL] 		Int64MultiArray p = Int64MultiArray.fromMessage(m); [EOL] 		assertEquals(a1.toString(), p.toString()); [EOL] 		assertEquals(a1.toJsonObject(), p.toJsonObject()); [EOL] 		assertEquals(a1.getMessageType(), p.getMessageType()); [EOL] 		assertEquals(a1.size(), p.size()); [EOL] 		assertTrue(Arrays.equals(a1.getData(), p.getData())); [EOL] 		assertEquals(a1.getLayout(), p.getLayout()); [EOL] 		assertNotSame(a1, p); [EOL] 		assertNotSame(a1.toString(), p.toString()); [EOL] 		assertNotSame(a1.toJsonObject(), p.toJsonObject()); [EOL] 	} [EOL]
@Test [EOL] public void testGetPeerAuthenticatorInstances_singleton() throws Exception { [EOL] when(config.getPeerAuthenticators()).thenReturn(ImmutableList.of(PassPeerAuthenticator.class, [EOL] FailPeerAuthenticator.class, PassPeerAuthenticator.class)); [EOL] List<PeerAuthenticator> peerAuthenticators = [EOL] Lists.newArrayList(peerAuth.getPeerAuthenticatorInstances()); [EOL] assertEquals(3, peerAuthenticators.size()); [EOL] assertTrue(peerAuthenticators.get(0) instanceof PassPeerAuthenticator); [EOL] assertTrue(peerAuthenticators.get(1) instanceof FailPeerAuthenticator); [EOL] assertTrue(peerAuthenticators.get(2) instanceof PassPeerAuthenticator); [EOL] assertSame(peerAuthenticators.get(0), peerAuthenticators.get(2)); [EOL] } [EOL]
@Test [EOL] public void unwrapAsyncExceptions_returns_passed_in_arg_if_exception_has_no_cause() { [EOL] // given [EOL] Exception noCause = new Exception("boom"); [EOL] [EOL] // expect [EOL] assertThat(cbSpy.unwrapAsyncExceptions(noCause)).isSameAs(noCause); [EOL] } [EOL]
@Test [EOL] 	public void test1() throws XMLStreamException { [EOL] 		StringReader json = new StringReader("{\"alice\":{\"@edgar\":\"david\",\"bob\":\"charlie\"}}"); [EOL] 		XMLEventReader reader = new JsonXMLInputFactory().createXMLEventReader(json); [EOL] 		Document node = DOMEventConsumer.consume(reader); [EOL] 		 [EOL] 		Node alice = node.getChildNodes().item(0); [EOL] 		Assert.assertEquals("alice", alice.getLocalName()); [EOL] 		Assert.assertEquals("david", alice.getAttributes().getNamedItem("edgar").getNodeValue()); [EOL] 		 [EOL] 		Node bob = alice.getChildNodes().item(0); [EOL] 		Assert.assertEquals("bob", bob.getLocalName());		 [EOL] 		Assert.assertEquals("charlie", bob.getTextContent()); [EOL] 	} [EOL]
@Test [EOL] public void shouldGetJobMetaAsString() { [EOL] when(metaRepository.getValue("someJob", "key")).thenReturn("42"); [EOL] final String value = testee.getMetaAsString("key"); [EOL] assertThat(value, is("42")); [EOL] } [EOL]
@Test [EOL] public void shouldReturnEmptyMergeObject() throws Exception { [EOL] String destString = "{\"fakeField\": null}"; [EOL] String srcString = new String(Files.readAllBytes(Paths.get("src/test/resources/utilTest/well1311src.json"))); [EOL] [EOL] JSONObject dest = new JSONObject(destString); [EOL] JSONObject src = new JSONObject(srcString); [EOL] JSONObject merged = JsonUtil.merge(dest, src); [EOL] [EOL] String actual = merged.toString(2); [EOL] String expected = "{\"uid\": \"uid12333\"}"; [EOL] [EOL] assertEquals(expected, actual); [EOL] } [EOL]
@Test [EOL] public void testGenerateNotFast() throws Exception { [EOL] try { [EOL] ClassicEngineBoot.getInstance().start(); [EOL] ReportListenerThreadHolder.clear(); [EOL] PentahoSessionHolder.setSession( new StandaloneSession() ); [EOL] [EOL] final File file = new File( "target/test/resource/solution/test/reporting/report.prpt" ); [EOL] final MasterReport report = [EOL] (MasterReport) new ResourceManager().createDirectly( file.getPath(), MasterReport.class ).getResource(); [EOL] fastXLSXOutput.generate( report, 1, new ByteArrayOutputStream(), 1 ); [EOL] [EOL] verify( listener, times( 0 ) ).reportProcessingStarted( any( ReportProgressEvent.class ) ); [EOL] verify( listener, times( 0 ) ).reportProcessingFinished( any( ReportProgressEvent.class ) ); [EOL] verify( listener, times( 0 ) ).reportProcessingUpdate( any( ReportProgressEvent.class ) ); [EOL] } finally { [EOL] PentahoSessionHolder.removeSession(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testBasicUriGeneration() { [EOL] GetTemplate getTemplate = new GetTemplate.Builder("personal_tweet").build(); [EOL] [EOL] assertEquals("GET", getTemplate.getRestMethodName()); [EOL] assertEquals("_template/personal_tweet", getTemplate.getURI(ElasticsearchVersion.UNKNOWN)); [EOL] } [EOL]
@Test [EOL] public void testGetHeader() { [EOL] MessageImpl protonMessage = createProtonMessage(); [EOL] AMQPStandardMessage message = new AMQPStandardMessage(0, encodeMessage(protonMessage), null, null); [EOL] [EOL] Header decoded = message.getHeader(); [EOL] assertNotSame(decoded, protonMessage.getHeader()); [EOL] assertHeaderEquals(protonMessage.getHeader(), decoded); [EOL] [EOL] // Update the values [EOL] decoded.setDeliveryCount(UnsignedInteger.ZERO); [EOL] decoded.setTtl(UnsignedInteger.valueOf(255)); [EOL] decoded.setFirstAcquirer(true); [EOL] [EOL] // Check that the message is unaffected. [EOL] assertHeaderNotEquals(protonMessage.getHeader(), decoded); [EOL] } [EOL]
@Test [EOL] void testUnsupportedRecordTypesThrow() { [EOL] assertThrows(HdfException.class, () -> BTreeRecord.readRecord(0, null, null)); [EOL] assertThrows(UnsupportedHdfException.class, () -> BTreeRecord.readRecord(2, null, null)); [EOL] assertThrows(UnsupportedHdfException.class, () -> BTreeRecord.readRecord(3, null, null)); [EOL] assertThrows(UnsupportedHdfException.class, () -> BTreeRecord.readRecord(4, null, null)); [EOL] assertThrows(UnsupportedHdfException.class, () -> BTreeRecord.readRecord(6, null, null)); [EOL] assertThrows(UnsupportedHdfException.class, () -> BTreeRecord.readRecord(7, null, null)); [EOL] assertThrows(UnsupportedHdfException.class, () -> BTreeRecord.readRecord(9, null, null)); [EOL] } [EOL]
@Test [EOL] public void typesIfSuitableElementExists() { [EOL] String cssSelector = ".something"; [EOL] String text = "text"; [EOL] String eventName = "TypeTextInElementFoundByCssSelector .something text"; [EOL] boolean expectsHttp = true; [EOL] [EOL] WebElement textBox = mock(WebElement.class); [EOL] WebDriver driver = mock(WebDriver.class); [EOL] when(driver.findElement(By.cssSelector(cssSelector))).thenReturn(textBox); [EOL] [EOL] SearchContextFunction contextProvider = webDriver1 -> driver; [EOL] WebDriverAction action = new TypeTextInElementFoundByCssSelector(cssSelector, text, expectsHttp, contextProvider); [EOL] action.execute(driver, mock(ReplayingState.class), mock(EventSynchronizer.class)); [EOL] [EOL] verify(textBox).sendKeys(text); [EOL] assertEquals(eventName, action.getName()); [EOL] assertEquals(expectsHttp, action.expectsHttpRequest()); [EOL] } [EOL]
@Test [EOL] public void noHiveDestination() { [EOL] [EOL] Destinations destinations = Destinations.builder().build(); [EOL] HiveRoad road = HiveRoad.builder().name(ROAD_NAME).destinations(destinations).build(); [EOL] [EOL] List<PatchOperation> operations = underTest.inspectModel(ROAD_NAME, road); [EOL] [EOL] assertThat(operations.size(), is(0)); [EOL] } [EOL]
@Test [EOL] public void testUpdateAmsEnvContent() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { [EOL] Method updateAmsEnvContent = UpgradeCatalog220.class.getDeclaredMethod("updateAmsEnvContent", String.class); [EOL] UpgradeCatalog220 upgradeCatalog220 = new UpgradeCatalog220(injector); [EOL] String oldContent = "some_content"; [EOL] [EOL] String expectedContent = "some_content" + "\n" + [EOL] "# AMS Collector GC options\n" + [EOL] "export AMS_COLLECTOR_GC_OPTS=\"-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 " + [EOL] "-XX:+UseCMSInitiatingOccupancyOnly -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps " + [EOL] "-XX:+UseGCLogFileRotation -XX:GCLogFileSize=10M " + [EOL] "-Xloggc:{{ams_collector_log_dir}}/collector-gc.log-`date +'%Y%m%d%H%M'`\"\n" + [EOL] "export AMS_COLLECTOR_OPTS=\"$AMS_COLLECTOR_OPTS $AMS_COLLECTOR_GC_OPTS\"\n"+ [EOL] "\n" + [EOL] "# HBase normalizer enabled\n" + [EOL] "export AMS_HBASE_NORMALIZER_ENABLED={{ams_hbase_normalizer_enabled}}\n" + [EOL] "\n" + [EOL] "# HBase compaction policy enabled\n" + [EOL] "export AMS_HBASE_FIFO_COMPACTION_ENABLED={{ams_hbase_fifo_compaction_enabled}}\n"; [EOL] [EOL] String result = (String) updateAmsEnvContent.invoke(upgradeCatalog220, oldContent); [EOL] Assert.assertEquals(expectedContent, result); [EOL] } [EOL]
@Test [EOL] public void isHigherThan() { [EOL] class TestCase extends GameEngineTestHelper.ComparisonTestCase<Contract> { [EOL] [EOL] TestCase(String name, Contract c1, Contract c2, boolean expected) { [EOL] super(name, c1, c2, expected); [EOL] } [EOL] [EOL] @Override [EOL] protected void runAssertions() { [EOL] assertThat(o1.isHigherThan(o2)).as("Check contract is higher").isEqualTo(expected); [EOL] } [EOL] } [EOL] [EOL] List<TestCase> testCases = [EOL] new ArrayList<>( [EOL] List.of( [EOL] new TestCase("capot hearts - null", createCapotContract(Suit.HEARTS), null, true), [EOL] new TestCase( [EOL] "capot hearts - capot hearts", [EOL] createCapotContract(Suit.HEARTS), [EOL] createCapotContract(Suit.HEARTS), [EOL] false), [EOL] new TestCase( [EOL] "generale clubs - generale clubs", [EOL] createGeneraleContract(Suit.CLUBS), [EOL] createGeneraleContract(Suit.CLUBS), [EOL] false), [EOL] new TestCase( [EOL] "capot hearts - capot spades", [EOL] createCapotContract(Suit.HEARTS), [EOL] createCapotContract(Suit.SPADES), [EOL] false), [EOL] new TestCase( [EOL] "capot hearts - generale hearts", [EOL] createCapotContract(Suit.HEARTS), [EOL] createGeneraleContract(Suit.HEARTS), [EOL] false), [EOL] new TestCase( [EOL] "generale hearts - capot diamonds", [EOL] createGeneraleContract(Suit.HEARTS), [EOL] createCapotContract(Suit.DIAMONDS), [EOL] true), [EOL] new TestCase( [EOL] "90 hearts - 90 hearts", [EOL] createPointsContract(90, Suit.HEARTS), [EOL] createPointsContract(90, Suit.HEARTS), [EOL] false), [EOL] new TestCase( [EOL] "130 hearts - 90 hearts", [EOL] createPointsContract(130, Suit.HEARTS), [EOL] createPointsContract(90, Suit.HEARTS), [EOL] true), [EOL] new TestCase( [EOL] "100 spades - 140 clubs", [EOL] createPointsContract(100, Suit.SPADES), [EOL] createPointsContract(140, Suit.CLUBS), [EOL] false), [EOL] new TestCase( [EOL] "110 diamonds - 80 spades", [EOL] createPointsContract(110, Suit.DIAMONDS), [EOL] createPointsContract(80, Suit.SPADES), [EOL] true), [EOL] new TestCase( [EOL] "capot hearts - 100 hearts", [EOL] createCapotContract(Suit.HEARTS), [EOL] createPointsContract(100, Suit.HEARTS), [EOL] true), [EOL] new TestCase( [EOL] "generale hearts - 140 hearts", [EOL] createGeneraleContract(Suit.HEARTS), [EOL] createPointsContract(140, Suit.HEARTS), [EOL] true))); [EOL] testCases.forEach(TestCase::run); [EOL] } [EOL]
@Test [EOL] 	public void testList() { [EOL] 		 [EOL] 		builder.addVar("*").addWhere(builder.list("<one>", "?two", "'three'"), "<foo>", "<bar>"); [EOL] 		Query query = builder.build(); [EOL] [EOL] 		 [EOL] 		Node one = NodeFactory.createURI("one"); [EOL] 		Node two = Var.alloc("two").asNode(); [EOL] 		Node three = NodeFactory.createLiteral( "three"); [EOL] 		Node foo = NodeFactory.createURI("foo"); [EOL] 		Node bar = NodeFactory.createURI("bar"); [EOL] 		 [EOL] 		ElementPathBlock epb = new ElementPathBlock(); [EOL] 		Node firstObject = NodeFactory.createBlankNode();		 [EOL] 		Node secondObject = NodeFactory.createBlankNode(); [EOL] 		Node thirdObject = NodeFactory.createBlankNode(); [EOL] 		 [EOL] 		epb.addTriplePath( new TriplePath( new Triple( firstObject, RDF.first.asNode(), one))); [EOL] 		epb.addTriplePath( new TriplePath( new Triple( firstObject, RDF.rest.asNode(), secondObject))); [EOL] 		epb.addTriplePath( new TriplePath( new Triple( secondObject, RDF.first.asNode(), two))); [EOL] 		epb.addTriplePath( new TriplePath( new Triple( secondObject, RDF.rest.asNode(), thirdObject))); [EOL] 		epb.addTriplePath( new TriplePath( new Triple( thirdObject, RDF.first.asNode(), three))); [EOL] 		epb.addTriplePath( new TriplePath( new Triple( thirdObject, RDF.rest.asNode(), RDF.nil.asNode()))); [EOL] 		epb.addTriplePath( new TriplePath( new Triple( firstObject, foo, bar))); [EOL] 		 [EOL] 		 [EOL] 		WhereValidator visitor = new WhereValidator( epb ); [EOL] 		query.getQueryPattern().visit( visitor ); [EOL] 		assertTrue( visitor.matching ); [EOL] 	} [EOL]
@Test [EOL] public void shouldRollbackCommitAndCloseConnectionIfExceptionIsThrownInExecuteQuery() throws Exception { [EOL] when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement); [EOL] [EOL] final JDBCBase.StatementWithReturnBlock<?> mockStatementWithReturnBlock = mock(JDBCBase.StatementWithReturnBlock.class); [EOL] doThrow(IllegalArgumentException.class).when(mockStatementWithReturnBlock).use(mockPreparedStatement); [EOL] [EOL] initializeJDBCTestSubclass(); [EOL] [EOL] assertThatExceptionIsThrown(new Callable<Void>() { [EOL] [EOL] @Override [EOL] public Void call() throws Exception { [EOL] jdbcTestSubclass.executeQuery("NO SQL", mockStatementWithReturnBlock); [EOL] return null; [EOL] } [EOL] }, IllegalArgumentException.class); [EOL] [EOL] InOrder inOrder = inOrder(mockPreparedStatement, mockConnection); [EOL] inOrder.verify(mockPreparedStatement).close(); [EOL] inOrder.verify(mockConnection).rollback(); [EOL] inOrder.verify(mockConnection).close(); [EOL] } [EOL]
@Test [EOL] public void testLogS3GuardDisabled() throws Exception { [EOL] final Logger localLogger = LoggerFactory.getLogger( [EOL] TestS3Guard.class.toString() + UUID.randomUUID()); [EOL] S3Guard.logS3GuardDisabled(localLogger, [EOL] S3Guard.DisabledWarnLevel.SILENT.toString(), "bucket"); [EOL] S3Guard.logS3GuardDisabled(localLogger, [EOL] S3Guard.DisabledWarnLevel.INFORM.toString(), "bucket"); [EOL] S3Guard.logS3GuardDisabled(localLogger, [EOL] S3Guard.DisabledWarnLevel.WARN.toString(), "bucket"); [EOL] [EOL] // Test that lowercase setting is accepted [EOL] S3Guard.logS3GuardDisabled(localLogger, [EOL] S3Guard.DisabledWarnLevel.WARN.toString() [EOL] .toLowerCase(Locale.US), "bucket"); [EOL] [EOL] ExitUtil.ExitException ex = LambdaTestUtils.intercept( [EOL] ExitUtil.ExitException.class, [EOL] String.format(S3Guard.DISABLED_LOG_MSG, "bucket"), [EOL] () -> S3Guard.logS3GuardDisabled( [EOL] localLogger, S3Guard.DisabledWarnLevel.FAIL.toString(), "bucket")); [EOL] if (ex.getExitCode() != LauncherExitCodes.EXIT_BAD_CONFIGURATION) { [EOL] throw ex; [EOL] } [EOL] LambdaTestUtils.intercept(IllegalArgumentException.class, [EOL] S3Guard.UNKNOWN_WARN_LEVEL, [EOL] () -> S3Guard.logS3GuardDisabled( [EOL] localLogger, "FOO_BAR_LEVEL", "bucket")); [EOL] } [EOL]
@Test [EOL] public void testGetMicroServiceLocationDictionaryEntityData() { [EOL] logger.info("testGetMicroServiceLocationDictionaryEntityData: Entering"); [EOL] [EOL] MockHttpServletResponse response = new MockHttpServletResponse(); [EOL] [EOL] controller.getMicroServiceLocationDictionaryEntityData(response); [EOL] [EOL] try { [EOL] assertTrue(response.getContentAsString() != null [EOL] && response.getContentAsString().contains("microServiceLocationDictionaryDatas")); [EOL] logger.info("response.getContentAsString(): " + response.getContentAsString()); [EOL] } catch (UnsupportedEncodingException e) { [EOL] fail("Exception: " + e); [EOL] } [EOL] [EOL] logger.info("testGetMicroServiceLocationDictionaryEntityData: exit"); [EOL] } [EOL]
@Test(groups = { "unit" }, expectedExceptions = IllegalArgumentException.class) [EOL] public void overlappingRanges2() { [EOL] RoutingMapProviderHelper.getOverlappingRanges(ROUTING_MAP_PROVIDER, "dbs/db1/colls/coll1", [EOL] Arrays.asList(new Range<String>("0A", "0D", true, true), new Range<String>("0D", "0E", true, true))); [EOL] } [EOL]
@Test [EOL] public void testGetSeekPoints_forSeekableInput_forSeekPointAtSyncPosition_return1SeekPoint() { [EOL] constantBitrateSeekMap = [EOL] new ConstantBitrateSeekMap( [EOL] /* inputLength= */ 2_300, [EOL] /* firstFrameBytePosition= */ 100, [EOL] /* bitrate= */ 8_000, [EOL] /* frameSize= */ 100); [EOL] SeekMap.SeekPoints seekPoints = constantBitrateSeekMap.getSeekPoints(/* timeUs= */ 1_200_000); [EOL] // Bitrate = 8000 (bits/s) = 1000 (bytes/s) [EOL] // FrameSize = 100 (bytes), so 1 frame = 1s = 100_000 us [EOL] assertThat(seekPoints.first.timeUs).isEqualTo(1_200_000); [EOL] assertThat(seekPoints.first.position).isEqualTo(1300); [EOL] assertThat(seekPoints.second).isEqualTo(seekPoints.first); [EOL] } [EOL]
@Test [EOL] public void testPathChangedNotNullPathElements() { [EOL] TreePath path = new TreePath(new Object[] {null}); [EOL] try { [EOL] support.firePathChanged(path); [EOL] fail("must not allow null path elements"); [EOL] } catch (NullPointerException e) { [EOL] // expected [EOL] } [EOL] // unexpected exception [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testReadAddressToLow() throws Exception { [EOL] [EOL] address = -1; [EOL] device.read(address, testData); [EOL] } [EOL]
@Test [EOL] public void testRead() { [EOL] assertNotNull(lut1.getMagnitudeGrid5()); [EOL] assertNotNull(lut1.getExponentGrid5()); [EOL] } [EOL]
@Test [EOL] public void testGetPropertyString04() throws Exception { [EOL] // 入力値の設定 [EOL] String input = ""; [EOL] [EOL] // テスト対象の実行 [EOL] String str = PropertyUtil.getProperty(input); [EOL] [EOL] // 結果確認 [EOL] assertNull(str); [EOL] } [EOL]
@Test [EOL] void shouldListPlugins(@TempDir final Path home) throws Exception { [EOL] createConfig(home, "allure-test.yml"); [EOL] [EOL] final ConfigOptions options = mock(ConfigOptions.class); [EOL] when(options.getProfile()).thenReturn("test"); [EOL] final Commands commands = new Commands(home); [EOL] final ExitCode exitCode = commands.listPlugins(options); [EOL] [EOL] assertThat(exitCode) [EOL] .isEqualTo(ExitCode.NO_ERROR); [EOL] } [EOL]
@Test [EOL] public void testCompile_ErrorForNamedAlignField() throws Exception { [EOL] assertThrows(JBBPCompilationException.class, () -> JBBPCompiler.compile("align hello;")); [EOL] } [EOL]
@Test [EOL] public void testInstantiate_typeConstructor() { [EOL] Transformer<List<?>, Type> serializer; [EOL] serializer = [EOL] Serializers.instantiate(ListToTypeSerializer.class, TypeToken.of(ImmutableList.class)); [EOL] assertEquals(ImmutableList.class, serializer.transformTo(ImmutableList.of())); [EOL] Type typeWithGeneric = new TypeToken<List<?>>() {}.getType(); [EOL] serializer = Serializers.instantiate(ListToTypeSerializer.class, TypeToken.of(typeWithGeneric)); [EOL] assertEquals(typeWithGeneric, serializer.transformTo(ImmutableList.of())); [EOL] assertEquals(ImmutableList.of(typeWithGeneric), serializer.transformFrom(List.class)); [EOL] try { [EOL] Serializers.instantiate(ListToTypeSerializer.class, TypeToken.of(Collection.class)); [EOL] fail("Shouldn't be able to instantiate with Collection"); [EOL] } catch (IllegalArgumentException e) { [EOL] // expected [EOL] } [EOL] } [EOL]
@Test [EOL] public void issue12_testGetPageUrl_criteriaQueryIsSpecified_queryTmplNotSpecified() { [EOL] PaginationInfo info = new PaginationInfo(page, "/{page}/{size}", null, "a=<>&\"'a1", false, 10); [EOL] [EOL] // expected [EOL] String expectedURL = "/3/5?a=&lt;&gt;&amp;&quot;&#39;a1"; [EOL] [EOL] // assert [EOL] // That the question-mark(?) is append [EOL] assertThat(info.getPageUrl(3), is(expectedURL)); [EOL] } [EOL]
@Test [EOL] void constructor17() { [EOL] final Supplier<MutableTuple17<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>> constructor = MutableTuples.constructor(Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class, Integer.class); [EOL] test(constructor.get()); [EOL] } [EOL]
@Test [EOL] void pushLevelProgress() [EOL] { [EOL] this.progress.pushLevelProgress(this); [EOL] [EOL] verify(this.observation).notify(new PushLevelProgressEvent(), this); [EOL] [EOL] this.progress.pushLevelProgress(42, this); [EOL] [EOL] verify(this.observation).notify(new PushLevelProgressEvent(42), this); [EOL] } [EOL]
@Test(expectedExceptions = IllegalArgumentException.class) [EOL] public void testGetAttributeOtherStoreColumn() { [EOL] GraphStore otherStore = new GraphStore(); [EOL] Column column = generateBasicColumn(otherStore); [EOL] GraphStore store = new GraphStore(); [EOL] [EOL] NodeImpl node = new NodeImpl("0", store); [EOL] node.getAttribute(column); [EOL] } [EOL]
@Test [EOL] public void testSpdyPingFrame() throws Exception { [EOL] short type = 6; [EOL] byte flags = 0; [EOL] int length = 4; [EOL] int id = RANDOM.nextInt(); [EOL] [EOL] ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length); [EOL] encodeControlFrameHeader(buf, type, flags, length); [EOL] buf.writeInt(id); [EOL] [EOL] decoder.decode(buf); [EOL] verify(delegate).readPingFrame(id); [EOL] assertFalse(buf.isReadable()); [EOL] buf.release(); [EOL] } [EOL]
@Test [EOL] public void encodeMd5StrAndBase64() throws Exception { [EOL] String origin = "a12345678"; [EOL] String result = Coder.encodeMd5StrAndBase64(origin); [EOL] logger.info("encodeMd5StrAndBase64, origin: [{}], result: [{}]", origin, result); [EOL] } [EOL]
@Test [EOL] public void testReadNumberOfBeats() throws Exception { [EOL] instance.openFile(simpleFile); [EOL] Mockito.verify(listener).readNumberOfBeats(0, 0, 4); [EOL] Mockito.verify(listener).readNumberOfBeats(0, 1, 1); // this beat can be empty [EOL] [EOL] Mockito.verify(listener).readNumberOfBeats(0, 2, 1); [EOL] [EOL] } [EOL]
@Test [EOL] void multiplicationWithBigDecimalAsSecondArg() { [EOL] final BigDecimal result = BigDecimalCalculator.times(2, BigDecimal.valueOf(3)); [EOL] assertThat(result).isEqualTo(new BigDecimal("6")); [EOL] } [EOL]
@Test [EOL] public void close() throws Exception { [EOL] underTest.init(1L, rebalanceListener); [EOL] underTest.close(); [EOL] [EOL] verify(consumer).close(); [EOL] } [EOL]
@SuppressWarnings("unchecked") [EOL] @Test [EOL] public void shouldReturnErrorMessageOnError() throws JMSException { [EOL] when(message.getText()).thenThrow(JMSException.class); [EOL] [EOL] assertThat(jmsMessageLoggerHelper.toJmsTraceString(message), containsString("Could not find: _metadata in message")); [EOL] } [EOL]
@Test [EOL] public void testInit() throws Exception { [EOL] global = new Global(); [EOL] // Method to test [EOL] DefaultTagable tags = new DefaultTagable(); [EOL] tags.setTag(GlobalTag.patientId.tagW, GlobalTag.patientId.value); [EOL] tags.setTag(GlobalTag.patientName.tagW, GlobalTag.patientName.value); [EOL] tags.setTag(GlobalTag.issuerOfPatientId.tagW, GlobalTag.issuerOfPatientId.value); [EOL] tags.setTag(GlobalTag.patientBirthDate.tagW, GlobalTag.patientBirthDate.value); [EOL] tags.setTag(GlobalTag.patientSex.tagW, GlobalTag.patientSex.value); [EOL] tags.setTag(GlobalTag.studyDate.tagW, GlobalTag.studyDate.value); [EOL] tags.setTag(GlobalTag.modality.tagW, GlobalTag.modality.value); [EOL] global.init(tags); [EOL] [EOL] // Tests [EOL] assertThat(global.getTagEntrySet()).hasSize(8); [EOL] } [EOL]
@Test [EOL] public void testLog_timeAndFields_messageProvided() { [EOL] Map<String, String> fields = new HashMap<>(); [EOL] fields.put(LOG_KEY_MESSAGE, "my-key-message"); [EOL] fields.put("foo", "bar"); [EOL] [EOL] Span result = undertest.log(100L, fields); [EOL] [EOL] assertSame(result, undertest); [EOL] assertEquals(1, grpcSpan.getLogsCount()); [EOL] Log logRecord = grpcSpan.getLogs(0); [EOL] Map<String, String> fieldMap = getLogFieldMap(logRecord); [EOL] assertEquals("my-key-message", fieldMap.get(LOG_KEY_MESSAGE)); [EOL] assertEquals("bar", fieldMap.get("foo")); [EOL] assertEquals(100L, Util.protoTimeToEpochMicros(logRecord.getTimestamp())); [EOL] } [EOL]
@Test [EOL] public void testServiceDeletion() { [EOL] StackInfo stack = stackManager.getStack("HDP", "2.0.6"); [EOL] Collection<ServiceInfo> allServices = stack.getServices(); [EOL] [EOL] assertEquals(12, allServices.size()); [EOL] HashSet<String> expectedServices = new HashSet<String>(); [EOL] expectedServices.add("GANGLIA"); [EOL] expectedServices.add("HBASE"); [EOL] expectedServices.add("HCATALOG"); [EOL] expectedServices.add("HDFS"); [EOL] expectedServices.add("HIVE"); [EOL] expectedServices.add("MAPREDUCE2"); [EOL] expectedServices.add("OOZIE"); [EOL] expectedServices.add("PIG"); [EOL] expectedServices.add("SPARK"); [EOL] expectedServices.add("ZOOKEEPER"); [EOL] expectedServices.add("FLUME"); [EOL] expectedServices.add("YARN"); [EOL] [EOL] for (ServiceInfo service : allServices) { [EOL] assertTrue(expectedServices.remove(service.getName())); [EOL] } [EOL] assertTrue(expectedServices.isEmpty()); [EOL] } [EOL]
@Test [EOL] public void testValue() throws Exception { [EOL] // Given [EOL] ServicePropertyInfo p = getServiceProperty(XML); [EOL] [EOL] // When [EOL] String value = p.getValue(); [EOL] [EOL] // Then [EOL] assertEquals("prop_value", value); [EOL] } [EOL]
@Test [EOL] public void testRelease1_2_0() { [EOL] assertTrue(NameNodeLayoutVersion.supports(LayoutVersion.Feature.CONCAT, [EOL] Feature.RESERVED_REL1_2_0.getInfo().getLayoutVersion())); [EOL] } [EOL]
@Test [EOL] public void compareArgumentType3() { [EOL] List<String> arg1 = new ArrayList<>(); [EOL] arg1.add("boolean"); [EOL] arg1.add("java.lang.String"); [EOL] List<String> arg2 = new ArrayList<>(); [EOL] arg2.add("boolean"); [EOL] arg2.add("java.lang.String[]"); [EOL] boolean b = ClassNameUtils.compareArgumentType(arg1, arg2, true); [EOL] assertEquals(true, b); [EOL] } [EOL]
@Test [EOL] 	public void testPathInterpreterFailure() throws Exception { [EOL] 		Mockito.when( [EOL] 			_pathInterpreter.interpretPath(Mockito.anyString()) [EOL] 		).thenThrow( [EOL] 			AMRuntimeException.class [EOL] 		); [EOL] [EOL] 		HttpServletRequest httpServletRequest = Mockito.mock( [EOL] 			HttpServletRequest.class); [EOL] [EOL] 		Optional<AdaptiveMedia<AMImageProcessor>> adaptiveMediaOptional = [EOL] 			_amImageRequestHandler.handleRequest(httpServletRequest); [EOL] [EOL] 		Assert.assertFalse(adaptiveMediaOptional.isPresent()); [EOL] 	} [EOL]
@Test [EOL] public void setCellGridOnly() { [EOL] abstractScesimGridModelSpy.setCellGridOnly(ROW_INDEX, COLUMN_INDEX, gridCellSupplier); [EOL] verify(abstractScesimGridModelSpy, times(1)).checkSimulation(); [EOL] } [EOL]
@Test [EOL] public void dictsToTrie_null_should_return_null() throws Exception { [EOL] assertThat(Utils.dictsToTrie(null), nullValue()); [EOL] } [EOL]
@Test [EOL] public void testToString() throws Exception { [EOL] PhivePriorityResult result = new PhivePriorityResult(2263, "FGFR2", 0.827862024307251, geneModelPhenotypeMatch); [EOL] assertThat(result.toString(), startsWith("PhivePriorityResult{geneId=2263, geneSymbol='FGFR2', score=0.827862024307251")); [EOL] } [EOL]
@Test [EOL] public void testPREPARE_TEMPLATES() throws Exception [EOL] { [EOL] workflow.PREPARE_TEMPLATES(); [EOL] [EOL] verify( environmentManager ).update( environment ); [EOL] } [EOL]
@Test [EOL] public void testGetFactCallsDelegate() throws Exception { [EOL] FactGetByIdDelegate delegate = mock(FactGetByIdDelegate.class); [EOL] when(delegateProvider.get(FactGetByIdDelegate.class)).thenReturn(delegate); [EOL] [EOL] GetFactByIdRequest request = new GetFactByIdRequest(); [EOL] service.getFact(RequestHeader.builder().build(), request); [EOL] verify(delegate).handle(request); [EOL] } [EOL]
@Test [EOL] 	public void testByteConstructor() { [EOL] 		assertEquals((short) 123, i1.getData()); [EOL] [EOL] 		assertEquals("{\"data\":123}", i1.toString()); [EOL] [EOL] 		assertEquals(1, i1.toJsonObject().size()); [EOL] 		assertEquals( [EOL] 				(short) 123, [EOL] 				Primitive.toUInt16((short) i1.toJsonObject().getInt( [EOL] 						UInt16.FIELD_DATA))); [EOL] [EOL] 		assertEquals(UInt16.TYPE, i1.getMessageType()); [EOL] 	} [EOL]
@Test [EOL] public void simpleObject() throws IOException { [EOL] String obj = "{\"name\":\"value\",\"int\":1302,\"float\":1.57," [EOL] + "\"negint\":-5,\"negfloat\":-1.57,\"floatexp\":-1.5e7}"; [EOL] JsonLexer l = new JsonLexer(new StringReader(obj)); [EOL] JsonParser p = new JsonParser(l); [EOL] Map<String, Object> m = p.parseObject(); [EOL] [EOL] assertEquals(6, m.size()); [EOL] assertEquals("value", m.get("name")); [EOL] assertEquals(1302L, m.get("int")); [EOL] assertEquals(1.57, m.get("float")); [EOL] assertEquals(-5L, m.get("negint")); [EOL] assertEquals(-1.57, m.get("negfloat")); [EOL] assertEquals(-1.5e7, m.get("floatexp")); [EOL] } [EOL]
@Test [EOL] public void testCacheUnknownLengthPartialCaching() throws Exception { [EOL] FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data") [EOL] .setSimulateUnknownLength(true) [EOL] .appendReadData(TestUtil.buildTestData(100)).endData(); [EOL] FakeDataSource dataSource = new FakeDataSource(fakeDataSet); [EOL] [EOL] Uri testUri = Uri.parse("test_data"); [EOL] DataSpec dataSpec = new DataSpec(testUri, 10, 20, null); [EOL] CachingCounters counters = new CachingCounters(); [EOL] CacheUtil.cache( [EOL] dataSpec, cache, /* cacheKeyFactory= */ null, dataSource, counters, /* isCanceled= */ null); [EOL] [EOL] counters.assertValues(0, 20, 20); [EOL] counters.reset(); [EOL] [EOL] CacheUtil.cache( [EOL] new DataSpec(testUri), [EOL] cache, [EOL] /* cacheKeyFactory= */ null, [EOL] dataSource, [EOL] counters, [EOL] /* isCanceled= */ null); [EOL] [EOL] counters.assertValues(20, 80, 100); [EOL] assertCachedData(cache, fakeDataSet); [EOL] } [EOL]
@Test [EOL] public void getSpecificUsedYangModuleBbfFast() throws Exception { [EOL] executeLibCheckTest("get-specific-used-yang-module-bbf-fast-response.xml", [EOL] document -> libInfoChecker.getSpecificUsedYangModules( [EOL] "bbf-fast", "2017-03-13", document)); [EOL] } [EOL]
@Test [EOL] 	public void testRethrowFatalError() { [EOL] 		// fatal error is rethrown [EOL] 		try { [EOL] 			ExceptionUtils.rethrowIfFatalError(new InternalError()); [EOL] 			fail(); [EOL] 		} catch (InternalError ignored) {} [EOL] [EOL] 		// non-fatal error is not rethrown [EOL] 		ExceptionUtils.rethrowIfFatalError(new NoClassDefFoundError()); [EOL] 	} [EOL]
@Test [EOL] public void show() { [EOL] deletePopupPresenter.show(MAIN_TITLE_TEXT, [EOL] MAIN_QUESTION_TEXT, [EOL] TEXT1_TEXT, [EOL] TEXT_QUESTION_TEXT, [EOL] TEXT_DANGER_TEXT, [EOL] OKDELETE_BUTTON_TEXT, [EOL] okDeleteCommandMock); [EOL] verify(deletePopupViewMock, times(1)).show(eq(MAIN_TITLE_TEXT), eq(MAIN_QUESTION_TEXT), eq(TEXT1_TEXT), eq(TEXT_QUESTION_TEXT), eq(TEXT_DANGER_TEXT), eq(OKDELETE_BUTTON_TEXT), eq(okDeleteCommandMock)); [EOL] } [EOL]
@Test [EOL] public void setRightController_setHeightAndWidthWithOptions() { [EOL] SideMenuOptions options = new SideMenuOptions(); [EOL] options.height = new Number(100); [EOL] options.width = new Number(200); [EOL] uut.options.sideMenuRootOptions.left = options; [EOL] [EOL] SimpleComponentViewController componentViewController = new SimpleComponentViewController(activity, childRegistry, "left", new Options()); [EOL] uut.setLeftController(componentViewController); [EOL] [EOL] int heightInDp = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 100, Resources.getSystem().getDisplayMetrics()); [EOL] int widthInDp = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 200, Resources.getSystem().getDisplayMetrics()); [EOL] [EOL] LayoutParams params = componentViewController.getView().getLayoutParams(); [EOL] assertThat(params.width).isEqualTo(widthInDp); [EOL] assertThat(params.height).isEqualTo(heightInDp); [EOL] } [EOL]
@Test [EOL] public void equalsMakesSense() { [EOL] Id id1 = Id.makeRandom(); [EOL] assertEquals(id1, id1); [EOL] } [EOL]
@Test(expected = ParseException.class) [EOL] public void testFailParse8() throws ParseException { [EOL] LinkFormatBuilder.parse("</fds>;obs=\"true\""); [EOL] } [EOL]
@Test [EOL] public void testRemove() { [EOL] Map<String, String> map = new FastMap<>(); [EOL] map.put("foo", "bar"); [EOL] map.remove("foo"); [EOL] assertEquals(0, map.size()); [EOL] assertTrue(map.isEmpty()); [EOL] assertNull(map.get("foo")); [EOL] } [EOL]
@Test [EOL] void testRequireNonPositive2() { [EOL] assertThrows(RuntimeException.class, () -> DoubleRangeUtil.requireNonPositive(1.0, RuntimeException::new)); [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("all") [EOL] public void getFeedMappingTest() { [EOL] com.google.ads.googleads.v5.services.FeedMappingName resourceName2 = [EOL] com.google.ads.googleads.v5.services.FeedMappingName.of("[CUSTOMER]", "[FEED_MAPPING]"); [EOL] FeedMapping expectedResponse = [EOL] FeedMapping.newBuilder().setResourceName(resourceName2.toString()).build(); [EOL] mockFeedMappingService.addResponse(expectedResponse); [EOL] [EOL] FeedMappingName resourceName = FeedMappingName.of("[CUSTOMER]", "[FEED_MAPPING]"); [EOL] [EOL] FeedMapping actualResponse = client.getFeedMapping(resourceName); [EOL] Assert.assertEquals(expectedResponse, actualResponse); [EOL] [EOL] List<AbstractMessage> actualRequests = mockFeedMappingService.getRequests(); [EOL] Assert.assertEquals(1, actualRequests.size()); [EOL] GetFeedMappingRequest actualRequest = (GetFeedMappingRequest) actualRequests.get(0); [EOL] [EOL] Assert.assertEquals(resourceName, FeedMappingName.parse(actualRequest.getResourceName())); [EOL] Assert.assertTrue( [EOL] channelProvider.isHeaderSent( [EOL] ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), [EOL] GaxGrpcProperties.getDefaultApiClientHeaderPattern())); [EOL] } [EOL]
@Test [EOL] public void testCheckEverythingWrongGetsMadeRightMoreInsanity() { [EOL] analysisSteps.add(INHERITANCE_FILTER); [EOL] analysisSteps.add(PHIVE_PRIORITISER); [EOL] analysisSteps.add(OMIM_PRIORITISER); [EOL] analysisSteps.add(FREQUENCY_FILTER); [EOL] analysisSteps.add(NONE_TYPE_PRIORITY_SCORE_FILTER); [EOL] analysisSteps.add(PHIVE_PRIORITY_SCORE_FILTER); [EOL] analysisSteps.add(KNOWN_VARIANT_FILTER); [EOL] analysisSteps.add(OMIM_PRIORITY_SCORE_FILTER); [EOL] [EOL] expectedSteps.add(PHIVE_PRIORITISER); [EOL] expectedSteps.add(PHIVE_PRIORITY_SCORE_FILTER); [EOL] expectedSteps.add(FREQUENCY_FILTER); [EOL] expectedSteps.add(KNOWN_VARIANT_FILTER); [EOL] expectedSteps.add(INHERITANCE_FILTER); [EOL] expectedSteps.add(OMIM_PRIORITISER); [EOL] expectedSteps.add(OMIM_PRIORITY_SCORE_FILTER); [EOL] [EOL] assertThat(instance.check(analysisSteps), equalTo(expectedSteps)); [EOL] } [EOL]
@Test [EOL] public void testHtmlProcessorTarget() { [EOL] PolicySetType mockPolicySetType = Mockito.mock(PolicySetType.class); [EOL] processor = new HtmlProcessor(temp, mockPolicySetType); [EOL] [EOL] processor.target(null); [EOL] [EOL] AnyOfType mockAnyOfType = Mockito.mock(AnyOfType.class); [EOL] List<AnyOfType> anyOfList = new ArrayList<AnyOfType>(); [EOL] anyOfList.add(mockAnyOfType); [EOL] anyOfList.add(mockAnyOfType); // adding duplicate element [EOL] [EOL] AllOfType mockAllOfType = Mockito.mock(AllOfType.class); [EOL] List<AllOfType> allOfTypeList = new ArrayList<AllOfType>(); [EOL] allOfTypeList.add(mockAllOfType); [EOL] allOfTypeList.add(mockAllOfType); // adding duplicate element [EOL] [EOL] MatchType mockMatchType = Mockito.mock(MatchType.class); [EOL] List<MatchType> matchTypeList = new ArrayList<MatchType>(); [EOL] matchTypeList.add(mockMatchType); [EOL] matchTypeList.add(mockMatchType); // adding duplicate element [EOL] [EOL] AttributeValueType mockAttrValType = Mockito.mock(AttributeValueType.class); [EOL] AttributeDesignatorType mockAttrDesType = Mockito.mock(AttributeDesignatorType.class); [EOL] AttributeSelectorType mockAttrSelType = Mockito.mock(AttributeSelectorType.class); [EOL] [EOL] List<Object> contentList = new ArrayList<Object>(); [EOL] [EOL] when(mockAnyOfType.getAllOf()).thenReturn(allOfTypeList); [EOL] when(mockAllOfType.getMatch()).thenReturn(matchTypeList); [EOL] when(mockMatchType.getAttributeValue()).thenReturn(mockAttrValType); [EOL] when(mockMatchType.getMatchId()).thenReturn(XACML1.ID_FUNCTION_STRING_EQUAL.stringValue()); [EOL] when(mockMatchType.getAttributeDesignator()).thenReturn(mockAttrDesType); [EOL] when(mockAttrValType.getDataType()).thenReturn(""); [EOL] when(mockAttrValType.getContent()).thenReturn(contentList); [EOL] when(mockAttrDesType.getCategory()).thenReturn(""); [EOL] when(mockAttrDesType.getAttributeId()).thenReturn(""); [EOL] when(mockAttrDesType.getIssuer()).thenReturn(""); [EOL] when(mockAttrDesType.getDataType()).thenReturn(""); [EOL] processor.target(anyOfList); [EOL] verify(mockAnyOfType, atLeast(1)).getAllOf(); [EOL] verify(mockAllOfType, atLeast(1)).getMatch(); [EOL] verify(mockMatchType, atLeast(1)).getAttributeValue(); [EOL] verify(mockMatchType, atLeast(1)).getMatchId(); [EOL] verify(mockMatchType, atLeast(1)).getAttributeDesignator(); [EOL] verify(mockAttrValType, atLeast(1)).getDataType(); [EOL] verify(mockAttrValType, atLeast(1)).getContent(); [EOL] verify(mockAttrDesType, atLeast(1)).getCategory(); [EOL] verify(mockAttrDesType, atLeast(1)).getAttributeId(); [EOL] verify(mockAttrDesType, atLeast(1)).getIssuer(); [EOL] verify(mockAttrDesType, atLeast(1)).getDataType(); [EOL] [EOL] when(mockMatchType.getAttributeDesignator()).thenReturn(null); [EOL] when(mockMatchType.getAttributeSelector()).thenReturn(mockAttrSelType); [EOL] when(mockAttrSelType.getCategory()).thenReturn(""); [EOL] when(mockAttrSelType.getContextSelectorId()).thenReturn(""); [EOL] when(mockAttrSelType.getDataType()).thenReturn(""); [EOL] processor.target(anyOfList); [EOL] verify(mockMatchType, atLeast(1)).getAttributeDesignator(); [EOL] verify(mockMatchType, atLeast(1)).getAttributeSelector(); [EOL] verify(mockAttrSelType, atLeast(1)).getCategory(); [EOL] verify(mockAttrSelType, atLeast(1)).getContextSelectorId(); [EOL] verify(mockAttrSelType, atLeast(1)).getDataType(); [EOL] [EOL] when(mockMatchType.getAttributeDesignator()).thenReturn(null); [EOL] when(mockMatchType.getAttributeSelector()).thenReturn(null); [EOL] processor.target(anyOfList); [EOL] verify(mockMatchType, atLeast(1)).getAttributeDesignator(); [EOL] verify(mockMatchType, atLeast(1)).getAttributeSelector(); [EOL] } [EOL]
@Test [EOL] public void sqrt_missing_value() { [EOL] FunctionExpression sqrt = dsl.sqrt(DSL.ref(INT_TYPE_MISSING_VALUE_FIELD, INTEGER)); [EOL] assertEquals(DOUBLE, sqrt.type()); [EOL] assertTrue(sqrt.valueOf(valueEnv()).isMissing()); [EOL] } [EOL]
@Test [EOL] 	public void testFunctionInputInOutputMultipleTimes() { [EOL] 		RichMapFunction<Float, ?> function = new FieldDuplicator<Float>(); [EOL] [EOL] 		TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, BasicTypeInfo.FLOAT_TYPE_INFO); [EOL] [EOL] 		Assert.assertTrue(ti.isTupleType()); [EOL] 		Assert.assertEquals(2, ti.getArity()); [EOL] 		TupleTypeInfo<?> tti = (TupleTypeInfo<?>) ti; [EOL] 		Assert.assertEquals(BasicTypeInfo.FLOAT_TYPE_INFO, tti.getTypeAt(0)); [EOL] 		Assert.assertEquals(BasicTypeInfo.FLOAT_TYPE_INFO, tti.getTypeAt(1)); [EOL] 	} [EOL]
@Test [EOL] void toTuple5() { [EOL] final Function<Integer, Tuple5<Integer, Integer, Integer, Integer, Integer>> mapper = Tuples.toTuple(i -> i + 0, i -> i + 1, i -> i + 2, i -> i + 3, i -> i + 4); [EOL] assertTuple(mapper.apply(0), 5); [EOL] } [EOL]
@Test [EOL] public void checkNotAcceptNonGraphPath() { [EOL] final Path path = mock( Path.class ); [EOL] when( path.getFileName() ).thenReturn( "a-file.txt" ); [EOL] assertFalse( type.accept( path ) ); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void testAdjacentHashThrowsExceptionGivenBlankHash() { [EOL] GeoHash.adjacentHash("", Direction.RIGHT); [EOL] } [EOL]
@Test [EOL] public void testParseOutputSettingsUnsupportedOutputFormatDefaultsToHtml() { [EOL] OutputSettings outputSettings = instance.parseOutputSettings( [EOL] "outputOptions:\n" [EOL] + " outputPassVariantsOnly: true\n" [EOL] + " numGenes: 1\n" [EOL] + " outputPrefix: results/Pfeiffer-hiphive\n" [EOL] + " outputFormats: [WIBBLE!]\n"); [EOL] Set<OutputFormat> outputFormats = EnumSet.of(OutputFormat.HTML); [EOL] assertThat(outputSettings.getOutputFormats(), equalTo((outputFormats))); [EOL] } [EOL]
@Test [EOL] public void testExecuteActionsOnViews_text_tagList() throws Exception { [EOL] Controller controller = spy(new Controller()); [EOL] [EOL] TextView textView = mock(TextView.class); [EOL] doReturn("$user.name").when(textView).getText(); [EOL] [EOL] List<CarpaccioAction> actions = new ArrayList<>(); [EOL] actions.add(new CarpaccioAction("setFont(font)")); [EOL] [EOL] doReturn(actions).when(textView).getTag(); [EOL] [EOL] carpaccioManager.carpaccioViews.add(textView); [EOL] carpaccioManager.registerControllers.add(controller); [EOL] [EOL] carpaccioManager.executeActionsOnViews(); [EOL] [EOL] List<CarpaccioAction> expected = new ArrayList<>(); [EOL] expected.add(new CarpaccioAction("setFont(font)")); [EOL] expected.add(new CarpaccioAction("setText($user.name)")); [EOL] [EOL] assertEquals(expected,textView.getTag()); [EOL] } [EOL]
@Test [EOL] void shouldSupportReturnQueryKeysMultipleTimes() throws Throwable [EOL] { [EOL] // Given [EOL] RunResponseHandler runHandler = newRunResponseHandler(); [EOL] List<String> expected = asList( "key1", "key2", "key3" ); [EOL] runHandler.onSuccess( Collections.singletonMap( "fields", value( expected ) ) ); [EOL] [EOL] PullResponseHandler pullHandler = mock( PullResponseHandler.class ); [EOL] [EOL] // When [EOL] RxResultCursor cursor = new RxResultCursorImpl( runHandler, pullHandler ); [EOL] [EOL] // Then [EOL] List<String> actual = cursor.keys(); [EOL] assertEquals( expected, actual ); [EOL] [EOL] // Many times [EOL] actual = cursor.keys(); [EOL] assertEquals( expected, actual ); [EOL] [EOL] actual = cursor.keys(); [EOL] assertEquals( expected, actual ); [EOL] } [EOL]
@Test [EOL] void testIsSymbolic() { [EOL] assertThat(AllelePosition.of(4477084, "C", "<DEL:ME:ALU>").isSymbolic(), is(true)); [EOL] assertThat(AllelePosition.of(321681, "G", "G]17:198982]").isSymbolic(), is(true)); [EOL] assertThat(AllelePosition.of(0, "N", ".[13 : 123457[").isSymbolic(), is(true)); [EOL] assertThat(AllelePosition.of(0, "C", "C.").isSymbolic(), is(true)); [EOL] // Having a symbolic ref allele isn't mention in the VCF 4.2 spec, but we'll make sure though [EOL] assertThat(AllelePosition.of(4477084, "<INS>", "A").isSymbolic(), is(true)); [EOL] [EOL] } [EOL]
@Test [EOL] public void testCollectAndSortFeatureTypesToExport_LimitedConfiguredFeatureTypes() { [EOL] List<FeatureType> featureTypes = featureTypes(); [EOL] StoredQueryHandler storedQueryHandler = new StoredQueryHandler( mockWFS( featureTypes ), new ArrayList<URL>(), [EOL] managedStoredQueries ); [EOL] [EOL] List<QName> configuredFeatureTypeNames = configuredFeatureTypeNames(); [EOL] List<QName> featureTypeNamesToExport = storedQueryHandler.collectAndSortFeatureTypesToExport( configuredFeatureTypeNames ); [EOL] [EOL] assertThat( featureTypeNamesToExport.size(), is( 1 ) ); [EOL] [EOL] QName featureTypeNameToExport = featureTypeNamesToExport.get( 0 ); [EOL] assertThat( featureTypeNameToExport.getLocalPart(), is( "one" ) ); [EOL] assertThat( featureTypeNameToExport.getNamespaceURI(), is( "" ) ); [EOL] assertThat( featureTypeNameToExport.getPrefix(), is( "" ) ); [EOL] } [EOL]
@Test [EOL] public void multipleElementsDots() { [EOL] Path path = KeyPathParser.parse("$.a.bc.d"); [EOL] assertThat(path.elements().size(), is(4)); [EOL] assertThat(path.elements().get(0).isRoot(), is(true)); [EOL] assertThat(path.elements().get(0).id(), is("$")); [EOL] assertThat(path.elements().get(1).isRoot(), is(false)); [EOL] assertThat(path.elements().get(1).id(), is("a")); [EOL] assertThat(path.elements().get(2).isRoot(), is(false)); [EOL] assertThat(path.elements().get(2).id(), is("bc")); [EOL] assertThat(path.elements().get(3).isRoot(), is(false)); [EOL] assertThat(path.elements().get(3).id(), is("d")); [EOL] } [EOL]
@Test [EOL] public void testInvalidNumPercentage() throws Exception { [EOL] expectInvalidResourcePercentage("cpu"); [EOL] parseResourceConfigValue("95A% cpu, 50% memory"); [EOL] } [EOL]
@Test [EOL] public void testProcessActionSameActionAndResult02() { [EOL] // Set mock behavior [EOL] // for Spring3 [EOL] when(requestDataValueProcessor.processAction(any( [EOL] HttpServletRequest.class), anyString())).thenReturn("action"); [EOL] // for Spring4 [EOL] when(requestDataValueProcessor.processAction(any( [EOL] HttpServletRequest.class), anyString(), anyString())) [EOL] .thenReturn("action"); [EOL] String result = compositeRequestDataValueProcessor.processAction( [EOL] request, "action", "method"); [EOL] [EOL] // assert [EOL] assertThat(result, is("action")); [EOL] } [EOL]
@Test [EOL] 	public void testCreationWithArgs() throws Exception { [EOL] 		 [EOL] 		Resource r = model.createResource( "http://apache.org/jena/permissions/test#secModel2"); [EOL] 		Object o = assembler.open( r ); [EOL] 		Assert.assertTrue( o instanceof Model); [EOL] 		Assert.assertTrue( o instanceof SecuredModel ); [EOL] 	} [EOL]
@Test [EOL] public void testReload() throws Exception { [EOL] WXModuleManager.reload(); [EOL] } [EOL]
@Test [EOL] public void testNth() throws RecognitionException { [EOL] CommonTree sink = FlumeBuilder.parseSink(simple); [EOL] PatternMatch pp = kind("DECO").nth( [EOL] 1, [EOL] kind("DECO") [EOL] .child(kind("SINK").child(var("node", kind("logicalNode"))))); [EOL] [EOL] Map<String, CommonTree> m = pp.match(sink); [EOL] assertNotNull(m); [EOL] assertEquals(m.get("node").getText(), "logicalNode"); [EOL] dumpMatches(m); [EOL] LOG.info(m); [EOL] [EOL] // This will attempt to match logicalNode to batch, which will fail [EOL] pp = kind("DECO").nth(0, [EOL] kind("SINK").child(var("node", kind("logicalNode")))); [EOL] m = pp.match(sink); [EOL] assertNull(m); [EOL] dumpMatches(m); [EOL] LOG.info(m); [EOL] [EOL] } [EOL]
@Test [EOL] void putByte() { [EOL] instance.putByte(User.BYTE_FIELD); [EOL] assertContainsWhenRendered(BYTE); [EOL] } [EOL]
@Test [EOL] public void testOverwriteFile() throws IOException { [EOL] assertTrue("Creating empty dst file", DST_FILE.createNewFile()); [EOL] [EOL] OutputStream fos = new AtomicFileOutputStream(DST_FILE); [EOL] [EOL] assertTrue("Empty file still exists", DST_FILE.exists()); [EOL] fos.write(TEST_STRING.getBytes()); [EOL] fos.flush(); [EOL] [EOL] // Original contents still in place [EOL] assertEquals("", DFSTestUtil.readFile(DST_FILE)); [EOL] [EOL] fos.close(); [EOL] [EOL] // New contents replace original file [EOL] String readBackData = DFSTestUtil.readFile(DST_FILE); [EOL] assertEquals(TEST_STRING, readBackData); [EOL] } [EOL]
@Test [EOL] public void testLoadMap() throws Exception { [EOL] // These are just to allow initialization that's why i'm not connecting them [EOL] OutputStream os = new PipedOutputStream(); [EOL] InputStream is = new PipedInputStream(); [EOL] PB840Parameters pb840 = new PB840Parameters(is,os); [EOL] Map<String, PB840Parameters.Field[]> fields = new HashMap<String, PB840Parameters.Field[]>(); [EOL] pb840.loadFields(fields); [EOL] for(String key : fields.keySet()) { [EOL] System.out.println(key); [EOL] for(PB840Parameters.Field f : fields.get(key)) { [EOL] System.out.println("\t"+f); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void testAddMonitoringOperation() throws Exception { [EOL] monitoringManager.addMonitoringOperation(deviceMgtService.getAllDevices()); [EOL] } [EOL]
@Test [EOL] public void testFillVirtualEdges() [EOL] { [EOL] initGraph(g); [EOL] g.getNodeAccess().setNode(3, 0, 1); [EOL] g.edge(1, 3); [EOL] [EOL] final int baseNode = 1; [EOL] EdgeIterator iter = g.createEdgeExplorer().setBaseNode(baseNode); [EOL] iter.next(); [EOL] QueryResult res1 = createLocationResult(2, 1.7, iter, 1, PILLAR); [EOL] QueryGraph queryGraph = new QueryGraph(g) [EOL] { [EOL] [EOL] @Override [EOL] void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl ) [EOL] { [EOL] super.fillVirtualEdges(node2Edge, towerNode, mainExpl); [EOL] // ignore nodes should include baseNode == 1 [EOL] if (towerNode == 3) [EOL] assertEquals("[3->4]", node2Edge.get(towerNode).toString()); [EOL] else if (towerNode == 1) [EOL] assertEquals("[1->4, 1 1-0]", node2Edge.get(towerNode).toString()); [EOL] else [EOL] throw new IllegalStateException("not allowed " + towerNode); [EOL] } [EOL] }; [EOL] queryGraph.lookup(Arrays.asList(res1)); [EOL] EdgeIteratorState state = GHUtility.getEdge(queryGraph, 0, 1); [EOL] assertEquals(4, state.fetchWayGeometry(3).size()); [EOL] [EOL] // fetch virtual edge and check way geometry [EOL] state = GHUtility.getEdge(queryGraph, 4, 3); [EOL] assertEquals(2, state.fetchWayGeometry(3).size()); [EOL] } [EOL]
@Test [EOL] void isDigit() { [EOL] assertThat(ASCII.isDigit('0')).isTrue(); [EOL] assertThat(ASCII.isDigit('9')).isTrue(); [EOL] assertThat(ASCII.isDigit('!')).isFalse(); [EOL] assertThat(ASCII.isDigit('a')).isFalse(); [EOL] assertThat(ASCII.isDigit('z')).isFalse(); [EOL] assertThat(ASCII.isDigit('A')).isFalse(); [EOL] assertThat(ASCII.isDigit('Z')).isFalse(); [EOL] } [EOL]
@Test(expected = NullPointerException.class) [EOL] public void testNullVarargsRow() { [EOL] exporter = new CsvExporter(1, "abc"); [EOL] exporter.addRow((Object[]) null); [EOL] } [EOL]
@Test(expected = AccessDeniedException.class) [EOL] public void testSearchMetaFactsNoAccessToFact() throws Exception { [EOL] SearchMetaFactsRequest request = new SearchMetaFactsRequest().setFact(UUID.randomUUID()); [EOL] when(factRequestResolver.resolveFact(request.getFact())).thenReturn(new FactRecord()); [EOL] doThrow(AccessDeniedException.class).when(securityContext).checkReadPermission(isA(FactRecord.class)); [EOL] [EOL] delegate.handle(request); [EOL] } [EOL]
@Test [EOL] public void testGetPathsDirectionEnforcement2() [EOL] { [EOL] // Test enforce start & end direction [EOL] [EOL] GraphHopper instance = initSquareGraphInstance(false); [EOL] [EOL] // Start in middle of edge 4-5 [EOL] GHPoint start = new GHPoint(0.0015, 0.002); [EOL] // End at middle of edge 2-3 [EOL] GHPoint end = new GHPoint(0.002, 0.0005); [EOL] [EOL] // Test enforce south start direction and east end direction ; expected nodes (9)-5-8-1-2-(10) [EOL] GHRequest req = new GHRequest().addPoint(start, 180.).addPoint(end, 90.); [EOL] GHResponse response = new GHResponse(); [EOL] List<Path> paths = instance.getPaths(req, response); [EOL] assertArrayEquals(new int[] [EOL] { [EOL] 9, 5, 8, 1, 2, 10 [EOL] }, paths.get(0).calcNodes().toArray()); [EOL] [EOL] // Test uni-directional case [EOL] req.setAlgorithm(AlgorithmOptions.DIJKSTRA); [EOL] response = new GHResponse(); [EOL] paths = instance.getPaths(req, response); [EOL] assertArrayEquals(new int[] [EOL] { [EOL] 9, 5, 8, 1, 2, 10 [EOL] }, paths.get(0).calcNodes().toArray()); [EOL] } [EOL]
@Test(timeout = 100000) [EOL] public void testMaxIterationTime() throws Exception { [EOL] final Configuration conf = new HdfsConfiguration(); [EOL] initConf(conf); [EOL] int blockSize = 10*1024*1024; // 10MB block size [EOL] conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY, blockSize); [EOL] conf.setInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY, blockSize); [EOL] // limit the worker thread count of Balancer to have only 1 queue per DN [EOL] conf.setInt(DFSConfigKeys.DFS_BALANCER_MOVERTHREADS_KEY, 1); [EOL] // limit the bandwitdh to 1 packet per sec to emulate slow block moves [EOL] conf.setLong(DFSConfigKeys.DFS_DATANODE_BALANCE_BANDWIDTHPERSEC_KEY, [EOL] 64 * 1024); [EOL] // set client socket timeout to have an IN_PROGRESS notification back from [EOL] // the DataNode about the copy in every second. [EOL] conf.setLong(DFSConfigKeys.DFS_CLIENT_SOCKET_TIMEOUT_KEY, 2000L); [EOL] // set max iteration time to 2 seconds to timeout before moving any block [EOL] conf.setLong(DFSConfigKeys.DFS_BALANCER_MAX_ITERATION_TIME_KEY, 2000L); [EOL] // setup the cluster [EOL] final long capacity = 10L * blockSize; [EOL] final long[] dnCapacities = new long[] {capacity, capacity}; [EOL] final short rep = 1; [EOL] final long seed = 0xFAFAFA; [EOL] cluster = new MiniDFSCluster.Builder(conf) [EOL] .numDataNodes(0) [EOL] .build(); [EOL] try { [EOL] cluster.getConfiguration(0).setInt(DFSConfigKeys.DFS_REPLICATION_KEY, 1); [EOL] conf.setInt(DFSConfigKeys.DFS_REPLICATION_KEY, 1); [EOL] cluster.startDataNodes(conf, 1, true, null, null, dnCapacities); [EOL] cluster.waitClusterUp(); [EOL] cluster.waitActive(); [EOL] final Path path = new Path("/testMaxIterationTime.dat"); [EOL] DistributedFileSystem fs = cluster.getFileSystem(); [EOL] // fill the DN to 40% [EOL] DFSTestUtil.createFile(fs, path, 4L * blockSize, rep, seed); [EOL] // start a new DN [EOL] cluster.startDataNodes(conf, 1, true, null, null, dnCapacities); [EOL] cluster.triggerHeartbeats(); [EOL] // setup Balancer and run one iteration [EOL] List<NameNodeConnector> connectors = Collections.emptyList(); [EOL] try { [EOL] BalancerParameters bParams = BalancerParameters.DEFAULT; [EOL] connectors = NameNodeConnector.newNameNodeConnectors( [EOL] DFSUtil.getInternalNsRpcUris(conf), Balancer.class.getSimpleName(), [EOL] Balancer.BALANCER_ID_PATH, conf, bParams.getMaxIdleIteration()); [EOL] for (NameNodeConnector nnc : connectors) { [EOL] LOG.info("NNC to work on: " + nnc); [EOL] Balancer b = new Balancer(nnc, bParams, conf); [EOL] long startTime = Time.monotonicNow(); [EOL] Result r = b.runOneIteration(); [EOL] long runtime = Time.monotonicNow() - startTime; [EOL] assertEquals("We expect ExitStatus.IN_PROGRESS to be reported.", [EOL] ExitStatus.IN_PROGRESS, r.exitStatus); [EOL] // accept runtime if it is under 3.5 seconds, as we need to wait for [EOL] // IN_PROGRESS report from DN, and some spare to be able to finish. [EOL] // NOTE: This can be a source of flaky tests, if the box is busy, [EOL] // assertion here is based on the following: Balancer is already set [EOL] // up, iteration gets the blocks from the NN, and makes the decision [EOL] // to move 2 blocks. After that the PendingMoves are scheduled, and [EOL] // DataNode heartbeats in for the Balancer every second, iteration is [EOL] // two seconds long. This means that it will fail if the setup and the [EOL] // heartbeat from the DataNode takes more than 500ms, as the iteration [EOL] // should end at the 3rd second from start. As the number of [EOL] // operations seems to be pretty low, and all comm happens locally, I [EOL] // think the possibility of a failure due to node busyness is low. [EOL] assertTrue("Unexpected iteration runtime: " + runtime + "ms > 3.5s", [EOL] runtime < 3500); [EOL] } [EOL] } finally { [EOL] for (NameNodeConnector nnc : connectors) { [EOL] IOUtils.cleanupWithLogger(null, nnc); [EOL] } [EOL] } [EOL] } finally { [EOL] cluster.shutdown(true, true); [EOL] } [EOL] } [EOL]
@Test [EOL] void evaluateWithncludeMacro() throws XWikiVelocityException [EOL] { [EOL] this.engine.initialize(new Properties()); [EOL] [EOL] Context context = new XWikiVelocityContext(); [EOL] context.put("test", new TestClass(context)); [EOL] [EOL] // Can the script use an included macro [EOL] assertEvaluate("included", "$test.evaluate('#macro(includedmacro)included#end')#includedmacro()", context); [EOL] } [EOL]
@Test [EOL] public void testResolveNormal() { [EOL] String base = "http://a/b/c/d;p?q"; [EOL] [EOL] assertThat(resolve(base, "g:h")).isEqualTo("g:h"); [EOL] assertThat(resolve(base, "g")).isEqualTo("http://a/b/c/g"); [EOL] assertThat(resolve(base, "g/")).isEqualTo("http://a/b/c/g/"); [EOL] assertThat(resolve(base, "/g")).isEqualTo("http://a/g"); [EOL] assertThat(resolve(base, "//g")).isEqualTo("http://g"); [EOL] assertThat(resolve(base, "?y")).isEqualTo("http://a/b/c/d;p?y"); [EOL] assertThat(resolve(base, "g?y")).isEqualTo("http://a/b/c/g?y"); [EOL] assertThat(resolve(base, "#s")).isEqualTo("http://a/b/c/d;p?q#s"); [EOL] assertThat(resolve(base, "g#s")).isEqualTo("http://a/b/c/g#s"); [EOL] assertThat(resolve(base, "g?y#s")).isEqualTo("http://a/b/c/g?y#s"); [EOL] assertThat(resolve(base, ";x")).isEqualTo("http://a/b/c/;x"); [EOL] assertThat(resolve(base, "g;x")).isEqualTo("http://a/b/c/g;x"); [EOL] assertThat(resolve(base, "g;x?y#s")).isEqualTo("http://a/b/c/g;x?y#s"); [EOL] assertThat(resolve(base, "")).isEqualTo("http://a/b/c/d;p?q"); [EOL] assertThat(resolve(base, ".")).isEqualTo("http://a/b/c/"); [EOL] assertThat(resolve(base, "./")).isEqualTo("http://a/b/c/"); [EOL] assertThat(resolve(base, "..")).isEqualTo("http://a/b/"); [EOL] assertThat(resolve(base, "../")).isEqualTo("http://a/b/"); [EOL] assertThat(resolve(base, "../g")).isEqualTo("http://a/b/g"); [EOL] assertThat(resolve(base, "../..")).isEqualTo("http://a/"); [EOL] assertThat(resolve(base, "../../")).isEqualTo("http://a/"); [EOL] assertThat(resolve(base, "../../g")).isEqualTo("http://a/g"); [EOL] } [EOL]
@Test [EOL] public void testWrapSlice2() { [EOL] assertWrapped(newBuffer(8).slice(0, 1)); [EOL] } [EOL]
@Test [EOL] public void getAndConsume() throws IOException { [EOL] when(rw.get(key1, key2)).thenReturn(Stream.of(entity1, entity2).iterator()); [EOL] sut.get(List.of(key1, key2), entityConsumer); [EOL] verify(rw).get(key1, key2); [EOL] verify(entityConsumer).accept(entity1); [EOL] verify(entityConsumer).accept(entity2); [EOL] } [EOL]
@Test [EOL] public void testToPathDataMutationTaster() { [EOL] AlleleProperties alleleProperties = AlleleProperties.newBuilder().putProperties("MUT_TASTER", 0.7f).build(); [EOL] assertThat(AlleleProtoAdaptor.toPathogenicityData(alleleProperties), equalTo(PathogenicityData.of(PathogenicityScore.of(MUTATION_TASTER, 0.7f)))); [EOL] } [EOL]
@Test [EOL] public void loginWithError() { [EOL] DeveloperLogin developerLogin = new DeveloperLogin(); [EOL] developerLogin.setEmail("other@gmail.com"); [EOL] developerLogin.setPassword("otherPassword"); [EOL] [EOL] Mockito.when(developerRepository.findByEmailAndPassword(Mockito.anyString(), Mockito.anyString())).thenReturn(null); [EOL] Developer logged = developerService.login(developerLogin); [EOL] [EOL] assertNull(logged); [EOL] } [EOL]
@Test [EOL] 	public void testExecute() throws Exception { [EOL] [EOL] 		String line = "rename /tomcat-vm as tomcat-vm-copy"; [EOL] 		Assert.assertEquals( 0, this.cmdMngr.validate( this.app, line ).size()); [EOL] [EOL] 		String cmdName = "my-command"; [EOL] 		this.cmdMngr.createOrUpdateCommand( this.app, cmdName, line ); [EOL] [EOL] 		Assert.assertNotNull( InstanceHelpers.findInstanceByPath( this.app, "/tomcat-vm" )); [EOL] 		Assert.assertNull( InstanceHelpers.findInstanceByPath( this.app, "/tomcat-vm-copy" )); [EOL] 		this.cmdMngr.execute( this.app, cmdName, CommandHistoryItem.ORIGIN_REST_API, "some source" ); [EOL] 		Assert.assertNull( InstanceHelpers.findInstanceByPath( this.app, "/tomcat-vm" )); [EOL] 		Assert.assertNotNull( InstanceHelpers.findInstanceByPath( this.app, "/tomcat-vm-copy" )); [EOL] 	} [EOL]
@Test [EOL] public void test_getVaultTokenLookupDetails_failure_500() throws TVaultValidationException, IOException { [EOL] String token = "7QPMPIGiyDFlJkrK3jFykUqa"; [EOL] Response response = getMockResponse(HttpStatus.INTERNAL_SERVER_ERROR, true, ""); [EOL] VaultTokenLookupDetails expectedLookupDetails = new VaultTokenLookupDetails(); [EOL] expectedLookupDetails.setAdmin(false); [EOL] expectedLookupDetails.setValid(true); [EOL] expectedLookupDetails.setToken(token); [EOL] expectedLookupDetails.setUsername(null); [EOL] String [] policies = {"default"}; [EOL] ArrayList<String> adminPolicies = new ArrayList<>(); [EOL] adminPolicies.add("adminpolicy"); [EOL] expectedLookupDetails.setPolicies(policies); [EOL] [EOL] when(reqProcessor.process("/auth/tvault/lookup","{}", token)).thenReturn(response); [EOL] [EOL] try { [EOL] VaultTokenLookupDetails lookupDetails = tokenValidator.getVaultTokenLookupDetails(token); [EOL] }catch (TVaultValidationException t) { [EOL] assertTrue(true); [EOL] } [EOL] [EOL] } [EOL]
@Test [EOL] public void calculateContentDisposition() throws Exception { [EOL] final IAsyncReportState state1 = [EOL] new AsyncReportState( UUID.randomUUID(), "/somepath/anotherlevel/file.prpt", AsyncExecutionStatus.FINISHED, 0, 0, [EOL] 0, 0, 0, 0, "", MimeHelper.MIMETYPE_CSV, "", false ); [EOL] [EOL] final Response.ResponseBuilder builder1 = mock( Response.ResponseBuilder.class ); [EOL] [EOL] JobManager.calculateContentDisposition( builder1, state1 ); [EOL] [EOL] ArgumentCaptor<String> argument = ArgumentCaptor.forClass( String.class ); [EOL] [EOL] verify( builder1, times( 1 ) ).header( eq( "Content-Description" ), argument.capture() ); [EOL] assertTrue( argument.getValue().contains( "file.prpt" ) ); [EOL] [EOL] verify( builder1, times( 1 ) ).header( eq( "Content-Disposition" ), argument.capture() ); [EOL] assertTrue( argument.getValue().contains( "attachment; filename*=UTF-8''file.csv" ) ); [EOL] [EOL] final IAsyncReportState state2 = [EOL] new AsyncReportState( UUID.randomUUID(), "/somepath/anotherlevel/file.prpt", AsyncExecutionStatus.FINISHED, 0, 0, [EOL] 0, 0, 0, 0, "", MimeHelper.MIMETYPE_PDF, "", false ); [EOL] [EOL] final Response.ResponseBuilder builder2 = mock( Response.ResponseBuilder.class ); [EOL] [EOL] JobManager.calculateContentDisposition( builder2, state2 ); [EOL] [EOL] argument = ArgumentCaptor.forClass( String.class ); [EOL] [EOL] verify( builder2, times( 1 ) ).header( eq( "Content-Description" ), argument.capture() ); [EOL] assertTrue( argument.getValue().contains( "file.prpt" ) ); [EOL] [EOL] verify( builder2, times( 1 ) ).header( eq( "Content-Disposition" ), argument.capture() ); [EOL] assertTrue( argument.getValue().contains( "inline; filename*=UTF-8''file.pdf" ) ); [EOL] } [EOL]
@Test [EOL] 	public void testAddAll() { [EOL] 		Triple t = new Triple(NodeFactory.createURI("one"), [EOL] 				NodeFactory.createURI("two"), NodeFactory.createURI("three")); [EOL] 		ConstructHandler handler2 = new ConstructHandler(new Query()); [EOL] 		handler2.addConstruct(t); [EOL] 		handler.addAll(handler2); [EOL] 		Template template = query.getConstructTemplate(); [EOL] 		assertNotNull(template); [EOL] 		List<Triple> lst = template.getTriples(); [EOL] 		assertEquals(1, lst.size()); [EOL] 		assertEquals(t, lst.get(0)); [EOL] 	} [EOL]
@Test [EOL] public void testPutAndGetMandatoryShortUtcDateValue_returnDefault() { [EOL] final Date dateValue = configuration.getMandatoryShortUtcDateValue("date.key", "1981-02-02"); [EOL] assertNotNull(dateValue); [EOL] assertEquals(349920000000L, dateValue.getTime()); [EOL] } [EOL]
@Test [EOL] 	public void testStoreDirectoryResourcesAsBytes_withExclusionPatterns() throws Exception { [EOL] [EOL] 		File dir = this.folder.newFolder(); [EOL] 		Assert.assertTrue( new File( dir, "dir1/dir2" ).mkdirs()); [EOL] 		Assert.assertTrue( new File( dir, "dir1/dir2/t1.txt" ).createNewFile()); [EOL] 		Assert.assertTrue( new File( dir, "dir1/dir2/t2.toto" ).createNewFile()); [EOL] 		Assert.assertTrue( new File( dir, "t3.txt" ).createNewFile()); [EOL] [EOL] 		Map<String,byte[]> map = Utils.storeDirectoryResourcesAsBytes( dir ); [EOL] 		Assert.assertEquals( 3, map.size()); [EOL] 		Assert.assertTrue( map.containsKey( "dir1/dir2/t1.txt" )); [EOL] 		Assert.assertTrue( map.containsKey( "dir1/dir2/t2.toto" )); [EOL] 		Assert.assertTrue( map.containsKey( "t3.txt" )); [EOL] [EOL] 		map = Utils.storeDirectoryResourcesAsBytes( dir, Arrays.asList( ".*\\.txt" )); [EOL] 		Assert.assertEquals( 1, map.size()); [EOL] 		Assert.assertTrue( map.containsKey( "dir1/dir2/t2.toto" )); [EOL] [EOL] 		map = Utils.storeDirectoryResourcesAsBytes( dir, Arrays.asList( ".*toto.*" )); [EOL] 		Assert.assertEquals( 2, map.size()); [EOL] 		Assert.assertTrue( map.containsKey( "dir1/dir2/t1.txt" )); [EOL] 		Assert.assertTrue( map.containsKey( "t3.txt" )); [EOL] [EOL] 		map = Utils.storeDirectoryResourcesAsBytes( dir, Arrays.asList( "dir1" )); [EOL] 		Assert.assertEquals( 3, map.size()); [EOL] 		Assert.assertTrue( map.containsKey( "dir1/dir2/t1.txt" )); [EOL] 		Assert.assertTrue( map.containsKey( "dir1/dir2/t2.toto" )); [EOL] 		Assert.assertTrue( map.containsKey( "t3.txt" )); [EOL] 	} [EOL]
@Test [EOL] 	public void testFindComponent() { [EOL] [EOL] 		Graphs g = new Graphs(); [EOL] 		Assert.assertNull( ComponentHelpers.findComponent( g, "c" )); [EOL] [EOL] 		Component c1 = new Component( "c1" ); [EOL] 		g.getRootComponents().add( c1 ); [EOL] 		Assert.assertEquals( c1, ComponentHelpers.findComponent( g, "c1" )); [EOL] [EOL] 		Component c2 = new Component( "c2" ); [EOL] 		g.getRootComponents().add( c2 ); [EOL] 		Assert.assertEquals( c2, ComponentHelpers.findComponent( g, "c2" )); [EOL] [EOL] 		Component c21 = new Component( "c21" ); [EOL] 		c2.addChild( c21 ); [EOL] 		Assert.assertEquals( c21, ComponentHelpers.findComponent( g, "c21" )); [EOL] [EOL] 		Component duplicateC1 = new Component( "c1" ); [EOL] 		g.getRootComponents().add( duplicateC1 ); [EOL] 		Assert.assertNotNull( ComponentHelpers.findComponent( g, "c1" )); [EOL] [EOL] 		TestApplication app = new TestApplication(); [EOL] 		Assert.assertNotNull( ComponentHelpers.findComponent( app, "tomcat" )); [EOL] 		Assert.assertNull( ComponentHelpers.findComponent( app, "tommy" )); [EOL] 	} [EOL]
@Test [EOL] void appendWithMask() { [EOL] var param = new BytesLogParam(Strings.bytes("{\"field1\":\"value1\",\"password\":\"pass123\",\"field2\":\"value2\"}")); [EOL] var builder = new StringBuilder(); [EOL] param.append(builder, Set.of("password", "passwordConfirm"), 50); [EOL] assertThat(builder.toString()) [EOL] .isEqualTo("{\"field1\":\"value1\",\"password\":\"******\",\"field2\":\"...(truncated)"); [EOL] } [EOL]
@Test( expected = IllegalArgumentException.class ) [EOL] public void shouldFailAddingEmptyParameterName() throws Exception { [EOL] this.procedure.addParameter( getTransaction(), StringConstants.EMPTY_STRING ); [EOL] } [EOL]
@Test [EOL] public void testCreateBulkMutation() throws Exception { [EOL] RowMutationEntry entry = RowMutationEntry.create(ROW_KEY); [EOL] when(mockDataClient.newBulkMutationBatcher(TABLE_ID)).thenReturn(mockMutationBatcher); [EOL] when(mockMutationBatcher.add(entry)).thenReturn(ApiFutures.<Void>immediateFuture(null)); [EOL] BulkMutationWrapper mutationWrapper = dataClientWrapper.createBulkMutation(TABLE_ID); [EOL] mutationWrapper.add(entry).get(); [EOL] verify(mockDataClient).newBulkMutationBatcher(TABLE_ID); [EOL] verify(mockMutationBatcher).add(entry); [EOL] } [EOL]
@Test [EOL] public void itHandlesErr() throws Exception { [EOL] assertThat(ERR_RESULT.isOk()).isFalse(); [EOL] assertThat(ERR_RESULT.isErr()).isTrue(); [EOL] } [EOL]
@Test [EOL] public void testBasic() [EOL] { [EOL] Migration m1 = () -> Arrays.asList(v1opA, v1opB); [EOL] Migration m2 = () -> Collections.singletonList(v2op); [EOL] Migration m3 = () -> Collections.singletonList(v3op); [EOL] MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3)); [EOL] [EOL] complete(manager.migrate(migrationSet)); [EOL] [EOL] ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec); [EOL] complete(v3Client.read(), (m, e) -> { [EOL] Assert.assertEquals(m.getAge(), 30); [EOL] Assert.assertEquals(m.getFirstName(), "One"); [EOL] Assert.assertEquals(m.getLastName(), "Two"); [EOL] }); [EOL] [EOL] int count = manager.debugCount.get(); [EOL] complete(manager.migrate(migrationSet)); [EOL] Assert.assertEquals(manager.debugCount.get(), count); // second call should do nothing [EOL] } [EOL]
@Test [EOL] public void includesAGaugeForMappedCount() throws Exception { [EOL] final Gauge gauge = (Gauge) buffers.getMetrics().get(MAPPED_COUNT); [EOL] [EOL] when(mBeanServer.getAttribute(mapped, "Count")).thenReturn(100); [EOL] [EOL] assertThat(gauge.getValue()) [EOL] .isEqualTo(100); [EOL] } [EOL]
@Test [EOL] public void testBuildFunctionTransaction() throws Exception { [EOL] AbiDefinition functionDefinition = new AbiDefinition( [EOL] false, [EOL] Arrays.asList( [EOL] new AbiDefinition.NamedType("param", "uint8")), [EOL] "functionName", [EOL] Collections.emptyList(), [EOL] "type", [EOL] false); [EOL] [EOL] MethodSpec methodSpec = solidityFunctionWrapper.buildFunction(functionDefinition); [EOL] [EOL] //CHECKSTYLE:OFF [EOL] String expected = [EOL] "public org.web3j.protocol.core.RemoteCall<org.web3j.protocol.core.methods.response.TransactionReceipt> functionName(java.math.BigInteger param) {\n" [EOL] + " final com.peersafe.abi.datatypes.Function function = new com.peersafe.abi.datatypes.Function(\n" [EOL] + " FUNC_FUNCTIONNAME, \n" [EOL] + " java.util.Arrays.<com.peersafe.abi.datatypes.Type>asList(new com.peersafe.abi.datatypes.generated.Uint8(param)), \n" [EOL] + " java.util.Collections.<com.peersafe.abi.TypeReference<?>>emptyList());\n" [EOL] + " return executeRemoteCallTransaction(function);\n" [EOL] + "}\n"; [EOL] //CHECKSTYLE:ON [EOL] [EOL] assertThat(methodSpec.toString(), is(expected)); [EOL] } [EOL]
@Test (expected=ExWarning.class) public void checker14() { check("'12 3'^^xsd:integer") ; } [EOL]
@Test [EOL] public void throwsWhenUnableToDeserializeEnums() { [EOL] NodeMapper mapper = new NodeMapper(); [EOL] [EOL] NodeDeserializationException e = Assertions.assertThrows( [EOL] NodeDeserializationException.class, [EOL] () -> mapper.deserialize(Node.from("invalid"), FooEnum.class)); [EOL] [EOL] assertThat(e.getMessage(), equalTo( [EOL] "Deserialization error at (/): unable to create software.amazon.smithy.model.node.NodeMapperTest.FooEnum " [EOL] + "from \"invalid\": Expected one of the following enum strings: [foo, Baz, BAR]")); [EOL] } [EOL]
@Test [EOL] public void testBulkMutation() throws IOException { [EOL] BigtableOptions options = [EOL] BigtableOptions.builder() [EOL] .setProjectId(TEST_PROJECT_ID) [EOL] .setInstanceId(TEST_INSTANCE_ID) [EOL] .setCredentialOptions(CredentialOptions.nullCredential()) [EOL] .setUserAgent("Test-user-agent") [EOL] .build(); [EOL] dataSettings = BigtableVeneerSettingsFactory.createBigtableDataSettings(options); [EOL] [EOL] BulkOptions bulkOptions = options.getBulkOptions(); [EOL] BatchingSettings batchingSettings = [EOL] dataSettings.getStubSettings().bulkMutateRowsSettings().getBatchingSettings(); [EOL] long outstandingElementCount = [EOL] bulkOptions.getMaxInflightRpcs() * bulkOptions.getBulkMaxRowKeyCount(); [EOL] [EOL] assertTrue(batchingSettings.getIsEnabled()); [EOL] assertEquals( [EOL] bulkOptions.getBulkMaxRequestSize(), [EOL] batchingSettings.getRequestByteThreshold().longValue()); [EOL] assertEquals( [EOL] bulkOptions.getBulkMaxRowKeyCount(), [EOL] batchingSettings.getElementCountThreshold().longValue()); [EOL] assertEquals( [EOL] bulkOptions.getMaxMemory(), [EOL] batchingSettings.getFlowControlSettings().getMaxOutstandingRequestBytes().longValue()); [EOL] assertEquals( [EOL] outstandingElementCount, [EOL] batchingSettings.getFlowControlSettings().getMaxOutstandingElementCount().longValue()); [EOL] } [EOL]
@Test [EOL] public void doWithoutListeners() throws Exception { [EOL] } [EOL]
@Test [EOL] public void testConvertNull() { [EOL] assertNull(converter.apply(null)); [EOL] } [EOL]
@Test [EOL] void readNumber() throws IOException { [EOL] var stream = new ByteArrayInputStream(Strings.bytes(":10\r\n")); [EOL] long response = (Long) Protocol.read(new RedisInputStream(stream)); [EOL] assertThat(response).isEqualTo(10); [EOL] } [EOL]
@Test [EOL] public void testParseIntervalMapByte() { [EOL] IntervalByteMap expected = new IntervalByteMap(); [EOL] expected.put(new Interval(1, 2), (byte) 1); [EOL] expected.put(new Interval(3, 5), (byte) 2); [EOL] expected.put(new Interval(5, 6), (byte) 3); [EOL] expected.put(new Interval(6, 7), (byte) 4); [EOL] [EOL] assertEqualIntervalMaps(expected, IntervalsParser.parseIntervalMap(Byte.class, "[1, 2, 1]; [3, 5, 2]; [5, 6, '3']; [6, 7, \"4\"]")); [EOL] assertEqualIntervalMaps(expected, IntervalsParser.parseIntervalMap(byte.class, "[1, 2, 1]; [3, 5, 2]; [5, 6, '3']; [6, 7, \"4\"]")); [EOL] } [EOL]
@Test [EOL] public void shouldTerminate_greater() { [EOL] WaitContext context = new WaitContext(0L); [EOL] context.setCurrentTime(1500L); [EOL] assertTrue(STRATEGY.shouldTerminate(context)); [EOL] } [EOL]
@Test(description = "Handle request with empty transport headers") [EOL] public void testHandleRequestWithEmptyTransportHeader() throws Exception { [EOL] boolean response = this.handler.handleRequest(createSynapseMessageContext("<empty/>", this.synapseConfiguration, [EOL] new HashMap<>(), "https://test.com/testservice")); [EOL] Assert.assertFalse(response); [EOL] } [EOL]
@Test [EOL] public void testRemaining() { [EOL] final int oneHourInMillis = 60_000 * 60; [EOL] final long nowPlusOneHour = System.currentTimeMillis() + oneHourInMillis; [EOL] final Deadline deadline = Deadline.fromUnixMilliseconds(nowPlusOneHour); [EOL] Assert.assertEquals(nowPlusOneHour, deadline.getValue()); [EOL] Assert.assertTrue(deadline.remaining() > 0); [EOL] Assert.assertTrue(deadline.remaining() <= oneHourInMillis); [EOL] } [EOL]
@Test [EOL] void getRepositoriesWithInvalid() throws Exception [EOL] { [EOL] // We define 2 repositories: a valid one and an invalid one. [EOL] // The goal is to verify that the invalid one is ignored but a warning is reported in the logs. [EOL] this.source.setProperty("extension.repositories", Arrays.asList("id:type:http://url", "invalid")); [EOL] [EOL] assertEquals( [EOL] Arrays.asList(new DefaultExtensionRepositoryDescriptor("id", "type", new URI("http://url"))), [EOL] new ArrayList<>(this.configuration.getExtensionRepositoryDescriptors())); [EOL] assertEquals(1, this.logCapture.size()); [EOL] assertEquals("Ignoring invalid repository configuration [invalid]. Root cause " [EOL] + "[ExtensionManagerConfigurationException: Invalid repository configuration format for [invalid]. Should " [EOL] + "have been matching [([^:]+):([^:]+):(.+)].]", this.logCapture.getMessage(0)); [EOL] } [EOL]
@Test [EOL] public void emptyGeneWithAnyInheritance() { [EOL] Gene empty = newGene(); [EOL] [EOL] double score = instance.calculateGenePriorityScoreForMode(empty, ModeOfInheritance.ANY); [EOL] assertThat(score, equalTo(0d)); [EOL] } [EOL]
@Test [EOL] public void serverShouldSend431OnHeaderSizeErrorWhenDecodingInitialHeaders() throws Exception { [EOL] int padding = 0; [EOL] handler = newHandler(); [EOL] Http2Exception e = new Http2Exception.HeaderListSizeException(STREAM_ID, PROTOCOL_ERROR, [EOL] "Header size exceeded max allowed size 8196", true); [EOL] [EOL] when(stream.id()).thenReturn(STREAM_ID); [EOL] when(connection.isServer()).thenReturn(true); [EOL] when(stream.isHeadersSent()).thenReturn(false); [EOL] when(remote.lastStreamCreated()).thenReturn(STREAM_ID); [EOL] when(frameWriter.writeRstStream(eq(ctx), eq(STREAM_ID), [EOL] eq(PROTOCOL_ERROR.code()), eq(promise))).thenReturn(future); [EOL] [EOL] handler.exceptionCaught(ctx, e); [EOL] [EOL] ArgumentCaptor<Http2Headers> captor = ArgumentCaptor.forClass(Http2Headers.class); [EOL] verify(encoder).writeHeaders(eq(ctx), eq(STREAM_ID), [EOL] captor.capture(), eq(padding), eq(true), eq(promise)); [EOL] Http2Headers headers = captor.getValue(); [EOL] assertEquals(HttpResponseStatus.REQUEST_HEADER_FIELDS_TOO_LARGE.codeAsText(), headers.status()); [EOL] verify(frameWriter).writeRstStream(ctx, STREAM_ID, PROTOCOL_ERROR.code(), promise); [EOL] } [EOL]
@Test [EOL] public void testCustomHtmlSchema() throws Exception { [EOL] // Default schema does not allow tables inside anchors [EOL] String test = "<html><body><a><table><tr><td>text</tr></tr></table></a></body></html>"; [EOL] [EOL] Metadata metadata = new Metadata(); [EOL] LinkContentHandler linkContentHandler = new LinkContentHandler(); [EOL] [EOL] new HtmlParser().parse( [EOL] new ByteArrayInputStream(test.getBytes(ISO_8859_1)), [EOL] linkContentHandler, metadata, new ParseContext()); [EOL] [EOL] // Expect no anchor text [EOL] assertEquals("", linkContentHandler.getLinks().get(0).getText()); [EOL] [EOL] // We'll change the schema to allow tables inside anchors! [EOL] Schema schema = new HTMLSchema(); [EOL] schema.elementType("a", HTMLSchema.M_ANY, 65535, 0); [EOL] [EOL] ParseContext parseContext = new ParseContext(); [EOL] parseContext.set(Schema.class, schema); [EOL] linkContentHandler = new LinkContentHandler(); [EOL] new HtmlParser().parse( [EOL] new ByteArrayInputStream(test.getBytes(ISO_8859_1)), [EOL] linkContentHandler, metadata, parseContext); [EOL] [EOL] // Expect anchor text [EOL] assertEquals("\ttext\n\n", linkContentHandler.getLinks().get(0).getText()); [EOL] } [EOL]
@Test [EOL] public void testImplicitParentSpan() { [EOL] OpencensusTracerFactory factory = [EOL] new OpencensusTracerFactory(internalTracer, defaultSpanAttributes); [EOL] [EOL] Span parentSpan = mock(Span.class); [EOL] Context origContext = ContextUtils.withValue(Context.current(), parentSpan).attach(); [EOL] [EOL] try { [EOL] factory.newTracer( [EOL] NoopApiTracer.getInstance(), [EOL] SpanName.of("FakeClient", "FakeMethod"), [EOL] OperationType.Unary); [EOL] } finally { [EOL] Context.current().detach(origContext); [EOL] } [EOL] [EOL] verify(internalTracer).spanBuilderWithExplicitParent(anyString(), same(parentSpan)); [EOL] } [EOL]
@Test [EOL] public void testToWKT() { [EOL] [EOL] float lat = 10.0F; [EOL] float lon = 20.0F; [EOL] String expResult = "<http://www.opengis.net/def/crs/EPSG/0/4326> POINT(10 20)"; [EOL] String result = ConvertLatLon.toWKT(lat, lon); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test(expected=NullPointerException.class) [EOL] public void testOpenNullLower() { [EOL] open(null, 42L); [EOL] } [EOL]
@Test [EOL] public void testAdd_NoFields() { [EOL] RowAndFamilyAddingSolrUpdateWriter updateWriter = new RowAndFamilyAddingSolrUpdateWriter(null, null, [EOL] uniqueKeyFormatter, keyValue, delegateWriter); [EOL] updateWriter.add(solrDocument); [EOL] [EOL] verify(solrDocument, never()).addField(anyString(), any()); [EOL] verify(delegateWriter).add(solrDocument); [EOL] } [EOL]
@Test [EOL] public void generateClientStatReporter() { [EOL] //user super method [EOL] AbstractSofaTracerStatisticReporter abstractSofaTracerStatisticReporter = serverTracer [EOL] .generateClientStatReporter(); [EOL] Assert.assertTrue(abstractSofaTracerStatisticReporter == null); [EOL] } [EOL]
@Test [EOL] public void testGetAttributesIntervalEmpty() { [EOL] GraphStore store = getIntervalGraphStore(); [EOL] Column column = generateIntervalColumn(store); [EOL] [EOL] NodeImpl node = new NodeImpl("0", store); [EOL] [EOL] Iterator<Map.Entry> itr = node.getAttributes(column).iterator(); [EOL] Assert.assertFalse(itr.hasNext()); [EOL] } [EOL]
@Test [EOL] 	public void parseBoolean(){ [EOL] 		assertEquals(Boolean.TRUE, TypeUtil.parse(DataType.BOOLEAN, "true")); [EOL] 		assertEquals(Boolean.TRUE, TypeUtil.parse(DataType.BOOLEAN, "TRUE")); [EOL] [EOL] 		assertEquals(Boolean.FALSE, TypeUtil.parse(DataType.BOOLEAN, "false")); [EOL] 		assertEquals(Boolean.FALSE, TypeUtil.parse(DataType.BOOLEAN, "FALSE")); [EOL] [EOL] 		try { [EOL] 			TypeUtil.parse(DataType.BOOLEAN, "yes"); [EOL] [EOL] 			fail(); [EOL] 		} catch(IllegalArgumentException iae){ [EOL] 			// Ignored [EOL] 		} [EOL] [EOL] 		assertEquals(Boolean.TRUE, TypeUtil.parse(DataType.BOOLEAN, "1")); [EOL] 		assertEquals(Boolean.TRUE, TypeUtil.parse(DataType.BOOLEAN, "1.0")); [EOL] [EOL] 		try { [EOL] 			TypeUtil.parse(DataType.BOOLEAN, "0.5"); [EOL] [EOL] 			fail(); [EOL] 		} catch(IllegalArgumentException iae){ [EOL] 			// Ignored [EOL] 		} [EOL] [EOL] 		assertEquals(Boolean.FALSE, TypeUtil.parse(DataType.BOOLEAN, "-0")); [EOL] 		assertEquals(Boolean.FALSE, TypeUtil.parse(DataType.BOOLEAN, "-0.0")); [EOL] 		assertEquals(Boolean.FALSE, TypeUtil.parse(DataType.BOOLEAN, "0")); [EOL] 		assertEquals(Boolean.FALSE, TypeUtil.parse(DataType.BOOLEAN, "0.0")); [EOL] 	} [EOL]
@Test [EOL] public void testParseDeleteMissing() { [EOL] DistCpOptions options = OptionsParser.parse(new String[] { [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.assertFalse(options.shouldDeleteMissing()); [EOL] [EOL] options = OptionsParser.parse(new String[] { [EOL] "-update", [EOL] "-delete", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.assertTrue(options.shouldSyncFolder()); [EOL] Assert.assertTrue(options.shouldDeleteMissing()); [EOL] [EOL] options = OptionsParser.parse(new String[] { [EOL] "-overwrite", [EOL] "-delete", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.assertTrue(options.shouldOverwrite()); [EOL] Assert.assertTrue(options.shouldDeleteMissing()); [EOL] [EOL] try { [EOL] OptionsParser.parse(new String[] { [EOL] "-atomic", [EOL] "-delete", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.fail("Atomic and delete folders were allowed"); [EOL] } catch (IllegalArgumentException ignore) { } [EOL] } [EOL]
@Test [EOL] public void testINodeXAttrsLimit() throws Exception { [EOL] List<XAttr> existingXAttrs = Lists.newArrayListWithCapacity(2); [EOL] XAttr xAttr1 = (new XAttr.Builder()).setNameSpace(XAttr.NameSpace.USER). [EOL] setName("a1").setValue(new byte[]{0x31, 0x32, 0x33}).build(); [EOL] XAttr xAttr2 = (new XAttr.Builder()).setNameSpace(XAttr.NameSpace.USER). [EOL] setName("a2").setValue(new byte[]{0x31, 0x31, 0x31}).build(); [EOL] existingXAttrs.add(xAttr1); [EOL] existingXAttrs.add(xAttr2); [EOL] [EOL] // Adding system and raw namespace xAttrs aren't affected by inode [EOL] // xAttrs limit. [EOL] XAttr newSystemXAttr = (new XAttr.Builder()). [EOL] setNameSpace(XAttr.NameSpace.SYSTEM).setName("a3"). [EOL] setValue(new byte[]{0x33, 0x33, 0x33}).build(); [EOL] XAttr newRawXAttr = (new XAttr.Builder()).setNameSpace(XAttr.NameSpace.RAW). [EOL] setName("a3").setValue(new byte[]{0x33, 0x33, 0x33}).build(); [EOL] List<XAttr> newXAttrs = Lists.newArrayListWithCapacity(2); [EOL] newXAttrs.add(newSystemXAttr); [EOL] newXAttrs.add(newRawXAttr); [EOL] List<XAttr> xAttrs = fsdir.setINodeXAttrs(existingXAttrs, newXAttrs, [EOL] EnumSet.of(XAttrSetFlag.CREATE, XAttrSetFlag.REPLACE)); [EOL] assertEquals(xAttrs.size(), 4); [EOL] [EOL] // Adding a trusted namespace xAttr, is affected by inode xAttrs limit. [EOL] XAttr newXAttr1 = (new XAttr.Builder()).setNameSpace( [EOL] XAttr.NameSpace.TRUSTED).setName("a4"). [EOL] setValue(new byte[]{0x34, 0x34, 0x34}).build(); [EOL] newXAttrs.set(0, newXAttr1); [EOL] try { [EOL] fsdir.setINodeXAttrs(existingXAttrs, newXAttrs, [EOL] EnumSet.of(XAttrSetFlag.CREATE, XAttrSetFlag.REPLACE)); [EOL] fail("Setting user visible xattr on inode should fail if " + [EOL] "reaching limit."); [EOL] } catch (IOException e) { [EOL] GenericTestUtils.assertExceptionContains("Cannot add additional XAttr " + [EOL] "to inode, would exceed limit", e); [EOL] } [EOL] } [EOL]
@Test [EOL] public void notEquals() { [EOL] assertFalse(Result.PASS.equals(Result.FAIL)); [EOL] assertFalse(Result.PASS.equals(Result.STOP)); [EOL] assertFalse(Result.FAIL.equals(Result.PASS)); [EOL] assertFalse(Result.FAIL.equals(Result.STOP)); [EOL] assertFalse(Result.STOP.equals(Result.PASS)); [EOL] assertFalse(Result.STOP.equals(Result.FAIL)); [EOL] } [EOL]
@Test [EOL] public void testMaxPassedGenesWhereMaxGenesIsZero() { [EOL] List<Gene> allPassedGenes = new ArrayList<>(); [EOL] allPassedGenes.add(passedGeneOne); [EOL] allPassedGenes.add(passedGeneTwo); [EOL] assertThat(ResultsWriterUtils.getMaxPassedGenes(getGenes(), 0), equalTo(allPassedGenes)); [EOL] } [EOL]
@Test [EOL] public void testEvaluateIndexingSpecification_PullSolrZkHostFromIndexerDefinition() throws Exception { [EOL] [EOL] IndexerDefinition indexerDef = new IndexerDefinitionBuilder() [EOL] .name("customsolr") [EOL] .configuration(Resources.toByteArray(Resources.getResource(getClass(), "user_indexer.xml"))) [EOL] .connectionParams(ImmutableMap.of( [EOL] "solr.zk", "myZkHost/solr", [EOL] "solr.collection", "mycollection")) [EOL] .build(); [EOL] [EOL] addAndWaitForIndexer(indexerDef); [EOL] [EOL] opts.hbaseIndexerZkHost = "localhost:" + ZK_CLIENT_PORT; [EOL] opts.hbaseIndexerName = "customsolr"; [EOL] opts.zkHost = "customhost/solr"; [EOL] opts.collection = null; [EOL] [EOL] opts.evaluateIndexingSpecification(); [EOL] [EOL] INDEXER_MODEL.deleteIndexerInternal("customsolr"); [EOL] [EOL] assertEquals("customhost/solr", opts.zkHost); [EOL] assertEquals("mycollection", opts.collection); [EOL] } [EOL]
@Test [EOL] public void testPropertyPathExp() throws Exception { [EOL] final String entitySetName = "ESName"; [EOL] final String keyPropertyName = "a"; [EOL] EdmProperty keyProperty = mockProperty(keyPropertyName, [EOL] OData.newInstance().createPrimitiveTypeInstance(EdmPrimitiveTypeKind.String)); [EOL] EdmKeyPropertyRef keyPropertyRef = mockKeyPropertyRef(keyPropertyName, keyProperty); [EOL] EdmEntityType entityType = mockEntityType(keyPropertyName, keyPropertyRef); [EOL] Mockito.when(entityType.getPropertyNames()).thenReturn(Collections.singletonList(keyPropertyName)); [EOL] Mockito.when(entityType.getProperty(keyPropertyName)).thenReturn(keyProperty); [EOL] EdmEntitySet entitySet = mockEntitySet(entitySetName, entityType); [EOL] EdmEntityContainer container = mockContainer(entitySetName, entitySet); [EOL] Edm mockedEdm = Mockito.mock(Edm.class); [EOL] Mockito.when(mockedEdm.getEntityContainer()).thenReturn(container); [EOL] [EOL] UriTokenizer tokenizer = new UriTokenizer("a eq \'abc\'"); [EOL] Expression expression = new ExpressionParser(mockedEdm, odata).parse(tokenizer, [EOL] entityType, null, null); [EOL] assertNotNull(expression); [EOL] assertEquals("{[a] EQ \'abc\'}", expression.toString()); [EOL] [EOL] tokenizer = new UriTokenizer("a in (\'abc\', \'xyz\')"); [EOL] expression = new ExpressionParser(mockedEdm, odata).parse(tokenizer, [EOL] entityType, null, null); [EOL] assertNotNull(expression); [EOL] assertEquals("{[a] IN [\'abc\', \'xyz\']}", expression.toString()); [EOL] try { [EOL] tokenizer = new UriTokenizer("a in (\'abc\', 10)"); [EOL] expression = new ExpressionParser(mockedEdm, odata).parse(tokenizer, [EOL] entityType, null, null); [EOL] } catch (UriParserSemanticException e) { [EOL] assertEquals("Incompatible types.", e.getMessage()); [EOL] } [EOL] } [EOL]
@Test [EOL] public void invokingZInterStoreCreatesNewSpan() { [EOL] commandCreatesNewSpan(RedisCommand.ZINTERSTORE, [EOL] () -> getConnection().zInterStore("dst".getBytes(), "set".getBytes())); [EOL] verify(mockRedisConnection()).zInterStore("dst".getBytes(), "set".getBytes()); [EOL] [EOL] commandCreatesNewSpan(RedisCommand.ZINTERSTORE, [EOL] () -> getConnection().zInterStore("dst".getBytes(), [EOL] RedisZSetCommands.Aggregate.SUM, new int[]{0}, "set".getBytes())); [EOL] verify(mockRedisConnection()) [EOL] .zInterStore("dst".getBytes(), RedisZSetCommands.Aggregate.SUM, new int[]{0}, [EOL] "set".getBytes()); [EOL] } [EOL]
@Test(timeout = 2000) [EOL] public void testTimeoutSelectorNormal1() { [EOL] PublishSubject<Integer> source = PublishSubject.create(); [EOL] final PublishSubject<Integer> timeout = PublishSubject.create(); [EOL] [EOL] Func1<Integer, Observable<Integer>> timeoutFunc = new Func1<Integer, Observable<Integer>>() { [EOL] @Override [EOL] public Observable<Integer> call(Integer t1) { [EOL] return timeout; [EOL] } [EOL] }; [EOL] [EOL] Func0<Observable<Integer>> firstTimeoutFunc = new Func0<Observable<Integer>>() { [EOL] @Override [EOL] public Observable<Integer> call() { [EOL] return timeout; [EOL] } [EOL] }; [EOL] [EOL] Observable<Integer> other = Observable.from(Arrays.asList(100)); [EOL] [EOL] @SuppressWarnings("unchecked") [EOL] Observer<Object> o = mock(Observer.class); [EOL] InOrder inOrder = inOrder(o); [EOL] [EOL] source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o); [EOL] [EOL] source.onNext(1); [EOL] source.onNext(2); [EOL] source.onNext(3); [EOL] timeout.onNext(1); [EOL] [EOL] inOrder.verify(o).onNext(1); [EOL] inOrder.verify(o).onNext(2); [EOL] inOrder.verify(o).onNext(3); [EOL] inOrder.verify(o).onNext(100); [EOL] inOrder.verify(o).onCompleted(); [EOL] verify(o, never()).onError(any(Throwable.class)); [EOL] [EOL] } [EOL]
@Test [EOL] public void getAllPostsOfGroup() throws Exception { [EOL] server.enqueue(new MockResponse().setBody(file("groups/posts_of_group.json"))); [EOL] Response<List<Post>, HttpError> response = resource.getAllPostsOfGroup("1234123").execute(); [EOL] assertThat(response.body()).isNotNull(); [EOL] assertThat(response.body().size()).isEqualTo(10); [EOL] Post firstPost = response.body().get(0); [EOL] assertThat(firstPost).isNotNull(); [EOL] assertThat(firstPost.title()).isEqualTo("Android-Entwickler (M/W) - Region Oldenburg (Oldb) - Hamburg"); [EOL] assertThat(firstPost.content()).isEqualTo( [EOL] "Android Entwickler (M/W) - Oldenburg (Oldb) oder Hamburg\n" [EOL] + "\n" [EOL] + "Nur wenn man etwas wirklich gern macht, macht man es auch wirklich gut. Wir legen daher großen " [EOL] + "Wert auf eine angenehme Atmosphäre, die es unseren Entwicklern und Beratern erlaubt, das " [EOL] + "auszuleben, was sie bei all ihrer Vielfalt verbindet: ihre Leidenschaft für Technik, Computer und " [EOL] + "Programme. Wir bieten eine anspruchsvolle Position mit viel Abwechslung in den Aufgabenstellungen " [EOL] + "und Kundenprojekten. Für die tägliche Arbeit bekommst Du den nötigen Freiraum, den Du brauchst - " [EOL] + "und auch interne Verantwortung für Deine eigenen Projekte. Wir arbeiten in einem jungen, " [EOL] + "aufgeschlossenen Team und modernem Arbeitsumfeld.\n" [EOL] + "\n" [EOL] + "Unsere gemeinsamen Aufgaben:\n" [EOL] + "- Software-Entwicklung für Smartphone- und Tablet-Plattformen\n" [EOL] + "(iPhone, iPad, Android, Windows-Phone)\n" [EOL] + "- Programmierung plattformunabhängiger Software\n" [EOL] + "- Portal- und Website-Entwicklung\n" [EOL] + "- Technologie-Consulting\n" [EOL] + "- UI / UX Design\n" [EOL] + "\n" [EOL] + "Deine Qualitäten:\n" [EOL] + "- Erfolgreich abgeschlossenes Studium der Informatik/Wirtschaftsinformatik oder vergleichbare " [EOL] + "Ausbildung mit entsprechendem Hintergrund\n" [EOL] + "- Kenntnisse als Entwickler in Android ab Version 4 sowie den gängigen Tools (Android SDK)\n" [EOL] + "- Erfahrungen im Testen, Releasen und Deployen von Android Apps\n" [EOL] + "- idealer weise bereits Umgang mit agiler Projektmethode (SCRUM)\n" [EOL] + "\n" [EOL] + "Wir sind ein Softwareentwicklungshaus mit Hauptsitz in Oldenburg (Oldb) und einer Niederlassung in" [EOL] + " Hamburg. Unser Team von 15 Mitmachern entwickelt individuelle Softwareapplikationen, z.B. mobile " [EOL] + "Anwendungen für iPhone und Android. Viele zufriedene Kunden - insbesondere ein großes regionales " [EOL] + "Energieunternehmen - profitieren von unserer mehrjährigen Erfahrung. Aufgrund unserer " [EOL] + "hervorragenden Auftragslage wollen wir weiter wachsen.\n" [EOL] + "\n" [EOL] + "Kontaktaufnahme: \n" [EOL] + "\n" [EOL] + "Markus Kunle, Personalberater \n" [EOL] + "expertum GmbH \n" [EOL] + "01752626532\n" [EOL] + "markus.kunle@expertum-gruppe.de"); [EOL] assertThat(firstPost.likeCount()).isEqualTo(0); [EOL] assertThat(firstPost.commentCount()).isEqualTo(0); [EOL] } [EOL]
@Test [EOL] void shouldSupportAsOffsetTime() [EOL] { [EOL] OffsetTime time = OffsetTime.of( 23, 59, 59, 999_999_999, ZoneOffset.ofHoursMinutes( 2, 15 ) ); [EOL] TimeValue timeValue = new TimeValue( time ); [EOL] assertEquals( time, timeValue.asOffsetTime() ); [EOL] } [EOL]
@Test [EOL] public void checkCanCreateWhenFeatureDisabled() { [EOL] when(authorizationManager.authorize(any(ResourceRef.class), [EOL] eq(ResourceAction.READ), [EOL] eq(user))).thenReturn(false); [EOL] [EOL] assertFalse(handler.canCreate()); [EOL] assertResourceRef(); [EOL] } [EOL]
@Test [EOL] public void hasAGaugeForGcCounts() throws Exception { [EOL] final Gauge gauge = (Gauge) metrics.getMetrics().get(PS_OLDGEN_COUNT); [EOL] assertThat(gauge.getValue()) [EOL] .isEqualTo(1L); [EOL] } [EOL]
@Test [EOL] public void testDecodeGet() throws Exception { [EOL] DefaultResourceRequest decoded = decode(HttpMethod.GET, "/memory/people/bob"); [EOL] [EOL] assertThat(decoded.requestType()).isEqualTo(RequestType.READ); [EOL] [EOL] assertThat(decoded.resourcePath().segments()).hasSize(3); [EOL] assertThat(decoded.resourcePath().segments().get(0).name()).isEqualTo("memory"); [EOL] assertThat(decoded.resourcePath().segments().get(1).name()).isEqualTo("people"); [EOL] assertThat(decoded.resourcePath().segments().get(2).name()).isEqualTo("bob"); [EOL] [EOL] //assertThat(decoded.mediaType()).isEqualTo(MediaType.JSON); [EOL] [EOL] assertThat(decoded.requestContext().pagination()).isNotNull(); [EOL] // TODO: still looking into whether this test failing is proper or not [EOL] //assertThat( decoded.pagination() ).isEqualTo(Pagination.NONE); [EOL] [EOL] assertThat(decoded.state()).isNull(); [EOL] } [EOL]
@Test [EOL] public void testWriteIterable() throws Exception { [EOL] write(records, writer); [EOL] // note writer does not add trailing commas to blockSizes and blockStarts as examples contain [EOL] assertEquals("chr1\t11873\t14409\tuc001aaa.3\t0\t+\t11873\t11873\t0\t3\t354,109,1189\t0,739,1347", stringWriter.toString().trim()); [EOL] } [EOL]
@Test [EOL] public void testToString() throws Exception { [EOL] Job newJob = new JobImpl(3L, "test", "test_org", 0L, "simple", "do", null, DISPATCHING, "localhost", [EOL] "remotehost", null, null, null, 100L, 200L, "result", 3L, 1L, true, null, 1.5F); [EOL] JpaJob jpaJob = JpaJob.from(newJob); [EOL] String jobString = "Job {id:3, operation:do, status:DISPATCHING}"; [EOL] assertEquals(jpaJob.toString(), jobString); [EOL] } [EOL]
@Test [EOL] public void builderNullHandler() { [EOL] try { [EOL] PathDispatcher.builder().add("GET", "", null); [EOL] fail("expected NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] // expected [EOL] } [EOL] } [EOL]
@Test [EOL] void testDeduplication() { [EOL] // GIVEN [EOL] ColumnIdentifier a1 = new ColumnIdentifier("R", "A1"); [EOL] ColumnIdentifier a2 = new ColumnIdentifier("R", "A2"); [EOL] ColumnIdentifier a3 = new ColumnIdentifier("R", "A3"); [EOL] ColumnIdentifier b1 = new ColumnIdentifier("S", "B1"); [EOL] ColumnIdentifier b3 = new ColumnIdentifier("S", "B3"); [EOL] InclusionDependency ind = new InclusionDependency( [EOL] new ColumnPermutation(a1, a2, a3), [EOL] new ColumnPermutation(b1, b1, b3)); [EOL] Set<InclusionDependency> expectedInds = ImmutableSet.of( [EOL] new InclusionDependency(new ColumnPermutation(a1, a3), new ColumnPermutation(b1, b3)), [EOL] new InclusionDependency(new ColumnPermutation(a2, a3), new ColumnPermutation(b1, b3))); [EOL] [EOL] // WHEN [EOL] Set<InclusionDependency> dedupedInds = IndDeduplicator.deduplicateColumnIdentifier(ind); [EOL] [EOL] // THEN [EOL] assertThat(dedupedInds).isEqualTo(expectedInds); [EOL] } [EOL]
@Test [EOL] public void propertyIncludeTest() throws FileNotFoundException, IOException, XmlPullParserException { [EOL] String property = "svn:ignore"; [EOL] assertEquals(filter.includeProperty(property), true); [EOL] } [EOL]
@Test [EOL] public void testMethodInjection() { [EOL] prep(Inject.class); [EOL] [EOL] TestMethodInjection testObject = mRealObjectMaker.createObject( [EOL] mDependencyProvider, [EOL] TypeToken.of(TestMethodInjection.class)); [EOL] [EOL] assertTestObjectNormal(testObject, TestMethodInjection.class); [EOL] verifyDependencyProviderCalls(runnableKey); [EOL] assertThat(testObject.mRunnable).isEqualTo(mRunnableMock); [EOL] } [EOL]
@Test [EOL] public void shouldFindPositionOfFirstOffendingParenthesis() throws Exception { [EOL] final String input = ")()("; [EOL] int position = checker.firstOffendingParenthesis(input); [EOL] assertThat(position, equalTo(0)); [EOL] } [EOL]
@Test [EOL] 	public void check_two() { [EOL] [EOL] 		for( boolean sub : new boolean[]{false,true}) { [EOL] 			FunctionBatchNorm_F32 alg = new FunctionBatchNorm_F32(false); [EOL] [EOL] 			alg.initialize(d0, d1); [EOL] 			alg.setEPS(EPS); [EOL] [EOL] 			Tensor_F32 input = TensorFactory_F32.random(random, sub, N, d0, d1); [EOL] 			Tensor_F32 params = TensorFactory_F32.random(random, sub, d0, d1, 2); [EOL] 			Tensor_F32 output = TensorFactory_F32.random(random, sub, N, d0, d1); [EOL] [EOL] 			Tensor_F32 expected = new Tensor_F32(N, d0, d1); [EOL] [EOL] 			for (int batch = 0; batch < N; batch++) { [EOL] 				int indexIn = input.idx(batch, 0, 0); [EOL] 				int indexP = params.idx(0,0,0); [EOL] 				int indexOut = expected.idx(batch,0,0); [EOL] [EOL] 				for (int i = 0; i < D; i++) { [EOL] 					float m = params.d[indexP++]; [EOL] 					float v = params.d[indexP++]; [EOL] [EOL] 					expected.d[indexOut++] = (input.d[indexIn++]-m) / (float)Math.sqrt(v+EPS); [EOL] 				} [EOL] 			} [EOL] [EOL] 			alg.setParameters(WT(params)); [EOL] 			alg.forward(input, output); [EOL] [EOL] 			DeepUnitTest.assertEquals(expected,output, DeepBoofConstants.TEST_TOL_F32); [EOL] 		} [EOL] 	} [EOL]
@Test [EOL] public final void testGetComponentClass() throws IOException { [EOL] FacesRequest facesRequest = startFacesRequest(); [EOL] FacesContext facesContext = FacesContext.getCurrentInstance(); [EOL] AbstractDataGrid component = (AbstractDataGrid) facesContext.getViewRoot().findComponent("dataGrid"); [EOL] DataGridRenderer renderer = (DataGridRenderer) FacesContext.getCurrentInstance().getRenderKit() [EOL] .getRenderer(component.getFamily(), component.getRendererType()); [EOL] assertEquals(AbstractDataGrid.class, renderer.getComponentClass()); [EOL] facesRequest.release(); [EOL] } [EOL]
@Test [EOL] public void testgetAsBool_True() { [EOL] assertTrue(new JBBPFieldLong(new JBBPNamedFieldInfo("test.field", "field", 123), 32423L).getAsBool()); [EOL] } [EOL]
@Test [EOL] public void testGetGeneratedTranscriptionNotInWorkspace() throws Exception { [EOL] InputStream stream = GoogleSpeechTranscriptionServiceTest.class.getResourceAsStream("/" + PULLED_TRANSCRIPTION_FILE); [EOL] [EOL] database.storeJobControl(MP_ID, TRACK_ID, JOB_ID, TranscriptionJobControl.Status.InProgress.name(), TRACK_DURATION, DATE_EXPECTED, PROVIDER); [EOL] [EOL] URI uri = new URI("http://ADMIN_SERVER/collection/" + GoogleSpeechTranscriptionService.TRANSCRIPT_COLLECTION + "/" [EOL] + JOB_ID + ".json"); [EOL] EasyMock.expect(workspace.getCollectionURI(GoogleSpeechTranscriptionService.TRANSCRIPT_COLLECTION, JOB_ID + ".json")) [EOL] .andReturn(uri); [EOL] EasyMock.expect(workspace.get(uri)).andThrow(new NotFoundException()); [EOL] EasyMock.expect(workspace.putInCollection(EasyMock.anyObject(String.class), EasyMock.anyObject(String.class), [EOL] EasyMock.anyObject(InputStream.class))).andReturn(uri); [EOL] EasyMock.replay(workspace); [EOL] [EOL] HttpEntity httpEntity = EasyMock.createNiceMock(HttpEntity.class); [EOL] EasyMock.expect(httpEntity.getContent()).andReturn(stream); [EOL] [EOL] CloseableHttpResponse response = EasyMock.createNiceMock(CloseableHttpResponse.class); [EOL] StatusLine status = EasyMock.createNiceMock(StatusLine.class); [EOL] EasyMock.expect(response.getStatusLine()).andReturn(status).anyTimes(); [EOL] EasyMock.expect(response.getEntity()).andReturn(httpEntity).anyTimes(); [EOL] EasyMock.expect(status.getStatusCode()).andReturn(HttpStatus.SC_OK).anyTimes(); [EOL] EasyMock.replay(httpEntity, response, status); [EOL] [EOL] EasyMock.expect(httpClient.execute(EasyMock.anyObject(HttpGet.class))).andReturn(response).anyTimes(); [EOL] EasyMock.replay(httpClient); [EOL] [EOL] MediaPackageElement mpe = service.getGeneratedTranscription(MP_ID, JOB_ID); [EOL] Assert.assertEquals("captions", mpe.getFlavor().getType()); [EOL] Assert.assertEquals("google-speech-json", mpe.getFlavor().getSubtype()); [EOL] Assert.assertEquals(uri.toString(), mpe.getURI().toString()); [EOL] } [EOL]
@Test( expected = KException.class ) [EOL] public void shouldNotAllowNullCategoryIfNotSet() throws Exception { [EOL] this.function.setCategory( getTransaction(), null ); [EOL] } [EOL]
@Test [EOL] public void testSetupHideColumnWhenItIsNotEnabled() throws Exception { [EOL] page.setupHideColumn(); [EOL] [EOL] verify(view, [EOL] never()).showHideColumn(any(Boolean.class)); [EOL] } [EOL]
@Test [EOL] public void testIsWildcardMatch() { [EOL] assertTrue(FormatUtils.isWildCardMatch("TEST_1", "TEST_*")); [EOL] assertTrue(FormatUtils.isWildCardMatch("TEST_2", "TEST_*")); [EOL] assertTrue(FormatUtils.isWildCardMatch("TEST_TEST_TEST", "TEST_*")); [EOL] assertFalse(FormatUtils.isWildCardMatch("NOT_A_MATCH", "TEST_*")); [EOL] assertFalse(FormatUtils.isWildCardMatch("NOT_A_MATCH_TEST_1", "TEST_*")); [EOL] assertTrue(FormatUtils.isWildCardMatch("NOT_A_MATCH_TEST_1", "*TEST*")); [EOL] assertFalse(FormatUtils.isWildCardMatch("TEST_12", "TEST_1")); [EOL] assertFalse(FormatUtils.isWildCardMatch("B_A", "*A*B")); [EOL] assertTrue(FormatUtils.isWildCardMatch("A_B", "*A*B")); [EOL] assertFalse(FormatUtils.isWildCardMatch("TEST_NO_MATCH", "TEST_*,!TEST_NO_MATCH")); [EOL] assertTrue(FormatUtils.isWildCardMatch("A_B", "A*B")); [EOL] } [EOL]
@Test [EOL] public void testIgnoresIncorrectExpression1() { [EOL] String path = "/a/b/c/d/e"; [EOL] String expr = "/a/b/{c/d/e"; [EOL] [EOL] PathFilter regexpPathUriFilter = new DefaultPathFilter("XXX", expr); [EOL] [EOL] String result = regexpPathUriFilter.filter(path); [EOL] assertThat(path, sameInstance(result)); [EOL] } [EOL]
@Test [EOL] public void testExceptionHandling() throws Exception { [EOL] InvocationHandler rtExcHandler = new InvocationHandler() { [EOL] @Override [EOL] public Object invoke(Object proxy, Method method, Object[] args) [EOL] throws Throwable { [EOL] throw new RuntimeException("forced runtime error"); [EOL] } [EOL] }; [EOL] DBIterator dbiter = (DBIterator) Proxy.newProxyInstance( [EOL] DBIterator.class.getClassLoader(), new Class[] { DBIterator.class }, [EOL] rtExcHandler); [EOL] LeveldbIterator iter = new LeveldbIterator(dbiter); [EOL] for (CallInfo ci : RTEXC_METHODS) { [EOL] Method method = iter.getClass().getMethod(ci.methodName, ci.argTypes); [EOL] assertNotNull("unable to locate method " + ci.methodName, method); [EOL] try { [EOL] method.invoke(iter, ci.args); [EOL] fail("operation should have thrown"); [EOL] } catch (InvocationTargetException ite) { [EOL] Throwable exc = ite.getTargetException(); [EOL] assertTrue("Method " + ci.methodName + " threw non-DBException: " [EOL] + exc, exc instanceof DBException); [EOL] assertFalse("Method " + ci.methodName + " double-wrapped DBException", [EOL] exc.getCause() instanceof DBException); [EOL] } [EOL] } [EOL] [EOL] // check close() throws IOException [EOL] try { [EOL] iter.close(); [EOL] fail("operation shoul have thrown"); [EOL] } catch (IOException e) { [EOL] // expected [EOL] } [EOL] } [EOL]
@Test [EOL] public void checkBuilder() { [EOL] SampleDAO sampleDAO = DAOBuilder.buildDAO(Sample.class, [EOL] SampleDAO.class, [EOL] PartialSampleDAOImplementation.class, [EOL] null); [EOL] [EOL] // TODO: reflect on sampleDAO for concrete implementations of methods found in SampleDAO [EOL] // TODO: can check sampleDAO's real class type [EOL] List<Sample> t = sampleDAO.getMany(0); [EOL] [EOL] Assert.assertTrue(t.size() > 1); [EOL] sampleDAO.findByFieldOne(0); [EOL] sampleDAO.findByFieldOneGreaterThan(1); [EOL] } [EOL]
@Test [EOL] public void testCreateWhenBundleVersionAlreadyExists() throws IOException { [EOL] final BundleVersionType type = BundleVersionType.NIFI_NAR; [EOL] [EOL] final String content1 = "g1-a1-1.0.0"; [EOL] final BundleVersionCoordinate versionCoordinate = getVersionCoordinate("b1", "g1", "a1", "1.0.0", type); [EOL] createBundleVersion(fileSystemBundleProvider, versionCoordinate, content1); [EOL] verifyBundleVersion(bundleStorageDir, versionCoordinate, content1); [EOL] [EOL] // try to save same bundle version that already exists [EOL] try { [EOL] final String newContent = "new content"; [EOL] createBundleVersion(fileSystemBundleProvider, versionCoordinate, newContent); [EOL] Assert.fail("Should have thrown exception"); [EOL] } catch (BundlePersistenceException e) { [EOL] // expected [EOL] } [EOL] [EOL] // verify existing content wasn't modified [EOL] verifyBundleVersion(bundleStorageDir, versionCoordinate, content1); [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("all") [EOL] public void listCampaignDraftAsyncErrorsTest() { [EOL] String nextPageToken = ""; [EOL] com.google.rpc.Status errorsElement = com.google.rpc.Status.newBuilder().build(); [EOL] List<com.google.rpc.Status> errors = Arrays.asList(errorsElement); [EOL] ListCampaignDraftAsyncErrorsResponse expectedResponse = [EOL] ListCampaignDraftAsyncErrorsResponse.newBuilder() [EOL] .setNextPageToken(nextPageToken) [EOL] .addAllErrors(errors) [EOL] .build(); [EOL] mockCampaignDraftService.addResponse(expectedResponse); [EOL] [EOL] CampaignDraftName resourceName = CampaignDraftName.of("[CUSTOMER]", "[CAMPAIGN_DRAFT]"); [EOL] [EOL] ListCampaignDraftAsyncErrorsPagedResponse pagedListResponse = [EOL] client.listCampaignDraftAsyncErrors(resourceName); [EOL] [EOL] List<com.google.rpc.Status> resources = Lists.newArrayList(pagedListResponse.iterateAll()); [EOL] Assert.assertEquals(1, resources.size()); [EOL] Assert.assertEquals(expectedResponse.getErrorsList().get(0), resources.get(0)); [EOL] [EOL] List<AbstractMessage> actualRequests = mockCampaignDraftService.getRequests(); [EOL] Assert.assertEquals(1, actualRequests.size()); [EOL] ListCampaignDraftAsyncErrorsRequest actualRequest = [EOL] (ListCampaignDraftAsyncErrorsRequest) actualRequests.get(0); [EOL] [EOL] Assert.assertEquals(resourceName, CampaignDraftName.parse(actualRequest.getResourceName())); [EOL] Assert.assertTrue( [EOL] channelProvider.isHeaderSent( [EOL] ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), [EOL] GaxGrpcProperties.getDefaultApiClientHeaderPattern())); [EOL] } [EOL]
@Test [EOL] void testChecksum() throws URISyntaxException, IOException { [EOL] final Path checksumTestFile = Path.of(Objects.requireNonNull(Thread.currentThread().getContextClassLoader() [EOL] .getResource("checksum_test.txt")).toURI()); [EOL] [EOL] final Mono<String> result = sha256ChecksumProvider.checksum( [EOL] Files.newInputStream(checksumTestFile).readAllBytes()); [EOL] [EOL] StepVerifier.create(result) [EOL] .assertNext(resultValue -> assertThat(resultValue, is( [EOL] "5be0888bbe2087f962fee5748d9cf52e37e4c6a24af79675ff7e1ca0a1b12739"))) [EOL] .verifyComplete(); [EOL] } [EOL]
@Test [EOL] public void testStoreDataFile_alreadyInDb() { [EOL] final String path = "/path/to/wherever"; [EOL] final DataFile dataFile = new DataFile(path, new SensorBuilder().name("Firlefanz").build()); [EOL] [EOL] when(mockStorage.getDatafile(path)).thenReturn(dataFile); [EOL] [EOL] try { [EOL] MmdIngestionTool.storeDataFile(dataFile, mockStorage); [EOL] fail("IllegalStateException expected"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] [EOL] verify(mockStorage, times(1)).getDatafile(path); [EOL] verifyNoMoreInteractions(mockStorage); [EOL] } [EOL]
@Test [EOL] public void testSetFlowLock() throws Exception { [EOL] // trying to execute a locked flow should raise an error [EOL] this.flow1.setLocked(true); [EOL] final String msg = this.controller.submitExecutableFlow(this.flow1, this.user.getUserId()); [EOL] assertThat(msg).isEqualTo("Flow derived-member-data for project flow is locked."); [EOL] [EOL] // should succeed after unlocking the flow [EOL] this.flow1.setLocked(false); [EOL] this.controller.submitExecutableFlow(this.flow1, this.user.getUserId()); [EOL] verify(this.loader).uploadExecutableFlow(this.flow1); [EOL] } [EOL]
@Test(expected = SchemaValidationException.class) [EOL] public void rootTypeIsNotRecord() throws Exception { [EOL] Schema schema = SchemaBuilder.builder().bytesType(); [EOL] DataHighwaySchemaValidator.validate(schema, DISALLOW_NON_NULLABLE_UNIONS); [EOL] } [EOL]
@Test [EOL] public void getKieAssetsDropdownItemFileWithoutPath() { [EOL] String fullPath = "filename.etc"; [EOL] KieAssetsDropdownItem item = scenarioSimulationKogitoRuntimeCreationAssetsDropdownProviderImplSpy.getKieAssetsDropdownItem(fullPath); [EOL] assertNotNull(item); [EOL] assertEquals(fullPath, item.getValue()); [EOL] assertEquals(fullPath, item.getSubText()); [EOL] assertEquals(fullPath, item.getText()); [EOL] } [EOL]
@Test(expected = ParseException.class) [EOL] public void testParseFailure5() throws Exception { [EOL] impl.parse("TLSv1.A"); [EOL] } [EOL]
@Test(expected = AssertionError.class) [EOL] public void testInterpitLocator_nonExistingXpath() throws IOException { [EOL] seleniumNavigationService.navigate_to_url(MockReferenceDatePopulator.TABLE_TEST_PAGE_URL); [EOL] seleniumElementService.translateLocatorToWebElement(ElementService.XPATH_LOCATOR_PREFIX + "//table//marquee"); [EOL] } [EOL]
@Test [EOL] 	public void testReadFile() throws IOException { [EOL] 		// Act [EOL] 		String ruleExecutionResponseContainer = fileReader [EOL] 				.readFile("ruleExecutionResponseContainer.xml"); [EOL] [EOL] 		logger.debug(ruleExecutionResponseContainer); [EOL] [EOL] 		// Assert [EOL] 		assertTrue(ruleExecutionResponseContainer [EOL] 				.contains("<ruleExecutionContainer>")); [EOL] 		assertTrue(ruleExecutionResponseContainer [EOL] 				.contains("<executionResponseList>")); [EOL] 		assertTrue(ruleExecutionResponseContainer [EOL] 				.contains("<executionResponse>")); [EOL] 		assertTrue(ruleExecutionResponseContainer [EOL] 				.contains("<c32SectionLoincCode>11450-4</c32SectionLoincCode>")); [EOL] 		assertTrue(ruleExecutionResponseContainer [EOL] 				.contains("<sensitivity>ETH</sensitivity>")); [EOL] 		assertTrue(ruleExecutionResponseContainer [EOL] 				.contains("<sensitivity>HIV</sensitivity>")); [EOL] 	} [EOL]
@Test [EOL] public void testDestroyUnregisters() { [EOL] verifyZeroInteractions(m_deviceManager); [EOL] [EOL] m_listener.destroy(); [EOL] [EOL] verify(m_deviceManager).removeDeviceStateProvider(m_listener); [EOL] } [EOL]
@Test [EOL] public void retrieveStateAttributesOfDeviceB() throws Exception { [EOL] Map<ModelNodeId, Pair<List<QName>, List<FilterNode>>> mapAttributes = new HashMap<>(); [EOL] Document deviceStateFilter = DocumentUtils.loadXmlDocument(DeviceManagementSubsystemTest.class.getResourceAsStream("/filter-connection-state-request.xml")); [EOL] mapAttributes.put(DEVICE_B_ID_TEMPLATE, new Pair<>(Collections.emptyList(), Arrays.asList(getFilterNode(deviceStateFilter)))); [EOL] Map<ModelNodeId, List<Element>> stateInfo = m_deviceManagementSubsystem.retrieveStateAttributes(mapAttributes); [EOL] assertEquals(1, stateInfo.size()); [EOL] List<Element> deviceBState = stateInfo.get(DEVICE_B_ID_TEMPLATE); [EOL] assertEquals(1, deviceBState.size()); [EOL] Document deviceBStatedocument = getDeviceStateDocumentWithConnectionStateFilter(DEVICE_B); [EOL] TestUtil.assertXMLEquals(deviceBStatedocument.getDocumentElement(), deviceBState.get(0)); [EOL] } [EOL]
@Test(expectedExceptions = ArrayIndexOutOfBoundsException.class) [EOL] public void wrongTargetIndexTest() throws IOException { [EOL] // GIVEN [EOL] try (BigByteBuffer buf = new BigByteBuffer(new byte[] { 1, 2 })) { [EOL] [EOL] // WHEN THEN [EOL] byte[] tmp = new byte[2]; [EOL] buf.get(0, tmp, 1, 2); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testEnumerateFileNameOptionsWithDefaultBundleWithoutContext() { [EOL] List<String> options = strategy.enumerateFileNameOptions(new String[] { [EOL] "resource.properties", [EOL] "default.properties" [EOL] }, in(Locale.US)); [EOL] assertEquals(6, options.size()); [EOL] assertEquals("resource-en_US.properties", options.get(0)); [EOL] assertEquals("resource-en.properties", options.get(1)); [EOL] assertEquals("resource.properties", options.get(2)); [EOL] assertEquals("default-en_US.properties", options.get(3)); [EOL] assertEquals("default-en.properties", options.get(4)); [EOL] assertEquals("default.properties", options.get(5)); [EOL] } [EOL]
@Test [EOL] public void testTerm() { [EOL] TerminalParser.parse(TerminalParser.term("select"), "select"); [EOL] TerminalParser.parse(TerminalParser.term("select"), "SELECT"); [EOL] TerminalParser.parse(TerminalParser.term("select"), " SELEcT --coment"); [EOL] assertFailure(TerminalParser.term("select"), "[select]", 1, 1); [EOL] } [EOL]
@Test [EOL] public void testStringToOperatorBetween() { [EOL] String symbol = "><"; [EOL] Assert.assertEquals(Convert.stringToOperator(symbol), Operator.BETWEEN); [EOL] } [EOL]
@Test [EOL] 	public void testHashCode() { [EOL] 		String message = "message"; [EOL] 		Throwable throwable = new Throwable(); [EOL] [EOL] 		LocalProcessLog localProcessLog = new LocalProcessLog( [EOL] 			ProcessLog.Level.DEBUG, message, throwable); [EOL] [EOL] 		int hash = HashUtil.hash(0, ProcessLog.Level.DEBUG); [EOL] [EOL] 		hash = HashUtil.hash(hash, message); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			localProcessLog.hashCode(), HashUtil.hash(hash, throwable)); [EOL] 	} [EOL]
@Test [EOL] public void testCreateTable() { [EOL] String sql = "CREATE TABLE table123 (uid INT)"; [EOL] QueryEvent event = new QueryEvent(1L, TIMESTAMP, BINLOG_FILE_POS, "db1", sql); [EOL] List<MysqlColumn> newTableColumns = [EOL] Collections.singletonList(new MysqlColumn("uid", "int", "int", false)); [EOL] when(schemaDatabase.getColumnsForAllTables("db1")) [EOL] .thenReturn( [EOL] ImmutableMap.of( [EOL] "table1", TABLE1_COLUMNS, "table2", TABLE2_COLUMNS, "table123", newTableColumns)); [EOL] [EOL] schemaManager.processDDL(event, GTID); [EOL] verify(schemaDatabase).applyDDL(sql, "db1"); [EOL] verify(schemaStore) [EOL] .put( [EOL] new MysqlTableSchema( [EOL] 0, [EOL] "db1", [EOL] "table123", [EOL] BINLOG_FILE_POS, [EOL] GTID, [EOL] sql, [EOL] TIMESTAMP, [EOL] newTableColumns, [EOL] Collections.emptyMap())); [EOL] } [EOL]
@Test [EOL] public void show() { [EOL] User user = WebClient.create("http://localhost:4204/rest-on-ejb") [EOL] .path("/user/show/" + users.iterator().next().getId()) [EOL] .get(User.class); [EOL] assertEquals("foo", user.getFullname()); [EOL] assertEquals("foopwd", user.getPassword()); [EOL] assertEquals("foo@foo.com", user.getEmail()); [EOL] } [EOL]
@Test(expected = ImmutableViolationException.class) [EOL] public void testSaveFactCommentTwiceThrowsException() { [EOL] FactCommentEntity comment = createFactComment(createAndSaveFact().getId()); [EOL] getFactManager().saveFactComment(comment); [EOL] getFactManager().saveFactComment(comment); [EOL] } [EOL]
@Test [EOL] public void testOut() throws Exception { [EOL] final String prog = "void f(out int x) { } void main() { int a; f(a); }"; [EOL] TranslationUnit tu = ParseHelper.parse(prog); [EOL] List<SimplifyExprReductionOpportunity> ops = ExprToConstantReductionOpportunities [EOL] .findOpportunities(MakeShaderJobFromFragmentShader.make(tu), [EOL] new ReducerContext(true, ShadingLanguageVersion.ESSL_100, [EOL] new RandomWrapper(0), new IdGenerator())); [EOL] for (SimplifyExprReductionOpportunity op : ops) { [EOL] op.applyReduction(); [EOL] } [EOL] assertEquals(PrettyPrinterVisitor.prettyPrintAsString(ParseHelper.parse(prog)), [EOL] PrettyPrinterVisitor.prettyPrintAsString(tu)); [EOL] } [EOL]
@Test [EOL] public void testGetDatanodeByHost() throws Exception { [EOL] assertEquals(map.getDatanodeByHost("1.1.1.1"), dataNodes[0]); [EOL] assertEquals(map.getDatanodeByHost("2.2.2.2"), dataNodes[1]); [EOL] DatanodeDescriptor node = map.getDatanodeByHost("3.3.3.3"); [EOL] assertTrue(node == dataNodes[2] || node == dataNodes[3]); [EOL] assertNull(map.getDatanodeByHost("4.4.4.4")); [EOL] } [EOL]
@Test [EOL] public void testMaximumLengthEmpty() { [EOL] assertEquals(-1L, maximumLength(Collections.<Range<Long>>emptySet())); [EOL] } [EOL]
@Test [EOL] 	public void testRecognizeComponent() throws Exception { [EOL] [EOL] 		Map<String,ParsingError> resourceNameToErrorCode = new LinkedHashMap<> (); [EOL] 		resourceNameToErrorCode.put( "component-invalid-property.graph", new ParsingError( ErrorCode.P_INVALID_PROPERTY, null, 2 )); [EOL] 		resourceNameToErrorCode.put( "component-invalid-end.graph", new ParsingError( ErrorCode.P_C_C_BRACKET_EXTRA_CHARACTERS, null, 3 )); [EOL] 		resourceNameToErrorCode.put( "component-missing-closing-cb.graph", new ParsingError( ErrorCode.P_C_C_BRACKET_MISSING, null, 3 )); [EOL] 		resourceNameToErrorCode.put( "component-missing-opening-cb.graph", new ParsingError( ErrorCode.P_O_C_BRACKET_MISSING, null, 1 )); [EOL] 		resourceNameToErrorCode.put( "component-extra-char.graph", new ParsingError( ErrorCode.P_O_C_BRACKET_EXTRA_CHARACTERS, null, 1 )); [EOL] 		resourceNameToErrorCode.put( "component-line-number.graph", new ParsingError( ErrorCode.P_C_C_BRACKET_MISSING, null, 6 )); [EOL] [EOL] 		testRecognizePropertiesHolder( resourceNameToErrorCode, AbstractBlock.COMPONENT ); [EOL] 	} [EOL]
@Test [EOL] public void test_getFoldersRecursively_admin() { [EOL] [EOL] String path = "shared/mysafe01"; [EOL] String token = "5PDrOhsy4ig8L3EpsJZSLAMg"; [EOL] UserDetails userDetails = getMockUser(true); [EOL] String responseJson = "{\"keys\":[\"mysafe01\"]}"; [EOL] [EOL] ResponseEntity<String> response = ResponseEntity.status(HttpStatus.OK).body(responseJson); [EOL] ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body(responseJson); [EOL] when(safesService.getFoldersRecursively(token, path)).thenReturn(response); [EOL] ResponseEntity<String> responseEntity = selfSupportService.getFoldersRecursively(userDetails, token, path); [EOL] assertEquals(HttpStatus.OK, responseEntity.getStatusCode()); [EOL] assertEquals(responseEntityExpected, responseEntity); [EOL] } [EOL]
@Test [EOL] void get4Test() { [EOL] assertEquals(4, (int) instance.get4()); [EOL] } [EOL]
@Test [EOL] void toUpperCase() { [EOL] assertThat(ASCII.toUpperCase(null)).isNull(); [EOL] assertThat(ASCII.toUpperCase("text")).isEqualTo("TEXT"); [EOL] assertThat(ASCII.toUpperCase("tExt")).isEqualTo("TEXT"); [EOL] assertThat(ASCII.toUpperCase("TEXT")).isEqualTo("TEXT"); [EOL] assertThat(ASCII.toUpperCase("01239_-")).isEqualTo("01239_-"); [EOL] } [EOL]
@Test [EOL] 	public void shouldNameMethodsFieldsWhenAnnotatedOrNot2() throws SecurityException, NoSuchMethodException { [EOL] 		assertThat(provider.parameterNamesFor(Horse.class.getMethod("runThroughWithAnnotation3", Field.class, Field.class))[0], is(equalTo("one"))); [EOL] 		assertThat(provider.parameterNamesFor(Horse.class.getMethod("runThroughWithAnnotation3", Field.class, Field.class))[1], is(equalTo("size"))); [EOL] 	} [EOL]
@Test [EOL] public void testLoadWithNonExistentMountFile() throws Exception { [EOL] ViewFsTestSetup.addMountLinksToFile(TABLE_NAME, [EOL] new String[] {SRC_ONE, SRC_TWO }, [EOL] new String[] {TARGET_ONE, TARGET_TWO }, [EOL] new Path(oldVersionMountTableFile.toURI()), conf); [EOL] loader.load(oldVersionMountTableFile.toURI().toString(), conf); [EOL] Assert.assertEquals(conf.get(MOUNT_LINK_KEY_SRC_TWO), TARGET_TWO); [EOL] Assert.assertEquals(conf.get(MOUNT_LINK_KEY_SRC_ONE), TARGET_ONE); [EOL] } [EOL]
@Test [EOL] public void testEndBy1() { [EOL] Parser<List<Integer>> parser = INTEGER.endBy1(isChar(';')); [EOL] assertListParser(parser, "1;", 1); [EOL] assertListParser(parser, "12;3;", 12, 3); [EOL] assertFailure(mode, parser, "", 1, 1); [EOL] assertFailure(mode, parser, ";", 1, 1); [EOL] assertFailure(mode, parser, "1", 1, 2); [EOL] assertFailure(mode, areChars("ab").endBy1(isChar(';')), "ab;a", 1, 5); [EOL] } [EOL]
@Test [EOL] 	void testGetIdWorksForValidId() { [EOL] 		ByteBuffer id = ByteBuffer.allocate(7); [EOL] 		id.put(new byte[] { 0 }); // Flags none set for managed [EOL] 		id.putInt(3129); // offset [EOL] 		id.putShort((short) 18); // length [EOL] 		id.rewind(); [EOL] [EOL] 		ByteBuffer data = fractalHeap.getId(id); [EOL] [EOL] 		assertThat(data.position(), is(equalTo(0))); [EOL] 		assertThat(data.limit(), is(equalTo(18))); [EOL] 	} [EOL]
@Test [EOL] public void parserReturnsPortGivenIpUrl() { [EOL] [EOL] // given [EOL] String url = "tcp://10.120.10.10:8080"; [EOL] UriParser uriParser = new UriParser(); [EOL] [EOL] // when [EOL] int parsedPort = uriParser.getPort(url); [EOL] [EOL] // then [EOL] Assert.assertEquals(8080, parsedPort); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void afterPropertiesSet_with_invalid_config_test() { [EOL] target = new KeyStoreResourceTrustAnchorProvider(); [EOL] target.afterPropertiesSet(); [EOL] } [EOL]
@Test [EOL] public void testParseSkipCRC() { [EOL] DistCpOptions options = OptionsParser.parse(new String[] { [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.assertFalse(options.shouldSkipCRC()); [EOL] [EOL] options = OptionsParser.parse(new String[] { [EOL] "-update", [EOL] "-skipcrccheck", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.assertTrue(options.shouldSyncFolder()); [EOL] Assert.assertTrue(options.shouldSkipCRC()); [EOL] } [EOL]
@Test [EOL] public void shouldObtainStatementOptionNames() throws Exception { [EOL] final String custom = "blah"; [EOL] this.function.setStatementOption( getTransaction(), custom, "sledge" ); [EOL] [EOL] final String standard = this.function.getStandardOptions().keySet().iterator().next(); [EOL] this.function.setStatementOption( getTransaction(), standard, "hammer" ); [EOL] [EOL] assertThat( this.function.getStatementOptionNames( getTransaction() ).length, is( 2 ) ); [EOL] assertThat( Arrays.asList( this.function.getStatementOptionNames( getTransaction() ) ), hasItems( custom, standard ) ); [EOL] } [EOL]
@Test [EOL] public void defaultTimeout() throws Throwable { [EOL] sut = new CachedSupplier<>(delegate, time); [EOL] [EOL] // Initial load [EOL] var a = sut.get(); [EOL] assertThat(a, is(INITIAL_VALUE)); [EOL] verify(delegate, times(1)).get(); [EOL] [EOL] // Make supplier return new value and progress time enough to trigger refresh [EOL] when(delegate.get()).thenReturn(NEW_VALUE); [EOL] now = now.plus(DEFAULT_TIMEOUT).plusSeconds(1); [EOL] [EOL] // Eventually observe new value [EOL] await().until(() -> sut.get() == NEW_VALUE); [EOL] } [EOL]
@Test [EOL] public void testGetSettingProperties() { [EOL] Map<String, Set<HashMap<String, String>>> properties = new HashMap<>(); [EOL] Set<HashMap<String, String>> setting1 = new HashSet<>(); [EOL] Set<HashMap<String, String>> setting2 = new HashSet<>(); [EOL] [EOL] // Setting 1: Property1 [EOL] HashMap<String, String> setting1Properties1 = new HashMap<String, String>(); [EOL] setting1Properties1.put(Setting.SETTING_NAME_RECOVERY_ENABLED, "true"); [EOL] setting1.add(setting1Properties1); [EOL] [EOL] // Setting 2: Property1 and Property2 [EOL] HashMap<String, String> setting2Properties1 = new HashMap<String, String>(); [EOL] setting2Properties1.put(Setting.SETTING_NAME_NAME, "HDFS"); [EOL] setting2Properties1.put(Setting.SETTING_NAME_RECOVERY_ENABLED, "false"); [EOL] [EOL] HashMap<String, String> setting2Properties2 = new HashMap<String, String>(); [EOL] setting2Properties2.put(Setting.SETTING_NAME_NAME, "TEZ"); [EOL] setting2Properties2.put(Setting.SETTING_NAME_RECOVERY_ENABLED, "false"); [EOL] [EOL] setting2.add(setting2Properties1); [EOL] setting2.add(setting2Properties2); [EOL] [EOL] properties.put(Setting.SETTING_NAME_RECOVERY_SETTINGS, setting1); [EOL] properties.put(Setting.SETTING_NAME_SERVICE_SETTINGS, setting2); [EOL] [EOL] Setting setting = new Setting(properties); [EOL] assertEquals(setting2, setting.getSettingValue(Setting.SETTING_NAME_SERVICE_SETTINGS)); [EOL] } [EOL]
@Test [EOL] public void adapt_oneRow_hasNoMatchingLabels() throws IOException { [EOL] Result expectedResult = [EOL] Result.create( [EOL] ImmutableList.<Cell>of( [EOL] new RowCell( [EOL] Bytes.toBytes("key"), [EOL] Bytes.toBytes("family"), [EOL] Bytes.toBytes("q"), [EOL] 10000L, [EOL] Bytes.toBytes("value"), [EOL] ImmutableList.of("a-out")))); [EOL] when(mockBigtableResultScanner.next()).thenReturn(expectedResult); [EOL] [EOL] ResultScanner scanner = adapter.adapt(mockBigtableResultScanner, mockSpan); [EOL] assertNull(scanner.next()); [EOL] verify(mockSpan, times(1)).end(); [EOL] verify(mockBigtableResultScanner).next(); [EOL] } [EOL]
@Test [EOL] public void testConvertDatanodeRegistration() { [EOL] DatanodeID dnId = DFSTestUtil.getLocalDatanodeID(); [EOL] BlockKey[] keys = new BlockKey[] { getBlockKey(2), getBlockKey(3) }; [EOL] ExportedBlockKeys expKeys = new ExportedBlockKeys(true, 9, 10, [EOL] getBlockKey(1), keys); [EOL] DatanodeRegistration reg = new DatanodeRegistration(dnId, [EOL] new StorageInfo(NodeType.DATA_NODE), expKeys, "3.0.0"); [EOL] DatanodeRegistrationProto proto = PBHelper.convert(reg); [EOL] DatanodeRegistration reg2 = PBHelper.convert(proto); [EOL] compare(reg.getStorageInfo(), reg2.getStorageInfo()); [EOL] compare(reg.getExportedKeys(), reg2.getExportedKeys()); [EOL] compare(reg, reg2); [EOL] assertEquals(reg.getSoftwareVersion(), reg2.getSoftwareVersion()); [EOL] } [EOL]
@Test [EOL] void get2Test() { [EOL] assertEquals(2, (int) instance.get2().orElseThrow(NoSuchElementException::new)); [EOL] } [EOL]
@Test [EOL] public void testCreateEnvironment() throws Exception [EOL] { [EOL] doReturn( "ENV" ).when( topology ).getEnvironmentName(); [EOL] Map<String, Set<Node>> placement = mock( Map.class ); [EOL] doReturn( placement ).when( topology ).getNodeGroupPlacement(); [EOL] doReturn( false ).when( placement ).isEmpty(); [EOL] [EOL] proxy.createEnvironment( topology, true ); [EOL] [EOL] verify( environmentManager ).createEnvironment( topology, true ); [EOL] } [EOL]
@Test [EOL] public void testGetBooleanWithFalseValue() { [EOL] System.setProperty("key", "false"); [EOL] assertFalse(SystemPropertyUtil.getBoolean("key", true)); [EOL] System.setProperty("key", "no"); [EOL] assertFalse(SystemPropertyUtil.getBoolean("key", false)); [EOL] System.setProperty("key", "0"); [EOL] assertFalse(SystemPropertyUtil.getBoolean("key", true)); [EOL] } [EOL]
@Test [EOL] public void testIsCompleteWhenHeaderIsNotEnabled() throws Exception { [EOL] createEmptyModel(); [EOL] page.isComplete(Assert::assertFalse); [EOL] verify(view).showWarning(ENTER_COLUMN_DESCRIPTION); [EOL] } [EOL]
@Test [EOL] public void equalsIsTypeAware() { [EOL] assertFalse("Comparison with different type should always return false", [EOL] x.equals(this)); [EOL] } [EOL]
@Test [EOL] public void test_bytes() { [EOL] byte[] b = new byte[] {1, 2, 3}; [EOL] byte[] bytes = toBytes(b); [EOL] assertArrayEquals(b, toBytes(bytes, 0, 3)); [EOL] } [EOL]
@Test [EOL] public void testDoFilter_shouldDelegateToSecurityFilterChain() throws Exception { [EOL] ServletRequest req = mock(ServletRequest.class); [EOL] ServletResponse resp = mock(ServletResponse.class); [EOL] FilterChain chain = mock(FilterChain.class); [EOL] Filter filter = filterFactory.createFilter(mock(ConfigurableFilterConfig.class)); [EOL] [EOL] filter.doFilter(req, resp, chain); [EOL] [EOL] verify(delegateFilter).doFilter(req, resp, chain); [EOL] } [EOL]
@Test [EOL] 	public void testDeleteConsent_when_authentication_fails() throws Exception { [EOL] 		when(consentService.isConsentBelongToThisUser(anyLong(), anyLong())) [EOL] 				.thenReturn(false); [EOL] 		mockMvc.perform( [EOL] 				post("/consents/deleteConsents").param("consentId", [EOL] 						"ScrambledText")).andExpect( [EOL] 				view().name("redirect:/consents/listConsents.html")); [EOL] 		verify(consentService, never()).deleteConsent(anyLong()); [EOL] 	} [EOL]
@Test [EOL] 	public void shouldNotInvokeInterceptorsMethodIfInterceptorDoesntAcceptsResource() throws InterceptionException, IOException { [EOL] 		final Object instance = new Object(); [EOL] 	when(container.instanceFor(Interceptor.class)).thenReturn(interceptor); [EOL] 	when(interceptor.accepts(method)).thenReturn(false); [EOL] [EOL] 		ToInstantiateInterceptorHandler handler = new ToInstantiateInterceptorHandler(container, Interceptor.class); [EOL] 		handler.execute(stack, method, instance); [EOL] 		 [EOL] 	verify(interceptor, never()).intercept(stack, method, instance); [EOL] 	verify(stack).next(method, instance); [EOL] 	} [EOL]
@Test [EOL] public void testCreated() { [EOL] final Response created = BaseResource.created(); [EOL] assertEquals(Response.Status.CREATED.getStatusCode(), created.getStatus()); [EOL] } [EOL]
@Test [EOL] public void testChooseSrcDatanodesWithDupEC() throws Exception { [EOL] bm.maxReplicationStreams = 4; [EOL] [EOL] long blockId = -9223372036854775776L; // real ec block id [EOL] Block aBlock = new Block(blockId, 0, 0); [EOL] // ec policy [EOL] ECSchema rsSchema = new ECSchema("rs", 3, 2); [EOL] String policyName = "RS-3-2-128k"; [EOL] int cellSize = 128 * 1024; [EOL] ErasureCodingPolicy ecPolicy = [EOL] new ErasureCodingPolicy(policyName, rsSchema, cellSize, (byte) -1); [EOL] // striped blockInfo [EOL] BlockInfoStriped aBlockInfoStriped = new BlockInfoStriped(aBlock, ecPolicy); [EOL] // ec storageInfo [EOL] DatanodeStorageInfo ds1 = DFSTestUtil.createDatanodeStorageInfo( [EOL] "storage1", "1.1.1.1", "rack1", "host1"); [EOL] DatanodeStorageInfo ds2 = DFSTestUtil.createDatanodeStorageInfo( [EOL] "storage2", "2.2.2.2", "rack2", "host2"); [EOL] DatanodeStorageInfo ds3 = DFSTestUtil.createDatanodeStorageInfo( [EOL] "storage3", "3.3.3.3", "rack3", "host3"); [EOL] DatanodeStorageInfo ds4 = DFSTestUtil.createDatanodeStorageInfo( [EOL] "storage4", "4.4.4.4", "rack4", "host4"); [EOL] DatanodeStorageInfo ds5 = DFSTestUtil.createDatanodeStorageInfo( [EOL] "storage5", "5.5.5.5", "rack5", "host5"); [EOL] // link block with storage [EOL] aBlockInfoStriped.addStorage(ds1, aBlock); [EOL] aBlockInfoStriped.addStorage(ds2, new Block(blockId + 1, 0, 0)); [EOL] aBlockInfoStriped.addStorage(ds3, new Block(blockId + 2, 0, 0)); [EOL] // dup internal block [EOL] aBlockInfoStriped.addStorage(ds4, new Block(blockId + 3, 0, 0)); [EOL] aBlockInfoStriped.addStorage(ds5, new Block(blockId + 3, 0, 0)); [EOL] // simulate the node 2 arrive maxReplicationStreams [EOL] for(int i = 0; i < 4; i++){ [EOL] ds4.getDatanodeDescriptor().incrementPendingReplicationWithoutTargets(); [EOL] } [EOL] [EOL] addEcBlockToBM(blockId, ecPolicy); [EOL] List<DatanodeDescriptor> cntNodes = new LinkedList<DatanodeDescriptor>(); [EOL] List<DatanodeStorageInfo> liveNodes = new LinkedList<DatanodeStorageInfo>(); [EOL] NumberReplicas numReplicas = new NumberReplicas(); [EOL] List<Byte> liveBlockIndices = new ArrayList<>(); [EOL] List<Byte> liveBusyBlockIndices = new ArrayList<>(); [EOL] [EOL] bm.chooseSourceDatanodes( [EOL] aBlockInfoStriped, [EOL] cntNodes, [EOL] liveNodes, [EOL] numReplicas, liveBlockIndices, [EOL] liveBusyBlockIndices, [EOL] LowRedundancyBlocks.QUEUE_VERY_LOW_REDUNDANCY); [EOL] [EOL] assertEquals("Choose the source node for reconstruction with one node reach" [EOL] + " the MAX maxReplicationStreams, the numReplicas still return the" [EOL] + " correct live replicas.", 4, [EOL] numReplicas.liveReplicas()); [EOL] [EOL] assertEquals("Choose the source node for reconstruction with one node reach" [EOL] + " the MAX maxReplicationStreams, the numReplicas should return" [EOL] + " the correct redundant Internal Blocks.", 1, [EOL] numReplicas.redundantInternalBlocks()); [EOL] } [EOL]
@Test [EOL] public void testSolutionSets() { [EOL] Solution<String> s1, s2; [EOL] long expTime = StreamProcessor.NEVER_EXPIRE; [EOL] s1 = newSolution(new String[]{}, expTime); [EOL] s2 = newSolution(new String[]{}, expTime); [EOL] [EOL] assertTrue(s1.equals(s1)); [EOL] assertTrue(s1.equals(s2)); [EOL] [EOL] s2 = newSolution(new String[]{"v1"}, expTime); [EOL] assertTrue(s2.equals(s2)); [EOL] assertFalse(s1.equals(s2)); [EOL] [EOL] s1 = newSolution(new String[]{"v2"}, expTime); [EOL] assertFalse(s1.equals(s2)); [EOL] [EOL] s1 = newSolution(new String[]{"v1", "v2"}, expTime); [EOL] assertFalse(s1.equals(s2)); [EOL] [EOL] s2 = newSolution(new String[]{"v1", "v2"}, expTime); [EOL] assertTrue(s1.equals(s2)); [EOL] [EOL] s2 = newSolution(new String[]{"v1", "v3"}, expTime); [EOL] assertFalse(s1.equals(s2)); [EOL] } [EOL]
@Test [EOL] public void size() { [EOL] assertThat(rules.size()).isEqualTo(0); [EOL] [EOL] rules.register(new DummyRule()); [EOL] assertThat(rules.size()).isEqualTo(1); [EOL] [EOL] rules.unregister(new DummyRule()); [EOL] assertThat(rules.size()).isEqualTo(0); [EOL] } [EOL]
@Test [EOL] void get2() { [EOL] assertEquals(m2, instance.get2()); [EOL] } [EOL]
@Test [EOL] 	public void testIsPasswordResetTokenExpired_Returns_True_Successfully() [EOL] 			throws TokenNotExistException { [EOL] 		// Arrange [EOL] 		final String token = "TheToken"; [EOL] 		EmailToken passwordResetToken = mock(EmailToken.class); [EOL] 		when(passwordResetToken.isTokenExpired()).thenReturn(true); [EOL] 		when(passwordResetTokenRepository.findByToken(token)).thenReturn( [EOL] 				passwordResetToken); [EOL] [EOL] 		// Act [EOL] 		Boolean result = sut.isPasswordResetTokenExpired(token); [EOL] [EOL] 		// Assert [EOL] 		assertTrue(result); [EOL] 	} [EOL]
@Test [EOL] public void testReadLine13() throws Exception { [EOL] // テスト対象のインスタンス化 [EOL] char dChar = ','; [EOL] char[] eChar = { '\"', Character.MIN_VALUE, '|' }; [EOL] byte[] buf = "\"aaa\",\"aaa\",|aaaaaa|\r\naaa".getBytes(); [EOL] [EOL] BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buf))); [EOL] [EOL] String parm = "\r\n"; [EOL] EncloseCharLineFeed2LineReader testCalss = new EncloseCharLineFeed2LineReader(dChar, Character.MIN_VALUE, eChar, bufferedReader, parm); [EOL] [EOL] // テスト実施 [EOL] String result = testCalss.readLine(); [EOL] [EOL] // 返却値なし [EOL] assertEquals("\"aaa\",\"aaa\",|aaaaaa|", result); [EOL] } [EOL]
@Test public void testIsActionBarAvailable() { [EOL] 		// Arrange: [EOL] 		final ActionBarFragment fragment = new TestFragment(); [EOL] 		fragment.actionBarDelegate = mock(ActionBarDelegate.class); [EOL] 		// Act + Assert: [EOL] 		assertThat(fragment.isActionBarAvailable(), is(true)); [EOL] 	} [EOL]
@Test [EOL] public void normalizeWithReservedChar() throws Exception { [EOL] final String[] TEST_NAMES = { [EOL] "test?.txt", "?test.txt", "test.txt?", "?test?txt?" [EOL] }; [EOL] final String[] EXPECTED_NAMES = { [EOL] "test%3F.txt", "%3Ftest.txt", "test.txt%3F", "%3Ftest%3Ftxt%3F" [EOL] }; [EOL] [EOL] for (int i=0; i<TEST_NAMES.length; ++i) { [EOL] //System.out.println("checking " + TEST_NAMES[i]); [EOL] assertEquals(EXPECTED_NAMES[i], FilenameUtils.normalize(TEST_NAMES[i])); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetFirstWeekBetween() throws Exception { [EOL] [EOL] LocalDate date = LocalDate.parse("2014-08-01"); [EOL] [EOL] RangeUnit unit = new Month(date, date, date.plusDays(2), date.plusWeeks(2)); [EOL] [EOL] assertEquals(0, unit.getFirstWeek(date.plusDays(12))); [EOL] [EOL] } [EOL]
@Test [EOL] public void testHandleNotificationNewDevice() { [EOL] Notification notification = mock(Notification.class); [EOL] AdapterContext adapterContext = mock(AdapterContext.class); [EOL] DeviceInterface deviceInterface = mock(DeviceInterface.class); [EOL] when(m_adapterManager.getAdapterContext(any(DeviceAdapterId.class))).thenReturn(adapterContext); [EOL] when(adapterContext.getDeviceInterface()).thenReturn(deviceInterface); [EOL] m_nonNetconfDeviceAdapter.handleNotification(ip_address, port, notification); [EOL] verify(notification).notificationToString(); [EOL] } [EOL]
@Test [EOL] public void testIsClusterBuildCommandAvailableAndNoBlueprints() { [EOL] when(context.isConnectedToCluster()).thenReturn(false); [EOL] when(context.isFocusOnClusterBuild()).thenReturn(false); [EOL] when(context.areBlueprintsAvailable()).thenReturn(false); [EOL] [EOL] boolean result = clusterCommands.isClusterBuildCommandAvailable(); [EOL] [EOL] assertFalse(result); [EOL] } [EOL]
@Test [EOL] public void enableCreateCollectionContainer_DefineList() { [EOL] enableCreateCollectionContainer(false, true); [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("all") [EOL] public void mutateCampaignDraftsTest() { [EOL] MutateCampaignDraftsResponse expectedResponse = [EOL] MutateCampaignDraftsResponse.newBuilder().build(); [EOL] mockCampaignDraftService.addResponse(expectedResponse); [EOL] [EOL] String customerId = "customerId-1772061412"; [EOL] List<CampaignDraftOperation> operations = new ArrayList<>(); [EOL] [EOL] MutateCampaignDraftsResponse actualResponse = [EOL] client.mutateCampaignDrafts(customerId, operations); [EOL] Assert.assertEquals(expectedResponse, actualResponse); [EOL] [EOL] List<AbstractMessage> actualRequests = mockCampaignDraftService.getRequests(); [EOL] Assert.assertEquals(1, actualRequests.size()); [EOL] MutateCampaignDraftsRequest actualRequest = (MutateCampaignDraftsRequest) actualRequests.get(0); [EOL] [EOL] Assert.assertEquals(customerId, actualRequest.getCustomerId()); [EOL] Assert.assertEquals(operations, actualRequest.getOperationsList()); [EOL] Assert.assertTrue( [EOL] channelProvider.isHeaderSent( [EOL] ApiClientHeaderProvider.getDefaultApiClientHeaderKey(), [EOL] GaxGrpcProperties.getDefaultApiClientHeaderPattern())); [EOL] } [EOL]
@Test(expected = IllegalStateException.class) [EOL] public void TooShortSTLTest() { [EOL] constant = "2"; [EOL] constants.add(constant); [EOL] [EOL] datapoints.put(1000L, 1000.0); [EOL] datapoints.put(2000L, 1000.0); [EOL] datapoints.put(3000L, 1000.0); [EOL] [EOL] metric.setDatapoints(datapoints); [EOL] metrics.add(metric); [EOL] [EOL] List<Metric> transformedMetrics = anomalySTLTransform.transform(null, metrics, constants); [EOL] } [EOL]
@Test [EOL] public void testLoadTwoActions() throws Exception { [EOL] ActionFile actionFile = getActionFile("offline/action_file_two_actions.exi"); [EOL] DownloadRequest[] actions = actionFile.load(); [EOL] assertThat(actions).hasLength(2); [EOL] assertThat(actions[0]).isEqualTo(expectedAction1); [EOL] assertThat(actions[1]).isEqualTo(expectedAction2); [EOL] } [EOL]
@Test [EOL] public void testAmong_noChars() { [EOL] Parser<Void> scanner = Scanners.among(""); [EOL] assertFailure(mode, scanner, "a", 1, 1, "none expected, a encountered."); [EOL] assertFailure(mode, scanner, "", 1, 1, "none expected, EOF encountered."); [EOL] } [EOL]
@Test [EOL] public void getGroups() throws Exception { [EOL] this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); [EOL] [EOL] this.mockHttpSession = loginAsAdmin(); [EOL] [EOL] this.mockMvc.perform(get("/srv/api/groups") [EOL] .session(this.mockHttpSession) [EOL] .accept(MediaType.APPLICATION_JSON_VALUE)) [EOL] .andExpect(status().isOk()) [EOL] .andExpect(jsonPath("$", hasSize(1))) [EOL] .andExpect(content().contentType(API_JSON_EXPECTED_ENCODING)); [EOL] } [EOL]
@Test [EOL] 	public void testCreateConfigService() throws NacosException { [EOL] 		ConfigService configService = nacosServiceFactory.createConfigService(properties); [EOL] 		ConfigService configService2 = nacosServiceFactory [EOL] 				.createConfigService(properties); [EOL] 		Assert.assertTrue(configService == configService2); [EOL] 	} [EOL]
@Test [EOL] public void testReadBuffer() throws IOException { [EOL] // 32 buf.length < 52 TEST_STRING.length() [EOL] byte[] buf = new byte[32]; [EOL] int bytesToRead = TEST_STRING.length(); [EOL] int i = 0; [EOL] while (bytesToRead > 0) { [EOL] int n = Math.min(bytesToRead, buf.length); [EOL] int bytesRead = decompressorStream.read(buf, 0, n); [EOL] assertTrue(bytesRead > 0 && bytesRead <= n); [EOL] assertThat(new String(buf, 0, bytesRead), [EOL] is(TEST_STRING.substring(i, i + bytesRead))); [EOL] bytesToRead = bytesToRead - bytesRead; [EOL] i = i + bytesRead; [EOL] } [EOL] try { [EOL] int ret = decompressorStream.read(buf, 0, buf.length); [EOL] fail("Not reachable but got ret " + ret); [EOL] } catch (EOFException e) { [EOL] // Expect EOF exception [EOL] } [EOL] } [EOL]
@Test [EOL] public void shouldDeserializeStorageCapabilitiesV3() { [EOL] JsonParser parser = new JsonParser(); [EOL] JsonElement jsonElement = parser.parse(STORAGE_CAPABILITIES_V3); [EOL] [EOL] StorageCapabilities capabilities = deserializer.deserialize(jsonElement, StorageCapabilities.class, null); [EOL] [EOL] assertThat(capabilities, is(notNullValue())); [EOL] assertThat(capabilities.getRaidLevels(), containsInAnyOrder(RaidLevel.values())); [EOL] assertThat(capabilities.getControllerModes(), contains(ControllerMode.RAID)); [EOL] assertThat(capabilities.getDriveTechnologies(), is(Matchers.<DriveTechnology>empty())); [EOL] } [EOL]
@Test [EOL] public void invokingUnwatchCreatesNewSpan() { [EOL] commandCreatesNewSpan(RedisCommand.UNWATCH, () -> getConnection().unwatch()); [EOL] verify(mockRedisConnection()).unwatch(); [EOL] } [EOL]
@Test [EOL] 	public void testIsContained_NOT_contained() throws Exception { [EOL] 		BufferedImage entireImage = ImageIO.read(getClass().getResource("hifive_logo.png")); [EOL] 		BufferedImage partImage = ImageIO.read(getClass().getResource("hifive_logo_not_part.png")); [EOL] [EOL] 		assertThat(ImageUtils.isContained(entireImage, partImage), is(false)); [EOL] 	} [EOL]
@Test [EOL] public void testSNAPSHOT() { [EOL] for(Feature f : Feature.values()) { [EOL] final int version = f.getInfo().getLayoutVersion(); [EOL] if (NameNodeLayoutVersion.supports(Feature.SNAPSHOT, version)) { [EOL] assertTrue(NameNodeLayoutVersion.supports( [EOL] Feature.FSIMAGE_NAME_OPTIMIZATION, version)); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void handleRequest_imageCreationNotYetStabilized_inProgress_building() { [EOL] final GetImageResponse getImageResponse = GetImageResponse.builder() [EOL] .image(Image.builder() [EOL] .arn(generateImageForTest().arn()) [EOL] .state((ImageState.builder() [EOL] .status(ImageStatus.BUILDING.toString()) [EOL] .build())) [EOL] .build()) [EOL] .build(); [EOL] final ResourceHandlerRequest<ResourceModel> request = ResourceHandlerRequest.<ResourceModel>builder() [EOL] .desiredResourceState(model) [EOL] .build(); [EOL] final CallbackContext inputContext = CallbackContext.builder() [EOL] .imageCreationInvoked(true) [EOL] .build(); [EOL] final CallbackContext outputContext = CallbackContext.builder() [EOL] .imageCreationInvoked(true) [EOL] .build(); [EOL] [EOL] doReturn(getImageResponse) [EOL] .when(proxy) [EOL] .injectCredentialsAndInvokeV2(any(GetImageRequest.class), any()); [EOL] [EOL] final ProgressEvent<ResourceModel, CallbackContext> response [EOL] = handler.handleRequest(proxy, request, inputContext, logger); [EOL] [EOL] assertThat(response).isNotNull(); [EOL] assertThat(response.getStatus()).isEqualTo(OperationStatus.IN_PROGRESS); [EOL] assertThat(response.getCallbackContext()).isEqualTo(outputContext); [EOL] assertThat(response.getCallbackDelaySeconds()).isEqualTo(10); [EOL] [EOL] ResourceModel returnModel = response.getResourceModel(); [EOL] [EOL] assertThat(returnModel.getArn()).isEqualTo(model.getArn()); [EOL] assertThat(response.getResourceModels()).isNull(); [EOL] assertThat(response.getMessage()).isNull(); [EOL] assertThat(response.getErrorCode()).isNull(); [EOL] } [EOL]
@Test [EOL] public void testNormalizedDateUnchanged() { [EOL] Date date = calendar.getTime(); [EOL] Date normalized = model.getNormalizedDate(date); [EOL] assertEquals(date, normalized); [EOL] } [EOL]
@Test [EOL] 	public void testRewordAlterColumnTypeNoSemicolon() throws Exception { [EOL] 		Assert.assertEquals( [EOL] 			"alter table DLFolder alter column userName nvarchar(75);\n", [EOL] 			buildSQL("alter_column_type DLFolder userName VARCHAR(75)")); [EOL] 	} [EOL]
@Test [EOL] public void postBodyLengthTooLargeTest() { [EOL] [EOL] final Props jobProps = new Props(); [EOL] jobProps.put("job.notification." [EOL] + JobCallbackStatusEnum.FAILURE.name().toLowerCase() + ".1.url", [EOL] "http://www.linkedin.com"); [EOL] [EOL] jobProps.put("job.notification." [EOL] + JobCallbackStatusEnum.FAILURE.name().toLowerCase() + ".1.method", [EOL] JobCallbackConstants.HTTP_POST); [EOL] [EOL] final String postBodyValue = "abcdefghijklmnopqrstuvwxyz"; [EOL] [EOL] final int postBodyLength = 20; [EOL] Assert.assertTrue(postBodyValue.length() > postBodyLength); [EOL] jobProps.put("job.notification." [EOL] + JobCallbackStatusEnum.FAILURE.name().toLowerCase() + ".1.body", [EOL] postBodyValue); [EOL] [EOL] final Props localServerProps = new Props(); [EOL] localServerProps.put(MAX_POST_BODY_LENGTH_PROPERTY_KEY, postBodyLength); [EOL] [EOL] final Set<String> errors = new HashSet<>(); [EOL] [EOL] Assert.assertEquals(0, JobCallbackValidator.validate("bogusJob", [EOL] localServerProps, jobProps, errors)); [EOL] [EOL] System.out.println(errors); [EOL] Assert.assertEquals(1, errors.size()); [EOL] [EOL] } [EOL]
@Test [EOL] public void testGetProxyUriFromPluginsReturnsNullIfNoPlugins() [EOL] throws URISyntaxException { [EOL] ApplicationId id = BuilderUtils.newApplicationId(6384623l, 5); [EOL] List<TrackingUriPlugin> list = [EOL] Lists.newArrayListWithExpectedSize(0); [EOL] assertNull(ProxyUriUtils.getUriFromTrackingPlugins(id, list)); [EOL] } [EOL]
@Test [EOL] public void readFromJar() throws WSDLException, URISyntaxException, Exception { [EOL] [EOL] ReadWSDL readWSDL = new ReadWSDL(); [EOL] Definition definition = readWSDL.readWSDL("uddi_v3_service.wsdl"); [EOL] Assert.assertNotNull(definition); [EOL] } [EOL]
@Test(expected = UnexpectedAuthenticationFailedException.class) [EOL] public void testGetCurrentUserIdThrowsUnexpectedAuthenticationFailedException() throws Exception { [EOL] when(accessController.validate(credentials)).thenThrow(InvalidCredentialsException.class); [EOL] context.getCurrentUserID(); [EOL] } [EOL]
@Test [EOL] public void testRpushx() { [EOL] jedisSentinel.rpushx("key", "string"); [EOL] } [EOL]
@Test [EOL] public void testAction0() { [EOL] final AtomicInteger value = new AtomicInteger(); [EOL] Action0 action = new Action0() { [EOL] @Override [EOL] public void call() { [EOL] value.incrementAndGet(); [EOL] } [EOL] }; [EOL] [EOL] Async.toAsync(action, Schedulers.immediate()) [EOL] .call() [EOL] .subscribe(new TestObserver<Object>(observer)); [EOL] [EOL] verify(observer, never()).onError(any(Throwable.class)); [EOL] verify(observer, times(1)).onNext(null); [EOL] verify(observer, times(1)).onCompleted(); [EOL] [EOL] Assert.assertEquals(1, value.get()); [EOL] } [EOL]
@Test [EOL] 	public void testDDMFormSerializationWithSchemaVersion() throws Exception { [EOL] 		String expectedJSON = read( [EOL] 			"ddm-form-json-serializer-with-definition-schema-version.json"); [EOL] [EOL] 		DDMForm ddmForm = createDDMForm(); [EOL] [EOL] 		ddmForm.setDefinitionSchemaVersion("2.0"); [EOL] [EOL] 		String actualJSON = serialize(ddmForm); [EOL] [EOL] 		JSONAssert.assertEquals(expectedJSON, actualJSON, false); [EOL] 	} [EOL]
@Test [EOL] void get4Test() { [EOL] assertEquals(4, (int) instance.get4().orElseThrow(NoSuchElementException::new)); [EOL] } [EOL]
@Test [EOL] void toDatabaseType() { [EOL] assertEquals(0, instance.toDatabaseType(User.Name.ZERO)); [EOL] } [EOL]
@Test [EOL] public void testGetParameterTypeForExtensionImplementer() { [EOL] Class<?> clazz = EventConsumer.getParameterType(new TestEventContainsIdExtension(), ContainsId.class); [EOL] Assert.assertNotNull(clazz); [EOL] Assert.assertEquals(Integer.class, clazz); [EOL] } [EOL]
@Test [EOL] public void getMessageNoRequestIdInMessage() { [EOL] ApiErrorException exception = new ApiErrorException("fubared!", 4711, true, REQUEST_ID); [EOL] assertThat(exception.getMessage(), is("fubared! (Request ID: " + REQUEST_ID + ")")); [EOL] } [EOL]
@Test [EOL] void toTuple17() { [EOL] final Function<Integer, Tuple17<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>> mapper = Tuples.toTuple(i -> i + 0, i -> i + 1, i -> i + 2, i -> i + 3, i -> i + 4, i -> i + 5, i -> i + 6, i -> i + 7, i -> i + 8, i -> i + 9, i -> i + 10, i -> i + 11, i -> i + 12, i -> i + 13, i -> i + 14, i -> i + 15, i -> i + 16); [EOL] assertTuple(mapper.apply(0), 17); [EOL] } [EOL]
@Test [EOL] public void longCsvTestProposalRows() throws LoadException { [EOL] // GIVEN [EOL] // a CSV with PROPOSAL_ROWS rows with numbers 0..PROPOSAL_ROWS-1 [EOL] int rows = ColumnShardBuilder.PROPOSAL_ROWS; [EOL] BigByteBuffer buf = generateCsvOneColumn(CSV_COL_A, rows); [EOL] colInfo.registerColumnType(CSV_COL_A, ColumnType.LONG); [EOL] [EOL] // WHEN [EOL] // parsing this [EOL] TableShard shard = Iterables.getOnlyElement(csvLoader.load(0L, buf, "Test", colInfo)); [EOL] [EOL] // THEN [EOL] Assert.assertEquals(shard.getNumberOfRowsInShard(), rows, "Expected " + rows + " rows"); [EOL] [EOL] @SuppressWarnings("unchecked") [EOL] List<Long> colAValues = resolveAllValues(shard.getLongColumns().get(CSV_COL_A)); [EOL] [EOL] Assert.assertEquals(new HashSet<>(colAValues), generateLongSetRange(0, rows), "Expected correct values"); [EOL] [EOL] Assert.assertEquals(shard.getLongColumns().get(CSV_COL_A).getPages().size(), 1, "Only one ColumnPage expected"); [EOL] } [EOL]
@Test [EOL] public void shouldReturnAverageFromLastRecovery() { [EOL] // given: [EOL] SqlTimeHistory calculator; [EOL] long l1 = 10L; [EOL] long l2 = 20L; [EOL] long l3 = 30L; [EOL] long l4 = 40L; [EOL] Average avg1; [EOL] Average avg2; [EOL] Average avg3; [EOL] Average avg4; [EOL] Average avg5; [EOL] [EOL] // when: [EOL] calculator = new SqlTimeHistory(2, true, true); [EOL] calculator.updateAverage(10L); [EOL] calculator.updateAverage(20L); [EOL] calculator.updateAverage(30L); [EOL] calculator.updateAverage(Long.MAX_VALUE); [EOL] calculator.updateAverage(Long.MAX_VALUE); [EOL] avg1 = calculator.updateAverage(l1); [EOL] avg2 = calculator.updateAverage(Long.MAX_VALUE); [EOL] avg3 = calculator.updateAverage(l2); [EOL] avg4 = calculator.updateAverage(l3); [EOL] avg5 = calculator.updateAverage(l4); [EOL] [EOL] // then: [EOL] assertEquals(l1, avg1.getValue()); [EOL] assertEquals(Long.MAX_VALUE, avg2.getValue()); [EOL] assertEquals(l2, avg3.getValue()); [EOL] assertEquals((int)(l2 + l3)/2, avg4.getValue()); [EOL] assertEquals((int)(l3 + l4)/2, avg5.getValue()); [EOL] assertEquals(1, avg1.getItemsCountIncludedInAverage()); [EOL] assertEquals(2, avg2.getItemsCountIncludedInAverage()); [EOL] assertEquals(1, avg3.getItemsCountIncludedInAverage()); [EOL] assertEquals(2, avg4.getItemsCountIncludedInAverage()); [EOL] assertEquals(2, avg5.getItemsCountIncludedInAverage()); [EOL] } [EOL]
@Test [EOL] 	public void numeroUdocReDBEntityTest() { [EOL] 		Assert.notNull(getManager(), "ArchidocManager es nulo"); [EOL] 		INumeroDBEntity dbEntity = getManager().getNumeroUdocReDBEntity(); [EOL] 		Assert.notNull(dbEntity, "entity es nulo"); [EOL] 		Assert.isTrue(ArchivoTables.ADVCNUMUDOCRE_TABLE_NAME.equals(dbEntity [EOL] 				.getTableName()),"Las tablas no coinciden"); [EOL] [EOL] 		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount())); [EOL] 	} [EOL]
@Test [EOL] public void dataViewWithItems_getItem_returnsCorrectItem() { [EOL] Assert.assertEquals(items.get(0), dataView.getItem(0)); [EOL] Assert.assertEquals(items.get(1), dataView.getItem(1)); [EOL] Assert.assertEquals(items.get(2), dataView.getItem(2)); [EOL] } [EOL]
@Test public void testActivityNotFoundMessageWithNullValue() { [EOL] 		// Arrange: [EOL] 		final BaseIntent intent = new IntentImpl(); [EOL] 		// Act: [EOL] 		intent.activityNotFoundMessage(null); [EOL] 		// Assert: [EOL] 		assertThat(intent.activityNotFoundMessage(), is((CharSequence) "")); [EOL] 	} [EOL]
@Test [EOL] public void getCourseWithModules() { [EOL] MutableLiveData<CourseWithModule> dummyEntity = new MutableLiveData<>(); [EOL] dummyEntity.setValue(DataDummy.generateDummyCourseWithModules(DataDummy.generateDummyCourses().get(0), false)); [EOL] when(local.getCourseWithModules(courseId)).thenReturn(dummyEntity); [EOL] [EOL] Resource<CourseWithModule> courseEntities = LiveDataTestUtil.getValue(academyRepository.getCourseWithModules(courseId)); [EOL] verify(local).getCourseWithModules(courseId); [EOL] assertNotNull(courseEntities.data); [EOL] assertNotNull(courseEntities.data.mCourse.getTitle()); [EOL] assertEquals(courseResponses.get(0).getTitle(), courseEntities.data.mCourse.getTitle()); [EOL] } [EOL]
@Test [EOL] 	public void testSubmitDocumentWithStateId() throws Exception { [EOL] 		@SuppressWarnings("unused") [EOL] 		XdsSrcSubmitReq xdsSrcSubmitReq = mock(XdsSrcSubmitReq.class); [EOL] 		// PowerMockito. [EOL] 		// whenNew(XdsSrcSubmitReq.class).withNoArguments().thenReturn(xdsSrcSubmitReq); [EOL] [EOL] 		EhrPatientClientDto submitForPatient = mock(EhrPatientClientDto.class); [EOL] 		SourceSubmissionClientDto sourceSubmission = mock(SourceSubmissionClientDto.class); [EOL] 		Boolean withFolder = false; [EOL] 		String stateId = "MockedStateId"; [EOL] 		sat.submitDocument(submitForPatient, sourceSubmission, withFolder, [EOL] 				stateId); [EOL] [EOL] 		// verify(client).submit(xdsSrcSubmitReq); [EOL] 		verify(webService).submitDocument(any(XdsSrcSubmitReq.class)); [EOL] 	} [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] 	public void testInvalid4() throws Exception { [EOL] 		RetryPolicyFactory.create("2: "); [EOL] 	} [EOL]
@Test [EOL] public void testParsePK() { [EOL] TableMeta tableMeta = Mockito.mock(TableMeta.class); [EOL] Mockito.when(tableMeta.getPkName()).thenReturn("id"); [EOL] Mockito.when(tableMeta.getTableName()).thenReturn("table_name"); [EOL] [EOL] TableRecords beforeImage = new TableRecords(); [EOL] beforeImage.setTableName("table_name"); [EOL] beforeImage.setTableMeta(tableMeta); [EOL] [EOL] List<Row> beforeRows = new ArrayList<>(); [EOL] Row row0 = new Row(); [EOL] Field field01 = addField(row0, "id", 1, "12345"); [EOL] Field field02 = addField(row0, "age", 1, "2"); [EOL] beforeRows.add(row0); [EOL] Row row1 = new Row(); [EOL] Field field11 = addField(row1, "id", 1, "12346"); [EOL] Field field12 = addField(row1, "age", 1, "2"); [EOL] beforeRows.add(row1); [EOL] beforeImage.setRows(beforeRows); [EOL] [EOL] SQLUndoLog sqlUndoLog = new SQLUndoLog(); [EOL] sqlUndoLog.setSqlType(SQLType.UPDATE); [EOL] sqlUndoLog.setTableMeta(tableMeta); [EOL] sqlUndoLog.setTableName("table_name"); [EOL] sqlUndoLog.setBeforeImage(beforeImage); [EOL] sqlUndoLog.setAfterImage(null); [EOL] [EOL] TestUndoExecutor executor = new TestUndoExecutor(sqlUndoLog, true); [EOL] Object[] pkValues = executor.parsePkValues(beforeImage); [EOL] Assertions.assertEquals(2, pkValues.length); [EOL] } [EOL]
@Test [EOL] public void testAdd() { [EOL] final Vector2 vec1 = new Vector2(); [EOL] final Vector2 vec2 = new Vector2(Vector2.ONE); [EOL] [EOL] vec1.addLocal(1, 2); [EOL] assertEquals(new Vector2(1, 2), vec1); [EOL] vec1.addLocal(-1, -2); [EOL] assertEquals(Vector2.ZERO, vec1); [EOL] [EOL] vec1.zero(); [EOL] vec1.addLocal(vec2); [EOL] assertEquals(Vector2.ONE, vec1); [EOL] [EOL] vec1.zero(); [EOL] final Vector2 vec3 = vec1.add(vec2, new Vector2()); [EOL] assertEquals(Vector2.ZERO, vec1); [EOL] assertEquals(Vector2.ONE, vec3); [EOL] [EOL] final Vector2 vec4 = vec1.add(1, 0, null); [EOL] assertEquals(Vector2.ZERO, vec1); [EOL] assertEquals(Vector2.UNIT_X, vec4); [EOL] } [EOL]
@Test [EOL] public void checkNullContextPath() { [EOL] rule.expect(IllegalArgumentException.class); [EOL] [EOL] helper.createNewGuidedDecisionTable(null, [EOL] baseFileName, [EOL] tableFormat, [EOL] hitPolicy, [EOL] view, [EOL] onSaveSuccessCallback); [EOL] } [EOL]
@Test [EOL] public void testClose() [EOL] { [EOL] HttpClient mockClient = mock(HttpClient.class); [EOL] ScheduledExecutorService retryExecutor = mock(ScheduledExecutorService.class); [EOL] [EOL] balancingHttpClient = new BalancingHttpClient(serviceBalancer, mockClient, new BalancingHttpClientConfig(), retryExecutor); [EOL] balancingHttpClient.close(); [EOL] [EOL] verify(retryExecutor).shutdown(); [EOL] verify(retryExecutor).shutdownNow(); [EOL] verifyNoMoreInteractions(retryExecutor); [EOL] [EOL] verify(mockClient).close(); [EOL] verifyNoMoreInteractions(mockClient, serviceBalancer); [EOL] } [EOL]
@Test [EOL] public void testRareCommandWithGroupByShouldPass() { [EOL] ParseTree tree = new PPLSyntaxParser().analyzeSyntax("source=t a=1 | rare a by b"); [EOL] assertNotEquals(null, tree); [EOL] } [EOL]
@Test [EOL] @Timeout(2_000) [EOL] public void testRequestReplyWithCancel() { [EOL] Mono<Payload> response = rule.socket.requestResponse(EmptyPayload.INSTANCE); [EOL] [EOL] try { [EOL] response.block(Duration.ofMillis(100)); [EOL] } catch (IllegalStateException ise) { [EOL] } [EOL] [EOL] List<ByteBuf> sent = new ArrayList<>(rule.connection.getSent()); [EOL] [EOL] assertThat( [EOL] "Unexpected frame sent on the connection.", frameType(sent.get(0)), is(REQUEST_RESPONSE)); [EOL] assertThat("Unexpected frame sent on the connection.", frameType(sent.get(1)), is(CANCEL)); [EOL] Assertions.assertThat(sent).hasSize(2).allMatch(ReferenceCounted::release); [EOL] rule.assertHasNoLeaks(); [EOL] } [EOL]
@Test [EOL] public void testStopMockObject() throws IOException { [EOL] RPC.stopProxy(MockitoUtil.mockProtocol(TestProtocol.class)); [EOL] } [EOL]
@Test [EOL] public void shouldCreateBackfillFromInput() throws Exception { [EOL] final BackfillInput backfillInput = BACKFILL_INPUT.builder() [EOL] .reverse(true) [EOL] .build(); [EOL] [EOL] when(client.send(any(Request.class))).thenReturn(CompletableFuture.completedFuture( [EOL] response(HTTP_OK, BACKFILL))); [EOL] final CompletableFuture<Backfill> r = styx.backfillCreate(backfillInput) [EOL] .toCompletableFuture(); [EOL] verify(client, timeout(30_000)).send(requestCaptor.capture()); [EOL] assertThat(r.isDone(), is(true)); [EOL] final Request request = requestCaptor.getValue(); [EOL] assertThat(request.url().toString(), is(API_URL + "/backfills?allowFuture=false")); [EOL] assertThat(Json.deserialize(bytesOfRequestBody(request), BackfillInput.class), [EOL] equalTo(backfillInput)); [EOL] assertThat(r.isCompletedExceptionally(), is(false)); [EOL] assertThat(request.method(), is("POST")); [EOL] } [EOL]
@Test [EOL] public void testNextLineCompanionObject() { [EOL] String code = "class Counter {\nvar value: Long = 0\n}\n // comment\n\n object Counter {\n def apply(x: Long) = new Counter()\n}"; [EOL] assertEquals(InterpreterResult.Code.SUCCESS, flink.interpret(code, context).code()); [EOL] } [EOL]
@Test [EOL] public void testEncryptContent() throws Exception [EOL] { [EOL] doReturn( new ByteArrayInputStream( "OK".getBytes() ) ).when( cachedOutputStream ).getInputStream(); [EOL] doReturn( pgpPublicKey ).when( keyManager ).getRemoteHostPublicKey( anyString() ); [EOL] [EOL] doReturn( "OK".getBytes() ).when( encryptionTool ) [EOL] .encrypt( isA( byte[].class ), isA( PGPPublicKey.class ), eq( true ) ); [EOL] [EOL] [EOL] MessageContentUtil.encryptContent( securityManager, SRC, TARGET, message ); [EOL] [EOL] verify( encryptionTool ).encrypt( isA( byte[].class ), eq( pgpPublicKey ), eq( true ) ); [EOL] } [EOL]
@Test public void testTemporaryFilesAreCleanedUpAfterCompletion() [EOL] { [EOL] List<Binding> undistinct = new ArrayList<>(); [EOL] random = new Random(); [EOL] Var[] vars = new Var[]{ [EOL] Var.alloc("1"), Var.alloc("2"), Var.alloc("3"), [EOL] Var.alloc("4"), Var.alloc("5"), Var.alloc("6"), [EOL] Var.alloc("7"), Var.alloc("8"), Var.alloc("9"), Var.alloc("0") [EOL] }; [EOL] for(int i = 0; i < 500; i++){ [EOL] undistinct.add(randomBinding(vars)); [EOL] } [EOL] [EOL] DistinctDataBag<Binding> db = new DistinctDataBag<>( [EOL] new ThresholdPolicyCount<Binding>(10), [EOL] SerializationFactoryFinder.bindingSerializationFactory(), [EOL] new BindingComparator(new ArrayList<SortCondition>())); [EOL] [EOL] List<File> spillFiles = new ArrayList<>(); [EOL] try [EOL] { [EOL] db.addAll(undistinct); [EOL] spillFiles.addAll(db.getSpillFiles()); [EOL] [EOL] int count = 0; [EOL] for (File file : spillFiles) [EOL] { [EOL] if (file.exists()) [EOL] { [EOL] count++; [EOL] } [EOL] } [EOL] // 500 bindings divided into 50 chunks (49 in files, and 1 in memory) [EOL] assertEquals(49, count); [EOL] [EOL] Iterator<Binding> iter = db.iterator(); [EOL] while (iter.hasNext()) [EOL] { [EOL] iter.next(); [EOL] } [EOL] Iter.close(iter); [EOL] } [EOL] finally [EOL] { [EOL] db.close(); [EOL] } [EOL] [EOL] int count = 0; [EOL] for (File file : spillFiles) [EOL] { [EOL] if (file.exists()) [EOL] { [EOL] count++; [EOL] } [EOL] } [EOL] assertEquals(0, count); [EOL] } [EOL]
@Test [EOL] public void testNamespaceValidation_fullySpecified() throws Exception { [EOL] ApiConfig validNamespaceFullySpecified = configFactory.copy(config); [EOL] validNamespaceFullySpecified.getNamespaceConfig().setOwnerDomain("domain"); [EOL] validNamespaceFullySpecified.getNamespaceConfig().setOwnerName("name"); [EOL] validNamespaceFullySpecified.getNamespaceConfig().setPackagePath("package"); [EOL] validator.validate(validNamespaceFullySpecified); [EOL] } [EOL]
@Test [EOL] 	public void test20checkAccess() { [EOL] 		setup(); [EOL] 		XXPortalUserDao xPortalUserDao = Mockito.mock(XXPortalUserDao.class); [EOL] 		XXPortalUser xPortalUser = Mockito.mock(XXPortalUser.class); [EOL] 		Mockito.when(daoManager.getXXPortalUser()).thenReturn(xPortalUserDao); [EOL] 		Mockito.when(xPortalUserDao.getById(userId)).thenReturn(xPortalUser); [EOL] 		userMgr.checkAccess(userId); [EOL] 	} [EOL]
@Test [EOL] public void resetTest() { [EOL] presenterSpy.reset(); [EOL] verify(coverageReportViewMock, times(1)).reset(); [EOL] verify(presenterSpy, times(1)).resetDownload(); [EOL] } [EOL]
@Test [EOL] public void testBraceFormatNextTerm() throws ParseException { [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("", 0)).isEqualTo(-1); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("{", 0)).isEqualTo(0); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello {0} World {1}", 0)).isEqualTo(6); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello {0} World {1}", 6)).isEqualTo(6); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello {0} World {1}", 7)).isEqualTo(16); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello ''{0}'' World", 0)).isEqualTo(8); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello {0} World {1}", 17)) [EOL] .isEqualTo(-1); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello '{'0} World", 0)).isEqualTo(-1); [EOL] assertThat(BraceStyleMessageParser.nextBraceFormatTerm("Hello '{0}' World", 0)).isEqualTo(-1); [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("all") [EOL] public void getExpandedLandingPageViewExceptionTest() throws Exception { [EOL] StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT); [EOL] mockExpandedLandingPageViewService.addException(exception); [EOL] [EOL] try { [EOL] ExpandedLandingPageViewName resourceName = [EOL] ExpandedLandingPageViewName.of("[CUSTOMER]", "[EXPANDED_LANDING_PAGE_VIEW]"); [EOL] [EOL] client.getExpandedLandingPageView(resourceName); [EOL] Assert.fail("No exception raised"); [EOL] } catch (InvalidArgumentException e) { [EOL] // Expected exception [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testWebSocketMessage_instance() throws Exception { [EOL] [EOL] 		ObjectMapper mapper = JSonBindingUtils.createObjectMapper(); [EOL] 		WebSocketMessage wsm = new WebSocketMessage( null, null, null ); [EOL] [EOL] 		StringWriter writer = new StringWriter(); [EOL] 		mapper.writeValue( writer, wsm ); [EOL] 		Assert.assertEquals( "{}", writer.toString()); [EOL] [EOL] 		TestApplication app = new TestApplication(); [EOL] 		wsm = new WebSocketMessage( app.getMySql(), app, EventType.CREATED ); [EOL] 		writer = new StringWriter(); [EOL] 		mapper.writeValue( writer, wsm ); [EOL] [EOL] 		String s = writer.toString(); [EOL] 		Assert.assertEquals( "{\"event\":\"CREATED\",\"app\":{\"name\":\"test\",\"displayName\":\"test\",\"tplName\":\"test-app\",\"tplVersion\":\"1.0.1\"},\"inst\":" [EOL] 				+ "{\"name\":\"mysql-server\",\"path\":\"/mysql-vm/mysql-server\",\"status\":\"NOT_DEPLOYED\"," [EOL] 				+ "\"component\":{\"name\":\"mysql\",\"installer\":\"puppet\"},\"exports\":{\"mysql.port\":\"3306\",\"mysql.ip\":null}}}", s ); [EOL] 	} [EOL]
@Test [EOL] public void testGetParameters() throws Exception { [EOL] ViewConfig config = getConfig(); [EOL] List<ParameterConfig> parameters = config.getParameters(); [EOL] Assert.assertEquals(2, parameters.size()); [EOL] Assert.assertEquals("p1", parameters.get(0).getName()); [EOL] Assert.assertEquals("p2", parameters.get(1).getName()); [EOL] [EOL] // check the case where no parameters are specified for the view... [EOL] config = getConfig(minimal_xml); [EOL] parameters = config.getParameters(); [EOL] Assert.assertNotNull(parameters); [EOL] Assert.assertEquals(0, parameters.size()); [EOL] } [EOL]
@Test [EOL] 	public void testReadFileContentQuietly() throws Exception { [EOL] [EOL] 		String s = "this is\na\test\t"; [EOL] 		File output = this.folder.newFile(); [EOL] 		Utils.writeStringInto( s, output ); [EOL] [EOL] 		String readS = Utils.readFileContentQuietly( output, Logger.getLogger( getClass().getName())); [EOL] 		Assert.assertEquals( s, readS ); [EOL] 	} [EOL]
@Test [EOL] public void toSetShouldTrimSingleQuotes() { [EOL] [EOL] Options options = parse("--include-tags='(development & integration)'"); [EOL] assertThat(options.getIncludeTags(), contains("(development & integration)")); [EOL] } [EOL]
@Test [EOL] public void testFullIndexerConf() throws Exception { [EOL] IndexerComponentFactory factory = IndexerComponentFactoryUtil.getComponentFactory(impl, getClass().getResourceAsStream("indexerconf_full.xml"), Maps.<String, String>newHashMap()); [EOL] IndexerConf conf = factory.createIndexerConf(); [EOL] [EOL] assertEquals("table1", conf.getTable()); [EOL] assertEquals(IndexerConf.MappingType.COLUMN, conf.getMappingType()); [EOL] assertEquals(IndexerConf.RowReadMode.NEVER, conf.getRowReadMode()); [EOL] assertEquals("custom-id", conf.getUniqueKeyField()); [EOL] assertEquals("custom-row", conf.getRowField()); [EOL] assertEquals("custom-family", conf.getColumnFamilyField()); [EOL] assertEquals("custom-table-name", conf.getTableNameField()); [EOL] assertEquals(HexUniqueKeyFormatter.class, conf.getUniqueKeyFormatterClass()); [EOL] assertEquals(TestResultToSolrMapper.class, conf.getMapperClass()); [EOL] [EOL] List<FieldDefinition> fieldDefs = conf.getFieldDefinitions(); [EOL] List<FieldDefinition> expectedFieldDefs = Lists.newArrayList( [EOL] new FieldDefinition("field1", "col:qual1", ValueSource.QUALIFIER, "float"), [EOL] new FieldDefinition("field2", "col:qual2", ValueSource.VALUE, "long", [EOL] ImmutableMap.of("fieldKeyA", "fieldValueA", "fieldKeyB", "fieldValueB"))); [EOL] assertEquals(expectedFieldDefs, fieldDefs); [EOL] [EOL] List<DocumentExtractDefinition> extractDefs = conf.getDocumentExtractDefinitions(); [EOL] List<DocumentExtractDefinition> expectedExtractDefs = Lists.newArrayList( [EOL] new DocumentExtractDefinition("testprefix_", "col:qual3", ValueSource.QUALIFIER, "text/html", [EOL] ImmutableMap.of("extractKeyA", "extractValueA", "extractKeyB", "extractValueB"))); [EOL] assertEquals(expectedExtractDefs, extractDefs); [EOL] [EOL] assertEquals(ImmutableMap.of("globalKeyA", "globalValueA", "globalKeyB", "globalValueB"), conf.getGlobalParams()); [EOL] [EOL] } [EOL]
@Test [EOL] public void updateAudienceGroupDescription() throws Exception { [EOL] UpdateAudienceGroupDescriptionRequest request = UpdateAudienceGroupDescriptionRequest.builder() [EOL] .description( [EOL] "Hello") [EOL] .build(); [EOL] whenCall(retrofitMock.updateAudienceGroupDescription(anyLong(), any()), null); [EOL] final BotApiResponse actual = [EOL] target.updateAudienceGroupDescription(5693L, [EOL] request [EOL] ).get(); [EOL] verify(retrofitMock, only()).updateAudienceGroupDescription(5693L, request); [EOL] assertThat(actual).isEqualTo(BOT_API_SUCCESS_RESPONSE); [EOL] } [EOL]
@Test [EOL] public void testGetUnicodeEmojis() { [EOL] ObjectMapper objectMapper = JsonObjectMapperFactory.createObjectMapper(); [EOL] Map<String, String> emojis = LocalEmojiUtils.getUnicodeEmojis(objectMapper); [EOL] assertNotNull(emojis); [EOL] assertFalse(emojis.isEmpty()); [EOL] } [EOL]
@Test [EOL] public void testInitialState() [EOL] throws Exception [EOL] { [EOL] BucketedTimeDistribution distribution = new BucketedTimeDistribution(); [EOL] distribution.add(1); [EOL] assertPreviousDistributionEmpty(distribution); [EOL] } [EOL]
@Test [EOL] public void testConvertFactEmpty() { [EOL] assertNotNull(converter.apply(new FactRecord())); [EOL] } [EOL]
@Test [EOL] public void testBucketUpdatedEvent() { [EOL] final Event event = EventFactory.bucketUpdated(bucket); [EOL] event.validate(); [EOL] [EOL] assertEquals(EventType.UPDATE_BUCKET, event.getEventType()); [EOL] assertEquals(2, event.getFields().size()); [EOL] [EOL] assertEquals(bucket.getIdentifier(), event.getField(EventFieldName.BUCKET_ID).getValue()); [EOL] assertEquals("unknown", event.getField(EventFieldName.USER).getValue()); [EOL] } [EOL]
@Test [EOL] void testParse() { [EOL] System.out.println(Duration.ZERO.toString()); [EOL] doParseTest("30d", "P30D", Duration.ofDays(30)); [EOL] doParseTest("12h", "PT12H", Duration.ofHours(12)); [EOL] doParseTest("5m", "PT5M", Duration.ofMinutes(5)); [EOL] doParseTest("10s", "PT10S", Duration.ofSeconds(10)); [EOL] doParseTest("100ms", "PT0.1S", Duration.ofMillis(100)); [EOL] [EOL] // raw millis form [EOL] doParseTest("100", "PT0.1S", Duration.ofMillis(100)); [EOL] } [EOL]
@Test [EOL] 	public void testIsPOUMatches(){ [EOL] 		 [EOL] 		//Arrange [EOL] 		Set<String> selPOU = new HashSet<String>(); [EOL] 		selPOU.add("TREAT"); [EOL] 		 [EOL] 		Set<ConsentShareForPurposeOfUseCode> conPOU = new HashSet<ConsentShareForPurposeOfUseCode>(); [EOL] 		PurposeOfUseCode pCode = new PurposeOfUseCode(); [EOL] 		pCode.setCode("TREAT"); [EOL] 		ConsentShareForPurposeOfUseCode cpCode = new ConsentShareForPurposeOfUseCode(pCode); [EOL] 		conPOU.add(cpCode); [EOL] 		 [EOL] 		//Act [EOL] 		boolean isPouMatch = cst.isPOUMatches(selPOU, conPOU); [EOL] 		 [EOL] 		 [EOL] 		//Assert [EOL] 		assertEquals(isPouMatch, true);	 [EOL] 		 [EOL] 	} [EOL]
@Test [EOL] public void testTop() { [EOL] assertEquals("u1pc", top("u1pb")); [EOL] } [EOL]
@Test [EOL] public void testSeparateColumns01() throws Exception { [EOL] // テスト対象のインスタンス化 [EOL] URL url = this.getClass().getResource("File_Empty.txt"); [EOL] String fileName = url.getPath(); [EOL] Class<VariableFileLineIterator_Stub10> clazz = VariableFileLineIterator_Stub10.class; [EOL] Map<String, ColumnParser> columnParserMap = new HashMap<String, ColumnParser>(); [EOL] columnParserMap.put("java.lang.String", new NullColumnParser()); [EOL] VariableFileLineIterator<VariableFileLineIterator_Stub10> variableFileLineIterator = new VariableFileLineIterator<VariableFileLineIterator_Stub10>(fileName, clazz, columnParserMap); [EOL] [EOL] // 引数の設定 [EOL] String fileLineString = null; [EOL] [EOL] // 前提条件の設定 [EOL] // テスト対象のインスタンス化時に設定済み [EOL] [EOL] // テスト実施 [EOL] String[] result = variableFileLineIterator.separateColumns( [EOL] fileLineString); [EOL] [EOL] // 返却値の確認 [EOL] assertEquals(0, result.length); [EOL] [EOL] // 状態変化の確認 [EOL] // なし [EOL] } [EOL]
@Test [EOL] void toJSONWithOptional() { [EOL] var bean = new TestBean(); [EOL] bean.intField = 5; [EOL] Optional<TestBean> optional = Optional.of(bean); [EOL] byte[] bytes = writer.toJSON(optional); [EOL] assertThat(bytes).isNotEmpty(); [EOL] } [EOL]
@Test [EOL] 	public void test15revokeAccess() throws Exception { [EOL] 		HttpServletRequest request = Mockito.mock(HttpServletRequest.class); [EOL] 		String serviceName = "HDFS_1"; [EOL] 		Set<String> userList = new HashSet<String>(); [EOL] 		userList.add("user1"); [EOL] 		userList.add("user2"); [EOL] 		userList.add("user3"); [EOL] 		Set<String> groupList = new HashSet<String>(); [EOL] 		groupList.add("group1"); [EOL] 		groupList.add("group2"); [EOL] 		groupList.add("group3"); [EOL] 		GrantRevokeRequest revokeRequest = new GrantRevokeRequest(); [EOL] 		revokeRequest.setDelegateAdmin(true); [EOL] 		revokeRequest.setEnableAudit(true); [EOL] 		revokeRequest.setGrantor("read"); [EOL] 		revokeRequest.setGroups(groupList); [EOL] 		revokeRequest.setUsers(userList); [EOL] [EOL] 		RESTResponse restResponse = serviceREST.revokeAccess(serviceName, [EOL] 				revokeRequest, request); [EOL] 		Assert.assertNotNull(restResponse); [EOL] 	} [EOL]
@Test [EOL] public void testAnnotatedEncassDeleteBundle_WithPolicyFragment() { [EOL] BundleEntityBuilder builder = createBundleEntityBuilder(); [EOL] [EOL] Bundle bundle = createBundleWithPolicyFragment(false, projectInfo); [EOL] Encass encass = buildTestEncassWithAnnotation(TEST_GUID, TEST_ENCASS_POLICY, false); [EOL] bundle.putAllEncasses(ImmutableMap.of(TEST_ENCASS, encass)); [EOL] [EOL] Map<String, BundleArtifacts> bundles = builder.build(bundle, DEPLOYMENT, [EOL] DocumentTools.INSTANCE.getDocumentBuilder().newDocument(), projectInfo); [EOL] assertNotNull(bundles); [EOL] assertEquals(1, bundles.size()); [EOL] Element deleteBundleElement = bundles.get(TEST_ENCASS_ANNOTATION_NAME + "-1.0").getDeleteBundle().getElement(); [EOL] assertNotNull(deleteBundleElement); [EOL] [EOL] // Assert Bundle [EOL] assertEquals(BundleDocumentBuilder.GATEWAY_MANAGEMENT, deleteBundleElement.getAttribute(BundleDocumentBuilder.L7)); [EOL] assertEquals(BUNDLE, deleteBundleElement.getTagName()); [EOL] [EOL] final int expectedElementCountBundle = 3; [EOL] [EOL] // Assert References [EOL] final Element references = getSingleChildElement(deleteBundleElement, REFERENCES); [EOL] assertNotNull(references); [EOL] final List<Element> itemList = getChildElements(references, ITEM); [EOL] assertNotNull(itemList); [EOL] assertEquals(expectedElementCountBundle, itemList.size()); [EOL] final Element item1 = itemList.get(2); [EOL] assertEquals("::" + projectInfo.getGroupName() + "." + TEST_ENCASS_ANNOTATION_NAME + "::" + TEST_POLICY_FRAGMENT + "::" + projectInfo.getVersion() , [EOL] getSingleChildElementTextContent(item1, NAME)); [EOL] assertEquals(EntityTypes.POLICY_TYPE, getSingleChildElementTextContent(item1, TYPE)); [EOL] assertNotNull(getSingleChildElement(item1, RESOURCE)); [EOL] final Element item2 = itemList.get(1); [EOL] assertEquals("::" + projectInfo.getGroupName() + "." + TEST_ENCASS_ANNOTATION_NAME + "::" + TEST_ENCASS_POLICY + "::" + projectInfo.getVersion() , [EOL] getSingleChildElementTextContent(item2, NAME)); [EOL] assertEquals(EntityTypes.POLICY_TYPE, getSingleChildElementTextContent(item2, TYPE)); [EOL] assertNotNull(getSingleChildElement(item2, RESOURCE)); [EOL] final Element item3 = itemList.get(0); [EOL] assertEquals("::" + projectInfo.getGroupName() + "." + TEST_ENCASS_ANNOTATION_NAME + "::" + TEST_ENCASS + "::" + projectInfo.getVersion(), getSingleChildElementTextContent(item3, NAME)); [EOL] assertEquals(EntityTypes.ENCAPSULATED_ASSERTION_TYPE, getSingleChildElementTextContent(item3, TYPE)); [EOL] assertNotNull(getSingleChildElement(item3, RESOURCE)); [EOL] [EOL] // Assert Mappings [EOL] final Element mappings = getSingleChildElement(deleteBundleElement, MAPPINGS); [EOL] assertNotNull(mappings); [EOL] final List<Element> mappingItemList = getChildElements(mappings, MAPPING); [EOL] assertEquals(expectedElementCountBundle, mappingItemList.size()); [EOL] [EOL] final Element mapping1 = mappingItemList.get(2); [EOL] final Element mapping1Properties = getSingleChildElement(mapping1, PROPERTIES); [EOL] Set<String> propertyValues = getChildElementsTextContents(mapping1Properties, PROPERTY); [EOL] assertTrue(propertyValues.contains("::" + projectInfo.getGroupName() + "." + TEST_ENCASS_ANNOTATION_NAME + "::" + TEST_POLICY_FRAGMENT + "::" + projectInfo.getVersion())); [EOL] assertEquals(MappingActions.DELETE, mapping1.getAttribute("action")); [EOL] assertEquals(EntityTypes.POLICY_TYPE, mapping1.getAttribute("type")); [EOL] [EOL] final Element mapping2 = mappingItemList.get(1); [EOL] final Element mapping2Properties = getSingleChildElement(mapping2, PROPERTIES); [EOL] propertyValues = getChildElementsTextContents(mapping2Properties, PROPERTY); [EOL] assertTrue(propertyValues.contains("::" + projectInfo.getGroupName() + "." + TEST_ENCASS_ANNOTATION_NAME + "::" + TEST_ENCASS_POLICY + "::" + projectInfo.getVersion())); [EOL] assertEquals(MappingActions.DELETE, mapping2.getAttribute("action")); [EOL] assertEquals(EntityTypes.POLICY_TYPE, mapping2.getAttribute("type")); [EOL] [EOL] final Element mapping3 = mappingItemList.get(0); [EOL] final Element mapping3Properties = getSingleChildElement(mapping3, PROPERTIES); [EOL] propertyValues = getChildElementsTextContents(mapping3Properties, PROPERTY); [EOL] assertTrue(propertyValues.contains("::" + projectInfo.getGroupName() + "." + TEST_ENCASS_ANNOTATION_NAME + "::" + TEST_ENCASS + "::" + projectInfo.getVersion())); [EOL] assertEquals(MappingActions.DELETE, mapping3.getAttribute("action")); [EOL] assertEquals(EntityTypes.ENCAPSULATED_ASSERTION_TYPE, mapping3.getAttribute("type")); [EOL] } [EOL]
@Test(expected = InvalidEntityException.class) [EOL] public void shouldValidateEmptyDescription() throws AlreadyExistEntityException, InvalidEntityException { [EOL] resourceValidator.validateDescription(""); [EOL] [EOL] } [EOL]
@Test [EOL] void client() { [EOL] config.httpClient().timeout(Duration.ofSeconds(5)); [EOL] config.client(TestWebService.class, "http://localhost"); [EOL] [EOL] TestWebService client = (TestWebService) config.context.beanFactory.bean(TestWebService.class, null); [EOL] assertThat(client).isNotNull(); [EOL] } [EOL]
@Test [EOL] 	public void testConcatStrings() { [EOL] 		Assert.assertSame("test1", StringBundler.concat("test1")); [EOL] 		Assert.assertSame( [EOL] 			StringPool.NULL, StringBundler.concat(new String[] {null})); [EOL] 		Assert.assertEquals( [EOL] 			"test1test2", StringBundler.concat("test1", "test2")); [EOL] 		Assert.assertEquals("abcdef", StringBundler.concat("a", "bc", "def")); [EOL] 		Assert.assertEquals("abcdef", StringBundler.concat("abc", "de", "f")); [EOL] 		Assert.assertEquals( [EOL] 			"test1test2test3test4", [EOL] 			StringBundler.concat("test1", "test2", "test3", "test4")); [EOL] 	} [EOL]
@Test [EOL] public void onExportToCSV() { [EOL] RemoteCallback<String> remoteCallback = mock(RemoteCallback.class); [EOL] ScenarioSimulationHasBusyIndicatorDefaultErrorCallback errorCallback = mock(ScenarioSimulationHasBusyIndicatorDefaultErrorCallback.class); [EOL] scenarioSimulationEditorBusinessClientWrapper.onExportToCsv(remoteCallback, errorCallback, simulationMock); [EOL] verify(importExportCaller, times(1)).call(eq(remoteCallback), eq(errorCallback)); [EOL] verify(importExportServiceMock, times(1)).exportScesimModel(eq(ImportExportType.CSV), eq(simulationMock)); [EOL] } [EOL]
@Test [EOL] void get3() { [EOL] assertEquals(m3, instance.get3()); [EOL] } [EOL]
@Test [EOL] 	public void addDecoderReplaysLastHttp() { [EOL] 		ByteBuf buf = Unpooled.copiedBuffer("{\"foo\":1}", CharsetUtil.UTF_8); [EOL] 		EmbeddedChannel channel = new EmbeddedChannel(); [EOL] 		new HttpClientOperations(() -> channel, ConnectionObserver.emptyListener(), [EOL] 				ClientCookieEncoder.STRICT, ClientCookieDecoder.STRICT) [EOL] 				.addHandler(new JsonObjectDecoder()); [EOL] 		channel.writeInbound(new DefaultLastHttpContent(buf)); [EOL] [EOL] 		MatcherAssert.assertThat(channel.pipeline().names().iterator().next(), is("JsonObjectDecoder$extractor")); [EOL] [EOL] 		Object content = channel.readInbound(); [EOL] 		MatcherAssert.assertThat(content, instanceOf(ByteBuf.class)); [EOL] 		((ByteBuf) content).release(); [EOL] [EOL] 		content = channel.readInbound(); [EOL] 		MatcherAssert.assertThat(content, instanceOf(LastHttpContent.class)); [EOL] 		((LastHttpContent) content).release(); [EOL] [EOL] 		MatcherAssert.assertThat(channel.readInbound(), nullValue()); [EOL] 	} [EOL]
@Test (expected=DateFormatException.class) [EOL] public void fromString_noformat_unformat() { [EOL] 	DateUtils.fromString("2011/05/12 12:45:27"); [EOL] } [EOL]
@Test [EOL] 	public void willSetHttpStatusCode415IfTheResourceMethodDoesNotSupportTheGivenMediaTypes() throws Exception { [EOL] 		when(request.getContentType()).thenReturn("image/jpeg"); [EOL] [EOL] 		interceptor.intercept(stack, consumeXml, null); [EOL] 		verify(status).unsupportedMediaType("Request with media type [image/jpeg]. Expecting one of [application/xml]."); [EOL] 		verifyZeroInteractions(stack); [EOL] 	} [EOL]
@Test [EOL] public void noDuplicateRegionId() { [EOL] Set<String> regionIds = new HashSet<>(); [EOL] for (Region region : Region.values()) { [EOL] assertFalse(regionIds.contains(region.getRegionId())); [EOL] regionIds.add(region.getRegionId()); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetRelativePathsUnix() { [EOL] assertEquals("stuff/xyz.dat", FileSyncUtils.getRelativePath("/var/data/stuff/xyz.dat", "/var/data/", "/")); [EOL] assertEquals("../../b/c", FileSyncUtils.getRelativePath("/a/b/c", "/a/x/y/", "/")); [EOL] assertEquals("../../b/c", FileSyncUtils.getRelativePath("/m/n/o/a/b/c", "/m/n/o/a/x/y/", "/")); [EOL] } [EOL]
@Test [EOL] public void testCheckLock() { [EOL] long v = dynoLockClient.acquireLock(resource, 5000); [EOL] Assert.assertTrue("Acquire lock did not succeed in time", v > 0); [EOL] Assert.assertEquals(1, dynoLockClient.getLockedResources().size()); [EOL] v = dynoLockClient.checkLock(resource); [EOL] Assert.assertTrue("Check lock failed for acquired lock",v > 0); [EOL] dynoLockClient.releaseLock(resource); [EOL] Assert.assertTrue("Check lock failed for acquired lock", dynoLockClient.checkLock(resource) == 0); [EOL] } [EOL]
@Test [EOL] public void markValidationFailures() { [EOL] underTest.markValidationFailures(ROAD_NAME); [EOL] [EOL] assertThat(validationFailures.get().count(), is(1.0)); [EOL] } [EOL]
@Test [EOL] public void failoverHandlerIsNotExecutedImmediatelyIfBackoffPolicyShouldNotApply() { [EOL] [EOL] // given [EOL] BackoffPolicy<AbstractAction<BulkResult>> backoffPolicy = mock(BackoffPolicy.class); [EOL] when(backoffPolicy.shouldApply(any())).thenReturn(false); [EOL] [EOL] Builder builder = createTestObjectFactoryBuilder(); [EOL] builder.withBackoffPolicy(backoffPolicy); [EOL] [EOL] JestHttpObjectFactory config = spy(builder.build()); [EOL] [EOL] String payload1 = "test1"; [EOL] Bulk bulk = createTestBatch(payload1); [EOL] [EOL] FailoverPolicy failoverPolicy = mock(FailoverPolicy.class); [EOL] Function<Bulk, Boolean> listener = config.createBatchListener(failoverPolicy); [EOL] [EOL] // when [EOL] listener.apply(bulk); [EOL] [EOL] // then [EOL] ArgumentCaptor<FailedItemSource> captor = ArgumentCaptor.forClass(FailedItemSource.class); [EOL] verify(failoverPolicy, never()).deliver(captor.capture()); [EOL] [EOL] } [EOL]
@Test [EOL] public void shouldEncodeAList() throws Exception { [EOL] List<Object> encodedList = P11.encode_modified(Arrays.asList("a", "a", "a", "a", "b", "c", "c", "a", "a", "d", "e", "e", "e", "e")); [EOL] assertThat(encodedList, hasSize(6)); [EOL] assertThat(encodedList.get(0), is(equalTo(new SimpleEntry<>(4, "a")))); [EOL] assertThat(encodedList.get(1), is(equalTo("b"))); [EOL] assertThat(encodedList.get(2), is(equalTo(new SimpleEntry<>(2, "c")))); [EOL] assertThat(encodedList.get(3), is(equalTo(new SimpleEntry<>(2, "a")))); [EOL] assertThat(encodedList.get(4), is(equalTo("d"))); [EOL] assertThat(encodedList.get(5), is(equalTo(new SimpleEntry<>(4, "e")))); [EOL] } [EOL]
@Test(expected = ObjectNotFoundException.class) [EOL] public void testFetchObjectTypeNotFound() throws Exception { [EOL] UUID id = UUID.randomUUID(); [EOL] when(objectTypeRequestResolver.fetchExistingObjectType(id)).thenThrow(ObjectNotFoundException.class); [EOL] delegate.handle(new GetObjectTypeByIdRequest().setId(id)); [EOL] } [EOL]
@Test [EOL] public void testProducesCommonBatchesMultipleTablesTwoChannelsMultipleRouters() { [EOL] List<TriggerRouter> triggerRouters = new ArrayList<TriggerRouter>(); [EOL] triggerRouters.add(new TriggerRouter(new Trigger("a", CHANNEL_2_TEST.getChannelId()), new Router("test1", SOURCE_NODE_GROUP, TARGET_NODE_GROUP, "default"))); [EOL] triggerRouters.add(new TriggerRouter(new Trigger("b", "anotherchannel"), new Router("test2", SOURCE_NODE_GROUP, TARGET_NODE_GROUP, "column"))); [EOL] assertTrue(routerService.producesCommonBatches(CHANNEL_2_TEST, SOURCE_NODE_GROUP, triggerRouters)); [EOL] } [EOL]
@Test [EOL] void testFilter() { [EOL] Assertions.assertFalse(this.filter.isAllowGuestLogin()); [EOL] Assertions.assertEquals(PrincipalFormat.FQN, this.filter.getPrincipalFormat()); [EOL] Assertions.assertEquals(PrincipalFormat.BOTH, this.filter.getRoleFormat()); [EOL] Assertions.assertNull(this.filter.getFilterConfig()); [EOL] Assertions.assertNotNull(this.filter.getProvider()); [EOL] Assertions.assertTrue(this.filter.getAccessDeniedHandler() instanceof CustomAccessDeniedHandler); [EOL] } [EOL]
@Test [EOL] public void testGetSaveAndRenameCommand() { [EOL] [EOL] final Command expectedCommand = mock(Command.class); [EOL] final GuidedDecisionTableGraphEditorPresenter presenter = makePresenter(); [EOL] [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addPathSupplier(any()); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addValidator(any(Validator.class)); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addValidator(any(Supplier.class)); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addRenameService(any()); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addMetadataSupplier(any()); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addContentSupplier(any()); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addIsDirtySupplier(any()); [EOL] doReturn(saveAndRenameCommandBuilder).when(saveAndRenameCommandBuilder).addSuccessCallback(any()); [EOL] doReturn(expectedCommand).when(saveAndRenameCommandBuilder).build(); [EOL] [EOL] final Command actualCommand = presenter.getSaveAndRenameCommand(); [EOL] [EOL] assertEquals(expectedCommand, actualCommand); [EOL] } [EOL]
@Test [EOL] public void testAuthLocalJceks() throws Exception { [EOL] File localJceksFile = File.createTempFile( [EOL] getClass().getSimpleName() +".testAuthLocalJceks-", ".localjceks"); [EOL] populateLocalJceksTestFile(localJceksFile.getAbsolutePath()); [EOL] try { [EOL] String localJceksUri = "localjceks://file/" + [EOL] localJceksFile.getAbsolutePath(); [EOL] Configuration conf = new Configuration(); [EOL] conf.set(CredentialProviderFactory.CREDENTIAL_PROVIDER_PATH, [EOL] localJceksUri); [EOL] List<ZKAuthInfo> zkAuths = SecurityUtil.getZKAuthInfos(conf, [EOL] CommonConfigurationKeys.ZK_AUTH); [EOL] assertEquals(1, zkAuths.size()); [EOL] ZKAuthInfo zkAuthInfo = zkAuths.get(0); [EOL] assertEquals("a_scheme", zkAuthInfo.getScheme()); [EOL] assertArrayEquals("a_password".getBytes(), zkAuthInfo.getAuth()); [EOL] } finally { [EOL] boolean deleted = localJceksFile.delete(); [EOL] assertTrue(deleted); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testGetPortWhenDefaultPort() throws MalformedURLException { [EOL] 		OASURLParser oasURLParser = new OASURLParser( [EOL] 			"http://localhost/o/headless-commerce-admin-catalog/v1.0" + [EOL] 				"/openapi.json"); [EOL] [EOL] 		Assert.assertEquals("", oasURLParser.getPort()); [EOL] 	} [EOL]
@Test [EOL] public void backupPath() { [EOL] [EOL] File backupDirectory = provider.getBackupDirectory(); [EOL] [EOL] assertTrue(backupDirectory.exists()); [EOL] assertTrue(backupDirectory.canRead()); [EOL] assertTrue(backupDirectory.canWrite()); [EOL] [EOL] String actualPath = backupDirectory.getAbsolutePath(); [EOL] [EOL] String expectedPath = baseDir.getAbsolutePath() + File.separator [EOL] + AndroidDirectoryProvider.PREFERENCES_ROOT_DIRECTORY_NAME + File.separator [EOL] + PREF_NAME + File.separator [EOL] + AndroidDirectoryProvider.BACKUP_DIRECTORY_NAME; [EOL] [EOL] assertEquals(expectedPath, actualPath); [EOL] } [EOL]
@Test [EOL] void shouldCorrectlyEncodeData2() { [EOL] String username = "𠜎𠜱𠝹𠱓𠱸𠲖𠳏𠳕𠴕𠵼𠵿𠸎1234567#4? "; [EOL] String password = "tset1234"; [EOL] [EOL] int usernameLength = username.getBytes(CharsetUtil.UTF_8).length; [EOL] int passwordLength = password.length(); [EOL] [EOL] ByteBuf byteBuf = [EOL] AuthMetadataCodec.encodeSimpleMetadata( [EOL] ByteBufAllocator.DEFAULT, username.toCharArray(), password.toCharArray()); [EOL] [EOL] byteBuf.markReaderIndex(); [EOL] checkSimpleAuthMetadataEncoding( [EOL] username, password, usernameLength, passwordLength, byteBuf.retain()); [EOL] byteBuf.resetReaderIndex(); [EOL] checkSimpleAuthMetadataEncodingUsingDecoders( [EOL] username, password, usernameLength, passwordLength, byteBuf); [EOL] } [EOL]
@Test [EOL] public void testSkipAndCountWindowsWithGaps() { [EOL] Observable<String> subject = Observable.from("one", "two", "three", "four", "five"); [EOL] Observable<Observable<String>> windowed = Observable.create(window(subject, 2, 3)); [EOL] [EOL] List<List<String>> windows = toLists(windowed); [EOL] [EOL] assertEquals(2, windows.size()); [EOL] assertEquals(list("one", "two"), windows.get(0)); [EOL] assertEquals(list("four", "five"), windows.get(1)); [EOL] } [EOL]
@Test [EOL] public void testFromDecimalToFixed8ByteArray() { [EOL] BigDecimal d = BigDecimal.TEN; [EOL] byte[] i = Numeric.fromDecimalToFixed8ByteArray(d); [EOL] assertArrayEquals(i, new byte[]{(byte) 0x00, (byte) 0xca, (byte) 0x9a, (byte) 0x3b, 0x00, 0x00, 0x00, 0x00}); [EOL] [EOL] d = new BigDecimal("0.001"); [EOL] i = Numeric.fromDecimalToFixed8ByteArray(d); [EOL] assertArrayEquals(i, new byte[]{(byte) 0xa0, (byte) 0x86, (byte) 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}); [EOL] [EOL] d = new BigDecimal("0.00000001"); [EOL] i = Numeric.fromDecimalToFixed8ByteArray(d); [EOL] assertArrayEquals(i, new byte[]{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}); [EOL] [EOL] d = new BigDecimal("0.000000001"); [EOL] i = Numeric.fromDecimalToFixed8ByteArray(d); [EOL] assertArrayEquals(i, new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}); [EOL] } [EOL]
@Test public void selectHeader_03() { [EOL] test(QueryEngineHTTP.defaultSelectHeader(), WebContent.contentTypeTextTSV) ; [EOL] } [EOL]
@Test [EOL] 	public void testApplicationBinding_7() throws Exception { [EOL] [EOL] 		final String result = "{\"name\":\"app1\",\"displayName\":\"app1\",\"tplName\":\"\",\"tplVersion\":\"oops\"}"; [EOL] 		ObjectMapper mapper = JSonBindingUtils.createObjectMapper(); [EOL] [EOL] 		ApplicationTemplate tpl = new ApplicationTemplate( "" ).version( "oops" ); [EOL] 		Application app = new Application( "app1", tpl ); [EOL] 		app.getRootInstances().add( new Instance( "r" )); [EOL] [EOL] 		StringWriter writer = new StringWriter(); [EOL] 		mapper.writeValue( writer, app ); [EOL] 		String s = writer.toString(); [EOL] [EOL] 		Assert.assertEquals( result, s ); [EOL] 		Application readApp = mapper.readValue( result, Application.class ); [EOL] 		Assert.assertEquals( app, readApp ); [EOL] 		Assert.assertEquals( app.getName(), readApp.getName()); [EOL] 		Assert.assertEquals( app.getDescription(), readApp.getDescription()); [EOL] 		Assert.assertEquals( app.getTemplate(), readApp.getTemplate()); [EOL] 		Assert.assertEquals( app.getTemplate().getExternalExportsPrefix(), readApp.getTemplate().getExternalExportsPrefix()); [EOL] 	} [EOL]
@Test [EOL] public void shouldReturnNullIfNoSnapshotsExist() throws StorageException { [EOL] Snapshot snapshot = snapshotsStore.getLatestSnapshot(); [EOL] assertThat(snapshot, nullValue()); [EOL] } [EOL]
@Test [EOL] void parseSusceptibilityWithDiseaseId() { [EOL] OmimDisease output = instance.parseLine("{Bone mineral density QTL 12, osteoporosis}, 612560 (3)\tUGT2B17, BMND12\t601903\t4q13.2"); [EOL] System.out.println(output); [EOL] OmimDisease expected = new OmimDisease(612560, 601903, "Bone mineral density QTL 12, osteoporosis",7367, DiseaseType.SUSCEPTIBILITY, InheritanceMode.UNKNOWN); [EOL] assertThat(output, equalTo(expected)); [EOL] } [EOL]
@Test [EOL] 	public void test1() [EOL] 	{ [EOL] 		AnnotatedString in_string = AnnotatedString.read(new Scanner("Lorem ipsum dolor sit amet.\n\n" + [EOL] 				"Lorem ipsum dolor sit amet.")); [EOL] 		Rule r = new CheckNoBreak(); [EOL] 		List<Advice> ad_list = r.evaluate(in_string, in_string); [EOL] 		assertTrue(ad_list.isEmpty()); [EOL] 	} [EOL]
@Test [EOL] public void testSitePreemptionConversion() { [EOL] yarnConfig.setBoolean(FairSchedulerConfiguration.PREEMPTION, true); [EOL] yarnConfig.setInt(FairSchedulerConfiguration.WAIT_TIME_BEFORE_KILL, 123); [EOL] yarnConfig.setInt( [EOL] FairSchedulerConfiguration.WAIT_TIME_BEFORE_NEXT_STARVATION_CHECK_MS, [EOL] 321); [EOL] [EOL] converter.convertSiteProperties(yarnConfig, yarnConvertedConfig, false, [EOL] false); [EOL] [EOL] assertTrue("Preemption enabled", [EOL] yarnConvertedConfig.getBoolean( [EOL] YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS, [EOL] false)); [EOL] assertEquals("Wait time before kill", 123, [EOL] yarnConvertedConfig.getInt( [EOL] CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL, [EOL] -1)); [EOL] assertEquals("Starvation check wait time", 321, [EOL] yarnConvertedConfig.getInt( [EOL] CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL, [EOL] -1)); [EOL] } [EOL]
@Test [EOL] public void test_configureLdapGroup_failed_500() { [EOL] String token = "4EpPYDSfgN2D4Gf7UmNO3nuL"; [EOL] String jsonStr = "{\"groupname\":\"admin\",\"policies\": \"admin,default\"}"; [EOL] Response responseGroup = getMockResponse(HttpStatus.OK, true, "{\"data\": { \"policies\": [ \"admin\", \"default\"] }}"); [EOL] Response responseFailure = getMockResponse(HttpStatus.INTERNAL_SERVER_ERROR, false, "{\"errors\":[\"LDAP Group configuration failed\"]}"); [EOL] Response responseOk = getMockResponse(HttpStatus.OK, true, ""); [EOL] ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"messages\":[\"LDAP Group configured\"]}"); [EOL] LDAPGroup ldapGroup = new LDAPGroup("admin", "admin,default"); [EOL] when(JSONUtil.getJSON(ldapGroup)).thenReturn(jsonStr); [EOL] when(ControllerUtil.updateMetaDataOnConfigChanges(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(responseOk); [EOL] when(reqProcessor.process("/auth/ldap/groups","{\"groupname\":\"admin\"}",token)).thenReturn(responseGroup); [EOL] when(reqProcessor.process("/auth/ldap/groups/configure",jsonStr,token)).thenReturn(responseFailure); [EOL] [EOL] ResponseEntity<String> responseEntity = ldapAuthService.configureLdapGroup(token, ldapGroup); [EOL] assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntity.getStatusCode()); [EOL] //assertEquals(responseEntityExpected, responseEntity); [EOL] } [EOL]
@Test [EOL] public void testChannelShutdownInitialize() throws Exception { [EOL] [EOL] thrown.expect(InvalidArgumentException.class); [EOL] thrown.expectMessage("Channel shutdown has been shutdown."); [EOL] [EOL] shutdownChannel.initialize(); [EOL] [EOL] } [EOL]
@Test [EOL] void testIsReversed() { [EOL] boolean expResult = false; [EOL] boolean result = instance.isReversed(); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test(timeout = 300000) [EOL] public void testMoverWithStripedFile() throws Exception { [EOL] final Configuration conf = new HdfsConfiguration(); [EOL] initConfWithStripe(conf); [EOL] [EOL] // start 10 datanodes [EOL] int numOfDatanodes =10; [EOL] int storagesPerDatanode=2; [EOL] long capacity = 10 * defaultBlockSize; [EOL] long[][] capacities = new long[numOfDatanodes][storagesPerDatanode]; [EOL] for (int i = 0; i < numOfDatanodes; i++) { [EOL] for(int j=0;j<storagesPerDatanode;j++){ [EOL] capacities[i][j]=capacity; [EOL] } [EOL] } [EOL] final MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf) [EOL] .numDataNodes(numOfDatanodes) [EOL] .storagesPerDatanode(storagesPerDatanode) [EOL] .storageTypes(new StorageType[][]{ [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.DISK}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}, [EOL] {StorageType.DISK, StorageType.ARCHIVE}}) [EOL] .storageCapacities(capacities) [EOL] .build(); [EOL] [EOL] try { [EOL] cluster.waitActive(); [EOL] cluster.getFileSystem().enableErasureCodingPolicy( [EOL] StripedFileTestUtil.getDefaultECPolicy().getName()); [EOL] [EOL] // set "/bar" directory with HOT storage policy. [EOL] ClientProtocol client = NameNodeProxies.createProxy(conf, [EOL] cluster.getFileSystem(0).getUri(), ClientProtocol.class).getProxy(); [EOL] String barDir = "/bar"; [EOL] client.mkdirs(barDir, new FsPermission((short) 777), true); [EOL] client.setStoragePolicy(barDir, [EOL] HdfsConstants.HOT_STORAGE_POLICY_NAME); [EOL] // set an EC policy on "/bar" directory [EOL] client.setErasureCodingPolicy(barDir, [EOL] StripedFileTestUtil.getDefaultECPolicy().getName()); [EOL] [EOL] // write file to barDir [EOL] final String fooFile = "/bar/foo"; [EOL] long fileLen = 20 * defaultBlockSize; [EOL] DFSTestUtil.createFile(cluster.getFileSystem(), new Path(fooFile), [EOL] fileLen,(short) 3, 0); [EOL] [EOL] // verify storage types and locations [EOL] LocatedBlocks locatedBlocks = [EOL] client.getBlockLocations(fooFile, 0, fileLen); [EOL] for(LocatedBlock lb : locatedBlocks.getLocatedBlocks()){ [EOL] for( StorageType type : lb.getStorageTypes()){ [EOL] Assert.assertEquals(StorageType.DISK, type); [EOL] } [EOL] } [EOL] StripedFileTestUtil.verifyLocatedStripedBlocks(locatedBlocks, [EOL] dataBlocks + parityBlocks); [EOL] [EOL] // start 5 more datanodes [EOL] numOfDatanodes +=5; [EOL] capacities = new long[5][storagesPerDatanode]; [EOL] for (int i = 0; i < 5; i++) { [EOL] for(int j=0;j<storagesPerDatanode;j++){ [EOL] capacities[i][j]=capacity; [EOL] } [EOL] } [EOL] cluster.startDataNodes(conf, 5, [EOL] new StorageType[][]{ [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}, [EOL] {StorageType.ARCHIVE, StorageType.ARCHIVE}}, [EOL] true, null, null, null,capacities, null, false, false, false, null); [EOL] cluster.triggerHeartbeats(); [EOL] [EOL] // move file to ARCHIVE [EOL] client.setStoragePolicy(barDir, "COLD"); [EOL] // run Mover [EOL] int rc = ToolRunner.run(conf, new Mover.Cli(), [EOL] new String[] { "-p", barDir }); [EOL] Assert.assertEquals("Movement to ARCHIVE should be successful", 0, rc); [EOL] [EOL] // verify storage types and locations [EOL] locatedBlocks = client.getBlockLocations(fooFile, 0, fileLen); [EOL] for(LocatedBlock lb : locatedBlocks.getLocatedBlocks()){ [EOL] for( StorageType type : lb.getStorageTypes()){ [EOL] Assert.assertEquals(StorageType.ARCHIVE, type); [EOL] } [EOL] } [EOL] StripedFileTestUtil.verifyLocatedStripedBlocks(locatedBlocks, [EOL] dataBlocks + parityBlocks); [EOL] [EOL] // start 5 more datanodes [EOL] numOfDatanodes += 5; [EOL] capacities = new long[5][storagesPerDatanode]; [EOL] for (int i = 0; i < 5; i++) { [EOL] for (int j = 0; j < storagesPerDatanode; j++) { [EOL] capacities[i][j] = capacity; [EOL] } [EOL] } [EOL] cluster.startDataNodes(conf, 5, [EOL] new StorageType[][] { { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK }, [EOL] { StorageType.SSD, StorageType.DISK } }, [EOL] true, null, null, null, capacities, null, false, false, false, null); [EOL] cluster.triggerHeartbeats(); [EOL] [EOL] // move file blocks to ONE_SSD policy [EOL] client.setStoragePolicy(barDir, "ONE_SSD"); [EOL] [EOL] // run Mover [EOL] rc = ToolRunner.run(conf, new Mover.Cli(), new String[] { "-p", barDir }); [EOL] [EOL] // verify storage types and locations [EOL] // Movements should have been ignored for the unsupported policy on [EOL] // striped file [EOL] locatedBlocks = client.getBlockLocations(fooFile, 0, fileLen); [EOL] for (LocatedBlock lb : locatedBlocks.getLocatedBlocks()) { [EOL] for (StorageType type : lb.getStorageTypes()) { [EOL] Assert.assertEquals(StorageType.ARCHIVE, type); [EOL] } [EOL] } [EOL] }finally{ [EOL] cluster.shutdown(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testGetPrefixes() throws Exception { [EOL] testGetPrefixes(new XmlNamespaceContext(Collections.map( [EOL] tuple("foo", "http://foo.org"), [EOL] tuple("bar", "http://bar.org"), [EOL] tuple("baz", "http://bar.org"))), [EOL] asList("bar", "baz")); [EOL] testGetPrefixes(XmlNamespaceContext.mk(asList( [EOL] new XmlNamespaceBinding("foo", "http://foo.org"), [EOL] new XmlNamespaceBinding("bar", "http://bar.org"), [EOL] new XmlNamespaceBinding("baz", "http://bar.org"))), [EOL] asList("bar", "baz")); [EOL] } [EOL]
@Test [EOL] public void testUnion() { [EOL] Parser<Relation> parser = RelationParser.union(TABLE); [EOL] TerminalParserTest.assertParser(parser, "a", table("a")); [EOL] TerminalParserTest.assertParser(parser, "a union b", new UnionRelation(table("a"), false, table("b"))); [EOL] TerminalParserTest.assertParser(parser, "a union all b union (c)", [EOL] new UnionRelation( [EOL] new UnionRelation(table("a"), true, table("b")), [EOL] false, table("c") [EOL] ) [EOL] ); [EOL] TerminalParserTest.assertParser(parser, "a union all (b union (c))", [EOL] new UnionRelation( [EOL] table("a"), [EOL] true, [EOL] new UnionRelation(table("b"), false, table("c")) [EOL] ) [EOL] ); [EOL] } [EOL]
@Test [EOL] 	public void welcome() throws Exception { [EOL] 		mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON)) [EOL] 				.andExpect(status().isOk()).andExpect(content().string(equalTo("Hello World"))); [EOL] 	} [EOL]
@Test [EOL] public void shouldDeleteNetwork() throws OpenStackException, IOException { [EOL] [EOL] NetworkInstance net = new NetworkInstance("NETWORK", "vdc", "region"); [EOL] net.setIdNetwork("ID"); [EOL] [EOL] // when [EOL] when(openOperationUtil.executeNovaRequest(any(HttpUriRequest.class))).thenReturn("ok"); [EOL] openStackUtil.deleteSubNetwork(net.getIdNetwork(), "region", "token", "vdc"); [EOL] [EOL] verify(openOperationUtil).executeNovaRequest(any(HttpUriRequest.class)); [EOL] [EOL] } [EOL]
@Test(expectedExceptions=TransformationException.class) [EOL] public void testTransformIfIncorrectPath() throws Exception { [EOL] transformer.transform(new URI("/incorrect/path")); [EOL] } [EOL]
@Test [EOL] 	public void testFindPatientConnectionByUsername() { [EOL] 		Patient patient = mock(Patient.class); [EOL] 		when(patientRepository.findByUsername(anyString())).thenReturn(patient); [EOL] 	} [EOL]
@Test [EOL] public void readUTF8StringInvalidCap() throws IOException { [EOL] assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> DockerCloudUtils.readUTF8String [EOL] (TestInputStream.withUTF8String("hello"), -2)); [EOL] } [EOL]
@Test [EOL] public void testLoadXacmlProperties() { [EOL] XacmlRest.xacmlInit(servletConfig); [EOL] XacmlRest.loadXacmlProperties(null, null); [EOL] [EOL] XacmlRest.loadXacmlProperties(new Properties(), new Properties()); [EOL] [EOL] Logger.getRootLogger().setLevel(Level.INFO); [EOL] XacmlRest.loadXacmlProperties(new Properties(), new Properties()); [EOL] } [EOL]
@Test(expected=UnauthorizedException.class) [EOL] public void testRemoveDestinationInfoNotAuthorized() throws Exception { [EOL] String name = "myTopic"; [EOL] ActiveMQDestination dest = new ActiveMQTopic(name); [EOL] DestinationInfo info = new DestinationInfo(null, DestinationInfo.REMOVE_OPERATION_TYPE, dest); [EOL] [EOL] Subject subject = new PermsSubject(); [EOL] ConnectionContext context = createContext(subject); [EOL] [EOL] filter.removeDestinationInfo(context, info); [EOL] } [EOL]
@Test(expectedExceptions = IllegalStateException.class) [EOL] public void testGetWeightIntervalError() { [EOL] GraphStore graphStore = GraphGenerator.generateTinyGraphStore(TimeRepresentation.INTERVAL); [EOL] Edge e = graphStore.getEdge("0"); [EOL] e.getWeight(new Interval(1.0, 2.0)); [EOL] } [EOL]
@Test [EOL] public void minTest2() { [EOL] Map<String, String> variableDomains = new HashMap<>(); [EOL] PositiveBoundHiveSmallInt.PositiveBoundHiveSmallIntTag pos = new PositiveBoundHiveSmallInt.PositiveBoundHiveSmallIntTag(); [EOL] PositiveBoundHiveSmallInt test = new PositiveBoundHiveSmallInt(); [EOL] List<Map<String, String>> listOfMaps = new LinkedList<>(); [EOL] listOfMaps.add(variableDomains); [EOL] [EOL] pos.setMin("0"); [EOL] pos.setMax("100"); [EOL] pos.setNullable("true"); [EOL] pos.setName("test"); [EOL] [EOL] List<Map<String, String>> list = test.pipelinePossibleStates(pos, listOfMaps); [EOL] [EOL] Assert.assertEquals(list.get(0).get("test"), "0"); [EOL] Assert.assertEquals(list.get(1).get("test"), "1"); [EOL] Assert.assertEquals(list.get(2).get("test"), "50"); [EOL] Assert.assertEquals(list.get(3).get("test"), "99"); [EOL] Assert.assertEquals(list.get(4).get("test"), "100"); [EOL] } [EOL]
@Test(expected=NullPointerException.class) [EOL] public void testWriteIterableNullWriter() throws Exception { [EOL] write(records, null); [EOL] } [EOL]
@Test(expected=NullPointerException.class) [EOL] public void testArgNotNullFail() { [EOL] Args.notNull(null, "Stuff"); [EOL] } [EOL]
@Test [EOL] void shutdownTimeoutInMs() { [EOL] assertThat(shutdownHook.shutdownTimeoutInMs(Map.of())).isEqualTo(Duration.ofSeconds(25).toMillis()); // default is 25s [EOL] [EOL] assertThat(shutdownHook.shutdownTimeoutInMs(Map.of("SHUTDOWN_TIMEOUT_IN_SEC", "60"))) [EOL] .isEqualTo(Duration.ofSeconds(60).toMillis()); [EOL] [EOL] assertThatThrownBy(() -> shutdownHook.shutdownTimeoutInMs(Map.of("SHUTDOWN_TIMEOUT_IN_SEC", "-1"))) [EOL] .isInstanceOf(Error.class) [EOL] .hasMessageContaining("greater than 0"); [EOL] } [EOL]
@Test(expected=NullPointerException.class) [EOL] public void testOpenNullUpper() { [EOL] open(24L, null); [EOL] } [EOL]
@Test (timeout = 30000) [EOL] public void testGetRealAuthenticationMethod() { [EOL] UserGroupInformation ugi = UserGroupInformation.createRemoteUser("user1"); [EOL] ugi.setAuthenticationMethod(AuthenticationMethod.SIMPLE); [EOL] assertEquals(AuthenticationMethod.SIMPLE, ugi.getAuthenticationMethod()); [EOL] assertEquals(AuthenticationMethod.SIMPLE, ugi.getRealAuthenticationMethod()); [EOL] ugi = UserGroupInformation.createProxyUser("user2", ugi); [EOL] assertEquals(AuthenticationMethod.PROXY, ugi.getAuthenticationMethod()); [EOL] assertEquals(AuthenticationMethod.SIMPLE, ugi.getRealAuthenticationMethod()); [EOL] } [EOL]
@Test [EOL] void mapNameSpace() { [EOL] NameSpaceMapping oneNsMapping = NameSpaceMappingBuilder.of("a.b",""); [EOL] List<NameSpaceMapping> oneMapping = Collections.singletonList(oneNsMapping); [EOL] [EOL] SimpleNameSpaceMapper snsm = new SimpleNameSpaceMapper(oneMapping); [EOL] assertEquals(snsm.mapNameSpace("a.b"),""); [EOL] assertEquals(snsm.mapNameSpace("a.b.c"),"c"); [EOL] assertEquals(snsm.mapNameSpace("a.d"),"a.d"); [EOL] assertEquals(snsm.mapNameSpace(""),""); [EOL] } [EOL]
@Test [EOL] public void inc() { [EOL] assertThat(integer.get()).isEqualTo(0); [EOL] [EOL] integer.inc(); [EOL] assertThat(integer.get()).isEqualTo(1); [EOL] [EOL] integer.inc(); [EOL] assertThat(integer.get()).isEqualTo(2); [EOL] } [EOL]
@Test [EOL] public void test_getTargetSystemServiceList_failed()throws Exception{ [EOL] String token = "12345"; [EOL] String jsonStr = "{\"targetsystemservices\": [ {\n" + [EOL] " \"name\" : \"testservice1\",\n" + [EOL] " \"description\" : \"\",\n" + [EOL] " \"targetSystemServiceId\" : \"1234\",\n" + [EOL] " \"hostname\" : \"testhostname\",\n" + [EOL] " \"monitoringEnabled\" : false,\n" + [EOL] " \"multiIpMonitoringEnabled\" : false,\n" + [EOL] " \"port\" : 22\n" + [EOL] "} ]}"; [EOL] CertResponse response = new CertResponse(); [EOL] response.setHttpstatus(HttpStatus.INTERNAL_SERVER_ERROR); [EOL] response.setResponse("{\"errors\":[\"NCLM services are down. Please try after some time\"]}"); [EOL] response.setSuccess(false); [EOL] String jsonStrUser = "{ \"username\": \"testusername1\", \"password\": \"testpassword1\"}"; [EOL] CertResponse responseUser = new CertResponse(); [EOL] responseUser.setHttpstatus(HttpStatus.OK); [EOL] responseUser.setResponse(jsonStrUser); [EOL] responseUser.setSuccess(true); [EOL] Map<String, Object> requestMap = new HashMap<>(); [EOL] requestMap.put("access_token", "12345"); [EOL] requestMap.put("token_type", "type"); [EOL] when(ControllerUtil.parseJson(jsonStrUser)).thenReturn(requestMap); [EOL] [EOL] when(reqProcessor.processCert(eq("/auth/certmanager/login"), Mockito.anyObject(), Mockito.anyString(), [EOL] Mockito.anyString())).thenReturn(responseUser); [EOL] [EOL] when(reqProcessor.processCert(eq( "/certmanager/targetsystemservicelist"), Mockito.anyObject(), Mockito.anyString(), [EOL] Mockito.anyString())).thenReturn(response); [EOL] [EOL] [EOL] ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("{\"errors\":[\"Your request cannot be processed now due to some technical issue. Please try after some time\"]}"); [EOL] ResponseEntity<String> responseEntityActual = sSLCertificateService.getTargetSystemServiceList(token, getMockUser(true), "123"); [EOL] [EOL] assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, responseEntityActual.getStatusCode()); [EOL] assertEquals(responseEntityExpected.getBody(), responseEntityActual.getBody()); [EOL] } [EOL]
@Test [EOL] 	public void testGetResizeFitArgumentWithBlankMaxWidth() { [EOL] 		AMGIFImageScaler amGIFImageScaler = new AMGIFImageScaler(); [EOL] [EOL] 		AMImageConfigurationEntry amImageConfigurationEntry = [EOL] 			new AMImageConfigurationEntryImpl( [EOL] 				"test", "desc", "12345", [EOL] 				HashMapBuilder.put( [EOL] 					"max-height", "100" [EOL] 				).put( [EOL] 					"max-width", "" [EOL] 				).build(), [EOL] 				true); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			"_x100", [EOL] 			_getResizeFitValues(amGIFImageScaler, amImageConfigurationEntry)); [EOL] 	} [EOL]
@Test [EOL] void buildFedIPMissingCertReferences() { [EOL] final IdentityProvider identityProvider = new IdentityProvider(); [EOL] identityProvider.setType(FEDERATED); [EOL] final FederatedIdentityProviderDetail identityProviderDetail = new FederatedIdentityProviderDetail(); [EOL] identityProvider.setIdentityProviderDetail(identityProviderDetail); [EOL] identityProvider.setId(TEST_ID); [EOL] final Bundle bundle = new Bundle(projectInfo); [EOL] bundle.putAllIdentityProviders(new HashMap<String, IdentityProvider>() {{ [EOL] put("fail IDP", identityProvider); [EOL] }}); [EOL] [EOL] assertThrows(EntityBuilderException.class, () -> builder.build(bundle, BundleType.ENVIRONMENT, DocumentTools.INSTANCE.getDocumentBuilder().newDocument())); [EOL] } [EOL]
@Test [EOL] public void testSiteDrfDisabledConversion() { [EOL] converter.convertSiteProperties(yarnConfig, yarnConvertedConfig, false, [EOL] false); [EOL] [EOL] assertEquals("Resource calculator type", DefaultResourceCalculator.class, [EOL] yarnConvertedConfig.getClass( [EOL] CapacitySchedulerConfiguration.RESOURCE_CALCULATOR_CLASS, [EOL] CapacitySchedulerConfiguration.DEFAULT_RESOURCE_CALCULATOR_CLASS)); [EOL] } [EOL]
@Test [EOL] @SuppressWarnings("deprecation") [EOL] public void TestCancelReservation04() throws IllegalArgumentException, IllegalAccessException { [EOL] [EOL] // setup parameters [EOL] TransactionTokenInfo inTransactionToken = new TransactionTokenInfo("testTokenAttribute2", TransactionTokenType.IN); [EOL] TransactionToken receivedToken = new TransactionToken("bbb", "key", "value"); [EOL] [EOL] // setup up expected result [EOL] ReserveCommand expectedCommand = ReserveCommand.UPDATE_TOKEN; [EOL] [EOL] // run [EOL] TransactionTokenContextImpl contextImpl = new TransactionTokenContextImpl(inTransactionToken, receivedToken); [EOL] contextImpl.cancelReservation(); [EOL] [EOL] // test [EOL] Field field = ReflectionUtils.findField( [EOL] TransactionTokenContextImpl.class, "defaultCommand"); [EOL] ReflectionUtils.makeAccessible(field); [EOL] ReserveCommand resultCommand = (ReserveCommand) field.get(contextImpl); [EOL] assertThat(resultCommand, is(expectedCommand)); [EOL] [EOL] } [EOL]
@Test [EOL] public void testCreateOffset_ATSR1_1998() throws Exception { [EOL] try { [EOL] factory.createOffset("AT1", 1998); [EOL] fail(); [EOL] } catch (IllegalArgumentException expected) { [EOL] // [EOL] } [EOL] } [EOL]
@Test [EOL] public void should_keep_file_with_a_reference_on_workspace_when_cleanup_is_called() throws Exception { [EOL] //Folder creation [EOL] temporaryFolder.newFolderPath("pages",".metadata"); [EOL] temporaryFolder.newFolderPath("pages","myPage"); [EOL] temporaryFolder.newFilePath("pages/myPage/myPage.json"); [EOL] [EOL] temporaryFolder.newFilePath("pages/.metadata/.index.json"); [EOL] temporaryFolder.newFilePath("pages/.metadata/myPage.json"); [EOL] temporaryFolder.newFilePath("pages/.metadata/oldestPage.json"); [EOL] [EOL] workspace.cleanPageWorkspace(); [EOL] [EOL] assertThat(temporaryFolder.toPath().resolve("pages").resolve("myPage")).exists(); [EOL] assertThat(temporaryFolder.toPath().resolve("pages").resolve("myPage").resolve("js")).doesNotExist(); [EOL] assertThat(temporaryFolder.toPath().resolve("pages").resolve(".metadata").resolve(".index.json")).doesNotExist(); [EOL] assertThat(temporaryFolder.toPath().resolve("pages").resolve(".metadata").resolve("oldestPage.json")).doesNotExist(); [EOL] assertThat(temporaryFolder.toPath().resolve("pages").resolve(".metadata").resolve("myPage.json")).exists(); [EOL] } [EOL]
@Test [EOL] public void additionalPropertySchema() { [EOL] String expectedSchemaLocation = "#/bool/location"; [EOL] BooleanSchema boolSchema = BooleanSchema.builder().schemaLocation(expectedSchemaLocation).build(); [EOL] ObjectSchema subject = buildWithLocation(ObjectSchema.builder() [EOL] .schemaOfAdditionalProperties(boolSchema)); [EOL] TestSupport.failureOf(subject) [EOL] .input(OBJECTS.get("additionalPropertySchema")) [EOL] .expectedPointer("#/foo") [EOL] .expectedSchemaLocation(expectedSchemaLocation) [EOL] .expect(); [EOL] TestSupport.expectFailure(subject, "#/foo", OBJECTS.get("additionalPropertySchema")); [EOL] } [EOL]
@Test [EOL] public void getScore() { [EOL] assertThat(instance.getScore(), equalTo(score)); [EOL] } [EOL]
@Test [EOL] public void testPermittedTopology_point_polygon() { [EOL] [EOL] DimensionInfo sourceDimensionInfo = DimensionInfo.XY_POINT; [EOL] DimensionInfo targetDimensionInfo = DimensionInfo.XY_POLYGON; [EOL] SfWithinFF instance = new SfWithinFF(); [EOL] boolean expResult = true; [EOL] boolean result = instance.permittedTopology(sourceDimensionInfo, targetDimensionInfo); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test [EOL] public void testGetPropertyStringString06() throws Exception { [EOL] // 入力値の設定 [EOL] String input1 = ""; [EOL] String input2 = "default"; [EOL] [EOL] // テスト対象の実行 [EOL] String str = PropertyUtil.getProperty(input1, input2); [EOL] [EOL] // 結果確認 [EOL] assertEquals("default", str); [EOL] } [EOL]
@Test [EOL] public void clear() { [EOL] assetsDropdownView.clear(); [EOL] verify(assetsDropdownView, times(1)).refreshSelectPicker(); [EOL] verify(nativeSelectMock, never()).appendChild(any()); [EOL] } [EOL]
@Test [EOL] public void complete() { [EOL] FDBRecordVersion v1 = FDBRecordVersion.complete(VERSION_BYTES_ONE, 5); [EOL] assertTrue(v1.isComplete()); [EOL] assertEquals(1066L, v1.getDBVersion()); [EOL] assertArrayEquals(VERSION_BYTES_ONE, v1.getGlobalVersion()); [EOL] assertEquals(5, v1.getLocalVersion()); [EOL] [EOL] FDBRecordVersion v2 = FDBRecordVersion.complete(VERSION_BYTES_FOUR); [EOL] assertTrue(v2.isComplete()); [EOL] assertEquals(1776L, v2.getDBVersion()); [EOL] assertArrayEquals(Arrays.copyOfRange(VERSION_BYTES_FOUR, 0, 10), v2.getGlobalVersion()); [EOL] assertEquals(0, v2.getLocalVersion()); [EOL] [EOL] FDBRecordVersion v3 = FDBRecordVersion.complete(VERSION_BYTES_FIVE); [EOL] assertTrue(v3.isComplete()); [EOL] assertEquals(1776L, v3.getDBVersion()); [EOL] assertArrayEquals(Arrays.copyOfRange(VERSION_BYTES_FIVE, 0, 10), v3.getGlobalVersion()); [EOL] assertEquals(0xffff, v3.getLocalVersion()); [EOL] } [EOL]
@Test [EOL] public void shouldReturnNoContentIfCASSucceedsAndDeletesAKey() { [EOL] SetValue deleteKeySetValue = new SetValue(); [EOL] deleteKeySetValue.setExpectedValue(EXPECTED_VALUE); [EOL] deleteKeySetValue.setNewValue(null); [EOL] [EOL] when(distributedStore.compareAndSet(KEY, deleteKeySetValue)).thenReturn(Futures.<KeyValue>immediateFuture(null)); [EOL] [EOL] ClientResponse response = client().resource(REQUEST_URI).type(MediaType.APPLICATION_JSON_TYPE).put(ClientResponse.class, deleteKeySetValue); [EOL] [EOL] assertThat(response.getClientResponseStatus(), equalTo(ClientResponse.Status.NO_CONTENT)); [EOL] } [EOL]
@Test [EOL] public void testShouldDaosBeCalledWithTheCleanupPolicy() throws Exception { [EOL] // GIVEN [EOL] cleanables = new HashSet<>(); [EOL] cleanables.add(cleanableDao); [EOL] expect(cleanableDao.cleanup(capture(timeBasedCleanupPolicyCapture))).andReturn(2L); [EOL] [EOL] replay(cleanableDao); [EOL] cleanupServiceImpl = new CleanupServiceImpl(cleanables); [EOL] [EOL] // WHEN [EOL] long rows = cleanupServiceImpl.cleanup(cleanupPolicy); [EOL] [EOL] // THEN [EOL] Assert.assertNotNull("The argument is null", timeBasedCleanupPolicyCapture.getValue()); [EOL] Assert.assertEquals("The cluster name is wrong!", timeBasedCleanupPolicyCapture.getValue().getClusterName(), CLUSTER_NAME); [EOL] Assert.assertEquals("The to date is wrong!", timeBasedCleanupPolicyCapture.getValue().getToDateInMillis(), FROM_DATE_TIMESTAMP); [EOL] } [EOL]
@Test [EOL] public void shouldReturnClassLevelAdaptorComponent() throws NoSuchFieldException { [EOL] assertThat(componentNameExtractor.componentFrom(injectionPointWith( [EOL] AdapterAnnotation.class.getDeclaredField(FIELD_NAME))), [EOL] equalTo("EVENT_LISTENER")); [EOL] } [EOL]
@Test [EOL] public void testParseFiveOf1() [EOL] { [EOL] VirtualCheckOperator op = VirtualCheckExpressionParser.parseVirtualCheckExpression("five of [ host 'vm1', host 'vm2', host 'vm3', host 'vm4' ] as WARNING"); [EOL] assertThat(op.toString(), is(equalTo("five of [host 'vm1', host 'vm2', host 'vm3', host 'vm4'] as WARNING"))); [EOL] } [EOL]
@Test [EOL] public void testPrepareView() { [EOL] [EOL] page.prepareView(); [EOL] [EOL] verify(page).markAsViewed(); [EOL] verify(page).setupValueList(); [EOL] verify(page).setupCepOperators(); [EOL] verify(page).setupDefaultValue(); [EOL] verify(page).setupLimitedValue(); [EOL] } [EOL]
@Test [EOL] public void testGetResources() throws Exception { [EOL] @SuppressWarnings("unchecked") [EOL] ResourceProvider provider = init( [EOL] new HashMap<String,String>() {{ [EOL] put("status", "RUNNING"); [EOL] put("name", "a1"); [EOL] }}); [EOL] [EOL] PredicateBuilder pb = new PredicateBuilder().property( [EOL] HostComponentProcessResourceProvider.HC_PROCESS_CLUSTER_NAME_ID).equals("c1").and(); [EOL] pb = pb.property( [EOL] HostComponentProcessResourceProvider.HC_PROCESS_HOST_NAME_ID).equals("h1").and(); [EOL] Predicate predicate = pb.property( [EOL] HostComponentProcessResourceProvider.HC_PROCESS_COMPONENT_NAME_ID).equals("comp1").toPredicate(); [EOL] [EOL] Request request = PropertyHelper.getReadRequest(Collections.<String>emptySet()); [EOL] [EOL] Set<Resource> resources = provider.getResources(request, predicate); [EOL] [EOL] Assert.assertEquals(Integer.valueOf(1), Integer.valueOf(resources.size())); [EOL] Resource res = resources.iterator().next(); [EOL] [EOL] Assert.assertNotNull(res.getPropertyValue( [EOL] HostComponentProcessResourceProvider.HC_PROCESS_NAME_ID)); [EOL] Assert.assertNotNull(res.getPropertyValue( [EOL] HostComponentProcessResourceProvider.HC_PROCESS_STATUS_ID)); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void decodeHexDumpWithOddLength() { [EOL] ByteBufUtil.decodeHexDump("abc"); [EOL] } [EOL]
@Test(expected = ElasticsearchStatusException.class) [EOL] public void test_tag_unknown_document() throws IOException { [EOL] indexer.tag(project(TEST_INDEX), "unknown", "routing", tag("foo"), tag("bar")); [EOL] } [EOL]
@Test [EOL] void shouldEncodeGoodbyeMessage() throws Exception [EOL] { [EOL] encoder.encode( GOODBYE, packer ); [EOL] [EOL] verify( packer ).packStructHeader( 0, GoodbyeMessage.SIGNATURE ); [EOL] } [EOL]
@Test [EOL] public void testSuccessExecutionAudit() throws Exception { [EOL] final ExecuteReportContentHandler handler = new ExecuteReportContentHandler( contentGenerator ); [EOL] [EOL] when( reportComponent.validate() ).thenReturn( true ); [EOL] when( reportComponent.execute() ).thenReturn( true ); [EOL] [EOL] handler.createReportContent( outputStream, fileId, path, true, reportComponent, audit ); [EOL] [EOL] // execution attempt registered [EOL] verify( audit, times( 1 ) ).audit( [EOL] eq( sessionId ), [EOL] eq( sessionName ), [EOL] eq( path ), [EOL] eq( ReportContentGenerator.class.getName() ), [EOL] eq( handler.getClass().getName() ), [EOL] eq( MessageTypes.INSTANCE_START ), [EOL] eq( instanceId ), [EOL] eq( "" ), [EOL] eq( (float) 0 ), [EOL] eq( contentGenerator ) [EOL] ); [EOL] [EOL] verify( audit, times( 1 ) ).audit( [EOL] eq( sessionId ), [EOL] eq( sessionName ), [EOL] eq( path ), [EOL] eq( ReportContentGenerator.class.getName() ), [EOL] eq( handler.getClass().getName() ), [EOL] eq( MessageTypes.INSTANCE_END ), [EOL] eq( instanceId ), [EOL] eq( "" ), [EOL] anyFloat(), [EOL] eq( contentGenerator ) [EOL] ); [EOL] } [EOL]
@Test [EOL] void get11Test() { [EOL] assertEquals(11, (int) instance.get11()); [EOL] } [EOL]
@Test(expected=IllegalStateException.class) [EOL] public void testEvaluateGoLiveArgs_ZkHostButNoCollection() { [EOL] opts.zkHost = "myzkhost"; [EOL] opts.collection = null; [EOL] [EOL] opts.evaluateGoLiveArgs(); [EOL] } [EOL]
@Test [EOL] public void testGetSchema() { [EOL] Optional<Schema> optional = admin.getSchema("bogus"); [EOL] assertFalse(optional.isPresent()); [EOL] optional = admin.getSchema(GRANDFATHER_SCHEMA_NAME); [EOL] assertTrue(optional.isPresent()); [EOL] Schema schema = optional.get(); [EOL] Schema expected = schemaManager.getSchema(Grandfather.class); [EOL] assertReflectionEquals(expected, schema, LENIENT_ORDER); [EOL] } [EOL]
@Test [EOL] public void testDefault() { [EOL] span = (MockSpan) (helperWithoutProvider.buildSpan("get")); [EOL] assertEquals("get", span.operationName()); [EOL] } [EOL]
@Test [EOL] public void testEviction() throws Exception { [EOL] HashMap<String, Object> data = new HashMap<>(); [EOL] data.put("first", 1); [EOL] Event event = new Event("collected", data); [EOL] alertingService.store(event); [EOL] [EOL] data = new HashMap<>(); [EOL] data.put("second", 2); [EOL] data.put("alertRule", "test"); [EOL] event = new Event("collected", data); [EOL] alertingService.store(event); [EOL] [EOL] Assert.assertEquals(2, alertingService.list().size()); [EOL] [EOL] alertingService.eviction(); [EOL] [EOL] Assert.assertEquals(1, alertingService.list().size()); [EOL] } [EOL]
@Test [EOL] public void testFormatBadLogData() { [EOL] Throwable cause = new Throwable("Original Cause"); [EOL] LogData data = [EOL] FakeLogData.withPrintfStyle("Hello World").addMetadata(LogContext.Key.LOG_CAUSE, cause); [EOL] [EOL] SimpleLogHandler handler = getSimpleLogHandler(); [EOL] RuntimeException error = new RuntimeException("Runtime Error"); [EOL] LogDataFormatter.formatBadLogData(error, data, handler); [EOL] [EOL] String message = handler.toString(); [EOL] assertThat(message).contains("message: Hello World"); [EOL] assertThat(message).contains("level: INFO"); [EOL] assertThat(message).contains("Original Cause"); [EOL] } [EOL]
@Test [EOL] public void whenNextActivationIsSetToNullBeforeContext() { [EOL] listener.beforeProcessing(context); [EOL] assertEquals(1, metricRegistry.getHistograms().get("foobarName.0.myWorkflow.my-state.retries").getCount()); [EOL] assertNotNull(metricRegistry.getTimers().get("foobarName.0.myWorkflow.my-state.execution-time")); [EOL] assertNull(metricRegistry.getHistograms().get("foobarName.0.startup-delay")); [EOL] } [EOL]
@Test [EOL] 	public void testUnmarshallFromXml() throws JAXBException { [EOL] 		// Act [EOL] 		ruleExecutionContainer = marshaller.unmarshalFromXml( [EOL] 				RuleExecutionContainer.class, ruleExecutionContainerString); [EOL] 		final String[] results = new String[2]; [EOL] 		int i = 0; [EOL] 		for (final RuleExecutionResponse r : ruleExecutionContainer [EOL] 				.getExecutionResponseList()) { [EOL] 			final String s = ruleExecutionResponseToString(r); [EOL] 			results[i] = s; [EOL] 			logger.debug(s); [EOL] 			i++; [EOL] 		} [EOL] [EOL] 		// Assert [EOL] 		assertNotNull(ruleExecutionContainer); [EOL] 		assertEquals(2, ruleExecutionContainer.getExecutionResponseList() [EOL] 				.size()); [EOL] 		assertEquals(EXPECTED_RESPONSE_1, results[0]); [EOL] 		assertEquals(EXPECTED_RESPONSE_2, results[1]); [EOL] 	} [EOL]
@Test [EOL] public void testIsRelevantKV_WithWildcards() { [EOL] FieldDefinition fieldDef = new FieldDefinition("fieldA", "cf:quali*", ValueSource.QUALIFIER, "int"); [EOL] MorphlineResultToSolrMapper resultMapper = createMorphlineMapper(fieldDef); [EOL] [EOL] KeyValue relevantKV = new KeyValue(Bytes.toBytes("row"), Bytes.toBytes("cf"), Bytes.toBytes("qualifier"), [EOL] Bytes.toBytes("value")); [EOL] KeyValue notRelevantKV_WrongFamily = new KeyValue(Bytes.toBytes("row"), Bytes.toBytes("wrongcf"), [EOL] Bytes.toBytes("qualifier"), Bytes.toBytes("value")); [EOL] KeyValue notRelevantKV_WrongQualifier = new KeyValue(Bytes.toBytes("row"), Bytes.toBytes("cf"), [EOL] Bytes.toBytes("qu wrong qualifier"), Bytes.toBytes("value")); [EOL] [EOL] assertTrue(resultMapper.isRelevantKV(relevantKV)); [EOL] assertFalse(resultMapper.isRelevantKV(notRelevantKV_WrongFamily)); [EOL] assertFalse(resultMapper.isRelevantKV(notRelevantKV_WrongQualifier)); [EOL] } [EOL]
@Test [EOL] void validateEnvironmentProvidedMissingCassandra() { [EOL] Bundle environmentBundle = new Bundle(); [EOL] environmentBundle.getCassandraConnections().put("cassandra1", new CassandraConnection()); [EOL] BundleEnvironmentValidator bundleEnvironmentValidator = new BundleEnvironmentValidator(environmentBundle); [EOL] Executable validateBundle = () -> bundleEnvironmentValidator.validateEnvironmentProvided("myBundle", "" + [EOL] "<l7:Bundle xmlns:l7=\"http://ns.l7tech.com/2010/04/gateway-management\">\n" + [EOL] " <l7:References>" + [EOL] " </l7:References>\n" + [EOL] " <l7:Mappings>" + [EOL] " <l7:Mapping action=\"NewOrExisting\" srcId=\"89dbda0631bd25a08c73c96aebec7f5a\" type=\"CASSANDRA_CONFIGURATION\">\n" + [EOL] " <l7:Properties>\n" + [EOL] " <l7:Property key=\"MapBy\">\n" + [EOL] " <l7:StringValue>name</l7:StringValue>\n" + [EOL] " </l7:Property>\n" + [EOL] " <l7:Property key=\"MapTo\">\n" + [EOL] " <l7:StringValue>cassandra</l7:StringValue>\n" + [EOL] " </l7:Property>\n" + [EOL] " <l7:Property key=\"FailOnNew\">\n" + [EOL] " <l7:BooleanValue>true</l7:BooleanValue>\n" + [EOL] " </l7:Property>\n" + [EOL] " </l7:Properties>\n" + [EOL] " </l7:Mapping>" + [EOL] " </l7:Mappings>\n" + [EOL] "</l7:Bundle>", APPLICATION); [EOL] [EOL] MissingEnvironmentException exception = assertThrows(MissingEnvironmentException.class, validateBundle); [EOL] assertTrue(exception.getMessage().contains("cassandra")); [EOL] } [EOL]
@Test [EOL] public void testValidation() { [EOL] NoteModel model = viewModel.initAndResume(TestData.ID_A); [EOL] [EOL] model.getTitle().set(""); [EOL] model.getText().set(""); [EOL] [EOL] viewModel.save(); [EOL] [EOL] assertThat(model.getTitleError().get()).isEqualTo(R.string.mandatory_field); [EOL] assertThat(model.getTextError().get()).isEqualTo(R.string.mandatory_field); [EOL] [EOL] verify(noteSaver, never()).save(anyString(), any(Note.class)); [EOL] verify(messageManager, never()).showMessage(any(ActivityHolder.class), anyInt()); [EOL] } [EOL]
@Test [EOL] public void testCompareTable_columnSelectionWithNonUniqueColunsOutsideMatch() throws Throwable { [EOL] seleniumNavigationService.navigate_to_url(MockReferenceDatePopulator.COMPLEX_TABLE_TEST_PAGE_URL); [EOL] WebElement table = seleniumElementService.translateLocatorToWebElement("Table locator"); [EOL] [EOL] List<List<String>> expectedRows = new ArrayList<List<String>>(); [EOL] final List<String> header = Arrays.asList(new String[]{"Table header 1", "Table header 5"}); [EOL] final List<String> row1 = Arrays.asList(new String[]{"Table cell 1_1", "Table cell 1_5"}); [EOL] final List<String> row2 = Arrays.asList(new String[]{"<rowspan>", "<colspan>"}); [EOL] final List<String> row3 = Arrays.asList(new String[]{"Table cell 3_1", "Table cell 3_5"}); [EOL] final List<String> row4 = Arrays.asList(new String[]{"Table cell 4_1", "Table cell 4_5"}); [EOL] [EOL] expectedRows = new ArrayList<List<String>>() { [EOL] { [EOL] add(header); [EOL] add(row1); [EOL] add(row2); [EOL] add(row3); [EOL] add(row4); [EOL] } [EOL] }; [EOL] [EOL] DataTable expectedContent = mock(DataTable.class); [EOL] when(expectedContent.raw()).thenReturn(expectedRows); [EOL] [EOL] ExpectedTableDefinition expectedTableDefinition = new ExpectedTableDefinition(expectedContent); [EOL] expectedTableDefinition.setMatchOnlyPassedInColumns(true); [EOL] [EOL] seleniumTableService.compareTable(expectedTableDefinition, table); [EOL] } [EOL]
@Test(timeout=60000) [EOL] public void testDisableVolumeScanner() throws Exception { [EOL] Configuration conf = new Configuration(); [EOL] disableBlockScanner(conf); [EOL] TestContext ctx = new TestContext(conf, 1); [EOL] try { [EOL] Assert.assertFalse(ctx.datanode.getBlockScanner().isEnabled()); [EOL] } finally { [EOL] ctx.close(); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testMissingURL() throws Exception { [EOL] 		whenGetEntryThenReturn(_blogsEntry); [EOL] [EOL] 		addTrackback(); [EOL] [EOL] 		assertError("Trackback requires a valid permanent URL"); [EOL] 	} [EOL]
@Test [EOL] public void testBasic() throws Exception [EOL] { [EOL] RecordingListener recordingListener = new RecordingListener(); [EOL] TestRetryPolicy retryPolicy = new TestRetryPolicy(); [EOL] CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service); [EOL] [EOL] listener.stateChanged(dummyClient, ConnectionState.RECONNECTED); [EOL] Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED); [EOL] [EOL] listener.stateChanged(dummyClient, ConnectionState.SUSPENDED); [EOL] Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED); [EOL] listener.stateChanged(dummyClient, ConnectionState.SUSPENDED); // 2nd suspended is ignored [EOL] Assert.assertTrue(recordingListener.stateChanges.isEmpty()); [EOL] listener.stateChanged(dummyClient, ConnectionState.LOST); [EOL] Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST); [EOL] [EOL] synchronized(listener) // don't let retry policy run while we're pushing state changes [EOL] { [EOL] listener.stateChanged(dummyClient, ConnectionState.READ_ONLY); // all further events are ignored [EOL] listener.stateChanged(dummyClient, ConnectionState.RECONNECTED); // all further events are ignored [EOL] listener.stateChanged(dummyClient, ConnectionState.SUSPENDED); // all further events are ignored [EOL] listener.stateChanged(dummyClient, ConnectionState.LOST); // all further events are ignored [EOL] listener.stateChanged(dummyClient, ConnectionState.SUSPENDED); // all further events are ignored - this will be the last event [EOL] } [EOL] retryTiming.multiple(2).sleep(); [EOL] Assert.assertTrue(recordingListener.stateChanges.isEmpty()); [EOL] [EOL] retryPolicy.isRetrying = false; // retry policy will return false [EOL] Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED); [EOL] } [EOL]
@Test [EOL] public void testCacheMiss() { [EOL] String value = cachingWrapper.translate("testKey"); [EOL] assertEquals("testValue", value); [EOL] verify(mockTranslator, times(1)).translate("testKey"); [EOL] } [EOL]
@Test [EOL] public void testCedeActive() throws Exception { [EOL] cluster.start(); [EOL] DummyZKFC zkfc = cluster.getZkfc(0); [EOL] // It should be in active to start. [EOL] assertEquals(ActiveStandbyElector.State.ACTIVE, [EOL] zkfc.getElectorForTests().getStateForTests()); [EOL] [EOL] // Ask it to cede active for 3 seconds. It should respond promptly [EOL] // (i.e. the RPC itself should not take 3 seconds!) [EOL] ZKFCProtocol proxy = zkfc.getLocalTarget().getZKFCProxy(conf, 5000); [EOL] long st = Time.now(); [EOL] proxy.cedeActive(3000); [EOL] long et = Time.now(); [EOL] assertTrue("RPC to cedeActive took " + (et - st) + " ms", [EOL] et - st < 1000); [EOL] [EOL] // Should be in "INIT" state since it's not in the election [EOL] // at this point. [EOL] assertEquals(ActiveStandbyElector.State.INIT, [EOL] zkfc.getElectorForTests().getStateForTests()); [EOL] [EOL] // After the prescribed 3 seconds, should go into STANDBY state, [EOL] // since the other node in the cluster would have taken ACTIVE. [EOL] cluster.waitForElectorState(0, ActiveStandbyElector.State.STANDBY); [EOL] long et2 = Time.now(); [EOL] assertTrue("Should take ~3 seconds to rejoin. Only took " + (et2 - et) + [EOL] "ms before rejoining.", [EOL] et2 - et > 2800); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] 	public void testHandError_Throws_Exception_Given_Null_Message() throws Throwable { [EOL] 		sut.handleError(null); [EOL] 	} [EOL]
@Test [EOL] public void testReplaceAclEntriesDefaultMaskPreserved() throws AclException { [EOL] List<AclEntry> existing = new ImmutableList.Builder<AclEntry>() [EOL] .add(aclEntry(ACCESS, USER, ALL)) [EOL] .add(aclEntry(ACCESS, USER, "bruce", READ)) [EOL] .add(aclEntry(ACCESS, USER, "diana", READ_WRITE)) [EOL] .add(aclEntry(ACCESS, GROUP, READ)) [EOL] .add(aclEntry(ACCESS, MASK, READ_WRITE)) [EOL] .add(aclEntry(ACCESS, OTHER, READ)) [EOL] .add(aclEntry(DEFAULT, USER, ALL)) [EOL] .add(aclEntry(DEFAULT, USER, "diana", ALL)) [EOL] .add(aclEntry(DEFAULT, GROUP, READ)) [EOL] .add(aclEntry(DEFAULT, MASK, READ)) [EOL] .add(aclEntry(DEFAULT, OTHER, NONE)) [EOL] .build(); [EOL] List<AclEntry> aclSpec = Lists.newArrayList( [EOL] aclEntry(ACCESS, USER, ALL), [EOL] aclEntry(ACCESS, USER, "bruce", READ), [EOL] aclEntry(ACCESS, USER, "diana", READ_WRITE), [EOL] aclEntry(ACCESS, GROUP, ALL), [EOL] aclEntry(ACCESS, OTHER, READ)); [EOL] List<AclEntry> expected = new ImmutableList.Builder<AclEntry>() [EOL] .add(aclEntry(ACCESS, USER, ALL)) [EOL] .add(aclEntry(ACCESS, USER, "bruce", READ)) [EOL] .add(aclEntry(ACCESS, USER, "diana", READ_WRITE)) [EOL] .add(aclEntry(ACCESS, GROUP, ALL)) [EOL] .add(aclEntry(ACCESS, MASK, ALL)) [EOL] .add(aclEntry(ACCESS, OTHER, READ)) [EOL] .add(aclEntry(DEFAULT, USER, ALL)) [EOL] .add(aclEntry(DEFAULT, USER, "diana", ALL)) [EOL] .add(aclEntry(DEFAULT, GROUP, READ)) [EOL] .add(aclEntry(DEFAULT, MASK, READ)) [EOL] .add(aclEntry(DEFAULT, OTHER, NONE)) [EOL] .build(); [EOL] assertEquals(expected, replaceAclEntries(existing, aclSpec)); [EOL] } [EOL]
@Test [EOL] public void testDependentMapMultipleParents() throws Exception { [EOL] List<Table> list = new ArrayList<Table>(4); [EOL] Table t1 = new Table("1"); [EOL] Table t2 = new Table("2"); [EOL] Table t3 = new Table("3"); [EOL] Table t4 = new Table("4"); [EOL] Table t5 = new Table("5"); [EOL] [EOL] t2.addForeignKey(new ForeignKey("1","1")); [EOL] t3.addForeignKey(new ForeignKey("1","1")); [EOL] [EOL] t3.addForeignKey(new ForeignKey("4","4")); [EOL] t5.addForeignKey(new ForeignKey("4","4")); [EOL] [EOL] list.add(t1); [EOL] list.add(t2); [EOL] list.add(t3); [EOL] list.add(t4); [EOL] list.add(t5); [EOL] [EOL] Map<Integer, Set<Table>> dependencyMap = new HashMap<Integer, Set<Table>>(); [EOL] [EOL] list = Database.sortByForeignKeys(list, null, dependencyMap, null); [EOL] [EOL] assertTrue(dependencyMap.get(1).contains(t1)); [EOL] assertTrue(dependencyMap.get(1).contains(t2)); [EOL] assertTrue(dependencyMap.get(1).contains(t3)); [EOL] assertTrue(dependencyMap.get(1).contains(t4)); [EOL] assertTrue(dependencyMap.get(1).contains(t5)); [EOL] } [EOL]
@Test(expected = InvalidCredentialsException.class) [EOL] public void testValidateWithCredentialsOfWrongType() throws Exception { [EOL] setup("subject.1.name = subject"); [EOL] accessController.validate(new Credentials() {}); [EOL] } [EOL]
@Test [EOL] public void testGetEmojis_badEmojiList() throws Exception { [EOL] WebResource emojiResource = mock(WebResource.class); [EOL] when(mockResource.path("emoji.list")).thenReturn(emojiResource); [EOL] String emojiResponseStr = "{\"emoji\": \"BAD JSON\"}"; [EOL] doReturn(emojiResponseStr).when(underTest).getJsonResultWithRetries(emojiResource, [EOL] apiRetries); [EOL] [EOL] Map<String, String> result = underTest.getEmojis(); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL]
@Test [EOL] public void testFinalizeProperties__collection_subResource_noProperties() { [EOL] SchemaFactory schemaFactory = createNiceMock(SchemaFactory.class); [EOL] Schema serviceSchema = createNiceMock(Schema.class); [EOL] Schema componentSchema = createNiceMock(Schema.class); [EOL] [EOL] // schema expectations [EOL] expect(schemaFactory.getSchema(Resource.Type.Service)).andReturn(serviceSchema).anyTimes(); [EOL] expect(serviceSchema.getKeyPropertyId(Resource.Type.Service)).andReturn("ServiceInfo/service_name").anyTimes(); [EOL] expect(serviceSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn("ServiceInfo/cluster_name").anyTimes(); [EOL] expect(schemaFactory.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes(); [EOL] expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn("ServiceComponentInfo/service_name").anyTimes(); [EOL] expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn("ServiceComponentInfo/component_name").anyTimes(); [EOL] [EOL] replay(schemaFactory, serviceSchema, componentSchema); [EOL] [EOL] HashSet<String> serviceProperties = new HashSet<String>(); [EOL] QueryInfo rootQuery = new QueryInfo(new ServiceResourceDefinition(), serviceProperties); [EOL] TreeNode<QueryInfo> queryTree = new TreeNodeImpl<QueryInfo>(null, rootQuery, "Service"); [EOL] queryTree.addChild(new QueryInfo(new ComponentResourceDefinition(), new HashSet<String>()), "Component"); [EOL] [EOL] DefaultRenderer renderer = new DefaultRenderer(); [EOL] renderer.init(schemaFactory); [EOL] TreeNode<Set<String>> propertyTree = renderer.finalizeProperties(queryTree, true); [EOL] [EOL] assertEquals(1, propertyTree.getChildren().size()); [EOL] assertEquals(2, propertyTree.getObject().size()); [EOL] assertTrue(propertyTree.getObject().contains("ServiceInfo/service_name")); [EOL] assertTrue(propertyTree.getObject().contains("ServiceInfo/cluster_name")); [EOL] [EOL] [EOL] TreeNode<Set<String>> componentNode = propertyTree.getChild("Component"); [EOL] assertEquals(0, componentNode.getChildren().size()); [EOL] assertEquals(2, componentNode.getObject().size()); [EOL] assertTrue(componentNode.getObject().contains("ServiceComponentInfo/service_name")); [EOL] assertTrue(componentNode.getObject().contains("ServiceComponentInfo/component_name")); [EOL] [EOL] verify(schemaFactory, serviceSchema, componentSchema); [EOL] } [EOL]
@Test [EOL] public void postOrder_graph_connectedRoots() { [EOL] Walker<String> walker = [EOL] DataType.GRAPH.newWalker( [EOL] ImmutableListMultimap.of("foo", "bar", "bar", "dog", "zoo", "dog", "zoo", "cat")); [EOL] assertThat(walker.postOrderFrom("foo", "zoo")) [EOL] .containsExactly("cat", "zoo", "dog", "bar", "foo") [EOL] .inOrder(); [EOL] } [EOL]
@Test // Not what the user would want, but no good way to avoid it [EOL] 	public void splitString_multi_caps() { [EOL] 		assertEquals(Arrays.asList("this","is","astring"), StringUtils.splitString("thisIsAString")); [EOL] 	} [EOL]
@Test [EOL] public void testLoadConfigConnections() { [EOL] StringReader configReader = new StringReader( [EOL] "processor:\n" + [EOL] " processor_id: 2\n" + [EOL] " connections:\n" + [EOL] " - target_processor: 1\n" + [EOL] " dest_port: 0\n" + [EOL] " channel: channel0\n" + [EOL] " - target_processor: 0\n" + [EOL] " dest_port: 4\n" + [EOL] " channel: channel1\n"); [EOL] [EOL] AssemblerConfig config = Assembler.loadConfig(configReader); [EOL] [EOL] assertThat(config.getProcessor().getIopins(), is(equalTo(Collections.emptyList()))); [EOL] assertThat(config.getProcessor().getProcessor_id(), is(equalTo(2))); [EOL] assertThat(config.getProcessor().getConnections().get(0).getTarget_processor(), is(equalTo(1))); [EOL] assertThat(config.getProcessor().getConnections().get(0).getDest_port(), is(equalTo(0))); [EOL] assertThat(config.getProcessor().getConnections().get(0).getChannel(), is(equalTo("channel0"))); [EOL] assertThat(config.getProcessor().getConnections().get(1).getTarget_processor(), is(equalTo(0))); [EOL] assertThat(config.getProcessor().getConnections().get(1).getDest_port(), is(equalTo(4))); [EOL] assertThat(config.getProcessor().getConnections().get(1).getChannel(), is(equalTo("channel1"))); [EOL] } [EOL]
@Test [EOL] public void getRoad_RoadDoesNotExist() throws Exception { [EOL] doThrow(new UnknownRoadException("road1")).when(paverService).getRoad(NAME); [EOL] [EOL] mockMvc [EOL] .perform(get(CONTEXT_PATH + "/roads/road1")) [EOL] .andExpect(status().isNotFound()) [EOL] .andExpect(content().contentType(APPLICATION_JSON_UTF8)) [EOL] .andExpect(jsonPath("$.message", is("Road \"road1\" does not exist."))); [EOL] } [EOL]
@Test [EOL] public void testPermittedTopology_point_linestring() { [EOL] [EOL] DimensionInfo sourceDimensionInfo = DimensionInfo.XY_POINT; [EOL] DimensionInfo targetDimensionInfo = DimensionInfo.XY_LINESTRING; [EOL] RccExternallyConnectedFF instance = new RccExternallyConnectedFF(); [EOL] boolean expResult = false; [EOL] boolean result = instance.permittedTopology(sourceDimensionInfo, targetDimensionInfo); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test [EOL] public void testGetRecordPortalUrl() { [EOL] String baseUrl = null; [EOL] [EOL] Api2UrlService s1 = new Api2UrlService(baseUrl, null, null, null); [EOL] assertEquals("https://www.europeana.eu/item/1/2", s1.getRecordPortalUrl("/1/2")); [EOL] [EOL] baseUrl = "pro.europeana.eu"; [EOL] Api2UrlService s2 = new Api2UrlService(baseUrl, null, null, null); [EOL] // In this case https:// is added by UrlBuilder class! [EOL] assertEquals("https://pro.europeana.eu/item/x/y", s2.getRecordPortalUrl("/x/y")); [EOL] [EOL] baseUrl = "http://localhost:8080"; [EOL] Api2UrlService s3 = new Api2UrlService(baseUrl, null, null, null); [EOL] assertEquals("http://localhost:8080/item/x/y", s3.getRecordPortalUrl("/x/y")); [EOL] } [EOL]
@Test [EOL] 	public final void testDecodeEmptyString() { [EOL] 		final byte[] expecteds = new byte[0]; [EOL] 		final byte[] actuals = Hex.decode(""); [EOL] 		Assert.assertArrayEquals(expecteds, actuals); [EOL] 	} [EOL]
@Test [EOL] public void test_路径短化_永假_多路() { [EOL] TableNode table = new TableNode("TABLE1"); [EOL] table.query("(ID = 1 AND NAME = 'HELLO') OR (0) "); [EOL] table.build(); [EOL] FilterPreProcessor.optimize(table, true, null); [EOL] Assert.assertEquals(table.getWhereFilter().toString(), "(TABLE1.ID = 1 AND TABLE1.NAME = HELLO)"); [EOL] } [EOL]
@Test [EOL] public void testUnmappedUnicodeStats() throws Exception { [EOL] List<Metadata> metadataList = getRecursiveMetadata("testPDF_bad_page_303226.pdf", true); [EOL] Metadata m = metadataList.get(0); [EOL] int[] totalChars = m.getIntValues(PDF.CHARACTERS_PER_PAGE); [EOL] int[] unmappedUnicodeChars = m.getIntValues(PDF.UNMAPPED_UNICODE_CHARS_PER_PAGE); [EOL] //weird issue with pdfbox 2.0.20 [EOL] //this test passes in my IDE, but does not pass with mvn clean install from commandline [EOL] if (totalChars[15] > 0) { [EOL] assertEquals(3805, totalChars[15]); [EOL] assertEquals(120, unmappedUnicodeChars[15]); [EOL] } [EOL] //confirm all works with angles [EOL] PDFParserConfig pdfParserConfig = new PDFParserConfig(); [EOL] pdfParserConfig.setDetectAngles(true); [EOL] ParseContext parseContext = new ParseContext(); [EOL] parseContext.set(PDFParserConfig.class, pdfParserConfig); [EOL] metadataList = getRecursiveMetadata("testPDF_bad_page_303226.pdf", parseContext,true); [EOL] m = metadataList.get(0); [EOL] totalChars = m.getIntValues(PDF.CHARACTERS_PER_PAGE); [EOL] unmappedUnicodeChars = m.getIntValues(PDF.UNMAPPED_UNICODE_CHARS_PER_PAGE); [EOL] if (totalChars[15] > 0) { [EOL] assertEquals(3805, totalChars[15]); [EOL] assertEquals(120, unmappedUnicodeChars[15]); [EOL] } [EOL] [EOL] } [EOL]
@Test [EOL] public void testEquals() { [EOL] final AmazonS3Object object2 = [EOL] new AmazonS3Object( [EOL] "us-east-1", "bucket-name", "object-key", 100, "object eTag", "object version"); [EOL] assertThat(object).isEqualTo(object2); [EOL] } [EOL]
@Test [EOL] public void testgetAsBool_True() { [EOL] assertTrue(new JBBPFieldUShort(new JBBPNamedFieldInfo("test.field", "field", 123), (short) 32423).getAsBool()); [EOL] } [EOL]
@Test [EOL] public void testSnapshot() { [EOL] ProtobufSerializer<SimpleMessage> serializer = [EOL] ProtobufSerializer.forMessageGeneratedClass(SimpleMessage.class); [EOL] ProtobufSerializerSnapshot snapshot = serializer.snapshot(); [EOL] [EOL] assertThat(snapshot.getGeneratedJavaName(), is(SimpleMessage.class.getName())); [EOL] assertThat(snapshot.getMessageName(), is(SimpleMessage.getDescriptor().getFullName())); [EOL] assertThat(snapshot.getDescriptorSet(), notNullValue()); [EOL] } [EOL]
@Test [EOL] public void testValidInputParsedOutputPortNotConnected() throws JSONException [EOL] { [EOL] parser.parsedOutput.setSink(null); [EOL] String tuple = "{" + "\"id\": 2," + "\"name\": \"An ice sculpture\"," + "\"price\": 1," [EOL] + "\"tags\": [\"cold\", \"ice\"]," + "\"dimensions\": {" + "\"length\": 7.0," + "\"width\" : 8.0," [EOL] + "\"height\": 9.5" + "}," + "\"warehouseLocation\": {" + "\"latitude\": -78.75," + "\"longitude\": 20.4" [EOL] + "}," + "\"dateOfManufacture\": \"2013/09/29\"," + "\"dateOfExpiry\": \"2013\"" + "}"; [EOL] parser.beginWindow(0); [EOL] parser.in.process(tuple.getBytes()); [EOL] parser.endWindow(); [EOL] Assert.assertEquals(0, objectPort.collectedTuples.size()); [EOL] Assert.assertEquals(1, pojoPort.collectedTuples.size()); [EOL] Assert.assertEquals(0, error.collectedTuples.size()); [EOL] Object obj = pojoPort.collectedTuples.get(0); [EOL] Assert.assertNotNull(obj); [EOL] Assert.assertEquals(Product.class, obj.getClass()); [EOL] Product pojo = (Product)obj; [EOL] Assert.assertEquals(2, pojo.getId()); [EOL] Assert.assertEquals(1, pojo.getPrice()); [EOL] Assert.assertEquals("An ice sculpture", pojo.getName()); [EOL] Assert.assertEquals(7.0, (double)pojo.getDimensions().get("length"), 0); [EOL] } [EOL]
@Test [EOL] public void cacheMiss() throws Exception { [EOL] mDispatcher.processRequest(mRequest); [EOL] verifyNoResponse(mDelivery); [EOL] verify(mNetworkQueue).put(mRequest); [EOL] assertNull(mRequest.getCacheEntry()); [EOL] } [EOL]
@Test [EOL] 	public void testVisitBinaryExpressionOperationWithLowerOperationAndNullValue() { [EOL] 		Map<String, EntityField> entityFieldsMap = [EOL] 			_entityModel.getEntityFieldsMap(); [EOL] [EOL] 		AbstractThrowableAssert exception = Assertions.assertThatThrownBy( [EOL] 			() -> _expressionVisitorImpl.visitBinaryExpressionOperation( [EOL] 				BinaryExpression.Operation.LT, entityFieldsMap.get("title"), [EOL] 				null) [EOL] 		).isInstanceOf( [EOL] 			UnsupportedOperationException.class [EOL] 		); [EOL] [EOL] 		exception.hasMessage( [EOL] 			"Unsupported method _getLTFilter with null values"); [EOL] 	} [EOL]
@Test [EOL] public void testGetAppsInQueue() throws Exception { [EOL] scheduler.init(conf); [EOL] scheduler.start(); [EOL] scheduler.reinitialize(conf, resourceManager.getRMContext()); [EOL] [EOL] ApplicationAttemptId appAttId1 = [EOL] createSchedulingRequest(1024, 1, "queue1.subqueue1", "user1"); [EOL] ApplicationAttemptId appAttId2 = [EOL] createSchedulingRequest(1024, 1, "queue1.subqueue2", "user1"); [EOL] ApplicationAttemptId appAttId3 = [EOL] createSchedulingRequest(1024, 1, "user1", "user1"); [EOL] [EOL] List<ApplicationAttemptId> apps = [EOL] scheduler.getAppsInQueue("queue1.subqueue1"); [EOL] assertEquals(1, apps.size()); [EOL] assertEquals(appAttId1, apps.get(0)); [EOL] // with and without root prefix should work [EOL] apps = scheduler.getAppsInQueue("root.queue1.subqueue1"); [EOL] assertEquals(1, apps.size()); [EOL] assertEquals(appAttId1, apps.get(0)); [EOL] [EOL] apps = scheduler.getAppsInQueue("user1"); [EOL] assertEquals(1, apps.size()); [EOL] assertEquals(appAttId3, apps.get(0)); [EOL] // with and without root prefix should work [EOL] apps = scheduler.getAppsInQueue("root.user1"); [EOL] assertEquals(1, apps.size()); [EOL] assertEquals(appAttId3, apps.get(0)); [EOL] [EOL] // apps in subqueues should be included [EOL] apps = scheduler.getAppsInQueue("queue1"); [EOL] Assert.assertEquals(2, apps.size()); [EOL] Set<ApplicationAttemptId> appAttIds = Sets.newHashSet(apps.get(0), apps.get(1)); [EOL] assertTrue(appAttIds.contains(appAttId1)); [EOL] assertTrue(appAttIds.contains(appAttId2)); [EOL] } [EOL]
@Test(expected = NullPointerException.class) [EOL] public void testExecNull() throws MasterExecException { [EOL] CommandManager cmdman = new CommandManager(); [EOL] cmdman.exec(null); [EOL] } [EOL]
@Test [EOL] public void testRefreshGroupMembers() throws Exception { [EOL] [EOL] User user1 = createNiceMock(User.class); [EOL] User user2 = createNiceMock(User.class); [EOL] User user3 = createNiceMock(User.class); [EOL] User user4 = createNiceMock(User.class); [EOL] expect(user1.getUserName()).andReturn("user1").anyTimes(); [EOL] expect(user2.getUserName()).andReturn("user2").anyTimes(); [EOL] expect(user3.getUserName()).andReturn("user3").anyTimes(); [EOL] expect(user4.getUserName()).andReturn("user4").anyTimes(); [EOL] expect(user1.isLdapUser()).andReturn(false).anyTimes(); [EOL] expect(user2.isLdapUser()).andReturn(true).anyTimes(); [EOL] expect(user3.isLdapUser()).andReturn(true).anyTimes(); [EOL] expect(user4.isLdapUser()).andReturn(false).anyTimes(); [EOL] [EOL] Group group1 = createNiceMock(Group.class); [EOL] Group group2 = createNiceMock(Group.class); [EOL] expect(group1.isLdapGroup()).andReturn(true).anyTimes(); [EOL] expect(group2.isLdapGroup()).andReturn(true).anyTimes(); [EOL] expect(group1.getGroupName()).andReturn("group1").anyTimes(); [EOL] expect(group2.getGroupName()).andReturn("group2").anyTimes(); [EOL] Configuration configuration = createNiceMock(Configuration.class); [EOL] Users users = createNiceMock(Users.class); [EOL] LdapTemplate ldapTemplate = createNiceMock(LdapTemplate.class); [EOL] LdapServerProperties ldapServerProperties = createNiceMock(LdapServerProperties.class); [EOL] expect(ldapServerProperties.getGroupNamingAttr()).andReturn("cn").anyTimes(); [EOL] expect(ldapServerProperties.getUsernameAttribute()).andReturn("uid").anyTimes(); [EOL] replay(ldapTemplate, ldapServerProperties, users, configuration); [EOL] replay(user1, user2, user3, user4); [EOL] replay(group1, group2); [EOL] [EOL] AmbariLdapDataPopulatorTestInstance populator = createMockBuilder(AmbariLdapDataPopulatorTestInstance.class) [EOL] .addMockedMethod("getLdapUserByMemberAttr") [EOL] .addMockedMethod("getLdapGroupByMemberAttr") [EOL] .addMockedMethod("getInternalMembers") [EOL] .withConstructor(configuration, users) [EOL] .createNiceMock(); [EOL] [EOL] LdapGroupDto externalGroup = createNiceMock(LdapGroupDto.class); [EOL] expect(externalGroup.getGroupName()).andReturn("group1").anyTimes(); [EOL] expect(externalGroup.getMemberAttributes()).andReturn(createSet("user1", "user2", "user4", "user6")).anyTimes(); [EOL] replay(externalGroup); [EOL] [EOL] Map<String, User> internalMembers = new HashMap<String, User>(); [EOL] internalMembers.put("user1", user1); [EOL] internalMembers.put("user3", user3); [EOL] internalMembers.put("user4", user4); [EOL] [EOL] LdapBatchDto batchInfo = new LdapBatchDto(); [EOL] LdapUserDto externalUser1 = createNiceMock(LdapUserDto.class); [EOL] LdapUserDto externalUser2 = createNiceMock(LdapUserDto.class); [EOL] LdapUserDto externalUser3 = createNiceMock(LdapUserDto.class); [EOL] LdapUserDto externalUser4 = createNiceMock(LdapUserDto.class); [EOL] expect(externalUser1.getUserName()).andReturn("user1").anyTimes(); [EOL] expect(externalUser2.getUserName()).andReturn("user2").anyTimes(); [EOL] expect(externalUser3.getUserName()).andReturn("user4").anyTimes(); [EOL] expect(externalUser4.getUserName()).andReturn("user6").anyTimes(); [EOL] replay(externalUser1, externalUser2, externalUser3, externalUser4); [EOL] expect(populator.getLdapUserByMemberAttr("user1")).andReturn(externalUser1).anyTimes(); [EOL] expect(populator.getLdapUserByMemberAttr("user2")).andReturn(externalUser2).anyTimes(); [EOL] expect(populator.getLdapUserByMemberAttr("user4")).andReturn(null).anyTimes(); [EOL] expect(populator.getLdapGroupByMemberAttr("user4")).andReturn(externalGroup).anyTimes(); [EOL] expect(populator.getLdapUserByMemberAttr("user6")).andReturn(externalUser4).anyTimes(); [EOL] expect(populator.getInternalMembers("group1")).andReturn(internalMembers).anyTimes(); [EOL] replay(populator); [EOL] [EOL] populator.setLdapTemplate(ldapTemplate); [EOL] populator.setLdapServerProperties(ldapServerProperties); [EOL] [EOL] Map<String, User> internalUsers = new HashMap<String, User>(); [EOL] internalUsers.putAll(internalMembers); [EOL] internalUsers.put("user2", user2); [EOL] Map<String, Group> internalGroups = new HashMap<String, Group>(); [EOL] internalGroups.put("group2", group2); [EOL] [EOL] populator.refreshGroupMembers(batchInfo, externalGroup, internalUsers, internalGroups, null, true); [EOL] [EOL] Set<String> groupMembersToAdd = new HashSet<String>(); [EOL] for (LdapUserGroupMemberDto ldapUserGroupMemberDto : batchInfo.getMembershipToAdd()) { [EOL] groupMembersToAdd.add(ldapUserGroupMemberDto.getUserName()); [EOL] } [EOL] assertEquals(3, groupMembersToAdd.size()); [EOL] assertTrue(groupMembersToAdd.contains("user2")); [EOL] assertTrue(groupMembersToAdd.contains("user6")); [EOL] Set<String> groupMembersToRemove = new HashSet<String>(); [EOL] for (LdapUserGroupMemberDto ldapUserGroupMemberDto : batchInfo.getMembershipToRemove()) { [EOL] groupMembersToRemove.add(ldapUserGroupMemberDto.getUserName()); [EOL] } [EOL] assertEquals(2, groupMembersToRemove.size()); [EOL] assertTrue(groupMembersToRemove.contains("user3")); [EOL] assertEquals(1, batchInfo.getUsersToBeCreated().size()); [EOL] assertTrue(batchInfo.getUsersToBeCreated().contains("user6")); [EOL] assertEquals(1, batchInfo.getUsersToBecomeLdap().size()); [EOL] assertTrue(batchInfo.getUsersToBecomeLdap().contains("user1")); [EOL] assertTrue(!batchInfo.getUsersToBecomeLdap().contains("user4")); [EOL] assertTrue(batchInfo.getGroupsToBecomeLdap().isEmpty()); [EOL] assertEquals(1, batchInfo.getGroupsToBeCreated().size()); [EOL] assertTrue(batchInfo.getGroupsToBeRemoved().isEmpty()); [EOL] assertTrue(batchInfo.getUsersToBeRemoved().isEmpty()); [EOL] verify(populator.loadLdapTemplate(), populator); [EOL] } [EOL]
@Test [EOL] public void testRadix_ErrorForLessThan2() { [EOL] assertThrows(IllegalArgumentException.class, () -> makeWriter().Radix(1)); [EOL] } [EOL]
@Test [EOL] public void testEditSchedule() throws Exception { [EOL] [EOL] try { [EOL] policy.editSchedule(); [EOL] assertEquals(2, policy.getManagedParentQueues().size()); [EOL] [EOL] CSQueue parentQueue = cs.getQueue(PARENT_QUEUE); [EOL] [EOL] GuaranteedOrZeroCapacityOverTimePolicy autoCreatedQueueManagementPolicy = [EOL] (GuaranteedOrZeroCapacityOverTimePolicy) ((ManagedParentQueue) [EOL] parentQueue) [EOL] .getAutoCreatedQueueManagementPolicy(); [EOL] assertEquals(0f, autoCreatedQueueManagementPolicy [EOL] .getAbsoluteActivatedChildQueueCapacity(NO_LABEL), EPSILON); [EOL] [EOL] //submit app1 as USER1 [EOL] ApplicationId user1AppId = submitApp(mockRM, parentQueue, USER1, USER1, 1, [EOL] 1); [EOL] Map<String, Float> expectedAbsChildQueueCapacity = [EOL] populateExpectedAbsCapacityByLabelForParentQueue(1); [EOL] validateInitialQueueEntitlement(parentQueue, USER1, [EOL] expectedAbsChildQueueCapacity, accessibleNodeLabelsOnC); [EOL] [EOL] //submit another app2 as USER2 [EOL] ApplicationId user2AppId = submitApp(mockRM, parentQueue, USER2, USER2, 2, [EOL] 1); [EOL] expectedAbsChildQueueCapacity = [EOL] populateExpectedAbsCapacityByLabelForParentQueue(2); [EOL] validateInitialQueueEntitlement(parentQueue, USER2, [EOL] expectedAbsChildQueueCapacity, accessibleNodeLabelsOnC); [EOL] [EOL] //validate total activated abs capacity [EOL] assertEquals(0.2f, autoCreatedQueueManagementPolicy [EOL] .getAbsoluteActivatedChildQueueCapacity(NO_LABEL), EPSILON); [EOL] [EOL] //submit user_3 app. This cant be scheduled since there is no capacity [EOL] submitApp(mockRM, parentQueue, USER3, USER3, 3, 1); [EOL] final CSQueue user3LeafQueue = cs.getQueue(USER3); [EOL] validateCapacities((AutoCreatedLeafQueue) user3LeafQueue, 0.0f, 0.0f, [EOL] 1.0f, 1.0f); [EOL] [EOL] assertEquals(autoCreatedQueueManagementPolicy [EOL] .getAbsoluteActivatedChildQueueCapacity(NO_LABEL), 0.2f, EPSILON); [EOL] [EOL] //deactivate USER2 queue [EOL] cs.killAllAppsInQueue(USER2); [EOL] mockRM.waitForState(user2AppId, RMAppState.KILLED); [EOL] [EOL] //deactivate USER1 queue [EOL] cs.killAllAppsInQueue(USER1); [EOL] mockRM.waitForState(user1AppId, RMAppState.KILLED); [EOL] [EOL] policy.editSchedule(); [EOL] waitForPolicyState(0.1f, autoCreatedQueueManagementPolicy, NO_LABEL, [EOL] 1000); [EOL] [EOL] validateCapacities((AutoCreatedLeafQueue) user3LeafQueue, 0.5f, 0.1f, [EOL] 1.0f, 1.0f); [EOL] [EOL] validateCapacitiesByLabel((ManagedParentQueue) parentQueue, (AutoCreatedLeafQueue) user3LeafQueue, [EOL] NODEL_LABEL_GPU); [EOL] [EOL] } finally { [EOL] cleanupQueue(USER1); [EOL] cleanupQueue(USER2); [EOL] cleanupQueue(USER3); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testDistributedResourcePool() { [EOL] final LocalResourcePool pool2 = new LocalResourcePool("pool2"); [EOL] final LocalResourcePool pool3 = new LocalResourcePool("pool3"); [EOL] [EOL] DistributedResourcePool pool1 = new DistributedResourcePool("pool1", new ResourcePoolConnector() { [EOL] @Override [EOL] public ResourceSet getAllResources() { [EOL] ResourceSet set = pool2.getAll(); [EOL] set.addAll(pool3.getAll()); [EOL] [EOL] ResourceSet remoteSet = new ResourceSet(); [EOL] Gson gson = new Gson(); [EOL] for (Resource s : set) { [EOL] RemoteResource remoteResource = gson.fromJson(gson.toJson(s), RemoteResource.class); [EOL] remoteResource.setResourcePoolConnector(this); [EOL] remoteSet.add(remoteResource); [EOL] } [EOL] return remoteSet; [EOL] } [EOL] [EOL] @Override [EOL] public Object readResource(ResourceId id) { [EOL] if (id.getResourcePoolId().equals(pool2.id())) { [EOL] return pool2.get(id.getName()).get(); [EOL] } [EOL] if (id.getResourcePoolId().equals(pool3.id())) { [EOL] return pool3.get(id.getName()).get(); [EOL] } [EOL] return null; [EOL] } [EOL] }); [EOL] [EOL] assertEquals(0, pool1.getAll().size()); [EOL] [EOL] [EOL] // test get() can get from pool [EOL] pool2.put("object1", "value2"); [EOL] assertEquals(1, pool1.getAll().size()); [EOL] assertTrue(pool1.get("object1").isRemote()); [EOL] assertEquals("value2", pool1.get("object1").get()); [EOL] [EOL] // test get() is locality aware [EOL] pool1.put("object1", "value1"); [EOL] assertEquals(1, pool2.getAll().size()); [EOL] assertEquals("value1", pool1.get("object1").get()); [EOL] [EOL] // test getAll() is locality aware [EOL] assertEquals("value1", pool1.getAll().get(0).get()); [EOL] assertEquals("value2", pool1.getAll().get(1).get()); [EOL] } [EOL]
@Test [EOL] public void testPig134Dependencies() throws Exception { [EOL] ServiceInfo service = metaInfo.getService(STACK_NAME_HDP, "1.3.4", "PIG"); [EOL] List<ComponentInfo> componentList = service.getComponents(); [EOL] Assert.assertEquals(1, componentList.size()); [EOL] ComponentInfo component = componentList.get(0); [EOL] Assert.assertEquals("PIG", component.getName()); [EOL] // dependencies [EOL] Assert.assertEquals(0, component.getDependencies().size()); [EOL] // component auto deploy [EOL] Assert.assertNull(component.getAutoDeploy()); [EOL] // cardinality [EOL] Assert.assertEquals("0+", component.getCardinality()); [EOL] } [EOL]
@Test [EOL] @Transactional [EOL] public void test_ldapUserDetailsService_groups_and_profiles_jody() throws NamingException { [EOL] [EOL] //make sure its already in the repository, or nothing will happen [EOL] Group group = new Group().setName("GENERAL"); [EOL] group = groupRepository.save(group); [EOL] [EOL] [EOL] UserDetails details = ldapUserDetailsService.loadUserByUsername("jgee@example.com"); [EOL] assertNotNull(details); [EOL] [EOL] LDAPUser user1 = (LDAPUser) details; [EOL] assertEquals(0, user1.getPrivileges().size()); [EOL] [EOL] User user = userRepository.findOneByUsername("jgee@example.com"); [EOL] assertNotNull(user); [EOL] assertEquals("gee", user.getSurname()); [EOL] assertEquals(Profile.RegisteredUser, user.getProfile()); [EOL] [EOL] List<UserGroup> ug = userGroupRepository.findAll(UserGroupSpecs.hasUserId(user.getId())); [EOL] assertNotNull(ug); [EOL] assertEquals(0, ug.size()); [EOL] } [EOL]
@Test [EOL] public void shouldShowToastAfterRedirectedToLoginPage() throws Exception { [EOL] 	 fillUpFields(); [EOL] signupActivity.createUser(null); [EOL] assertThat(ShadowToast.getTextOfLatestToast(), equalTo(signupActivity.getString(R.string.registered)+" username")); [EOL] } [EOL]
@Test [EOL] 	public void testPartialClone() throws IllegalAccessException { [EOL] 		final BatchAggregationExpression original = this.createBatchExpression(); [EOL] 		final Partial partial1Clone = (Partial) original.getPartial(0).clone(); [EOL] 		final Partial partial2Clone = (Partial) original.getPartial(1).clone(); [EOL] [EOL] 		this.testPropertyClone(BatchAggregationExpression.class, original, partial1Clone.getBatch()); [EOL] 		Assert.assertSame(partial1Clone.getBatch(), partial2Clone.getBatch()); [EOL] 	} [EOL]
@Test(dependsOnGroups = "create", groups = "read1") [EOL] public void testGetAlerts() { [EOL] Iterator<Alert> itr = this.manager.getAlerts(this.manager.criteria().asServiceAccount(true)); [EOL] [EOL] Assertions.assertThat(itr) [EOL] .isNotNull() [EOL] .hasSize(2) [EOL] .extracting("type", "level", "description", "content") [EOL] .contains(Assertions.tuple(URI.create("http://example.com/test/alert/1"), Level.MINOR, TRUNK_DESCR, "1st content"), [EOL] Assertions.tuple(URI.create("http://example.com/test/alert/2"), Level.CRITICAL, "2nd description", "2nd content")); [EOL] } [EOL]
@Test( expected = IllegalArgumentException.class ) [EOL] 	public void testListAllFiles_invalidParameter() throws Exception { [EOL] 		Utils.listAllFiles( this.folder.newFile( "roboconf.txt" )); [EOL] 	} [EOL]
@Test(expected = IllegalStateException.class) [EOL] public void testCreateSnapshotVersionNotNextVersion() { [EOL] final VersionedFlowSnapshot snapshot = createSnapshot(); [EOL] [EOL] final BucketEntity existingBucket = new BucketEntity(); [EOL] existingBucket.setId("b1"); [EOL] existingBucket.setName("My Bucket"); [EOL] existingBucket.setDescription("This is my bucket"); [EOL] existingBucket.setCreated(new Date()); [EOL] [EOL] when(metadataService.getBucketById(existingBucket.getId())).thenReturn(existingBucket); [EOL] [EOL] // return a flow with the existing snapshot when getFlowById is called [EOL] final FlowEntity existingFlow = new FlowEntity(); [EOL] existingFlow.setId("flow1"); [EOL] existingFlow.setName("My Flow"); [EOL] existingFlow.setDescription("This is my flow."); [EOL] existingFlow.setCreated(new Date()); [EOL] existingFlow.setModified(new Date()); [EOL] existingFlow.setBucketId(existingBucket.getId()); [EOL] [EOL] // make a snapshot that has the same version as the one being created [EOL] final FlowSnapshotEntity existingSnapshot = new FlowSnapshotEntity(); [EOL] existingSnapshot.setFlowId(snapshot.getSnapshotMetadata().getFlowIdentifier()); [EOL] existingSnapshot.setVersion(snapshot.getSnapshotMetadata().getVersion()); [EOL] existingSnapshot.setComments("This is an existing snapshot"); [EOL] existingSnapshot.setCreated(new Date()); [EOL] existingSnapshot.setCreatedBy("test-user"); [EOL] [EOL] when(metadataService.getFlowById(existingFlow.getId())).thenReturn(existingFlow); [EOL] [EOL] // set the version to something that is not the next one-up version [EOL] snapshot.getSnapshotMetadata().setVersion(100); [EOL] registryService.createFlowSnapshot(snapshot); [EOL] } [EOL]
@Test [EOL] public void testReadWriteDiskValidator() [EOL] throws DiskErrorException, InterruptedException { [EOL] int count = 100; [EOL] File testDir = new File(System.getProperty("test.build.data")); [EOL] ReadWriteDiskValidator readWriteDiskValidator = [EOL] (ReadWriteDiskValidator) DiskValidatorFactory.getInstance( [EOL] ReadWriteDiskValidator.NAME); [EOL] [EOL] for (int i = 0; i < count; i++) { [EOL] readWriteDiskValidator.checkStatus(testDir); [EOL] } [EOL] [EOL] ReadWriteDiskValidatorMetrics metric = [EOL] ReadWriteDiskValidatorMetrics.getMetric(testDir.toString()); [EOL] Assert.assertEquals("The count number of estimator in MutableQuantiles" [EOL] + "metrics of file read is not right", [EOL] metric.getFileReadQuantiles()[0].getEstimator().getCount(), count); [EOL] [EOL] Assert.assertEquals("The count number of estimator in MutableQuantiles" [EOL] + "metrics of file write is not right", [EOL] metric.getFileWriteQuantiles()[0].getEstimator().getCount(), [EOL] count); [EOL] [EOL] MetricsSource source = ms.getSource( [EOL] ReadWriteDiskValidatorMetrics.sourceName(testDir.toString())); [EOL] MetricsCollectorImpl collector = new MetricsCollectorImpl(); [EOL] source.getMetrics(collector, true); [EOL] [EOL] MetricsRecords.assertMetric(collector.getRecords().get(0), [EOL] "FailureCount", 0); [EOL] MetricsRecords.assertMetric(collector.getRecords().get(0), [EOL] "LastFailureTime", (long)0); [EOL] [EOL] // All MutableQuantiles haven't rolled over yet because the minimum [EOL] // interval is 1 hours, so we just test if these metrics exist. [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "WriteLatency3600sNumOps"); [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "WriteLatency3600s50thPercentileLatencyMicros"); [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "WriteLatency86400sNumOps"); [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "WriteLatency864000sNumOps"); [EOL] [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "ReadLatency3600sNumOps"); [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "ReadLatency3600s50thPercentileLatencyMicros"); [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "ReadLatency86400sNumOps"); [EOL] MetricsRecords.assertMetricNotNull(collector.getRecords().get(0), [EOL] "ReadLatency864000sNumOps"); [EOL] } [EOL]
@Test [EOL] 	public void crossover() { [EOL] 		final ISeq<CharacterGene> g1 = ISeq.of(CharacterChromosome.of("1234567890")); [EOL] 		final ISeq<CharacterGene> g2 = ISeq.of(CharacterChromosome.of("abcdefghij")); [EOL] [EOL] 		final int rv1 = 12; [EOL] 		using(new Random(10), r -> { [EOL] 			final UniformCrossover<CharacterGene, Double> [EOL] 				crossover = new UniformCrossover<>(0.5, 0.5); [EOL] [EOL] 			MSeq<CharacterGene> g1c = g1.copy(); [EOL] 			MSeq<CharacterGene> g2c = g2.copy(); [EOL] 			final int changed = crossover.crossover(g1c, g2c); [EOL] [EOL] 			Assert.assertEquals(changed, [EOL] 				IntStream.range(0, g2c.length()) [EOL] 					.filter(i -> Character.isDigit(g2c.get(i).charValue())) [EOL] 					.count() [EOL] 			); [EOL] 		}); [EOL] 	} [EOL]
@Test [EOL] public void testParseUTF8Entity() throws Exception { [EOL] final String ru_hello = constructString(RUSSIAN_HELLO); [EOL] final String ch_hello = constructString(SWISS_GERMAN_HELLO); [EOL] final List <NameValuePair> parameters = new ArrayList<>(); [EOL] parameters.add(new BasicNameValuePair("russian", ru_hello)); [EOL] parameters.add(new BasicNameValuePair("swiss", ch_hello)); [EOL] [EOL] final String s = WWWFormCodec.format(parameters, StandardCharsets.UTF_8); [EOL] [EOL] Assert.assertEquals("russian=%D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82" + [EOL] "&swiss=Gr%C3%BCezi_z%C3%A4m%C3%A4", s); [EOL] final StringEntity entity = new StringEntity(s, [EOL] ContentType.APPLICATION_FORM_URLENCODED.withCharset(StandardCharsets.UTF_8)); [EOL] final List<NameValuePair> result = EntityUtils.parse(entity); [EOL] Assert.assertEquals(2, result.size()); [EOL] assertNameValuePair(result.get(0), "russian", ru_hello); [EOL] assertNameValuePair(result.get(1), "swiss", ch_hello); [EOL] } [EOL]
@Test [EOL] public final void testGetResult() throws PolicyException { [EOL] service.getValidation(); [EOL] String result = service.getResult(false); [EOL] assertEquals("success", result); [EOL] } [EOL]
@Test [EOL] public void testOr_2Parsers() { [EOL] Parser<Character> parser = Parsers.or(isChar('a'), isChar('b')); [EOL] assertEquals("or", parser.toString()); [EOL] assertEquals((Object) 'a', parser.parse("a", mode)); [EOL] assertEquals((Object) 'b', parser.parse("b", mode)); [EOL] assertEquals((Object) 'a', Parsers.or(areChars("ab"), isChar('a')).parse("a", mode)); [EOL] assertFailure(mode, Parsers.or(areChars("abc"), areChars("ax")), "abx", 1, 3); [EOL] assertFailure(mode, Parsers.or(areChars("ax"), areChars("abc")), "abx", 1, 3); [EOL] } [EOL]
@Test [EOL] public void testCharAt() { [EOL] Assert.assertEquals(testSs.charAt(5), original.charAt(5)); [EOL] } [EOL]
@Test [EOL] public void testTrim22() throws Exception { [EOL] // 前処理(引数) [EOL] String columnString = "aaa１aaa"; [EOL] String fileEncoding = "Shift_JIS"; [EOL] char trimChar = 'a'; [EOL] TrimType trimType = TrimType.NONE; [EOL] [EOL] // テスト実施 [EOL] String result = FileDAOUtility.trim(columnString, fileEncoding, [EOL] trimChar, trimType); [EOL] [EOL] // 判定 [EOL] assertNotNull(result); [EOL] assertEquals("aaa１aaa", result); [EOL] } [EOL]
@Test [EOL] public void testExec_URI_URI() { [EOL] [EOL] NodeValue v1 = NodeValue.makeNode("<gml:Point xmlns:gml=\"http://www.opengis.net/ont/gml\" srsName=\"http://www.opengis.net/def/crs/EPSG/0/4326\"><gml:pos>0 10</gml:pos></gml:Point>", GMLDatatype.INSTANCE); [EOL] NodeValue v2 = NodeValue.makeNode(NodeFactory.createURI(WKTDatatype.URI)); [EOL] NodeValue v3 = NodeValue.makeNode(NodeFactory.createURI(SRS_URI.DEFAULT_WKT_CRS84)); [EOL] TransformFF instance = new TransformFF(); [EOL] NodeValue expResult = NodeValue.makeNode("POINT(10 0)", WKTDatatype.INSTANCE); [EOL] NodeValue result = instance.exec(v1, v2, v3); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test [EOL] public void testOnDecisionTableSelectionsChangedEventWithOtherwiseCellSelectedAndItHasEditableColumns() { [EOL] [EOL] model.getConditions().add(makePattern52()); [EOL] model.getData().add(makeDTCellValue52ListWithOtherwise()); [EOL] uiModel.selectCell(0, 3); [EOL] [EOL] builder.onDecisionTableSelectionsChangedEvent(new DecisionTableSelectionsChangedEvent(dtPresenter)); [EOL] [EOL] assertTrue(builder.miCut.getMenuItem().isEnabled()); [EOL] assertTrue(builder.miCopy.getMenuItem().isEnabled()); [EOL] assertFalse(builder.miPaste.getMenuItem().isEnabled()); [EOL] assertTrue(builder.miDeleteSelectedCells.getMenuItem().isEnabled()); [EOL] assertTrue(builder.miDeleteSelectedColumns.getMenuItem().isEnabled()); [EOL] assertTrue(builder.miDeleteSelectedRows.getMenuItem().isEnabled()); [EOL] assertTrue(builder.miOtherwiseCell.getMenuItem().isEnabled()); [EOL] verify(builder.miOtherwiseCell.getMenuItemView(), times(1)).setIconType(eq(IconType.CHECK)); [EOL] } [EOL]
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] 	@Test [EOL] 	public void testMultiDimensionalArray() { [EOL] 		// tuple array [EOL] 		MapFunction<?,?> function = new MapFunction<Tuple2<Integer, Double>[][], Tuple2<Integer, Double>[][]>() { [EOL] 			private static final long serialVersionUID = 1L; [EOL] [EOL] 			@Override [EOL] 			public Tuple2<Integer, Double>[][] map( [EOL] 					Tuple2<Integer, Double>[][] value) throws Exception { [EOL] 				return null; [EOL] 			} [EOL] 		}; [EOL] 		TypeInformation<?> ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("Tuple2<Integer, Double>[][]")); [EOL] 		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<Java Tuple2<Integer, Double>>>", ti.toString()); [EOL] [EOL] 		// primitive array [EOL] 		function = new MapFunction<int[][][], int[][][]>() { [EOL] 			private static final long serialVersionUID = 1L; [EOL] [EOL] 			@Override [EOL] 			public int[][][] map( [EOL] 					int[][][] value) throws Exception { [EOL] 				return null; [EOL] 			} [EOL] 		}; [EOL] 		ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("int[][][]")); [EOL] 		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<int[]>>", ti.toString()); [EOL] [EOL] 		// basic array [EOL] 		function = new MapFunction<Integer[][][], Integer[][][]>() { [EOL] 			private static final long serialVersionUID = 1L; [EOL] [EOL] 			@Override [EOL] 			public Integer[][][] map( [EOL] 					Integer[][][] value) throws Exception { [EOL] 				return null; [EOL] 			} [EOL] 		}; [EOL] 		ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("Integer[][][]")); [EOL] 		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<BasicArrayTypeInfo<Integer>>>", ti.toString()); [EOL] [EOL] 		// pojo array [EOL] 		function = new MapFunction<CustomType[][][], CustomType[][][]>() { [EOL] 			private static final long serialVersionUID = 1L; [EOL] [EOL] 			@Override [EOL] 			public CustomType[][][] map( [EOL] 					CustomType[][][] value) throws Exception { [EOL] 				return null; [EOL] 			} [EOL] 		}; [EOL] 		ti = TypeExtractor.getMapReturnTypes((MapFunction)function, [EOL] 				TypeInfoParser.parse("org.apache.flink.api.java.typeutils.TypeExtractorTest$CustomType<" [EOL] 					+ "myField1=String,myField2=int" [EOL] 					+ ">[][][]")); [EOL] 		 [EOL] 		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<" [EOL] 				+ "PojoType<org.apache.flink.api.java.typeutils.TypeExtractorTest$CustomType, fields = [myField1: String, myField2: Integer]>" [EOL] 				+ ">>>", ti.toString()); [EOL] 		 [EOL] 		// generic array [EOL] 		ti = TypeExtractor.getMapReturnTypes((MapFunction) new MapperWithMultiDimGenericArray<String>(), TypeInfoParser.parse("String[][][]")); [EOL] 		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<Java Tuple1<String>>>>", ti.toString()); [EOL] 	} [EOL]
@Test public void testUri() { [EOL] 		// Arrange: [EOL] 		final Uri uri = Uri.parse("content://android/data/images/leopard.png"); [EOL] 		final ShareIntent intent = new ShareIntent(); [EOL] 		// Act: [EOL] 		intent.uri(uri); [EOL] 		// Assert: [EOL] 		assertThat(intent.uri(), is(uri)); [EOL] 	} [EOL]
@Test [EOL] public void txn_nested_04() { [EOL] Txn.exec(counter, TxnType.READ_COMMITTED_PROMOTE, ()->{ [EOL] Txn.exec(counter, TxnType.READ, ()->{}); [EOL] }); [EOL] } [EOL]
@Test [EOL] public void equalsReturnsTrueIfReaderIndicesAreDifferent() { [EOL] [EOL] // given [EOL] KeySequenceConfig config1 = [EOL] new KeySequenceConfig(DEFAULT_TEST_SEQ_ID, RESERVED_KEYS, RESERVED_KEYS); [EOL] KeySequence sequence1 = createDefaultTestUUIDSequence(config1); [EOL] [EOL] KeySequenceConfig config2 = [EOL] new KeySequenceConfig(DEFAULT_TEST_SEQ_ID, RESERVED_KEYS + 1, RESERVED_KEYS); [EOL] KeySequence sequence2 = createDefaultTestUUIDSequence(config2); [EOL] [EOL] // when [EOL] boolean result = sequence1.equals(sequence2); [EOL] [EOL] // then [EOL] assertTrue(result); [EOL] [EOL] } [EOL]
@Test [EOL] public void testObservableWithCreate() throws Exception { [EOL] RxJavaCreate.observableWithCreate().subscribe(System.out::println); [EOL] } [EOL]
@Test(dataProvider = "maxTestValues") [EOL] 	public void max( [EOL] 		final Named<Comparator<Integer>> comparator, [EOL] 		final Integer a, [EOL] 		final Integer b, [EOL] 		final Integer max [EOL] 	) { [EOL] 		assertEquals(MinMax.max(comparator.value, a, b), max); [EOL] 	} [EOL]
@Test [EOL] public void testQuietlyVoid() { [EOL] quietlyEval("", "", [EOL] () -> { [EOL] throw HADOOP_CONNECTION_TIMEOUT_EX; [EOL] }); [EOL] } [EOL]
@Test [EOL] 	public void testSearchWithin() { [EOL] 		PointQuadTree<String> qt = getTree(); [EOL] 		List<PointData<String>> points = qt.searchWithin(4, -1, 51, 98); [EOL] 		Collections.sort(points); [EOL] 		String keyString = Arrays.asList(points).toString(); [EOL] 		String expected = "[(5.0, 20.0), (12.0, 0.0), (47.0, 96.0), (50.0, 32.0), (50.0, 50.0)]"; [EOL] 		System.out.println(points); [EOL] 	} [EOL]
@Test [EOL] public void create_a_page_and_fetch_associated_task() throws Exception { [EOL] ContractToPageMapper contractToPageMapper = makeContractToPageMapper(); [EOL] [EOL] Page page = contractToPageMapper.createFormPage("myPage", aSimpleContract(), FormScope.TASK); [EOL] [EOL] assertThat(page.getVariables()).contains(entry("task", anURLVariable().value("../API/bpm/userTask/{{taskId}}").build())); [EOL] } [EOL]
@Test( expected = IllegalArgumentException.class ) [EOL] public void shouldFailTryingToRemoveNullParameterName() throws Exception { [EOL] this.procedure.removeParameter( getTransaction(), null ); [EOL] } [EOL]
@Test [EOL] 	public void testCreateNamespace_NamespaceURI() throws XMLStreamException { [EOL] 		Namespace event = factory.createNamespace("http://foo"); [EOL] 		verify(event, XMLStreamConstants.NAMESPACE, "xmlns=\"http://foo\""); [EOL] 	} [EOL]
@Test [EOL] public void should_respond_500_when_error_appear_while_updating_property() throws Exception { [EOL] when(widgetService.updateProperty(eq("label"), eq("toBeUpdated"), any(Property.class))).thenThrow(RepositoryException.class); [EOL] [EOL] mockMvc.perform(put("/rest/widgets/label/properties/toBeUpdated") [EOL] .contentType(MediaType.APPLICATION_JSON_VALUE) [EOL] .content(convertObjectToJsonBytes(aProperty().build()))) [EOL] [EOL] .andExpect(status().isInternalServerError()); [EOL] } [EOL]
@Test [EOL] public void validate() { [EOL] } [EOL]
@Test [EOL] public void testFromDb() throws MapperException { [EOL] LOG.info("testFromDb"); [EOL] [EOL] Assert.assertEquals(Locale.ENGLISH, mapper.fromDb("en")); [EOL] Assert.assertEquals(Locale.US, mapper.fromDb("en_US")); [EOL] Assert.assertEquals(new Locale("nl", "NL"), mapper.fromDb("nl_NL")); [EOL] Assert.assertEquals(new Locale("en", "NL"), mapper.fromDb("en_NL")); [EOL] Assert.assertEquals(new Locale("en", "NL"), mapper.fromDb("en_NL")); [EOL] Assert.assertEquals(new Locale("es", "ES", "Traditional_WIN"), mapper.fromDb("es_ES_Traditional_WIN")); [EOL] } [EOL]
@Test [EOL] public void setImageUrl_requestsImage() { [EOL] mNIV.setLayoutParams( [EOL] new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)); [EOL] mNIV.setImageUrl("http://foo", mMockImageLoader); [EOL] assertEquals("http://foo", mMockImageLoader.lastRequestUrl); [EOL] assertEquals(0, mMockImageLoader.lastMaxWidth); [EOL] assertEquals(0, mMockImageLoader.lastMaxHeight); [EOL] } [EOL]
@Test [EOL] public void testzClassName() throws NoSuchFieldException, IllegalAccessException { [EOL] // given [EOL] String iriStr = "http://www.micello.com#hasFloor"; [EOL] IRI iri = IRI.create(iriStr); [EOL] ZObjectProperty zojectProperty = new ZObjectProperty(iri); [EOL] [EOL] // then [EOL] assertEquals("Fields didn't match", zojectProperty.getObjectPropertyShortForm(), "hasFloor"); [EOL] } [EOL]
@Test [EOL] 	public void testSaveScreenshot_selector() throws Exception { [EOL] 		Map<String, Object> map = new HashMap<String, Object>(); [EOL] 		map.put("platform", "WINDOWS"); [EOL] 		map.put("browserName", "firefox"); [EOL] 		map.put("version", "38"); [EOL] [EOL] 		PtlCapabilities capabilities = new PtlCapabilities(map); [EOL] 		IndexDomSelector selector = new IndexDomSelector(SelectorType.CSS_SELECTOR, "main", 0); [EOL] 		PersistMetadata metadata = new PersistMetadata("testId", "testClass", "testMethod", "scId", selector, null, [EOL] 				capabilities); [EOL] 		BufferedImage expected = ImageIO.read(getClass().getResource("FilePersister_Image.png")); [EOL] 		persister.saveScreenshot(metadata, expected); [EOL] [EOL] 		File file = new File(BASE_DIRECTORY [EOL] 				+ "/testId/testClass/testMethod_scId_WINDOWS_firefox_38_CSS_SELECTOR_main_[0].png"); [EOL] 		BufferedImage actual = ImageIO.read(file); [EOL] [EOL] 		assertArrayEquals(toRGB(expected), toRGB(actual)); [EOL] 	} [EOL]
@Test [EOL] public void testSplit() { [EOL] List<byte[]> res = SignalUtil.split(new byte[]{0,0,0,3,3,3,5},3); [EOL] assertArrayEquals(Arrays.asList(new byte[]{0,0,0},new byte[]{3,3,3},new byte[]{5}).toArray(),res.toArray()); [EOL] } [EOL]
@Test [EOL] 	public void when_stored_action_received__a_soft_store_observation_should_be_stored() { [EOL] 		InMemoryAtomStore atomStore = mock(InMemoryAtomStore.class); [EOL] 		InMemoryAtomStoreReducer reducer = new InMemoryAtomStoreReducer(atomStore); [EOL] 		RadixAddress address = mock(RadixAddress.class); [EOL] 		final Atom atom = mock(Atom.class); [EOL] 		when(atom.addresses()).thenAnswer(inv -> Stream.of(address)); [EOL] 		RadixNode node = mock(RadixNode.class); [EOL] 		RadixNodeAction action = SubmitAtomStatusAction.fromStatusNotification( [EOL] 				"different-id", [EOL] 				atom, [EOL] 				node, [EOL] 				new AtomStatusEvent(AtomStatus.STORED, null) [EOL] 			); [EOL] 		reducer.reduce(action); [EOL] [EOL] 		InOrder inOrder = Mockito.inOrder(atomStore, atomStore); [EOL] 		inOrder.verify(atomStore).store(eq(address), argThat(o -> [EOL] 			o.isStore() [EOL] 				&& o.getAtom().equals(atom) [EOL] 				&& o.getUpdateType().isSoft() [EOL] 		)); [EOL] 		inOrder.verify(atomStore).store(eq(address), argThat(AtomObservation::isHead)); [EOL] 	} [EOL]
@Test [EOL] public void testReleaseSavepoint01() throws Exception { [EOL] // テスト入力データ設定 [EOL] [EOL] // テスト実施 [EOL] try { [EOL] BatchUtil.releaseSavepoint(new TransactionStatusStub(), [EOL] new Object()); [EOL] } catch (Exception e) { [EOL] e.printStackTrace(); [EOL] fail(); [EOL] return; [EOL] } [EOL] [EOL] // 結果検証 [EOL] } [EOL]
@Test [EOL] public void testEncryptedRar() throws Exception { [EOL] Parser parser = new RarParser(); [EOL] [EOL] try (InputStream input = RarParserTest.class.getResourceAsStream( [EOL] "/test-documents/test-documents-enc.rar")) { [EOL] Metadata metadata = new Metadata(); [EOL] ContentHandler handler = new BodyContentHandler(); [EOL] ParseContext context = new ParseContext(); [EOL] context.set(PasswordProvider.class, new PasswordProvider() { [EOL] @Override [EOL] public String getPassword(Metadata metadata) { [EOL] return "ApacheTika"; [EOL] } [EOL] }); [EOL] [EOL] // Note - we don't currently support encrypted RAR [EOL] // files so we can't check the contents [EOL] parser.parse(input, handler, metadata, trackingContext); [EOL] fail("No support yet for Encrypted RAR files"); [EOL] } catch (EncryptedDocumentException e) { [EOL] // Good, as expected right now [EOL] } [EOL] } [EOL]
@Test [EOL] void negatingFalse() { [EOL] final MarketplaceFilterCondition c = MarketplaceFilterCondition.neverAccepting(); [EOL] final NegatingCondition nc = new NegatingCondition(c); [EOL] assertThat(nc.test(Wrapper.wrap(new LoanDescriptor(MockLoanBuilder.fresh()), FOLIO))).isTrue(); [EOL] } [EOL]
@Test [EOL] public void testMutlipleIteratorsResetMidIteration() { [EOL] [EOL] ArrayList<Integer> arrayList = new ArrayList<>(); [EOL] for (int i = 0; i < 1000; i++) { [EOL] arrayList.add(i); [EOL] } [EOL] ArrayList<Integer> arrayList2 = new ArrayList<>(); [EOL] for (int i = 1000; i < 2000; i++) { [EOL] arrayList2.add(i); [EOL] } [EOL] ArrayList<Integer> arrayList3 = new ArrayList<>(); [EOL] for (int i = 2000; i < 3000; i++) { [EOL] arrayList3.add(i); [EOL] } [EOL] [EOL] MultiResettableIterator<Integer> iterator = new MultiResettableIterator<>(new ResettableIterator[]{ArrayResettableIterator.iterator(arrayList), ArrayResettableIterator.iterator(arrayList2), ArrayResettableIterator.iterator(arrayList3)}); [EOL] for (int i = 0; i < 100; i++) { [EOL] assertTrue(iterator.hasNext()); [EOL] assertEquals(Integer.valueOf(i), iterator.next()); [EOL] } [EOL] [EOL] //Reset and ensure we re-iterate all. [EOL] iterator.reset(); [EOL] [EOL] for (int i = 0; i < 3000; i++) { [EOL] assertTrue(iterator.hasNext()); [EOL] assertNotNull(iterator.next()); [EOL] } [EOL] assertFalse(iterator.hasNext()); [EOL] [EOL] [EOL] } [EOL]
@Test [EOL] public void shouldIncludeOptionsWithPropertyNames() throws Exception { [EOL] final String custom = "blah"; [EOL] this.function.setStatementOption( getTransaction(), custom, "sledge" ); [EOL] boolean customFound = false; [EOL] [EOL] final String standard = this.function.getStandardOptions().keySet().iterator().next(); [EOL] this.function.setStatementOption( getTransaction(), standard, "hammer" ); [EOL] boolean standardFound = false; [EOL] [EOL] for ( final String prop : this.function.getPropertyNames( getTransaction() ) ) { [EOL] if ( custom.equals( prop ) ) { [EOL] if ( customFound ) { [EOL] fail( "Custom option included multiple times in property names" ); [EOL] } [EOL] [EOL] customFound = true; [EOL] } else if ( standard.equals( prop ) ) { [EOL] if ( standardFound ) { [EOL] fail( "Standard option included multiple times in property names" ); [EOL] } [EOL] [EOL] standardFound = true; [EOL] } [EOL] [EOL] if ( customFound && standardFound ) { [EOL] break; [EOL] } [EOL] } [EOL] [EOL] if ( !customFound ) { [EOL] fail( "Custom option not included in property names" ); [EOL] } [EOL] [EOL] if ( !standardFound ) { [EOL] fail( "Standard option not included in property names" ); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testValidateAuthenticator_noNullary() throws Exception { [EOL] final class InvalidAuthenticator implements Authenticator { [EOL] @SuppressWarnings("unused") [EOL] public InvalidAuthenticator(int x) {} [EOL] [EOL] @SuppressWarnings("unused") [EOL] @Override [EOL] public User authenticate(HttpServletRequest request) { [EOL] return null; [EOL] } [EOL] } [EOL] [EOL] config.getApiClassConfig().getMethods() [EOL] .get(methodToEndpointMethod(TestEndpoint.class.getMethod("getResultNoParams"))) [EOL] .setAuthenticators( [EOL] ImmutableList.<Class<? extends Authenticator>>of(InvalidAuthenticator.class)); [EOL] [EOL] try { [EOL] validator.validate(config); [EOL] fail(); [EOL] } catch (InvalidConstructorException expected) { [EOL] assertTrue(expected.getMessage().contains("Invalid custom authenticator")); [EOL] assertTrue(expected.getMessage().endsWith( [EOL] "InvalidAuthenticator. It must have a public nullary constructor.")); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testFindAllExportedVariables_withFacets() { [EOL] [EOL] 		Component component = new Component( "comp 1" ); [EOL] 		component.addExportedVariable( new ExportedVariable( "var1", "another value" )); [EOL] 		component.addExportedVariable( new ExportedVariable( "var2", "var 2 value" )); [EOL] 		component.addExportedVariable( new ExportedVariable( "ip", null )); [EOL] [EOL] 		Facet f1 = new Facet( "f1" ); [EOL] 		f1.addExportedVariable( new ExportedVariable( "param1", "value1" )); [EOL] 		component.associateFacet( f1 ); [EOL] [EOL] 		Facet f2 = new Facet( "f2" ); [EOL] 		f2.addExportedVariable( new ExportedVariable( "param2", "value2" )); [EOL] 		component.associateFacet( f2 ); [EOL] [EOL] 		Facet f3 = new Facet( "f3" ); [EOL] 		f3.addExportedVariable( new ExportedVariable( "param3", "value3" )); [EOL] 		component.associateFacet( f3 ); [EOL] 		component.addExportedVariable( new ExportedVariable( "f3.param3", "component overrides facet" )); [EOL] [EOL] 		Facet f4 = new Facet( "f4" ); [EOL] 		f4.addExportedVariable( new ExportedVariable( "param4-1", "value4" )); [EOL] 		f4.addExportedVariable( new ExportedVariable( "param4-2", "value4" )); [EOL] 		f2.extendFacet( f4 ); [EOL] 		f2.addExportedVariable( new ExportedVariable( "f4.param4-1", "facet overrides facet" )); [EOL] [EOL] 		Instance instance = new Instance( "inst 1" ); [EOL] 		instance.setComponent( component ); [EOL] 		instance.overriddenExports.put( "var1", "some value" ); [EOL] 		instance.overriddenExports.put( "toto.ip", null ); [EOL] 		instance.overriddenExports.put( "f1.param1", "my-value" ); [EOL] 		instance.data.put( Instance.IP_ADDRESS, "192.168.1.18" ); [EOL] [EOL] 		Component extendedComponent = new Component( "extended" ); [EOL] 		extendedComponent.addExportedVariable( new ExportedVariable( "v", "hop" )); [EOL] 		component.extendComponent( extendedComponent ); [EOL] 		component.addExportedVariable( new ExportedVariable( "extended.v", "nop" )); [EOL] [EOL] 		Map<String,String> map = InstanceHelpers.findAllExportedVariables( instance ); [EOL] 		Assert.assertEquals( 16, map.size()); [EOL] [EOL] 		Assert.assertEquals( "some value", map.get( "comp 1.var1" )); [EOL] 		Assert.assertEquals( "var 2 value", map.get( "comp 1.var2" )); [EOL] 		Assert.assertEquals( "192.168.1.18", map.get( "comp 1.ip" )); [EOL] [EOL] 		Assert.assertEquals( "192.168.1.18", map.get( "toto.ip" )); [EOL] [EOL] 		Assert.assertEquals( "nop", map.get( "extended.v" )); [EOL] [EOL] 		// The first one was specifically overridden in the instance [EOL] 		Assert.assertEquals( "my-value", map.get( "f1.param1" )); [EOL] 		Assert.assertEquals( "value1", map.get( "comp 1.param1" )); [EOL] [EOL] 		Assert.assertEquals( "value2", map.get( "f2.param2" )); [EOL] 		Assert.assertEquals( "value2", map.get( "comp 1.param2" )); [EOL] [EOL] 		Assert.assertEquals( "component overrides facet", map.get( "f3.param3" )); [EOL] 		Assert.assertEquals( "component overrides facet", map.get( "comp 1.param3" )); [EOL] [EOL] 		Assert.assertEquals( "facet overrides facet", map.get( "f4.param4-1" )); [EOL] 		Assert.assertEquals( "value4", map.get( "f4.param4-2" )); [EOL] 	} [EOL]
@Test(expected = PoincutDefinitionException.class) [EOL] public void testCommitLocalTransactionPointcut() { [EOL] // Setup [EOL] [EOL] // Run the test [EOL] businessGlobalTransactionAspectUnderTest.commitLocalTransactionPointcut(); [EOL] [EOL] // Verify the results [EOL] } [EOL]
@Test(expected = NullPointerException.class) [EOL] public void testNullListRow() { [EOL] exporter = new CsvExporter(1, "abc"); [EOL] exporter.addRow((List) null); [EOL] } [EOL]
@Test [EOL] public void testRemoveIntersecting_onePoint() { [EOL] final List<SamplingPoint> clusterList = new ArrayList<>(); [EOL] addSamplePoint(111, 114, clusterList); [EOL] [EOL] final List<SamplingPoint> thinnedOutList = filter.apply(clusterList); [EOL] assertNotNull(thinnedOutList); [EOL] assertEquals(1, thinnedOutList.size()); [EOL] } [EOL]
@Test [EOL] public void testGetValues() throws Throwable { [EOL] // Set up a null file set to start with. [EOL] hfileReader.setFileSet(null); [EOL] // Test a batch of all even values along with some lookups on non existent keys. [EOL] List<ByteBuffer> keyList = Lists.newArrayListWithCapacity(5000); [EOL] for (int i = 0; i < 10000; i += 2) { [EOL] keyList.add(ByteBuffer.wrap(String.format("%04d", i).getBytes())); [EOL] } [EOL] // Add one not found key. [EOL] keyList.add(ByteBuffer.wrap(String.format("%04d", 15000).getBytes())); [EOL] [EOL] checkKeyValues(keyList, 5000, 1000, 1); [EOL] assertEquals(5001, Stats.getMetric("lookup-latency-ms").apply().count()); [EOL] assertEquals(1000, Stats.getCounter("lookup-errors").apply()); [EOL] assertEquals(1, Stats.getCounter("not-found").apply()); [EOL] [EOL] // Test a batch of all odd values along with some lookups on non existent keys. [EOL] // This time, we use "test" as the file set to check if the metrics are recorded [EOL] // correctly. [EOL] hfileReader.setFileSet("test"); [EOL] keyList = Lists.newArrayListWithCapacity(5000); [EOL] for (int i = 1; i < 10000; i += 2) { [EOL] keyList.add(ByteBuffer.wrap(String.format("%04d", i).getBytes())); [EOL] } [EOL] // Add one not found key. [EOL] keyList.add(ByteBuffer.wrap(String.format("%04d", 16000).getBytes())); [EOL] checkKeyValues(keyList, 5000, 1000, 1); [EOL] [EOL] assertEquals(10002, Stats.getMetric("lookup-latency-ms").apply().count()); [EOL] assertEquals(5001, Stats.getMetric("test-lookup-latency-ms").apply().count()); [EOL] assertEquals(8000, Stats.getMetric("value-size").apply().count()); [EOL] assertEquals(4000, Stats.getMetric("test-value-size").apply().count()); [EOL] assertEquals(2000, Stats.getCounter("lookup-errors").apply()); [EOL] assertEquals(1000, Stats.getCounter("test-lookup-errors").apply()); [EOL] assertEquals(2, Stats.getCounter("not-found").apply()); [EOL] assertEquals(1, Stats.getCounter("test-not-found").apply()); [EOL] } [EOL]
@Test [EOL] public void testToString() throws Exception { [EOL] Job newJob = new JobImpl(3L, "test", "test_org", 0L, "simple", "do", arguments, DISPATCHING, "localhost", [EOL] "remotehost", created, started, completed, 100L, 200L, "result", 3L, 1L, true, uri, 1.5F); [EOL] String jobString = "Job {id:3, operation:do, status:DISPATCHING}"; [EOL] assertEquals(newJob.toString(), jobString); [EOL] } [EOL]
@Test [EOL] public void testActivateUser_Throws_UserIsAlreadyVerifiedException() throws Exception { [EOL] // Arrange [EOL] final Long patientId = 10L; [EOL] final UserActivationRequestDtoForTest request = new UserActivationRequestDtoForTest(); [EOL] final UserActivationResponseDto response = new UserActivationResponseDto(); [EOL] final String email = "email"; [EOL] final String username = "email"; [EOL] final String verificationCode = "verificationCode"; [EOL] final int year = 2010; [EOL] final int month = 2; [EOL] final int day = 3; [EOL] final LocalDate birthDate = LocalDate.of(year, month, day); [EOL] final String firstName = "firstName"; [EOL] final String lastName = "lastName"; [EOL] final String genderCode = "genderCode "; [EOL] final String emailToken = "emailToken"; [EOL] final String password = "Password#1"; [EOL] final String confirmPassword = "Password#1"; [EOL] final boolean verified = true; [EOL] response.setEmail(email); [EOL] response.setBirthDate(birthDate); [EOL] response.setFirstName(firstName); [EOL] response.setLastName(lastName); [EOL] response.setId(patientId); [EOL] response.setGenderCode(genderCode); [EOL] response.setBirthDate(birthDate); [EOL] response.setGenderCode(genderCode); [EOL] response.setVerified(verified); [EOL] request.setVerificationCode(verificationCode); [EOL] request.setBirthDate(Arrays.asList(year, month, day)); [EOL] request.setEmailToken(emailToken); [EOL] request.setPassword(password); [EOL] request.setConfirmPassword(confirmPassword); [EOL] request.setUsername(username); [EOL] when(userCreationService.activateUser(argThat(matching( [EOL] req -> req.getBirthDate().equals(birthDate) && [EOL] req.getVerificationCode().equals(verificationCode) && [EOL] req.getEmailToken().equals(emailToken) && [EOL] req.getPassword().equals(password) [EOL] )), xForwardedProto, xForwardedHost, xForwardedPort)).thenThrow(UserIsAlreadyVerifiedException.class); [EOL] [EOL] // Act and Assert [EOL] mvc.perform(post("/activations") [EOL] .contentType(MediaType.APPLICATION_JSON_UTF8) [EOL] .content(objectMapper.writeValueAsBytes(request)) [EOL] .header(UserCreationController.X_FORWARDED_PROTO, xForwardedProto) [EOL] .header(UserCreationController.X_FORWARDED_HOST, xForwardedHost) [EOL] .header(UserCreationController.X_FORWARDED_PORT, xForwardedPort)) [EOL] .andExpect(status().isPreconditionFailed()); [EOL] } [EOL]
@Test [EOL] 	public void shouldIncludeOnResultWithAlias() throws Exception { [EOL] 		Object object = new Object(); [EOL] [EOL] 		serialization.from(object, "Abc"); [EOL] [EOL] 		verify(result).include("Abc", object); [EOL] 	} [EOL]
@Test [EOL] public void getHashData() { [EOL] byte[] magicNumber = new byte[]{0x4e, 0x45, 0x4F, 0x00}; [EOL] NeoConfig.setMagicNumber(magicNumber); [EOL] [EOL] List<Signer> signers = new ArrayList<>(); [EOL] signers.add(Signer.feeOnly(account1)); [EOL] Transaction tx = new Transaction(neow, (byte) 0, [EOL] 0L, [EOL] 0L, [EOL] signers, [EOL] 0L, [EOL] 0L, [EOL] new ArrayList<>(), [EOL] new byte[]{1, 2, 3}, [EOL] new ArrayList<>()); [EOL] [EOL] byte[] txHexWithoutWitness = Numeric.hexStringToByteArray( [EOL] "000000000000000000000000000000000000000000000000000123ba2703c53263e8d6e522dc32203339dcd8eee9000003010203"); [EOL] byte[] expectedData = ArrayUtils.concatenate(magicNumber, txHexWithoutWitness); [EOL] assertThat(tx.getHashData(), is(expectedData)); [EOL] } [EOL]
@Test [EOL] public void testToString() { [EOL] assertEquals(plain, testCs.toString()); [EOL] } [EOL]
@Test [EOL] public void testAddIdx() { [EOL] metadata.commit(() -> { [EOL] List<String> list = getList("prop1"); [EOL] list.add(1, "x"); [EOL] list.add(1, "y"); [EOL] }, MetadataAccess.SERVICE); [EOL] [EOL] metadata.read(() -> { [EOL] List<String> list = getList("prop1"); [EOL] [EOL] assertThat(list).contains("a", "y", "x", "b", "c"); [EOL] }, MetadataAccess.SERVICE); [EOL] } [EOL]
@Test(expected = NotFoundException.class) [EOL] public void testNotFoundInternalByIdAndVersion() throws NotFoundException { [EOL] EasyMock.replay(sr); [EOL] Assert.assertEquals("Only one version should move", [EOL] "1", tsamjp.internalMoveByIdAndVersion(new VersionImpl(5L), "fake", REMOTE_STORE_1_ID)); [EOL] } [EOL]
@Test [EOL] public void testPushMetricsFailed() throws Exception { [EOL] final UrlService svcMock = createStrictMock(UrlService.class); [EOL] final String payload = "test"; [EOL] final String expectedResponse = "mockResponse"; [EOL] RestMetricsSender sender = new RestMetricsSender("expectedHostName") { [EOL] @Override [EOL] protected UrlService getConnectedUrlService() throws IOException { [EOL] return svcMock; [EOL] } [EOL] }; [EOL] [EOL] expect(svcMock.send(anyString())).andThrow(new IOException()); [EOL] svcMock.disconnect(); [EOL] expectLastCall(); [EOL] [EOL] replay(svcMock); [EOL] [EOL] String response = sender.pushMetrics(payload); [EOL] [EOL] verify(svcMock); [EOL] } [EOL]
@Test [EOL] public void testDoFilter_occur_error() throws IOException, ServletException { [EOL] [EOL] OutOfMemoryError occurError = new OutOfMemoryError("out of memory error."); [EOL] [EOL] doThrow(occurError).when(mockFilterChain).doFilter(mockRequest, [EOL] mockResponse); [EOL] [EOL] try { [EOL] testTarget.doFilter(mockRequest, mockResponse, mockFilterChain); [EOL] } catch (OutOfMemoryError e) { [EOL] assertSame(occurError, e); [EOL] } [EOL] [EOL] verify(mockExceptionLogger, times(0)).error((Exception) any()); [EOL] [EOL] } [EOL]
@Test [EOL] public void testParseOneOf1() [EOL] { [EOL] VirtualCheckOperator op = VirtualCheckExpressionParser.parseVirtualCheckExpression("one of [ host 'vm1', host 'vm2', host 'vm3', host 'vm4' ] as WARNING"); [EOL] assertThat(op.toString(), is(equalTo("one of [host 'vm1', host 'vm2', host 'vm3', host 'vm4'] as WARNING"))); [EOL] } [EOL]
@Test [EOL] public void testTasks() { [EOL] [EOL] appController.tasks(); [EOL] [EOL] assertEquals(TasksPage.class, appController.getClazz()); [EOL] } [EOL]
@Test [EOL] public void submoduleOutPortHasSignal() { [EOL] try ( [EOL] ModuleInterpretation moduleInterpretation = testCaseBuilder("submoduleOutPortHasSignal", PROXY_CONTEXT) [EOL] .build() [EOL] ) { [EOL] MapStagingArea stagingArea = moduleInterpretation.getStagingArea(); [EOL] Map<ExecutionTrace, ObjectNode> stagingAreaMap = stagingArea.toUnmodifiableMap(); [EOL] put(stagingArea, ":in:x", ":in:y"); [EOL] [EOL] Props props = moduleInterpretation.toCompositeModuleInterpreterProps(3, bitSetOf(), bitSetOf(0, 1)); [EOL] ActorSystem actorSystem = moduleInterpretation.getActorSystem(); [EOL] TestActorRef<CompositeModuleInterpreterActor> actorRef = TestActorRef.create( [EOL] moduleInterpretation.getActorSystem(), props, moduleInterpretation.getSupervisor()); [EOL] [EOL] TestProbe akkaEventProbe = new TestProbe(actorSystem); [EOL] actorSystem.eventStream().subscribe(akkaEventProbe.ref(), Object.class); [EOL] [EOL] // Empty the executor queue, and subsequently verify that the appropriate actions happened as a result of [EOL] // the message and starting the interpretation. [EOL] CallingThreadExecutor asyncTaskExecutor = moduleInterpretation.getAsyncTaskExecutor(); [EOL] asyncTaskExecutor.executeAll(); [EOL] [EOL] Assert.assertEquals( [EOL] stagingAreaMap.keySet(), [EOL] tracesSet(":in:x", ":in:y", "/a:in:ax", "/a:in:ay", "/b:in:bx", ":out:q") [EOL] ); [EOL] TestProbe aProbe = moduleInterpretation.getTestProbeForChild("a"); [EOL] aProbe.expectMsgClass(InPortHasSignal.class); [EOL] aProbe.expectMsgClass(InPortHasSignal.class); [EOL] Assert.assertFalse(aProbe.msgAvailable()); [EOL] [EOL] int aId = submodule(moduleInterpretation, "a").getIndex(); [EOL] put(stagingArea, "/a:out:ap"); [EOL] actorRef.receive(new SubmoduleOutPortHasSignal(aId, 0)); [EOL] [EOL] // Verify warning if the SubmoduleOutPortHasSignal message mentions a port that already provided a value [EOL] Assert.assertFalse(akkaEventProbe.msgAvailable()); [EOL] actorRef.receive(new SubmoduleOutPortHasSignal(aId, 0)); [EOL] LogEvent redundantMsgLogEvent = akkaEventProbe.expectMsgClass(LogEvent.class); [EOL] Assert.assertEquals(redundantMsgLogEvent.logSource(), actorRef.path().toString()); [EOL] String redundantMsg = (String) redundantMsgLogEvent.message(); [EOL] Assert.assertTrue(redundantMsg.contains("redundant")); [EOL] RuntimeParentModule parentModule = (RuntimeParentModule) moduleInterpretation.getResolvedModule(); [EOL] RuntimeModule submodule = Objects.requireNonNull( [EOL] parentModule.getEnclosedElement(RuntimeModule.class, SimpleName.identifier("a"))); [EOL] Assert.assertTrue(redundantMsg.contains(submodule.getOutPorts().get(0).toString())); [EOL] [EOL] // Verify warning if the SubmoduleOutPortHasSignal message mentions a port that is not needed [EOL] Assert.assertFalse(akkaEventProbe.msgAvailable()); [EOL] actorRef.receive(new SubmoduleOutPortHasSignal(aId, 1)); [EOL] LogEvent unexpectedMsgLogEvent = akkaEventProbe.expectMsgClass(LogEvent.class); [EOL] Assert.assertEquals(unexpectedMsgLogEvent.logSource(), actorRef.path().toString()); [EOL] String unexpectedMsg = (String) unexpectedMsgLogEvent.message(); [EOL] Assert.assertTrue(unexpectedMsg.contains("unexpected")); [EOL] Assert.assertTrue(unexpectedMsg.contains(submodule.getOutPorts().get(1).toString())); [EOL] [EOL] // Verify that all successors receive values as events are processed. Note that the value of out-port a#ap [EOL] // will no longer be needed, so submodule a will have no needed out-ports any more and cleaning will happen. [EOL] asyncTaskExecutor.executeAll(); [EOL] Assert.assertEquals( [EOL] stagingAreaMap.keySet(), [EOL] tracesSet(":in:x", ":in:y", "/b:in:bx", "/b:in:by", ":out:q") [EOL] ); [EOL] } [EOL] } [EOL]
@Test [EOL] 	public void testFindOrganizationalProvider() { [EOL] 		organizationalProviderService.findOrganizationalProvider(anyLong()); [EOL] 		verify(organizationalProviderRepository).findOne(anyLong()); [EOL] 	} [EOL]
@Test [EOL] public void testListAllTables() throws Exception { [EOL] List<TableDesc> tables = getInstance(getTestConfig()).listAllTables(null); [EOL] Assert.assertNotNull(tables); [EOL] Assert.assertTrue(tables.size() > 0); [EOL] } [EOL]
@Test [EOL] public void testUpdateUITitleFontA() { [EOL] Font font = UIManager.getFont("JXHeader.titleFont"); [EOL] assertNotNull("sanity: title font available", font); [EOL] JXHeader header = new JXHeader(); [EOL] assertEquals(font, header.getTitleFont()); [EOL] } [EOL]
@Test [EOL] public void shouldFallBackToFileBaseJsonSchemaValidatorIfOptionalMediaTypeIsEmpty() { [EOL] final String envelopeJson = "{}"; [EOL] final String actionName = "actionName"; [EOL] [EOL] backwardsCompatibleJsonSchemaValidator.validate(envelopeJson, actionName, empty()); [EOL] [EOL] verify(fileBasedJsonSchemaValidator).validateWithoutSchemaCatalog(envelopeJson, actionName); [EOL] } [EOL]
@Test [EOL] public void testGood_Combinations() throws BitcoinURIParseException { [EOL] testObject = new BitcoinURI(MAINNET, BITCOIN_SCHEME + ":" + MAINNET_GOOD_ADDRESS [EOL] + "?amount=6543210&label=Hello%20World&message=Be%20well"); [EOL] assertEquals( [EOL] "BitcoinURI['amount'='654321000000000','label'='Hello World','message'='Be well','address'='"+CoinDefinition.UNITTEST_ADDRESS+"']", [EOL] testObject.toString()); [EOL] } [EOL]
@Test [EOL] public void testCompletion13() throws Exception { [EOL] JavaCompletion completion = getCompletion(); [EOL] File file = [EOL] new File( [EOL] project.getProjectRootPath(), [EOL] "./src/main/java/meghanada/completion/JavaCompletion.java") [EOL] .getCanonicalFile(); [EOL] assertTrue(file.exists()); [EOL] final Collection<? extends CandidateUnit> units = [EOL] timeIt(() -> completion.completionAt(file, 227, 10, "*map#")); [EOL] units.forEach(a -> log.info(a.getDeclaration())); [EOL] assertEquals(18, units.size()); [EOL] } [EOL]
@Test [EOL] public void isOperator() { [EOL] when(expr.isAction()).thenReturn(true).thenReturn(false); [EOL] assertTrue(test.isAction()); [EOL] assertFalse(test.isAction()); [EOL] verify(expr, times(2)).isAction(); [EOL] verifyNoMoreInteractions(expr); [EOL] } [EOL]
@Test [EOL] public void testChooseSpatialWithoutStatsHouseDay() { [EOL] final ChooseLocalityPreservingQueryStrategy strategy = [EOL] new ChooseLocalityPreservingQueryStrategy(); [EOL] [EOL] final Iterator<Index> it = [EOL] getIndices( [EOL] new HashMap<StatisticsId, InternalDataStatistics<SimpleFeature, ?, ?>>(), [EOL] new BasicQueryByClass(createConstraints(HOUSE, HOUSE, DAY)), [EOL] strategy); [EOL] assertTrue(it.hasNext()); [EOL] assertEquals(indices.get(3).getName(), it.next().getName()); [EOL] assertFalse(it.hasNext()); [EOL] } [EOL]
@Test [EOL] public void mixedTest() throws Exception { [EOL] filePlugin.process(openTwoCondMsg); [EOL] filePlugin.process(ackTwoCondMsg); [EOL] filePlugin.process(resolvedTwoCondMsg); [EOL] } [EOL]
@Test [EOL] public void testGetDownloadByNameUrl() throws B2Exception { [EOL] final String expectedUrl = "http://example.com/blah"; [EOL] [EOL] B2DownloadByNameRequest request = B2DownloadByNameRequest [EOL] .builder(bucketName(1), fileName(1)) [EOL] .build(); [EOL] when(webifier.getDownloadByNameUrl(ACCOUNT_AUTH, request)).thenReturn(expectedUrl); [EOL] [EOL] assertEquals(expectedUrl, client.getDownloadByNameUrl(request)); [EOL] [EOL] // check the "convenience" form that takes a bucketName & fileName instead of a request. [EOL] assertEquals(expectedUrl, client.getDownloadByNameUrl(bucketName(1), fileName(1))); [EOL] } [EOL]
@Test [EOL] public void testRetryExhausted() throws Exception { [EOL] MutateRowsRequest request = createRequest(2); [EOL] RetryingMutateRowsOperation underTest = createOperation(request); [EOL] ListenableFuture<?> future = underTest.getAsyncResult(); [EOL] MutateRowsRequest retryRequest = createRequest(request.getEntries(1)); [EOL] [EOL] send(underTest, OK, DEADLINE_EXCEEDED); [EOL] checkExecutor(1); [EOL] Assert.assertEquals(retryRequest, underTest.getRetryRequest()); [EOL] [EOL] // Fast forward until retry limit has been reached [EOL] clock.setTime( [EOL] clock.millisTime() + RETRY_OPTIONS.getMaxElapsedBackoffMillis() + 1, TimeUnit.MILLISECONDS); [EOL] [EOL] send(underTest, DEADLINE_EXCEEDED); [EOL] checkExecutor(1); [EOL] Assert.assertEquals(retryRequest, underTest.getRetryRequest()); [EOL] [EOL] checkResponse(future, createResponse(OK, DEADLINE_EXCEEDED)); [EOL] } [EOL]
@Test [EOL] public void testPopulateAmbariServerProperties() throws Exception { [EOL] File file = mock(File.class); [EOL] String recommendationsArtifactsLifetime = "1w"; [EOL] StackAdvisorRunner stackAdvisorRunner = mock(StackAdvisorRunner.class); [EOL] AmbariMetaInfo ambariMetaInfo = mock(AmbariMetaInfo.class); [EOL] StackAdvisorCommand<TestResource> cmd = new TestStackAdvisorCommand(file, recommendationsArtifactsLifetime, "test", 1, [EOL] stackAdvisorRunner, ambariMetaInfo); [EOL] ObjectNode objectNode = (ObjectNode) cmd.mapper.readTree("{\"Versions\": " + [EOL] "{\"stack_name\": \"stack\", \"stack_version\":\"1.0.0\"}}"); [EOL] [EOL] Map<String, String> props = Collections.singletonMap("a", "b"); [EOL] [EOL] doReturn(props).when(ambariMetaInfo).getAmbariServerProperties(); [EOL] [EOL] cmd.populateAmbariServerInfo(objectNode); [EOL] [EOL] JsonNode serverProperties = objectNode.get("ambari-server-properties"); [EOL] assertNotNull(serverProperties); [EOL] assertEquals("b", serverProperties.iterator().next().getTextValue()); [EOL] } [EOL]
@Test [EOL] void 상수값을_사용한다() throws Exception { [EOL] //given [EOL] int bookNo = 1; [EOL] for (int i = 1; i <= 10; i++) { [EOL] bookRepository.save(Book.builder() [EOL] .name("a"+i) [EOL] .bookNo(bookNo) [EOL] .build()); [EOL] } [EOL] [EOL] //when [EOL] List<BookPageDto> bookPages = bookQueryRepository.getBookPage(bookNo, 0); [EOL] [EOL] //then [EOL] assertThat(bookPages).hasSize(10); [EOL] assertThat(bookPages.get(0).getPageNo()).isEqualTo(0); [EOL] assertThat(bookPages.get(0).getBookNo()).isEqualTo(bookNo); [EOL] } [EOL]
@Test [EOL] public void testInvalidUri2() throws JSONException, Exception { [EOL] WebResource r = resource(); [EOL] String responseStr = ""; [EOL] try { [EOL] responseStr = r.accept(MediaType.APPLICATION_JSON).get(String.class); [EOL] fail("should have thrown exception on invalid uri"); [EOL] } catch (UniformInterfaceException ue) { [EOL] ClientResponse response = ue.getResponse(); [EOL] assertEquals(Status.NOT_FOUND, response.getClientResponseStatus()); [EOL] WebServicesTestUtils.checkStringMatch( [EOL] "error string exists and shouldn't", "", responseStr); [EOL] } [EOL] } [EOL]
@Test [EOL] public void getCommittee() throws IOException { [EOL] String responseBody = ContractTestHelper.loadFile( [EOL] "/responses/invokefunction_getcommittee.json"); [EOL] WireMock.stubFor(post(urlEqualTo("/")) [EOL] .withRequestBody(new RegexPattern("" [EOL] + ".*\"method\":\"invokefunction\"" [EOL] + ".*\"params\":" [EOL] + ".*\"de5f57d430d3dece511cf975a8d37848cb9e0525\"" // neo contract [EOL] + ".*\"getCommittee\".*" // function [EOL] )) [EOL] .willReturn(aResponse() [EOL] .withStatus(200) [EOL] .withBody(responseBody))); [EOL] [EOL] List<ECPublicKey> result = new NeoToken(neow).getCommittee(); [EOL] String expKeyHex = "026aa8fe6b4360a67a530e23c08c6a72525afde34719c5436f9d3ced759f939a3d"; [EOL] ECPublicKey expKey = new ECPublicKey(Numeric.hexStringToByteArray(expKeyHex)); [EOL] assertThat(result, contains(expKey)); [EOL] } [EOL]
@Test [EOL] void get3Test() { [EOL] assertEquals(3, (int) instance.get3()); [EOL] } [EOL]
@Test [EOL] void testWarn4() { [EOL] instance.warn(FORMATTING_MESSAGE2, MESSAGE, MESSAGE2); [EOL] assertTrue(output.contains(FORMATTING_MESSAGE_PREFIX + "|" + MESSAGE + "|" + MESSAGE2)); [EOL] } [EOL]
@Test [EOL] public void constructDeleteHttpMethod() throws UnsupportedEncodingException { [EOL] HttpUriRequest request = client.constructHttpMethod("DELETE", "jest/delete", null, null); [EOL] assertNotNull(request); [EOL] assertEquals(request.getURI().getPath(), "jest/delete"); [EOL] assertTrue(request instanceof HttpDeleteWithEntity); [EOL] } [EOL]
@Test [EOL] public void testReadSamplingPoints_SST_CCI_V2_Bottle_Data() throws Exception { [EOL] try (InsituReader reader = createReader("insitu_13_WMOID_856160_19850120_19850212.nc")) { [EOL] final List<SamplingPoint> samplingPoints = reader.readSamplingPoints(); [EOL] assertEquals(33, samplingPoints.size()); [EOL] [EOL] SamplingPoint samplingPoint = samplingPoints.get(0); [EOL] assertCorrectSamplingPoint(-62.1856, -55.0681, 475073388000L, 0, samplingPoint); [EOL] [EOL] samplingPoint = samplingPoints.get(16); [EOL] assertCorrectSamplingPoint(-62.7189, -60.6692, 476503740000L, 16, samplingPoint); [EOL] [EOL] samplingPoint = samplingPoints.get(32); [EOL] assertCorrectSamplingPoint(-62.2006, -58.9175, 477077112000L, 32, samplingPoint); [EOL] } [EOL] } [EOL]
@Test(expected = IllegalStateException.class) [EOL] 	public void testGetSettingsCatchException() throws Exception { [EOL] 		when( [EOL] 			_ddmDataProviderTracker.getDDMDataProvider(Matchers.anyString()) [EOL] 		).thenThrow( [EOL] 			IllegalStateException.class [EOL] 		); [EOL] [EOL] 		_ddmDataProviderInstanceSettingsImpl.getSettings( [EOL] 			_ddmDataProviderInstance, DDMRESTDataProviderSettings.class); [EOL] 	} [EOL]
@Test [EOL] public void testIdOutOfIntegerRange() throws IOException { [EOL] assumeNotWindows(); [EOL] String GET_ALL_USERS_CMD = "echo \"" [EOL] + "nfsnobody:x:4294967294:4294967294:Anonymous NFS User:/var/lib/nfs:/sbin/nologin\n" [EOL] + "nfsnobody1:x:4294967295:4294967295:Anonymous NFS User:/var/lib/nfs1:/sbin/nologin\n" [EOL] + "maxint:x:2147483647:2147483647:Grid Distributed File System:/home/maxint:/bin/bash\n" [EOL] + "minint:x:2147483648:2147483648:Grid Distributed File System:/home/minint:/bin/bash\n" [EOL] + "archivebackup:*:1031:4294967294:Archive Backup:/home/users/archivebackup:/bin/sh\n" [EOL] + "hdfs:x:11501:10787:Grid Distributed File System:/home/hdfs:/bin/bash\n" [EOL] + "daemon:x:2:2:daemon:/sbin:/sbin/nologin\"" [EOL] + " | cut -d: -f1,3"; [EOL] String GET_ALL_GROUPS_CMD = "echo \"" [EOL] + "hdfs:*:11501:hrt_hdfs\n" [EOL] + "rpcuser:*:29:\n" [EOL] + "nfsnobody:*:4294967294:\n" [EOL] + "nfsnobody1:*:4294967295:\n" [EOL] + "maxint:*:2147483647:\n" [EOL] + "minint:*:2147483648:\n" [EOL] + "mapred3:x:498\"" [EOL] + " | cut -d: -f1,3"; [EOL] // Maps for id to name map [EOL] BiMap<Integer, String> uMap = HashBiMap.create(); [EOL] BiMap<Integer, String> gMap = HashBiMap.create(); [EOL] [EOL] ShellBasedIdMapping.updateMapInternal(uMap, "user", GET_ALL_USERS_CMD, ":", [EOL] EMPTY_PASS_THROUGH_MAP); [EOL] assertTrue(uMap.size() == 7); [EOL] assertEquals("nfsnobody", uMap.get(-2)); [EOL] assertEquals("nfsnobody1", uMap.get(-1)); [EOL] assertEquals("maxint", uMap.get(2147483647)); [EOL] assertEquals("minint", uMap.get(-2147483648)); [EOL] assertEquals("archivebackup", uMap.get(1031)); [EOL] assertEquals("hdfs",uMap.get(11501)); [EOL] assertEquals("daemon", uMap.get(2)); [EOL] [EOL] ShellBasedIdMapping.updateMapInternal(gMap, "group", GET_ALL_GROUPS_CMD, ":", [EOL] EMPTY_PASS_THROUGH_MAP); [EOL] assertTrue(gMap.size() == 7); [EOL] assertEquals("hdfs",gMap.get(11501)); [EOL] assertEquals("rpcuser", gMap.get(29)); [EOL] assertEquals("nfsnobody", gMap.get(-2)); [EOL] assertEquals("nfsnobody1", gMap.get(-1)); [EOL] assertEquals("maxint", gMap.get(2147483647)); [EOL] assertEquals("minint", gMap.get(-2147483648)); [EOL] assertEquals("mapred3", gMap.get(498)); [EOL] } [EOL]
@Test [EOL] public void should_create_a_datepicker_for_date_contract_input_with_local_date_format() throws Exception { [EOL] ParametrizedWidgetFactory elementFactory = createFactory(); [EOL] [EOL] DatePickerWidget component = (DatePickerWidget) elementFactory [EOL] .createParametrizedWidget(aLocalDateContractInput("creationLocalDate")); [EOL] [EOL] DatePickerWidgetAssert.assertThat(component).hasPlaceholder(); [EOL] DatePickerWidgetAssert.assertThat(component).hasDateFormat("MM/dd/yyyy"); [EOL] } [EOL]
@Test public void testNotifyLoadingFinishedWithoutRegisteredListener() { [EOL] 		// Arrange: [EOL] 		final WebFragment fragment = new WebFragment(); [EOL] 		// Act: [EOL] 		// Only ensure that calling this method without registered listener does not cause any troubles. [EOL] 		fragment.notifyLoadingFinished("test_url"); [EOL] 	} [EOL]
@Test [EOL] public void hashCodeTest() { [EOL] final int expectedResult = 1774869086; [EOL] Assert.assertEquals(socketInfo.hashCode(), expectedResult); [EOL] } [EOL]
@Test [EOL] public void testNamedAttribute() { [EOL] Matcher matcher = parser.parse("/@name"); [EOL] assertFalse(matcher.matchesText()); [EOL] assertFalse(matcher.matchesElement()); [EOL] assertTrue(matcher.matchesAttribute(null, "name")); [EOL] assertFalse(matcher.matchesAttribute(NS, "name")); [EOL] assertFalse(matcher.matchesAttribute(NS, "eman")); [EOL] assertEquals(Matcher.FAIL, matcher.descend(NS, "name")); [EOL] } [EOL]
@Test [EOL] 	public void testReadFileContentQuietly_nullFile() throws Exception { [EOL] [EOL] 		String readS = Utils.readFileContentQuietly( null, Logger.getLogger( getClass().getName())); [EOL] 		Assert.assertEquals( "", readS ); [EOL] 	} [EOL]
@Test [EOL] public void invokingLPopCreatesNewSpan() { [EOL] commandCreatesNewSpan(RedisCommand.LPOP, () -> getConnection().lPop("key".getBytes())); [EOL] verify(mockRedisConnection()).lPop("key".getBytes()); [EOL] } [EOL]
@Test [EOL] public void shouldPrintWorkflows() throws IOException { [EOL] final Workflow foo1 = Workflow.create("foo1", WorkflowConfiguration.builder() [EOL] .id("bar1") [EOL] .schedule(Schedule.DAYS) [EOL] .build()); [EOL] final Workflow foo2 = Workflow.create("foo2", WorkflowConfiguration.builder() [EOL] .id("bar2") [EOL] .schedule(Schedule.DAYS) [EOL] .build()); [EOL] final List<Workflow> workflows = List.of(foo1, foo2); [EOL] cliOutput.printWorkflows(workflows); [EOL] assertThat(OBJECT_MAPPER.readValue(outContent.toString(), new TypeReference<List<Workflow>>() { }), [EOL] is(workflows)); [EOL] } [EOL]
@Test [EOL] public void testNot() throws Exception { [EOL] TNodeIf not = new TNodeIf(info, TextContentParserTest.createTestTextContentParser(), "Node", TNode.EMPTY_ATTRIBUTES, "!expr", false); [EOL] [EOL] TRenderContext context = new TRenderContext(new ByteArrayOutputStream(), Collections.<String, Object>singletonMap("expr", true)); [EOL] assertTrue(not.canRender(context).isPresent()); [EOL] [EOL] context = new TRenderContext(new ByteArrayOutputStream(), Collections.<String, Object>singletonMap("expr", false)); [EOL] assertFalse(not.canRender(context).isPresent()); [EOL] [EOL] TNodeIf normal = new TNodeIf(info, TextContentParserTest.createTestTextContentParser(), "Node", TNode.EMPTY_ATTRIBUTES, "expr", false); [EOL] [EOL] context = new TRenderContext(new ByteArrayOutputStream(), Collections.<String, Object>singletonMap("expr", false)); [EOL] assertTrue(normal.canRender(context).isPresent()); [EOL] [EOL] context = new TRenderContext(new ByteArrayOutputStream(), Collections.<String, Object>singletonMap("expr", true)); [EOL] assertFalse(normal.canRender(context).isPresent()); [EOL] [EOL] } [EOL]
@Test [EOL] public void testStateResponseIsPrepared() throws Exception { [EOL] Map<ModelNodeId, Pair<List<QName>, List<FilterNode>>> attributes = prepareAttributes(); [EOL] [EOL] Element dataElement = DocumentUtils.stringToDocument(DATA).getDocumentElement(); [EOL] Map<ModelNodeId, List<Element>> stateResponse = m_util.getStateResponse(attributes, dataElement); [EOL] assertResponse(stateResponse); [EOL] } [EOL]
@Test [EOL] public void testSetUseDatastoreIfSpecified() throws Exception { [EOL] annotationConfig.setUseDatastoreIfSpecified(AnnotationBoolean.TRUE); [EOL] Mockito.verify(config).setUseDatastore(true); [EOL] [EOL] annotationConfig.setUseDatastoreIfSpecified(AnnotationBoolean.FALSE); [EOL] Mockito.verify(config).setUseDatastore(false); [EOL] [EOL] Mockito.verifyNoMoreInteractions(config); [EOL] } [EOL]
@Test [EOL] public void testScaledBaumWelchTraining() { [EOL] // train the given network to the following output sequence [EOL] int[] observed = {1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 0, 1, 0, 0}; [EOL] [EOL] // expected values from Matlab HMM package / R HMM package [EOL] double[] initialExpected = {0, 0, 1.0, 0}; [EOL] double[][] transitionExpected = {{0.2319, 0.0993, 0.0005, 0.6683}, [EOL] {0.0001, 0.3345, 0.6654, 0}, {0.5975, 0, 0.4025, 0}, [EOL] {0.0024, 0.6657, 0, 0.3319}}; [EOL] double[][] emissionExpected = {{0.9995, 0.0004, 0.0001}, [EOL] {0.9943, 0.0036, 0.0021}, {0.0059, 0.9941, 0}, {0, 0, 1}}; [EOL] [EOL] HmmModel trained = HmmTrainer [EOL] .trainBaumWelch(getModel(), observed, 0.1, 10, true); [EOL] [EOL] Vector initialProbabilities = trained.getInitialProbabilities(); [EOL] Matrix emissionMatrix = trained.getEmissionMatrix(); [EOL] Matrix transitionMatrix = trained.getTransitionMatrix(); [EOL] [EOL] for (int i = 0; i < trained.getNrOfHiddenStates(); ++i) { [EOL] assertEquals(initialProbabilities.get(i), initialExpected[i], [EOL] 0.0001); [EOL] for (int j = 0; j < trained.getNrOfHiddenStates(); ++j) { [EOL] assertEquals(transitionMatrix.getQuick(i, j), [EOL] transitionExpected[i][j], 0.0001); [EOL] } [EOL] for (int j = 0; j < trained.getNrOfOutputStates(); ++j) { [EOL] assertEquals(emissionMatrix.getQuick(i, j), [EOL] emissionExpected[i][j], 0.0001); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void testAppend() throws VetoException { [EOL] modelSynchronizer.appendRow(); [EOL] [EOL] assertEquals(1, [EOL] model.getData().size()); [EOL] assertEquals(1, [EOL] uiModel.getRowCount()); [EOL] assertEquals(GuidedDecisionTableView.ROW_HEIGHT, [EOL] uiModel.getRow(0).getHeight(), [EOL] 0.0); [EOL] } [EOL]
@Test [EOL] public void testDefineMatchupPattern_onlyPrimarySensor() { [EOL] final String primarySensorname = "atsr.3"; [EOL] final Stack<EntityTransaction> transactionStack = new Stack<>(); [EOL] final Sensor primarySensor = new SensorBuilder().name(primarySensorname).pattern(10).build(); [EOL] [EOL] final EntityTransaction transaction = mock(EntityTransaction.class); [EOL] final Storage storage = mock(Storage.class); [EOL] final PersistenceManager persistenceManager = mock(PersistenceManager.class); [EOL] [EOL] when(persistenceManager.transaction()).thenReturn(transaction); [EOL] when(persistenceManager.getStorage()).thenReturn(storage); [EOL] [EOL] when(storage.getSensor("orb_atsr.3")).thenReturn(primarySensor); [EOL] [EOL] final long pattern = MatchupGenerator.defineMatchupPattern(primarySensorname, null, 1000000L, persistenceManager, transactionStack); [EOL] [EOL] assertEquals(1000000L | 10L, pattern); [EOL] [EOL] verify(persistenceManager, times(1)).getStorage(); [EOL] verify(persistenceManager, times(1)).transaction(); [EOL] verify(persistenceManager, times(1)).commit(); [EOL] verifyNoMoreInteractions(persistenceManager); [EOL] [EOL] verify(storage, times(1)).getSensor("orb_atsr.3"); [EOL] verifyNoMoreInteractions(storage); [EOL] [EOL] assertEquals(1, transactionStack.size()); [EOL] assertSame(transaction, transactionStack.pop()); [EOL] } [EOL]
@Test [EOL] 	public void upper_level() { [EOL] 		// given [EOL] 		String levelName = "animal"; [EOL] [EOL] 		// when [EOL] 		Level level = transform(codemap, levelName); [EOL] 		log.info("produced level '{}':\n{}", levelName, level.formatted()); [EOL] [EOL] 		// then [EOL] 		Component domestic = new Component("domestic"); [EOL] 		Component rodent = new Component("rodent"); [EOL] 		assertThat(level.name).isEqualTo(levelName); [EOL] 		assertThat(level.components).containsExactly(domestic, rodent); [EOL] 		assertThat(level.dependencies).containsExactly( [EOL] 				new ComponentDep(domestic, rodent) [EOL] 		); [EOL] 		assertThat(level.dependency(domestic, rodent).strength).isEqualTo(2); [EOL] 		assertThat(level.component("domestic").size).isGreaterThan(level.component("rodent").size); [EOL] 	} [EOL]
@Test [EOL] public void handleMethodAnnotationShouldSetParamsEncoded() throws Exception { [EOL] toTest.handleMethodAnnotation(mockAnnotation, mockMethodConfigBuilder); [EOL] verify(mockMethodConfigBuilder).setParamsEncoded(true); [EOL] } [EOL]
@Test [EOL] public void testRemove() { [EOL] PriorityCollection<TestPriorityAware> set = new PriorityCollection<>(CopyOnWriteArraySet::new); [EOL] [EOL] assertTrue(set.isEmpty()); [EOL] assertTrue(set.add(new TestPriorityAware(1))); [EOL] assertFalse(set.isEmpty()); [EOL] [EOL] assertFalse(set.remove(new TestPriorityAware(0))); [EOL] assertFalse(set.isEmpty()); [EOL] assertTrue(set.remove(new TestPriorityAware(1))); [EOL] assertTrue(set.isEmpty()); [EOL] } [EOL]
@Test [EOL] public void test_extract_embedded_without_ocr() throws Exception { [EOL] EmbeddedDocumentMemoryExtractor contentExtractor = new EmbeddedDocumentMemoryExtractor( [EOL] new CommonsDigester(20 * 1024 * 1024, CommonsDigester.DigestAlgorithm.SHA256.toString()), "SHA-256", false); [EOL] [EOL] TikaDocumentSource actual = contentExtractor.extract(documentFactory.create(Paths.get(getClass().getResource("/documents/embedded_with_duplicate.tgz").getPath())), [EOL] "f69680093a1c466d628c7b352a449e8e8a0ce291f61837f9bed9d55ff3658544"); [EOL] [EOL] assertThat(new String(actual.content).replace("\n", "")).isEqualTo("level2"); [EOL] } [EOL]
@Test [EOL] public void typicalString() throws Exception { [EOL] Schema schema = SchemaBuilder.builder().stringType(); [EOL] Field field = new Field("b", schema, null, (Object) null); [EOL] field.addProp(SENSITIVITY, PII); [EOL] [EOL] underTest.onPiiField(field, null); [EOL] [EOL] assertThat(schema.getProp("logicalType"), is("pii-string")); [EOL] } [EOL]
@Test [EOL] void unserializeMapType() throws Exception [EOL] { [EOL] Type mapType = new DefaultParameterizedType(null, Map.class, String.class, ComponentRole.class); [EOL] assertEquals(mapType, [EOL] ReflectionUtils.unserializeType( [EOL] "java.util.Map<java.lang.String, " + "org.xwiki.component.descriptor.ComponentRole>", [EOL] Thread.currentThread().getContextClassLoader())); [EOL] } [EOL]
@Test [EOL] 	public void testGetEvaluableFieldNames() throws Exception { [EOL] 		DDMForm ddmForm = DDMFormTestUtil.createDDMForm(); [EOL] [EOL] 		ddmForm.addDDMFormField( [EOL] 			DDMFormTestUtil.createTextDDMFormField( [EOL] 				"Field0", false, false, false)); [EOL] 		ddmForm.addDDMFormField( [EOL] 			DDMFormTestUtil.createTextDDMFormField( [EOL] 				"Field1", false, false, false)); [EOL] 		ddmForm.addDDMFormField( [EOL] 			DDMFormTestUtil.createTextDDMFormField( [EOL] 				"Field2", false, false, true)); [EOL] [EOL] 		DDMFormField ddmFormField3 = DDMFormTestUtil.createTextDDMFormField( [EOL] 			"Field3", false, false, false); [EOL] [EOL] 		ddmFormField3.setVisibilityExpression("equals(Field0, 'Joe')"); [EOL] [EOL] 		ddmForm.addDDMFormField(ddmFormField3); [EOL] [EOL] 		DDMFormField ddmFormField4 = DDMFormTestUtil.createTextDDMFormField( [EOL] 			"Field4", false, false, false); [EOL] [EOL] 		DDMFormFieldValidation ddmFormFieldValidation = [EOL] 			new DDMFormFieldValidation(); [EOL] [EOL] 		ddmFormFieldValidation.setDDMFormFieldValidationExpression( [EOL] 			new DDMFormFieldValidationExpression() { [EOL] 				{ [EOL] 					setValue("isEmailAddress(Field4)"); [EOL] 				} [EOL] 			}); [EOL] [EOL] 		ddmFormField4.setDDMFormFieldValidation(ddmFormFieldValidation); [EOL] [EOL] 		ddmForm.addDDMFormField(ddmFormField4); [EOL] [EOL] 		Set<String> expectedEvaluableFieldNames = SetUtil.fromArray( [EOL] 			new String[] {"Field0", "Field2", "Field4"}); [EOL] [EOL] 		Set<String> actualEvaluableFieldNames = [EOL] 			_ddmFormTemplateContextFactoryHelper.getEvaluableDDMFormFieldNames( [EOL] 				ddmForm, new DDMFormLayout()); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			expectedEvaluableFieldNames, actualEvaluableFieldNames); [EOL] 	} [EOL]
@Test [EOL] public void givenTag_whenNotifyHeaderChangedInSection_thenCallsNewClass() { [EOL] // When [EOL] cut.notifyHeaderChangedInSection(tag); [EOL] [EOL] // Then [EOL] verify(sectionAdapter).notifyHeaderChanged(); [EOL] } [EOL]
@Test [EOL] public void testTrimQueueNameEquals() throws Exception { [EOL] final String[] equalsStrings = { [EOL] // no spaces [EOL] "a", [EOL] // leading spaces [EOL] " a", [EOL] " \u3000a", [EOL] "\u2002\u3000\r\u0085\u200A\u2005\u2000\u3000a", [EOL] "\u2029\u000B\u3000\u2008\u2003\u205F\u3000\u1680a", [EOL] "\u0009\u0020\u2006\u2001\u202F\u00A0\u000C\u2009a", [EOL] "\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000a", [EOL] // trailing spaces [EOL] "a\u200A", [EOL] "a \u0085 ", [EOL] // spaces on both sides [EOL] " a ", [EOL] " a\u00A0", [EOL] "\u0009\u0020\u2006\u2001\u202F\u00A0\u000C\u2009a" + [EOL] "\u3000\u2004\u3000\u3000\u2028\n\u2007\u3000", [EOL] }; [EOL] for (String s : equalsStrings) { [EOL] assertEquals("a", trimQueueName(s)); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testFilterTwoSideBySideReplacements() { [EOL] String path = "/profiles/123456789/test@test.com/user.json"; [EOL] String expr = "/profiles/{organization}/{email}/user.json"; [EOL] [EOL] PathFilter regexpPathUriFilter = new DefaultPathFilter("XXX", expr); [EOL] [EOL] String result = regexpPathUriFilter.filter(path); [EOL] assertThat(result, is("/profiles/XXX/XXX/user.json")); [EOL] } [EOL]
@SuppressWarnings({ "rawtypes", "unchecked" }) [EOL] 	@Test [EOL] 	public void testCustomArray() { [EOL] 		RichMapFunction<?, ?> function = new RichMapFunction<CustomArrayObject[], CustomArrayObject[]>() { [EOL] 			private static final long serialVersionUID = 1L; [EOL] [EOL] 			@Override [EOL] 			public CustomArrayObject[] map(CustomArrayObject[] value) throws Exception { [EOL] 				return null; [EOL] 			} [EOL] 		}; [EOL] [EOL] 		TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, [EOL] 				(TypeInformation) TypeInfoParser.parse("org.apache.flink.api.java.typeutils.TypeExtractorTest$CustomArrayObject[]")); [EOL] [EOL] 		Assert.assertTrue(ti instanceof ObjectArrayTypeInfo<?, ?>); [EOL] 		Assert.assertEquals(CustomArrayObject.class, ((ObjectArrayTypeInfo<?, ?>) ti).getComponentInfo().getTypeClass()); [EOL] 	} [EOL]
@Test [EOL] public void testTopEntries() throws Exception { [EOL] Vector v = new SequentialAccessSparseVector(10); [EOL] v.set(2, 3.1); [EOL] v.set(4, 1.0); [EOL] v.set(6, 8.1); [EOL] v.set(7, -100); [EOL] v.set(9, 12.2); [EOL] v.set(1, 0.0); [EOL] v.set(3, 0.0); [EOL] v.set(8, 2.7); [EOL] // check if sizeOFNonZeroElementsInVector = maxEntries [EOL] assertEquals(6, VectorHelper.topEntries(v, 6).size()); [EOL] // check if sizeOfNonZeroElementsInVector < maxEntries [EOL] assertTrue(VectorHelper.topEntries(v, 9).size() < 9); [EOL] // check if sizeOfNonZeroElementsInVector > maxEntries [EOL] assertTrue(VectorHelper.topEntries(v, 5).size() < v.getNumNonZeroElements()); [EOL] } [EOL]
@Test [EOL] 	public void count() { [EOL] 		System.out.println(Rda.at(Rdo.class).count()); [EOL] 	} [EOL]
@Test [EOL] public void testGetP2pVersion() throws Exception [EOL] { [EOL] networkManager.getP2pVersion( resourceHost ); [EOL] [EOL] verify( commandResult ).getStdOut(); [EOL] } [EOL]
@Test [EOL] public void testBasicUsage() throws Throwable { [EOL] Statement base = verifyChildDelegateStatement(); [EOL] [EOL] Statement result = mRule.apply(base, mFrameworkMethod, mTarget); [EOL] result.evaluate(); [EOL] [EOL] InOrder inOrder = Mockito.inOrder(mConfig, mBuilderProvider, mBuilder, base, mConfig, mChildConfig); [EOL] inOrder.verify(mBuilder).deepCopy(); [EOL] inOrder.verify(mBuilder).testResourcesWithoutLifecycle(mTarget); [EOL] inOrder.verify(mBuilder).buildInternal(); [EOL] inOrder.verify(mConfig).setup(mOriginal); [EOL] inOrder.verify(base).evaluate(); [EOL] inOrder.verify(mConfig).teardown(); [EOL] [EOL] assertRuleNoLongerWorks(); [EOL] } [EOL]
@Test [EOL] public void testNamespaceInScope() throws Exception { [EOL] String xml = "<?xml version=\"1.0\"?><root " + [EOL] "xmlns:a=\"http://aaa\" " + [EOL] "xmlns:b=\"http://bbb\" " + [EOL] "xmlns:c=\"http://ccc\" " + [EOL] "xmlns:d=\"http://ddd\">" + [EOL] "<a:a/></root>"; [EOL] Element xmle = Xml.loadString(xml, false); [EOL] List<Namespace> inScope = NamespaceUtils.getNamespacesInScope(xmle); [EOL] [EOL] assertContains("Expected inscope namespace " + Namespace.NO_NAMESPACE, Namespace.NO_NAMESPACE, inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("a", "http://aaa"), Namespace.getNamespace("a", "http://aaa"), inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("b", "http://bbb"), Namespace.getNamespace("b", "http://bbb"), inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("c", "http://ccc"), Namespace.getNamespace("c", "http://ccc"), inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("d", "http://ddd"), Namespace.getNamespace("d", "http://ddd"), inScope); [EOL] [EOL] Element a = xmle.getChild("a", Namespace.getNamespace("a", "http://aaa")); [EOL] inScope = NamespaceUtils.getNamespacesInScope(a); [EOL] [EOL] assertContains("Expected inscope namespace " + Namespace.NO_NAMESPACE, Namespace.NO_NAMESPACE, inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("a", "http://aaa"), Namespace.getNamespace("a", "http://aaa"), inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("b", "http://bbb"), Namespace.getNamespace("b", "http://bbb"), inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("c", "http://ccc"), Namespace.getNamespace("c", "http://ccc"), inScope); [EOL] assertContains("Expected inscope namespace " + Namespace.getNamespace("d", "http://ddd"), Namespace.getNamespace("d", "http://ddd"), inScope); [EOL] } [EOL]
@Test [EOL] public void testDefaultConfigException() throws Exception { [EOL] //default xml parser will throw TikaException [EOL] //this and TestConfig() are broken into separate tests so that [EOL] //setUp and tearDown() are called each time [EOL] String[] params = {resourcePrefix + "bad_xml.xml"}; [EOL] boolean tikaEx = false; [EOL] try { [EOL] TikaCLI.main(params); [EOL] } catch (TikaException e) { [EOL] tikaEx = true; [EOL] } [EOL] assertTrue(tikaEx); [EOL] } [EOL]
@Test [EOL] public void loadConfigurationTest() throws Exception { [EOL] for (DistributedConfigurationPublisher publisher : publishers) { [EOL] [EOL] ConfigurationManager configurationManager = configurationManagers.get(publisher.getComponent()); [EOL] configurationManager.loadConfiguration(); [EOL] [EOL] // Checking for configuration files [EOL] for (Map.Entry<String, String> entry : publisher.getPropertiesFiles().entrySet()) { [EOL] File originalFile = new File(entry.getKey()); [EOL] Properties properties = new Properties(); [EOL] try (InputStream in = new FileInputStream(originalFile)) { [EOL] properties.load(in); [EOL] } catch (Exception e) { [EOL] fail(e.getMessage()); [EOL] } [EOL] [EOL] for (String key : properties.stringPropertyNames()) { [EOL] Assert.assertEquals(properties.getProperty(key), System.getProperty(key)); [EOL] } [EOL] [EOL] String fileName = entry.getValue(); [EOL] fileName = ConfigUtils.fixForComponentHome(publisher.getComponent(), fileName); [EOL] File downloadedFile = new File(fileName); [EOL] Assert.assertNotNull(downloadedFile); [EOL] Assert.assertTrue(downloadedFile.exists()); [EOL] } [EOL] [EOL] // Checking for configuration files [EOL] for (Map.Entry<String, String> entry : publisher.getConfigFiles().entrySet()) { [EOL] String fileName = entry.getValue(); [EOL] fileName = ConfigUtils.fixForComponentHome(publisher.getComponent(), fileName); [EOL] File file = new File(fileName); [EOL] Assert.assertTrue(file.exists()); [EOL] } [EOL] [EOL] List<String> localFiles = configurationManager.getSavedFiles(); [EOL] configurationManager.clearConfiguration(); [EOL] for (String localFile : localFiles) { [EOL] File file = new File(localFile); [EOL] Assert.assertFalse(file.exists()); [EOL] } [EOL] } [EOL] } [EOL]
@Test(expected = WrongTypeException.class) [EOL] public void testBigIntegerWrongType() { [EOL] map.put("value", true); [EOL] MapValueGetter.getAsBigInteger(map, "value"); [EOL] } [EOL]
@Test [EOL] 	public void shouldNotGetPropertyValue() { [EOL] 		DummyClass clazz = new DummyClass(); [EOL] 		assertNull(PropertyUtil.getProperty(clazz, "nonExistingField")); [EOL] 	} [EOL]
@Test [EOL] public void testIsRelease() { [EOL] [EOL] assertThat(new DownloadVersion("5.0.0-rc1").isRelease()).isFalse(); [EOL] assertThat(new DownloadVersion("4.1.1-hotfix1").isRelease()).isTrue(); [EOL] assertThat(new DownloadVersion("4.1.1").isRelease()).isTrue(); [EOL] assertThat(new DownloadVersion("3.0.0-rc9").isRelease()).isFalse(); [EOL] assertThat(new DownloadVersion("1.0.0").isRelease()).isTrue(); [EOL] [EOL] } [EOL]
@Test [EOL] public void testSize() throws IOException, ExecutorManagerException { [EOL] final QueuedExecutions queue = new QueuedExecutions(5); [EOL] final List<Pair<ExecutionReference, ExecutableFlow>> dataList = getDummyData(); [EOL] queue.enqueueAll(dataList); [EOL] Assert.assertEquals(queue.size(), 2); [EOL] } [EOL]
@Test [EOL] void executionStarted() { [EOL] final ExecutionStartedEvent e = EventFactory.executionStarted(mockPortfolioOverview()); [EOL] assertThat(e.getPortfolioOverview()).isNotNull(); [EOL] } [EOL]
@Test [EOL] public void closeDelegates() { [EOL] [EOL] // given [EOL] ChronicleMap<CharSequence, ItemSource> chronicleMap = createDefaultTestChronicleMap(); [EOL] [EOL] ChronicleMapProxy proxy = createDefaultTestProxy(chronicleMap); [EOL] [EOL] // when [EOL] proxy.close(); [EOL] [EOL] // then [EOL] Mockito.verify(chronicleMap).close(); [EOL] [EOL] } [EOL]
@Test [EOL] 	public void testOrFalse() [EOL] 	{ [EOL] 		FilterFilter filter = new FilterFilter(); [EOL] 		assertFalse(filter.apply(new OrOperator())); [EOL] 	} [EOL]
@Test [EOL] public void testToSnapshotNotHumanReadable() { [EOL] long snapshotLength = 1111; [EOL] long snapshotFileCount = 2222; [EOL] long snapshotDirectoryCount = 3333; [EOL] long snapshotSpaceConsumed = 4444; [EOL] [EOL] ContentSummary contentSummary = new ContentSummary.Builder() [EOL] .snapshotLength(snapshotLength).snapshotFileCount(snapshotFileCount) [EOL] .snapshotDirectoryCount(snapshotDirectoryCount) [EOL] .snapshotSpaceConsumed(snapshotSpaceConsumed).build(); [EOL] String expected = [EOL] " 1111 2222 3333 " [EOL] + " 4444 "; [EOL] assertEquals(expected, contentSummary.toSnapshot(false)); [EOL] } [EOL]
@Test [EOL] void unescapeOtherEscapes() [EOL] { [EOL] assertEquals("&deg;", XMLUtils.unescape("&deg;"), "Extra named entities were unescaped"); [EOL] assertEquals("&#65;", XMLUtils.unescape("&#65;"), "Extra decimal entities were unescaped"); [EOL] assertEquals("&#x5;", XMLUtils.unescape("&#x5;"), "Extra hexadecimal entities were unescaped"); [EOL] } [EOL]
@Test [EOL] public void channelMapExtractor() { [EOL] assertNotNull(Extractors.channelMapExtractor(channel("test1"))); [EOL] } [EOL]
@Test [EOL] public void test_getWorkloadDetails_failed() throws Exception { [EOL] String workloadResponse = "[{\"appName\":\"Other\",\"appTag\":\"Other\",\"appID\":\"oth\"}]"; [EOL] [EOL] ReflectionTestUtils.setField(workloadDetailsService, "workloadEndpoint", "http://appdetails.com"); [EOL] when(ControllerUtil.getCwmToken()).thenReturn("dG9rZW4="); [EOL] when(HttpClientBuilder.create()).thenReturn(httpClientBuilder); [EOL] when(httpClientBuilder.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)).thenReturn(httpClientBuilder); [EOL] when(httpClientBuilder.setSSLContext(any())).thenReturn(httpClientBuilder); [EOL] when(httpClientBuilder.setRedirectStrategy(any())).thenReturn(httpClientBuilder); [EOL] when(httpClientBuilder.build()).thenReturn(httpClient1); [EOL] when(httpClient1.execute(any())).thenReturn(httpResponse); [EOL] [EOL] when(httpResponse.getStatusLine()).thenReturn(statusLine); [EOL] when(statusLine.getStatusCode()).thenReturn(400); [EOL] [EOL] when(JSONUtil.getJSON(anyList())).thenReturn(workloadResponse); [EOL] [EOL] ResponseEntity<String> responseEntityExpected = ResponseEntity.status(HttpStatus.OK).body("[{\"appName\":\"Other\",\"appTag\":\"Other\",\"appID\":\"oth\"}]"); [EOL] [EOL] ResponseEntity<String> responseEntityActual = workloadDetailsService.getWorkloadDetails(token, userDetails); [EOL] assertEquals(responseEntityExpected.getStatusCode(), responseEntityActual.getStatusCode()); [EOL] assertEquals(responseEntityExpected, responseEntityActual); [EOL] [EOL] } [EOL]
@Test [EOL] public void retrieveFactModelTuple() { [EOL] businessCentralDmnDataManagementStrategySpy.retrieveFactModelTuple(testToolsPresenterMock, scenarioSimulationContextLocal, GridWidget.SIMULATION, "DMN_FILE_PATH"); [EOL] verify(businessCentralDmnDataManagementStrategySpy, times(1)).getSuccessCallback(eq(testToolsPresenterMock), eq(scenarioSimulationContextLocal), eq(GridWidget.SIMULATION)); [EOL] verify(dmnTypeServiceMock, times(1)).retrieveFactModelTuple(eq(currentPathMock), eq("DMN_FILE_PATH")); [EOL] } [EOL]
@Test [EOL] public void testIsAdjacent() { [EOL] GraphStore graphStore = GraphGenerator.generateTinyGraphStore(); [EOL] Node n1 = graphStore.getNode("1"); [EOL] Node n2 = graphStore.getNode("2"); [EOL] [EOL] Assert.assertTrue(graphStore.isAdjacent(n1, n2)); [EOL] Assert.assertFalse(graphStore.isAdjacent(n2, n1)); [EOL] graphStore.clearEdges(); [EOL] Assert.assertFalse(graphStore.isAdjacent(n1, n2)); [EOL] } [EOL]
@Test public void shouldReturnDeckLength() { [EOL] int length = dealer.getDeckLength(); [EOL] [EOL] assertThat(length).isEqualTo(3); [EOL] } [EOL]
@Test [EOL] 	public void testReadFileContentQuietly_exception() throws Exception { [EOL] [EOL] 		File output = this.folder.newFolder(); [EOL] 		String readS = Utils.readFileContentQuietly( output, Logger.getLogger( getClass().getName())); [EOL] 		Assert.assertEquals( "", readS ); [EOL] 	} [EOL]
@Test [EOL] void get2() { [EOL] assertEquals(m2, instance.get2()); [EOL] } [EOL]
@Test [EOL] void unescapeNullContent() [EOL] { [EOL] StringBuilder content = null; [EOL] assertNull(XMLUtils.unescape(content)); [EOL] } [EOL]
@Test [EOL] void get13Test() { [EOL] assertEquals(13, (int) instance.get13().orElseThrow(NoSuchElementException::new)); [EOL] } [EOL]
@Test [EOL] void createPolicy() { [EOL] AutoScalingPolicy policy = loader.createPolicy("as", "scale-out", ">=80%", "3min", "15%"); [EOL] [EOL] assertEquals("as-scale-out", policy.id); [EOL] assertEquals(80d, policy.cpuUtilizationPercentage, 0.0001); [EOL] assertEquals(ComparisonOperator.GreaterThanOrEqualToThreshold, policy.comparisonOperator); [EOL] assertEquals(3, policy.lastMinutes); [EOL] assertEquals(15, policy.adjustmentPercentage); [EOL] } [EOL]
@Test [EOL] public void handleMethodsAnnotationShouldSetDeserializer() throws Exception { [EOL] when(mockAnnotation.value()).thenReturn((Class)StringDeserializer.class); [EOL] toTest.handleMethodAnnotation(mockAnnotation, mockMethodConfigBuilder); [EOL] verify(mockAnnotation).value(); [EOL] verify(mockMethodConfigBuilder).setDeserializer(StringDeserializer.class); [EOL] } [EOL]
@Test [EOL] void testValidatePropertyPath_invalid() { [EOL] AppConfig appConfig = new AppConfig(); [EOL] ConfigMapper configMapper = new ConfigMapper(appConfig); [EOL] [EOL] boolean isValid = configMapper.validatePropertyPath(PropertyPath.fromPathString("stroom.unknown.prop")); [EOL] [EOL] assertThat(isValid).isFalse(); [EOL] } [EOL]
@Test [EOL] 	public void toStrictlyImproving() { [EOL] 		final ISeq<Integer> values = new Random().ints(0, 100) [EOL] 			.boxed() [EOL] 			.limit(500) [EOL] 			.flatMap(MinMax.toStrictlyImproving(Comparator.naturalOrder())) [EOL] 			.collect(ISeq.toISeq()); [EOL] [EOL] 		Assert.assertTrue(values.isSorted()); [EOL] 	} [EOL]
@Test [EOL] 	public void testParse() throws Exception { [EOL] 		assumeTrue(canRun()); [EOL] 		 [EOL] 		String resource = "/test-documents/testOCTET_header.dbase3"; [EOL] [EOL] 		String[] content = { "CLASSNO", "TITLE", "ITEMNO", "LISTNO", "LISTDATE" }; [EOL] 		 [EOL] 		String[] met_attributes = {"min-len", "encoding", "strings:file_output"}; [EOL] [EOL] 		StringsConfig stringsConfig = new StringsConfig(); [EOL] 		FileConfig fileConfig = new FileConfig(); [EOL] [EOL] 		Parser parser = new StringsParser(); [EOL] 		ContentHandler handler = new BodyContentHandler(); [EOL] 		Metadata metadata = new Metadata(); [EOL] [EOL] 		ParseContext context = new ParseContext(); [EOL] 		context.set(StringsConfig.class, stringsConfig); [EOL] 		context.set(FileConfig.class, fileConfig); [EOL] [EOL] 		try (InputStream stream = StringsParserTest.class.getResourceAsStream(resource)) { [EOL] 			parser.parse(stream, handler, metadata, context); [EOL] 		} catch (Exception e) { [EOL] 			e.printStackTrace(); [EOL] 		} [EOL] [EOL] 		// Content [EOL] 		for (String word : content) { [EOL] 			assertTrue(handler.toString().contains(word)); [EOL] 		} [EOL] 		 [EOL] 		// Metadata [EOL] 		Arrays.equals(met_attributes, metadata.names()); [EOL] 	} [EOL]
@Test [EOL] public void testFilterAclEntriesByAclSpecAutomaticDefaultOther() [EOL] throws AclException { [EOL] List<AclEntry> existing = new ImmutableList.Builder<AclEntry>() [EOL] .add(aclEntry(ACCESS, USER, ALL)) [EOL] .add(aclEntry(ACCESS, GROUP, READ)) [EOL] .add(aclEntry(ACCESS, OTHER, READ)) [EOL] .add(aclEntry(DEFAULT, USER, READ_WRITE)) [EOL] .add(aclEntry(DEFAULT, GROUP, READ_WRITE)) [EOL] .add(aclEntry(DEFAULT, OTHER, NONE)) [EOL] .build(); [EOL] List<AclEntry> aclSpec = Lists.newArrayList( [EOL] aclEntry(DEFAULT, OTHER)); [EOL] List<AclEntry> expected = new ImmutableList.Builder<AclEntry>() [EOL] .add(aclEntry(ACCESS, USER, ALL)) [EOL] .add(aclEntry(ACCESS, GROUP, READ)) [EOL] .add(aclEntry(ACCESS, OTHER, READ)) [EOL] .add(aclEntry(DEFAULT, USER, READ_WRITE)) [EOL] .add(aclEntry(DEFAULT, GROUP, READ_WRITE)) [EOL] .add(aclEntry(DEFAULT, OTHER, READ)) [EOL] .build(); [EOL] assertEquals(expected, filterAclEntriesByAclSpec(existing, aclSpec)); [EOL] } [EOL]
@Test [EOL] 	public void readorbitInformation() { [EOL] 		try { [EOL] 			SumoSafeReader safeReader=new SumoSafeReader(safeFile); [EOL] 			safeReader.readAcquisitionPeriod(); [EOL] 			safeReader.readorbitInformation(); [EOL] 		} catch (JDOMException e) { [EOL] 			fail(e.getMessage()); [EOL] 		} catch (IOException e) { [EOL] 			fail(e.getMessage()); [EOL] 		} catch (Exception e) { [EOL] 			e.printStackTrace(); [EOL] 			fail(e.getMessage()); [EOL] 		} [EOL] 		 [EOL] 	} [EOL]
@Test [EOL] public void testCaseFlag() { [EOL] RowFilter<TableModel, Integer> filter = RowFilters.regexFilter(Pattern.CASE_INSENSITIVE, "jeff"); [EOL] entry.modelIndex = 3; [EOL] assertTrue(filter.include(entry)); [EOL] } [EOL]
@Test [EOL] public void badInputZipStrFile() throws Exception { [EOL] [EOL] File destFile = new File(destDir, "badInputStrFile.zip"); [EOL] [EOL] try { [EOL] [EOL] // Null input filenames array, correct destination file [EOL] try { [EOL] ZipUtil.zip((String[]) null, destFile, true, 0); [EOL] logger.error("Zip should fail when input String array is null"); [EOL] Assert.fail("Zip should fail when input String array is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] logger.debug("Detecting null input File array (String, File): OK"); [EOL] } [EOL] [EOL] // Null some of the input filenames, correct destination file [EOL] try { [EOL] ZipUtil.zip(new String[] { srcFile.getCanonicalPath(), null, nestedSrcFile.getCanonicalPath() }, destFile, [EOL] true, ZipUtil.NO_COMPRESSION); [EOL] logger.error("Zip should fail when any input filename is null"); [EOL] Assert.fail("Zip should fail when any input filename is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] logger.debug("Detecting null input filename (String, File): OK"); [EOL] } [EOL] [EOL] // Non-existing some of the input filenames, correct destination file [EOL] try { [EOL] ZipUtil.zip( [EOL] new String[] { srcFile.getCanonicalPath(), dummieFile.getCanonicalPath(), [EOL] nestedSrcFile.getCanonicalPath() }, destFile, true, ZipUtil.NO_COMPRESSION); [EOL] logger.error("Zip should fail when any input filename does not exist"); [EOL] Assert.fail("Zip should fail when any input filename does not exist"); [EOL] } catch (FileNotFoundException e) { [EOL] logger.debug("Detecting non-existing input filename (String, File): OK"); [EOL] } [EOL] [EOL] // Correct input filenames array, null destination file [EOL] try { [EOL] ZipUtil.zip(new String[] { srcFile.getCanonicalPath(), nestedSrcFile.getCanonicalPath() }, (File) null, true, [EOL] ZipUtil.NO_COMPRESSION); [EOL] logger.error("Zip should fail when destination File is null"); [EOL] Assert.fail("Zip should fail when destination File is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] logger.debug("Detecting null destination File (String, File): OK"); [EOL] } [EOL] [EOL] // Correct input filenames, existing destination file [EOL] try { [EOL] ZipUtil.zip(new String[] { srcFile.getCanonicalPath(), nestedSrcFile.getCanonicalPath() }, sampleZip, true, [EOL] ZipUtil.NO_COMPRESSION); [EOL] logger.error("Zip should fail when destination file already exists"); [EOL] Assert.fail("Zip should fail when destination file already exists"); [EOL] } catch (IllegalArgumentException e) { [EOL] logger.debug("Detecting existing destination File (String, File): OK"); [EOL] } [EOL] [EOL] // Correct input filenames, invalid name for the zip file [EOL] try { [EOL] ZipUtil.zip(new String[] { srcFile.getCanonicalPath(), nestedSrcFile.getCanonicalPath() }, dummieFile, true, [EOL] ZipUtil.NO_COMPRESSION); [EOL] logger.error("Zip should fail when the destination File does not represent a zip file"); [EOL] Assert.fail("Zip should fail when the destination File does not represent a zip file"); [EOL] } catch (IllegalArgumentException e) { [EOL] logger.debug("Detecting destination File not representing a valid zip file (String, File): OK"); [EOL] } [EOL] [EOL] } catch (Exception e) { [EOL] logger.error("Another exception was expected, but got {} instead: {}", e.getClass().getName(), e.getMessage()); [EOL] Assert.fail("Another exception was expected, but got " + e.getClass().getName() + " instead: " + e.getMessage()); [EOL] } [EOL] [EOL] } [EOL]
@Test [EOL] 	public void testFindRevType_when_modifiedEntity_size_is_one() { [EOL] [EOL] 		List<ModifiedEntityTypeEntity> modifiedEntityTypeEntitys = new ArrayList<ModifiedEntityTypeEntity>(); [EOL] 		modifiedEntityTypeEntitys.add(mock(ModifiedEntityTypeEntity.class)); [EOL] 		when(modifiedEntityTypeEntitys.get(0).getRevisionType()).thenReturn( [EOL] 				(byte) 2); [EOL] 		AuditService pasutSpy = spy(pasut); [EOL] 		pasutSpy.findRevType(modifiedEntityTypeEntitys); [EOL] 		verify(pasutSpy, times(1)).findRevType((byte) 2); [EOL] [EOL] 	} [EOL]
@Test [EOL] public void testFileNameRegex() throws Exception { [EOL] assertTrue("20000701120000-ESACCI-L4_GHRSST-SSTdepth-OSTIA-GLOB_LT-v02.0-fv01.0.nc".matches(FILE_TYPE.getFilenameRegex())); [EOL] assertTrue("20000701120000-ESACCI-L4_GHRSST-SSTskin-OSTIA-GLOB_LT-v02.0-fv01.0.nc".matches(FILE_TYPE.getFilenameRegex())); [EOL] assertTrue("20000701120000-ESACCI-L4_GHRSST-SSTsubskin-OSTIA-GLOB_LT-v02.0-fv01.0.nc".matches(FILE_TYPE.getFilenameRegex())); [EOL] assertTrue("20000701120000-ESACCI-L4_GHRSST-SSTfnd-OSTIA-GLOB_LT-v02.0-fv01.0.nc".matches(FILE_TYPE.getFilenameRegex())); [EOL] } [EOL]
@Test [EOL] public void testCsvStream4() throws IOException, CsvParseException { [EOL] CsvReader reader = Csv.readerNoBOM(new PushbackReader(new StringReader("bla,\"bla\"\n"))); [EOL] Assert.assertEquals(TokenType.ELEMENT, reader.next()); [EOL] Assert.assertEquals("bla", reader.getElement().toString()); [EOL] Assert.assertEquals(TokenType.ELEMENT, reader.next()); [EOL] Assert.assertEquals("bla", reader.getElement().toString()); [EOL] Assert.assertEquals(TokenType.END_ROW, reader.next()); [EOL] Assert.assertEquals(TokenType.END_DOCUMENT, reader.next()); [EOL] Assert.assertEquals(TokenType.END_DOCUMENT, reader.next()); [EOL] } [EOL]
@Test [EOL] public void encodeUtf16() throws Exception { [EOL] Codec codec = CodecMethod.ASCII.getCodec(); [EOL] String encoded = codec.encode(UTF_16_STR); [EOL] assertEquals("128167", encoded); [EOL] } [EOL]
@Test [EOL] public void testDoUpdateForClusterCreate_Storm_Nimbus_HA_Enabled__defaultValues_YAML() throws Exception { [EOL] Map<String, Map<String, String>> properties = new HashMap<String, Map<String, String>>(); [EOL] Map<String, String> typeProps = new HashMap<String, String>(); [EOL] typeProps.put("nimbus.seeds", "localhost"); [EOL] properties.put("storm-site", typeProps); [EOL] [EOL] Configuration clusterConfig = new Configuration(properties, Collections.<String, Map<String, Map<String, String>>>emptyMap()); [EOL] [EOL] Collection<String> hgComponents = new HashSet<String>(); [EOL] hgComponents.add("NIMBUS"); [EOL] [EOL] TestHostGroup group1 = new TestHostGroup("group1", hgComponents, Collections.singleton("testhost")); [EOL] [EOL] Collection<String> hgComponents2 = new HashSet<String>(); [EOL] hgComponents2.add("NIMBUS"); [EOL] [EOL] Set<String> hosts2 = new HashSet<String>(); [EOL] hosts2.add("testhost2"); [EOL] [EOL] TestHostGroup group2 = new TestHostGroup("group2", hgComponents2, hosts2); [EOL] [EOL] Collection<TestHostGroup> hostGroups = new HashSet<TestHostGroup>(); [EOL] hostGroups.add(group1); [EOL] hostGroups.add(group2); [EOL] [EOL] ClusterTopology topology = createClusterTopology(bp, clusterConfig, hostGroups); [EOL] BlueprintConfigurationProcessor updater = new BlueprintConfigurationProcessor(topology); [EOL] [EOL] updater.doUpdateForClusterCreate(); [EOL] String updatedVal = topology.getConfiguration().getFullProperties().get("storm-site").get("nimbus.seeds"); [EOL] assertTrue("Updated YAML value should start with bracket", updatedVal.startsWith("[")); [EOL] assertTrue("Updated YAML value should end with bracket", updatedVal.endsWith("]")); [EOL] // remove the surrounding brackets [EOL] updatedVal = updatedVal.replaceAll("[\\[\\]]", ""); [EOL] [EOL] String[] hosts = updatedVal.split(","); [EOL] [EOL] Collection<String> expectedHosts = new HashSet<String>(); [EOL] expectedHosts.add("testhost"); [EOL] expectedHosts.add("testhost2"); [EOL] [EOL] assertEquals("Incorrect number of hosts found in updated Nimbus config property", 2, hosts.length); [EOL] for (String host : hosts) { [EOL] assertTrue("Expected host name = " + host + " not found in updated Nimbus config property", expectedHosts.contains(host)); [EOL] expectedHosts.remove(host); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testErrorHandlerViaProperty() { [EOL] try { [EOL] RxJavaPlugins p = new RxJavaPlugins(); [EOL] String fullClass = getFullClassNameForTestClass(RxJavaErrorHandlerTestImpl.class); [EOL] System.setProperty("rxjava.plugin.RxJavaErrorHandler.implementation", fullClass); [EOL] RxJavaErrorHandler impl = p.getErrorHandler(); [EOL] assertTrue(impl instanceof RxJavaErrorHandlerTestImpl); [EOL] } finally { [EOL] System.clearProperty("rxjava.plugin.RxJavaErrorHandler.implementation"); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testSubstituteArguments() throws Exception [EOL] { [EOL] //simple substitute [EOL] String newPropertyId = AbstractPropertyProvider.substituteArgument("category/name1/$1/name2/$2", "$1", "foo"); [EOL] Assert.assertEquals("category/name1/foo/name2/$2", newPropertyId); [EOL] [EOL] newPropertyId = AbstractPropertyProvider.substituteArgument("category/name1/$1/name2/$2", "$2", "bar"); [EOL] Assert.assertEquals("category/name1/$1/name2/bar", newPropertyId); [EOL] [EOL] //substitute with method [EOL] newPropertyId = AbstractPropertyProvider.substituteArgument( [EOL] "category/name1/$1.toLowerCase()/name2/$2.toUpperCase()", "$1", "FOO"); [EOL] Assert.assertEquals("category/name1/foo/name2/$2.toUpperCase()", newPropertyId); [EOL] [EOL] newPropertyId = AbstractPropertyProvider.substituteArgument( [EOL] "category/name1/$1.toLowerCase()/name2/$2.toUpperCase()", "$2", "bar"); [EOL] Assert.assertEquals("category/name1/$1.toLowerCase()/name2/BAR", newPropertyId); [EOL] [EOL] //substitute with chained methods [EOL] newPropertyId = AbstractPropertyProvider.substituteArgument( [EOL] "category/name1/$1.toLowerCase().substring(1)/name2", "$1", "FOO"); [EOL] Assert.assertEquals("category/name1/oo/name2", newPropertyId); [EOL] [EOL] newPropertyId = AbstractPropertyProvider.substituteArgument( [EOL] "category/name1/$1.toLowerCase().substring(1).concat(\"_post\")/name2/$2.concat(\"_post\")", "$1", "FOO"); [EOL] newPropertyId = AbstractPropertyProvider.substituteArgument(newPropertyId, "$2", "bar"); [EOL] Assert.assertEquals("category/name1/oo_post/name2/bar_post", newPropertyId); [EOL] } [EOL]
@Test [EOL] public void testIssue144() throws Exception { [EOL] UIManager.put("Addon.title", "customized"); [EOL] UIManager.put("Addon.border", new LineBorder(Color.blue)); [EOL] [EOL] Addon addon = new Addon(); [EOL] LookAndFeelAddons.contribute(addon); [EOL] [EOL] assertEquals("customized", UIManager.get("Addon.title")); [EOL] assertEquals("my subtitle", UIManager.get("Addon.subtitle")); [EOL] assertTrue(UIManager.get("Addon.border") instanceof LineBorder); [EOL] [EOL] UIManager.put("Addon.title", null); [EOL] assertEquals("my title", UIManager.get("Addon.title")); [EOL] } [EOL]
@Test [EOL] 	public void testValidateExampleInvalidExtraProperties() throws Exception { [EOL] 		expectedException.expect(JSONValidatorException.class); [EOL] 		expectedException.expectMessage( [EOL] 			new StringStartsWith("extraneous key [extra] is not permitted")); [EOL] [EOL] 		JSONValidator.validate( [EOL] 			_read("example_invalid_extra_properties.json"), [EOL] 			_readJSONSchemaAsStream()); [EOL] 	} [EOL]
@Test [EOL] public void canResolve_should_notHandleOtherReferences() { [EOL] assertThat(resolver.canResolve(anotherReference), is(false)); [EOL] } [EOL]
@Test [EOL] public void testCreatePedigreeWithMismatchedSampleNameAndPedigreeMember() { [EOL] assertThrows(RuntimeException.class, () -> [EOL] PedigreeSampleValidator.validate(VALID_PEDIGREE, SampleIdentifier.of("Seth", 2), ImmutableList.of("Adam", "Marge", "Seth")) [EOL] ); [EOL] } [EOL]
@Test [EOL] public void testActivity() throws Exception { [EOL] User user = new User(); [EOL] mListingActivity.onUserClick(user); [EOL] Mockito.verify(mListingPresenter).onItemClicked(user); [EOL] } [EOL]
@Test [EOL] public void inOrder_leftNodeIsNull() { [EOL] Tree<String> tree = tree("foo").setRight("right"); [EOL] assertThat(Tree.<String>walker().inOrderFrom(tree).map(Tree::value)) [EOL] .containsExactly("foo", "right") [EOL] .inOrder(); [EOL] } [EOL]
@Test [EOL] public void testParseMaps() { [EOL] DistCpOptions options = OptionsParser.parse(new String[] { [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] assertThat(options.getMaxMaps()).isEqualTo(DistCpConstants.DEFAULT_MAPS); [EOL] [EOL] options = OptionsParser.parse(new String[] { [EOL] "-m", [EOL] "1", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] assertThat(options.getMaxMaps()).isEqualTo(1); [EOL] [EOL] options = OptionsParser.parse(new String[] { [EOL] "-m", [EOL] "0", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] assertThat(options.getMaxMaps()).isEqualTo(1); [EOL] [EOL] try { [EOL] OptionsParser.parse(new String[] { [EOL] "-m", [EOL] "hello", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.fail("Non numberic map parsed"); [EOL] } catch (IllegalArgumentException ignore) { } [EOL] [EOL] try { [EOL] OptionsParser.parse(new String[] { [EOL] "-mapredXslConf", [EOL] "hdfs://localhost:8020/source/first", [EOL] "hdfs://localhost:8020/target/"}); [EOL] Assert.fail("Non numberic map parsed"); [EOL] } catch (IllegalArgumentException ignore) { } [EOL] } [EOL]
@Test [EOL] void validateNotNull() { [EOL] assertThatThrownBy(() -> new BeanValidatorBuilder(BeanWithDefaultValue.class).build()) [EOL] .isInstanceOf(Error.class) [EOL] .hasMessageContaining("field with default value must have @NotNull"); [EOL] } [EOL]
@Test [EOL] 	public void testMerge() { [EOL] 		Assert.assertNull(StringUtil.merge((boolean[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((byte[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((char[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((double[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((float[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((int[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((long[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((short[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((String[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((Object[])null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((Object[])null, null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((ArrayList<Object>)null, null)); [EOL] 		Assert.assertNull( [EOL] 			StringUtil.merge((ArrayList<Object>)null, null, null)); [EOL] 		Assert.assertNull(StringUtil.merge((Collection<Object>)null, null)); [EOL] 		Assert.assertNull( [EOL] 			StringUtil.merge((Collection<Object>)null, null, null)); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new boolean[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new byte[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new char[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new double[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new float[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new int[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new long[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new short[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new String[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new Object[0], null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new Object[0], null, null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new ArrayList<>(), null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new ArrayList<>(), null, null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new LinkedList<>(), null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new LinkedList<>(), null, null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(Arrays.asList(), null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(Arrays.asList(), null, null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new HashSet<>(), null)); [EOL] 		Assert.assertEquals( [EOL] 			StringPool.BLANK, StringUtil.merge(new HashSet<>(), null, null)); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			StringPool.TRUE, StringUtil.merge(new boolean[] {true}, null)); [EOL] 		Assert.assertEquals("1", StringUtil.merge(new byte[] {1}, null)); [EOL] 		Assert.assertEquals("a", StringUtil.merge(new char[] {'a'}, null)); [EOL] 		Assert.assertEquals("1.2", StringUtil.merge(new double[] {1.2D}, null)); [EOL] 		Assert.assertEquals("1.0", StringUtil.merge(new float[] {1.0F}, null)); [EOL] 		Assert.assertEquals("2", StringUtil.merge(new int[] {2}, null)); [EOL] 		Assert.assertEquals("3", StringUtil.merge(new long[] {3L}, null)); [EOL] 		Assert.assertEquals("4", StringUtil.merge(new short[] {4}, null)); [EOL] 		Assert.assertEquals( [EOL] 			"abc", StringUtil.merge(new String[] {"abc"}, null)); [EOL] 		Assert.assertEquals("4", StringUtil.merge(new Object[] {4}, null)); [EOL] 		Assert.assertEquals( [EOL] 			"5x", [EOL] 			StringUtil.merge( [EOL] 				new Object[] {5}, object -> object.toString() + "x", null)); [EOL] 		Assert.assertEquals( [EOL] 			"a", StringUtil.merge(new ArrayList<>(Arrays.asList("a")), null)); [EOL] 		Assert.assertEquals( [EOL] 			"ax", [EOL] 			StringUtil.merge( [EOL] 				new ArrayList<>(Arrays.asList("a")), s -> s + "x", null)); [EOL] 		Assert.assertEquals("a", StringUtil.merge(Arrays.asList("a"), null)); [EOL] 		Assert.assertEquals( [EOL] 			"ax", StringUtil.merge(Arrays.asList("a"), s -> s + "x", null)); [EOL] 		Assert.assertEquals( [EOL] 			"a", StringUtil.merge(new HashSet<>(Arrays.asList("a")), null)); [EOL] 		Assert.assertEquals( [EOL] 			"ax", [EOL] 			StringUtil.merge( [EOL] 				new HashSet<>(Arrays.asList("a")), s -> s + "x", null)); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			"true,false", [EOL] 			StringUtil.merge(new boolean[] {true, false}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"1,2", StringUtil.merge(new byte[] {1, 2}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"a,b", StringUtil.merge(new char[] {'a', 'b'}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"1.2,3.4", [EOL] 			StringUtil.merge(new double[] {1.2D, 3.4D}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"1.0,2.0", [EOL] 			StringUtil.merge(new float[] {1.0F, 2.0F}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"2,3", StringUtil.merge(new int[] {2, 3}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"3,4", StringUtil.merge(new long[] {3L, 4L}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"4,5", StringUtil.merge(new short[] {4, 5}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"abc,def", [EOL] 			StringUtil.merge(new String[] {"abc", "def"}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"4,x", StringUtil.merge(new Object[] {4, "x"}, StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"5x,ax", [EOL] 			StringUtil.merge( [EOL] 				new Object[] {5, 'a'}, object -> object.toString() + "x", [EOL] 				StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"a,b", [EOL] 			StringUtil.merge( [EOL] 				new ArrayList<>(Arrays.asList("a", "b")), StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"ax,bx", [EOL] 			StringUtil.merge( [EOL] 				new ArrayList<>(Arrays.asList("a", "b")), s -> s + "x", [EOL] 				StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"a,b", StringUtil.merge(Arrays.asList("a", "b"), StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"ax,bx", [EOL] 			StringUtil.merge( [EOL] 				Arrays.asList("a", "b"), s -> s + "x", StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"a,b", [EOL] 			StringUtil.merge( [EOL] 				new HashSet<>(Arrays.asList("a", "b")), StringPool.COMMA)); [EOL] 		Assert.assertEquals( [EOL] 			"ax,bx", [EOL] 			StringUtil.merge( [EOL] 				new HashSet<>(Arrays.asList("a", "b")), s -> s + "x", [EOL] 				StringPool.COMMA)); [EOL] 	} [EOL]
@Test [EOL] public void testDefaultPrefix() { [EOL] SLF4JSegmentListener listener = (SLF4JSegmentListener) AWSXRay.getGlobalRecorder().getSegmentListeners().get(0); [EOL] Segment seg = new SegmentImpl(AWSXRay.getGlobalRecorder(), "test", traceID); [EOL] [EOL] listener.onSetEntity(null, seg); [EOL] [EOL] Assert.assertEquals(TRACE_ID_KEY + ": " + traceID.toString() + "@" + seg.getId(), MDC.get(TRACE_ID_KEY)); [EOL] } [EOL]
@Test(timeout = 60000) [EOL] public void testLaunch() throws Exception { [EOL] [EOL] ExitUtil.disableSystemExit(); [EOL] try { [EOL] historyServer = [EOL] ApplicationHistoryServer.launchAppHistoryServer(new String[0]); [EOL] } catch (ExitUtil.ExitException e) { [EOL] assertEquals(0, e.status); [EOL] ExitUtil.resetFirstExitException(); [EOL] fail(); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testZeros() { [EOL] Empirical z = new Empirical(true, true, 3, 0, 1, 0.5, 2, 1, 3.0); [EOL] assertEquals(-16.52, z.sample(0), 1.0e-2); [EOL] assertEquals(20.47, z.sample(1), 1.0e-2); [EOL] } [EOL]
@Test [EOL] public void getIdentityNoServerResponse() throws Exception { [EOL] [EOL] thrown.expect(IdentityException.class); [EOL] thrown.expectMessage("Error while getting user"); [EOL] [EOL] HFCAClient client = HFCAClient.createNewInstance("http://localhost:99", null); [EOL] client.setCryptoSuite(crypto); [EOL] [EOL] HFCAIdentity ident = client.newHFCAIdentity("testuser1"); [EOL] ident.read(admin); [EOL] } [EOL]
@Test [EOL] public void testTokenizeWithLayoutToken_emptyText() { [EOL] assertThat(target.tokenizeWithLayoutToken(""), hasSize(0)); [EOL] } [EOL]
@Test [EOL] public void testBufferSizeParam() { [EOL] final BufferSizeParam p = new BufferSizeParam(BufferSizeParam.DEFAULT); [EOL] Assert.assertEquals(null, p.getValue()); [EOL] Assert.assertEquals( [EOL] conf.getInt(CommonConfigurationKeysPublic.IO_FILE_BUFFER_SIZE_KEY, [EOL] CommonConfigurationKeysPublic.IO_FILE_BUFFER_SIZE_DEFAULT), [EOL] p.getValue(conf)); [EOL] [EOL] new BufferSizeParam(1); [EOL] [EOL] try { [EOL] new BufferSizeParam(0); [EOL] Assert.fail(); [EOL] } catch(IllegalArgumentException e) { [EOL] LOG.info("EXPECTED: " + e); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testCalculateBestPhenotypeMatchesByTermReturnsEmptyMapForEmptyInputList() { [EOL] assertThat(instance.calculateBestPhenotypeMatchesByTerm(Collections.emptyList()), equalTo(Collections.emptyList())); [EOL] } [EOL]
@Test [EOL] void testResponseCompleted() throws Exception { [EOL] unit.responseCompleted(context); [EOL] verify(delegate).responseCompleted(context); [EOL] } [EOL]
@Test [EOL] 	public void updateTest() { [EOL] 		Mockito.when(middlewareRepository.findByApiIdAndId(Mockito.anyLong(), Mockito.anyLong())).thenReturn(middleware); [EOL] 		Mockito.when(middlewareRepository.findByApiIdAndVersion(Mockito.anyLong(), Mockito.anyString())).thenReturn(null); [EOL] 		middleware.setVersion("0.0.2"); [EOL] 		Mockito.when(middlewareRepository.save(Mockito.any(Middleware.class))).thenReturn(middleware); [EOL] 		Middleware updated = service.update(1L, 1L, middlewareDTO); [EOL] [EOL] 		assertEquals(middleware, updated); [EOL] [EOL] 	} [EOL]
@Test [EOL] 	public void testIsQualifiedForQualifiedName() [EOL] 	{ [EOL] 		boolean isQualified = NamesUtil.isQualifiedName("java.lang.Comparable"); [EOL] 		Assert.assertTrue("Class name not constructed correctly", isQualified); [EOL] 	} [EOL]
@Test [EOL] public void processRequestModulesStateFilter() throws Exception { [EOL] String request = [EOL] "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + [EOL] "<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" message-id=\"152026367257\">\n" + [EOL] " <get>\n" + [EOL] " <source>\n" + [EOL] " <running />\n" + [EOL] " </source>\n" + [EOL] " <filter type=\"subtree\">\n" + [EOL] " <modules-state xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-library\">\n" + [EOL] " <module-set-id>all</module-set-id>\n" + [EOL] " </modules-state>\n" + [EOL] " </filter>\n" + [EOL] " </get>\n" + [EOL] "</rpc>\n"; [EOL] [EOL] String response = ietfYangLibrary.processRequest(m_clientInfo, request); [EOL] assertTrue(response.contains("modules-state")); [EOL] } [EOL]
@Test [EOL] public void testValueOfNull() throws Exception { [EOL] ObjectReference or = this.getObjectReference("Foo"); [EOL] assertNull("Should return null for evaluating \"null\".", formatter.valueOf("null", or.referenceType(), new HashMap<>())); [EOL] assertNull("Should return null for evaluating null.", formatter.valueOf(null, or.referenceType(), new HashMap<>())); [EOL] } [EOL]
@Test [EOL] public void test_keySet_empty() { [EOL] assertEquals(Collections.<String>emptySet(), new CascadingMap<String, String>().keySet()); [EOL] } [EOL]
@Test [EOL] public void addMissingProjectDependencies() throws IOException { [EOL] InputStream inputStream = new NamedGraphBuilder() [EOL] .project(p -> {}) [EOL] .component(c -> c.name("test1")) [EOL] .component(c -> c.name("test2")) [EOL] .build(); [EOL] [EOL] BlackDuckIo bdio = graph.io(testBdio(TT.Metadata, TT.root)); [EOL] bdio.readGraph(inputStream, null, null); [EOL] BlackDuckIoNormalizationSpi spi = spi(bdio, graph.traversal().withStrategies(testImplicitConstant())); [EOL] spi.identifyRoot(); [EOL] spi.addMissingProjectDependencies(); [EOL] [EOL] GraphTraversalSource g = graph.traversal(); [EOL] List<String> directDependencyNames = g.V().hasLabel(TT.Metadata) [EOL] .out(TT.root) [EOL] .out(Bdio.ObjectProperty.dependency.name()) [EOL] .out(Bdio.ObjectProperty.dependsOn.name()) [EOL] .<String> values(Bdio.DataProperty.name.name()) [EOL] .toList(); [EOL] [EOL] assertThat(directDependencyNames).containsExactly("test1", "test2"); [EOL] } [EOL]
@Test [EOL] public void testReplicateLogEntries_MultipleKeyValuesForSingleRow() throws Exception { [EOL] byte[] rowKey = Bytes.toBytes("rowKey"); [EOL] [EOL] Cell kvA = new KeyValue(rowKey, DATA_COLFAM, PAYLOAD_QUALIFIER, Bytes.toBytes("A")); [EOL] Cell kvB = new KeyValue(rowKey, DATA_COLFAM, PAYLOAD_QUALIFIER, Bytes.toBytes("B")); [EOL] [EOL] WAL.Entry entry = createHlogEntry(TABLE_NAME, kvA, kvB); [EOL] [EOL] replicateWALEntry(new WAL.Entry[]{entry}); [EOL] [EOL] // We should get the first payload in our event (and the second one will be ignored, although the KeyValue will [EOL] // be present in the event [EOL] SepEvent expectedEvent = SepEvent.create(TABLE_NAME, rowKey, Lists.newArrayList(kvA, kvB), [EOL] Bytes.toBytes("A")); [EOL] [EOL] verify(eventListener).processEvents(Lists.newArrayList(expectedEvent)); [EOL] } [EOL]
@Test [EOL] public void testApplyWithoutLruCache() { [EOL] // GIVEN [EOL] EasyMock.expect(inputMock.getCache()).andReturn(null); [EOL] EasyMock.replay(inputMock); [EOL] // WHEN [EOL] boolean result = underTest.apply(generateLineMap(), inputMock); [EOL] // THEN [EOL] EasyMock.verify(inputMock); [EOL] assertFalse(result); [EOL] } [EOL]
@Test [EOL] 	public void testGetTabDefault() { [EOL] 		SearchAdminDisplayBuilder searchAdminDisplayBuilder = [EOL] 			new SearchAdminDisplayBuilder( [EOL] 				_language, _portal, new MockRenderRequest(), [EOL] 				new MockRenderResponse()); [EOL] [EOL] 		searchAdminDisplayBuilder.setIndexInformation( [EOL] 			Mockito.mock(IndexInformation.class)); [EOL] [EOL] 		SearchAdminDisplayContext searchAdminDisplayContext = [EOL] 			searchAdminDisplayBuilder.build(); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			"connections", searchAdminDisplayContext.getSelectedTab()); [EOL] 	} [EOL]
@Test [EOL] public void testGetJobQueueSize() throws JobRepositoryException { [EOL] int size = rmc.getJobQueueSize(); [EOL] [EOL] assertThat(size, equalTo(0)); [EOL] [EOL] //TODO Make it change queue size [EOL] [EOL] } [EOL]
@Test [EOL] public void testExec() { [EOL] [EOL] NodeValue v1 = NodeValue.makeDouble(0); [EOL] NodeValue v2 = NodeValue.makeDouble(0); [EOL] NodeValue v3 = NodeValue.makeDouble(0); [EOL] NodeValue v4 = NodeValue.makeDouble(10); [EOL] AzimuthDegreesFF instance = new AzimuthDegreesFF(); [EOL] NodeValue expResult = NodeValue.makeDouble(90); [EOL] NodeValue result = instance.exec(v1, v2, v3, v4); [EOL] assertEquals(expResult, result); [EOL] } [EOL]
@Test [EOL] public void testGetAllMethodsOnSubclass() { [EOL] List<Method> methodList = ReflectUtil.getAllDeclaredMethods(SubClass.class); [EOL] [EOL] assertThat(methodList).hasSize(14); [EOL] // first 12 methods should come from Object [EOL] for (int i = 0; i < 11; i++) { [EOL] assertTrue(methodList.get(i).getDeclaringClass() == Object.class); [EOL] } [EOL] // then the superclass method [EOL] assertThat(methodList.get(12).getName()).isEqualTo("doSomething"); [EOL] //then the subclass method [EOL] assertThat(methodList.get(13).getName()).isEqualTo("doSomethingElse"); [EOL] } [EOL]
@Test [EOL] public void testHasReadPermissionForObjectRecordReturnsTrueOnAccess() throws Exception { [EOL] ObjectRecord object = mockCheckPermissionForObjectRecord(true); [EOL] assertTrue(context.hasReadPermission(object)); [EOL] } [EOL]
@Test [EOL] 	public void testSearchArchivableWorkflows() { [EOL] 		String workflowId = "search-workflow-id"; [EOL] [EOL] 		workflow.setWorkflowId(workflowId); [EOL] 		workflow.setStatus(Workflow.WorkflowStatus.COMPLETED); [EOL] 		workflow.setCreateTime((new Date(System.currentTimeMillis() - TimeUnit.DAYS.toMillis(4))).getTime()); [EOL] 		workflow.setUpdateTime((new Date(System.currentTimeMillis() - TimeUnit.DAYS.toMillis(4))).getTime()); [EOL] 		workflow.setEndTime((new Date(System.currentTimeMillis() - TimeUnit.DAYS.toMillis(4))).getTime()); [EOL] [EOL] 		indexDAO.indexWorkflow(workflow); [EOL] [EOL] 		await() [EOL] 				.atMost(3, TimeUnit.SECONDS) [EOL] 				.untilAsserted( [EOL] 						() -> { [EOL] 							List<String> searchIds = indexDAO.searchArchivableWorkflows("conductor",3); [EOL] 							assertEquals(1, searchIds.size()); [EOL] 							assertEquals(workflowId, searchIds.get(0)); [EOL] 						} [EOL] 				); [EOL] 	} [EOL]
@Test [EOL] public void columnCount() { [EOL] final String[][] rows = new String[4][]; [EOL] rows[0] = new String[]{""}; [EOL] rows[1] = new String[]{"", "", "", "", ""}; [EOL] rows[2] = new String[]{"", "", "", ""}; [EOL] rows[3] = new String[]{"", "", ""}; [EOL] [EOL] final Data table = new Data(rows, false); [EOL] assertEquals(5, table.getColumns().size()); [EOL] } [EOL]
@Test [EOL] public void testSniff_nonAmrSignature_returnFalse() throws IOException, InterruptedException { [EOL] AmrExtractor amrExtractor = setupAmrExtractorWithOutput(); [EOL] FakeExtractorInput input = fakeExtractorInputWithData(Util.getUtf8Bytes("0#!AMR\n123")); [EOL] [EOL] boolean result = amrExtractor.sniff(input); [EOL] assertThat(result).isFalse(); [EOL] } [EOL]
@Test [EOL] public void testOther() throws Exception { [EOL] assertFalse(ROLE_SERVER_ALL_DB_ALL.implies(REQUEST_SERVER1_OTHER)); [EOL] assertFalse(REQUEST_SERVER1_OTHER.implies(ROLE_SERVER_ALL_DB_ALL)); [EOL] } [EOL]
@Test [EOL] public void testThrowException_IfPutting_NoNumber() [EOL] { [EOL] GHLongIntBTree instance = new GHLongIntBTree(2); [EOL] try [EOL] { [EOL] instance.put(-1, 1); [EOL] assertTrue(false); [EOL] } catch (Exception ex) [EOL] { [EOL] } [EOL] } [EOL]
@Test [EOL] public void testUpdateRequestScheduleEntityWithUnuniqueUser() throws Exception{ [EOL] final RequestScheduleDAO requestScheduleDAO = createMock(RequestScheduleDAO.class); [EOL] final Users users = createMock(Users.class); [EOL] [EOL] RequestScheduleEntity requestScheduleEntity = new RequestScheduleEntity(); [EOL] requestScheduleEntity.setCreateUser("createdUser"); [EOL] requestScheduleEntity.setClusterId(1L); [EOL] [EOL] expect(requestScheduleDAO.findAll()).andReturn(Collections.singletonList(requestScheduleEntity)).once(); [EOL] [EOL] expect(users.getUserIfUnique("createdUser")).andReturn(null).once(); [EOL] [EOL] final Injector injector = Guice.createInjector(new AbstractModule() { [EOL] @Override [EOL] protected void configure() { [EOL] bind(RequestScheduleDAO.class).toInstance(requestScheduleDAO); [EOL] bind(Users.class).toInstance(users); [EOL] bind(PasswordEncoder.class).toInstance(createMock(PasswordEncoder.class)); [EOL] bind(DBAccessor.class).toInstance(createMock(DBAccessor.class)); [EOL] bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class)); [EOL] bind(EntityManager.class).toInstance(entityManager); [EOL] bind(HookContextFactory.class).toInstance(createMock(HookContextFactory.class)); [EOL] bind(HookService.class).toInstance(createMock(HookService.class)); [EOL] } [EOL] }); [EOL] [EOL] UpgradeCatalog240 upgradeCatalog240 = new UpgradeCatalog240(injector); [EOL] [EOL] replay(requestScheduleDAO, users); [EOL] [EOL] upgradeCatalog240.updateRequestScheduleEntityUserIds(); [EOL] [EOL] verify(requestScheduleDAO, users); [EOL] [EOL] assertEquals(null, requestScheduleEntity.getAuthenticatedUserId()); [EOL] } [EOL]
@Test [EOL] public void testFlowStatusWithFetchExecutableFlows() throws Exception { [EOL] final ExecutableFlow flow = submitNewFlow("exectest1", "exec1", [EOL] System.currentTimeMillis(), ExecutionOptions.DEFAULT_FLOW_PRIORITY); [EOL] int execId = flow.getExecutionId(); [EOL] makeFlowStatusInconsistent(execId, Status.FAILED_FINISHING); [EOL] final ExecutableFlow fetchedFlow = this.executionFlowDao.fetchExecutableFlow(execId); [EOL] assertThat(fetchedFlow.getStatus()).isEqualTo(Status.FAILED_FINISHING); [EOL] } [EOL]
@Test [EOL] public void testSupported_BinaryComparatorEquals() { [EOL] BinaryComparator comparator = new BinaryComparator(new byte[] {0, 1, 2}); [EOL] org.apache.hadoop.hbase.filter.RowFilter filter = [EOL] new org.apache.hadoop.hbase.filter.RowFilter(CompareFilter.CompareOp.EQUAL, comparator); [EOL] Assert.assertTrue(adapter.isFilterSupported(context, filter).isSupported()); [EOL] } [EOL]
@Test [EOL] 	public void testMarkEvent() { [EOL] 		Counter c = new SimpleCounter(); [EOL] 		Meter m = new MeterView(c, 60); [EOL] [EOL] 		assertEquals(0, m.getCount()); [EOL] 		m.markEvent(); [EOL] 		assertEquals(1, m.getCount()); [EOL] 		m.markEvent(2); [EOL] 		assertEquals(3, m.getCount()); [EOL] 	} [EOL]
@Test [EOL] public void testAnnotateInvalidGenomeVariant() { [EOL] VariantAnnotations variantAnnotations = instance.annotateVariant("10", 0, "", ""); [EOL] assertThat(variantAnnotations.getChrName(), equalTo("10")); [EOL] assertThat(variantAnnotations.getChr(), equalTo(10)); [EOL] assertThat(variantAnnotations.getPos(), equalTo(-1)); //Jannovar uses and returns 0-based coordinates. [EOL] assertThat(variantAnnotations.getRef(), equalTo("")); [EOL] assertThat(variantAnnotations.getAlt(), equalTo("")); [EOL] assertThat(variantAnnotations.hasAnnotation(), is(false)); [EOL] assertThat(variantAnnotations.getHighestImpactEffect(), equalTo(VariantEffect.SEQUENCE_VARIANT)); [EOL] } [EOL]
@Test [EOL] public void returnsNullReaderKeyIfReaderKeyEqualsInitialWriterKey() { [EOL] [EOL] // given [EOL] KeySequenceConfig config = createDefaultTestKeySequenceConfig(); [EOL] KeySequence sequence = createDefaultTestUUIDSequence(config); [EOL] [EOL] // when [EOL] CharSequence readerKey1 = sequence.nextReaderKey(); [EOL] [EOL] // then [EOL] assertNull(readerKey1); [EOL] [EOL] } [EOL]
@Test [EOL] 	public void testToDXPVariantSettingsWithControlVariant() { [EOL] 		String controlSegmentsExperienceKey = RandomTestUtil.randomString(); [EOL] [EOL] 		double split = RandomTestUtil.randomDouble(); [EOL] [EOL] 		DXPVariantSettings dxpVariantSettings = [EOL] 			DXPVariantSettingsUtil.toDXPVariantSettings( [EOL] 				controlSegmentsExperienceKey, controlSegmentsExperienceKey, [EOL] 				split); [EOL] [EOL] 		Assert.assertEquals( [EOL] 			controlSegmentsExperienceKey, dxpVariantSettings.getDXPVariantId()); [EOL] 		Assert.assertEquals( [EOL] 			split, dxpVariantSettings.getTrafficSplit() / 100, 0.001); [EOL] 		Assert.assertTrue(dxpVariantSettings.isControl()); [EOL] 	} [EOL]
@Test [EOL] public void testUtf8String() { [EOL] Utf8String string = new Utf8String("Hello, world!"); [EOL] assertThat(PlatOnTypeEncoder.encode(string), [EOL] is("48656c6c6f2c20776f726c6421")); [EOL] } [EOL]
@Test [EOL] public void testAllocationWithNodeLabels() throws Exception { [EOL] ResourceBlacklistRequest blacklistRequest = [EOL] ResourceBlacklistRequest.newInstance( [EOL] new ArrayList<>(), new ArrayList<>()); [EOL] List<ResourceRequest> reqs = [EOL] Arrays.asList(ResourceRequest.newInstance(PRIORITY_NORMAL, [EOL] "*", CAPABILITY_1GB, 1, true, "label", OPPORTUNISTIC_REQ)); [EOL] ApplicationAttemptId appAttId = ApplicationAttemptId.newInstance( [EOL] ApplicationId.newInstance(0L, 1), 1); [EOL] [EOL] oppCntxt.updateNodeList( [EOL] Arrays.asList( [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h1", 1234), "h1:1234", "/r1"))); [EOL] List<Container> containers = allocator.allocateContainers( [EOL] blacklistRequest, reqs, appAttId, oppCntxt, 1L, "luser"); [EOL] /* Since there is no node satisfying node label constraints, requests [EOL] won't get fulfilled. [EOL] */ [EOL] Assert.assertEquals(0, containers.size()); [EOL] Assert.assertEquals(1, oppCntxt.getOutstandingOpReqs().size()); [EOL] [EOL] oppCntxt.updateNodeList( [EOL] Arrays.asList( [EOL] RemoteNode.newInstance( [EOL] NodeId.newInstance("h1", 1234), "h1:1234", "/r1", [EOL] "label"))); [EOL] [EOL] containers = allocator.allocateContainers( [EOL] blacklistRequest, reqs, appAttId, oppCntxt, 1L, "luser"); [EOL] Assert.assertEquals(1, containers.size()); [EOL] Assert.assertEquals(0, oppCntxt.getOutstandingOpReqs().size()); [EOL] } [EOL]
@Test public void ifPresent_optionalIsPresent() { [EOL] ifPresent(Optional.of("foo"), consumer::accept) [EOL] .orElse(otherwise::run); [EOL] verify(consumer).accept("foo"); [EOL] verify(otherwise, never()).run(); [EOL] } [EOL]
@Test [EOL] public void testGetMainIndex() { [EOL] GraphStore graphStore = new GraphStore(); [EOL] IndexStore<Node> indexStore = graphStore.nodeTable.store.indexStore; [EOL] [EOL] Assert.assertNotNull(indexStore.getIndex(graphStore)); [EOL] } [EOL]
@Test [EOL] public void testGetFlowSnapshotsWhenNoSnapshots() { [EOL] final BucketEntity existingBucket = new BucketEntity(); [EOL] existingBucket.setId("b1"); [EOL] existingBucket.setName("My Bucket"); [EOL] existingBucket.setDescription("This is my bucket"); [EOL] existingBucket.setCreated(new Date()); [EOL] [EOL] when(metadataService.getBucketById(existingBucket.getId())).thenReturn(existingBucket); [EOL] [EOL] // return a flow with the existing snapshot when getFlowById is called [EOL] final FlowEntity existingFlow = new FlowEntity(); [EOL] existingFlow.setId("flow1"); [EOL] existingFlow.setName("My Flow"); [EOL] existingFlow.setDescription("This is my flow."); [EOL] existingFlow.setCreated(new Date()); [EOL] existingFlow.setModified(new Date()); [EOL] existingFlow.setBucketId(existingBucket.getId()); [EOL] [EOL] final Set<FlowSnapshotEntity> snapshots = new HashSet<>(); [EOL] [EOL] when(metadataService.getFlowById(existingFlow.getId())).thenReturn(existingFlow); [EOL] [EOL] final SortedSet<VersionedFlowSnapshotMetadata> retrievedSnapshots = registryService.getFlowSnapshots(existingBucket.getId(), existingFlow.getId()); [EOL] assertNotNull(retrievedSnapshots); [EOL] assertEquals(0, retrievedSnapshots.size()); [EOL] } [EOL]
@Test(expected = IllegalArgumentException.class) [EOL] public void addShouldThrowExceptionWhenMimeTypeIsInvalidThree() { [EOL] new MimeTypeAggregator().add("/"); [EOL] } [EOL]
@Test [EOL] public void removeLastEndingCRLF() { [EOL] String line = "Test" + CRLF + CRLF; [EOL] assertEquals("Test" + CRLF, BatchParserCommon.removeEndingCRLF(new Line(line, 1)).toString()); [EOL] } [EOL]
@Test [EOL] public void getCourseWithModules() { [EOL] doAnswer(invocation -> { [EOL] ((RemoteDataSource.LoadCoursesCallback) invocation.getArguments()[0]) [EOL] .onAllCoursesReceived(courseResponses); [EOL] return null; [EOL] }).when(remote).getAllCourses(any(RemoteDataSource.LoadCoursesCallback.class)); [EOL] [EOL] CourseEntity courseEntities = LiveDataTestUtil.getValue(academyRepository.getCourseWithModules(courseId)); [EOL] [EOL] verify(remote).getAllCourses(any(RemoteDataSource.LoadCoursesCallback.class)); [EOL] [EOL] assertNotNull(courseEntities); [EOL] assertNotNull(courseEntities.getTitle()); [EOL] assertEquals(courseResponses.get(0).getTitle(), courseEntities.getTitle()); [EOL] } [EOL]
@Test [EOL] 	public void resolvedAddressTypes() { [EOL] 		assertNull(builder.build().resolvedAddressTypes()); [EOL] [EOL] 		builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY); [EOL] 		assertThat(builder.build().resolvedAddressTypes()).isEqualTo(ResolvedAddressTypes.IPV4_ONLY); [EOL] 	} [EOL]
@Test [EOL] public void getInt_chainLogic() { [EOL] toTest.providerChain.clear(); [EOL] [EOL] //gleicher aufbau wie get_chainLogic() [EOL] for (int i = 0; i < 3; i++) { [EOL] toTest.providerChain.add(mock(ValueProvider.class)); [EOL] if (i != 2) { [EOL] doReturn(i).when(toTest.providerChain.get(i)).getPropertyValueAsInt(any(Property.class)); [EOL] } else { [EOL] doReturn(null).when(toTest.providerChain.get(i)).getPropertyValueAsInt(any(Property.class)); [EOL] } [EOL] } [EOL] [EOL] assertTrue(1 == toTest.getPropertyValueAsInt(Property.MAP_PROVIDER_SCHEMA)); [EOL] } [EOL]
@Test [EOL] public void testTransfer_MultiSig_NotEnoughSignersPresent() throws IOException { [EOL] setUpWireMockForCall("invokescript", "invokescript_transfer.json"); [EOL] setUpWireMockForGetBlockCount(1000); [EOL] setUpWireMockForInvokeFunction("decimals", "invokefunction_decimals.json"); [EOL] setUpWireMockForBalanceOf(account1.getScriptHash(), "invokefunction_balanceOf_4.json"); [EOL] setUpWireMockForBalanceOf(multiSigAccount.getScriptHash(), [EOL] "invokefunction_balanceOf_3.json"); [EOL] [EOL] byte[] expectedScript = new ScriptBuilder().contractCall(NEO_TOKEN_SCRIPT_HASH, [EOL] NEP5_TRANSFER, Arrays.asList( [EOL] ContractParameter.hash160(account1.getScriptHash()), [EOL] ContractParameter.hash160(RECIPIENT_SCRIPT_HASH), [EOL] ContractParameter.integer(2))).toArray(); [EOL] [EOL] TransactionBuilder b = neoToken.transfer(Wallet.withAccounts(multiSigAccount, [EOL] account1), RECIPIENT_SCRIPT_HASH, new BigDecimal("2")); [EOL] [EOL] assertThat(b.getScript(), is(expectedScript)); [EOL] } [EOL]
@Test [EOL] public void shouldAddMaxOption() [EOL] { [EOL] HelmHistory command = Helm.history("foo"); [EOL] HelmHistory copy = command.max(19); [EOL] [EOL] assertThat(copy, is(not(sameInstance(command)))); [EOL] assertCommand(copy, "history", "--max", "19", "foo"); [EOL] } [EOL]
@Test [EOL] @Ignore [EOL] public void testFindAssignments() throws InterruptedException { [EOL] Assignment assignment = createTestAssignment(); [EOL] List<Assignment> expected = Arrays.asList(assignment); [EOL] ldapService.updateAssignments(expected); [EOL] assertTrue(CollectionUtils.isEqualCollection(modelManager.findAssignments(), expected)); [EOL] } [EOL]
@Test [EOL] void shouldHaveCorrectType() [EOL] { [EOL] assertThat( emptyNodeValue().type(), equalTo( InternalTypeSystem.TYPE_SYSTEM.NODE() )); [EOL] } [EOL]
@Test [EOL] public void testDispatch_successful_v3() throws Exception { [EOL] SNMPDispatcher dispatcher = new SNMPDispatcher(DEFAULT_SNMP_PORT); [EOL] Notification notification = new Notification(); [EOL] notification.Callback = mock(DispatchCallback.class); [EOL] notification.CallbackIds = new ArrayList<>(); [EOL] notification.Body = "body"; [EOL] notification.Subject = "subject"; [EOL] Map<String, String> properties = new HashMap<String, String>(); [EOL] properties.put(SNMPDispatcher.SUBJECT_OID_PROPERTY, "1"); [EOL] properties.put(SNMPDispatcher.BODY_OID_PROPERTY, "2"); [EOL] properties.put(SNMPDispatcher.PORT_PROPERTY, "162"); [EOL] properties.put(SNMPDispatcher.COMMUNITY_PROPERTY, "public"); [EOL] properties.put(SNMPDispatcher.SNMP_VERSION_PROPERTY, "SNMPv3"); [EOL] properties.put(SNMPDispatcher.TRAP_OID_PROPERTY, "1.3.6.1.6.3.1.1.5.4"); [EOL] properties.put(SNMPDispatcher.SECURITY_USERNAME_PROPERTY, "USER"); [EOL] properties.put(SNMPDispatcher.SECURITY_AUTH_PASSPHRASE_PROPERTY, "PASSPHRASE1"); [EOL] properties.put(SNMPDispatcher.SECURITY_PRIV_PASSPHRASE_PROPERTY, "PASSPHRASE2"); [EOL] properties.put(SNMPDispatcher.SECURITY_LEVEL_PROPERTY, "AUTH_NOPRIV"); [EOL] notification.DispatchProperties = properties; [EOL] Recipient recipient = new Recipient(); [EOL] recipient.Identifier = "192.168.0.2"; [EOL] notification.Recipients = Arrays.asList(recipient); [EOL] dispatcher.dispatch(notification); [EOL] verify(notification.Callback, never()).onFailure(notification.CallbackIds); [EOL] verify(notification.Callback).onSuccess(notification.CallbackIds); [EOL] } [EOL]
@Test [EOL] public void testHashCode() { [EOL] assertEquals(m_alarmParameters.hashCode(), m_alarmParameters2.hashCode()); [EOL] assertNotEquals(m_AlarmParametersDifferentSeverity.hashCode(), m_alarmParameters2.hashCode()); [EOL] } [EOL]
@Test [EOL] public void testInvalidRedis() throws IOException, ECFileCacheException { [EOL] if (eraseRedis) { [EOL] System.out.println("some redis data unreachable, do not run this case: " + [EOL] ((new Exception()).getStackTrace())[0].getMethodName()); [EOL] return; [EOL] } [EOL] [EOL] Map<Integer, DecoratedJedisPool> keyedPool = client.getRedisAccess().getKeyedPool(); [EOL] Map<Integer, DecoratedJedisPool> storedKeyedPool = new HashMap<Integer, DecoratedJedisPool>(keyedPool); [EOL] [EOL] // cache data ok when offline redis instance little than 3 [EOL] keyedPool.put(0, null); [EOL] keyedPool.put(1, null); [EOL] testPutGetDeleteImpl(); [EOL] [EOL] // cache data fail when offline redis instance more than 3 [EOL] keyedPool.put(0, null); [EOL] keyedPool.put(1, null); [EOL] keyedPool.put(2, null); [EOL] keyedPool.put(3, null); [EOL] try { [EOL] testPutGetDeleteImpl(); [EOL] Assert.fail("should not reach here"); [EOL] } catch (ECFileCacheException e) { [EOL] Assert.assertTrue(StringUtils.contains(e.getMessage(), "fail count > CODING_BLOCK_NUM.")); [EOL] } [EOL] [EOL] // restore redis 3 [EOL] keyedPool.put(3, storedKeyedPool.get(3)); [EOL] [EOL] // allocate cacheKey if remove little than three redis [EOL] keyedPool.remove(0); [EOL] keyedPool.remove(1); [EOL] keyedPool.remove(2); [EOL] testPutGetDeleteImpl(); [EOL] [EOL] // can not allocate cacheKey if remove more than three redis [EOL] keyedPool.remove(3); [EOL] try { [EOL] testPutGetDeleteImpl(); [EOL] Assert.fail("should not reach here"); [EOL] } catch (ECFileCacheException e) { [EOL] Assert.assertTrue(StringUtils.startsWith(e.getMessage(), "can not allocate offset id for cacheKey")); [EOL] } [EOL] [EOL] // restore client pool [EOL] for (int i = 0; i < 5; ++i) { [EOL] keyedPool.put(i, storedKeyedPool.get(i)); [EOL] } [EOL] [EOL] for (int i = 0; i < 5; ++i) { [EOL] Assert.assertNotNull(keyedPool.get(i)); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testPutFloatProperty() { [EOL] WProperties prop = new WProperties(); [EOL] prop.putFloatProperty("float", Float.MAX_VALUE); //$NON-NLS-1$ [EOL] Assert.assertEquals("different float", Float.MAX_VALUE, prop.getFloatProperty("float", 0.0f), 0.0f); //$NON-NLS-1$ //$NON-NLS-2$ [EOL] prop.putFloatProperty("float", Float.NaN); //$NON-NLS-1$ [EOL] Assert.assertEquals("different float", Float.NaN, prop.getFloatProperty("float", 0.0f), 0.0f); //$NON-NLS-1$ //$NON-NLS-2$ [EOL] } [EOL]
@Test [EOL] void fromStringEmptyArray() [EOL] { [EOL] assertEquals(new ArrayList<>(), this.tool.fromString("[]")); [EOL] } [EOL]
@Test [EOL] 	public void wrapHook() throws Exception { [EOL] 		final String id = "id"; [EOL] [EOL] 		Thread thread = Thread.currentThread(); [EOL] 		final ClassLoader originalClassLoader = thread.getContextClassLoader(); [EOL] 		final ClassLoader userClassLoader = new URLClassLoader(new URL[0]); [EOL] [EOL] 		final Runnable command = spy(new Runnable() { [EOL] 			@Override [EOL] 			public void run() { [EOL] 				assertEquals(userClassLoader, Thread.currentThread().getContextClassLoader()); [EOL] 			} [EOL] 		}); [EOL] [EOL] 		MasterTriggerRestoreHook<String> hook = spy(new MasterTriggerRestoreHook<String>() { [EOL] 			@Override [EOL] 			public String getIdentifier() { [EOL] 				assertEquals(userClassLoader, Thread.currentThread().getContextClassLoader()); [EOL] 				return id; [EOL] 			} [EOL] [EOL] 			@Nullable [EOL] 			@Override [EOL] 			public CompletableFuture<String> triggerCheckpoint(long checkpointId, long timestamp, Executor executor) throws Exception { [EOL] 				assertEquals(userClassLoader, Thread.currentThread().getContextClassLoader()); [EOL] 				executor.execute(command); [EOL] 				return null; [EOL] 			} [EOL] [EOL] 			@Override [EOL] 			public void restoreCheckpoint(long checkpointId, @Nullable String checkpointData) throws Exception { [EOL] 				assertEquals(userClassLoader, Thread.currentThread().getContextClassLoader()); [EOL] 			} [EOL] [EOL] 			@Nullable [EOL] 			@Override [EOL] 			public SimpleVersionedSerializer<String> createCheckpointDataSerializer() { [EOL] 				assertEquals(userClassLoader, Thread.currentThread().getContextClassLoader()); [EOL] 				return null; [EOL] 			} [EOL] 		}); [EOL] [EOL] 		MasterTriggerRestoreHook<String> wrapped = MasterHooks.wrapHook(hook, userClassLoader); [EOL] [EOL] 		// verify getIdentifier [EOL] 		wrapped.getIdentifier(); [EOL] 		verify(hook, times(1)).getIdentifier(); [EOL] 		assertEquals(originalClassLoader, thread.getContextClassLoader()); [EOL] [EOL] 		// verify triggerCheckpoint and its wrapped executor [EOL] 		TestExecutor testExecutor = new TestExecutor(); [EOL] 		wrapped.triggerCheckpoint(0L, 0, testExecutor); [EOL] 		assertEquals(originalClassLoader, thread.getContextClassLoader()); [EOL] 		assertNotNull(testExecutor.command); [EOL] 		testExecutor.command.run(); [EOL] 		verify(command, times(1)).run(); [EOL] 		assertEquals(originalClassLoader, thread.getContextClassLoader()); [EOL] [EOL] 		// verify restoreCheckpoint [EOL] 		wrapped.restoreCheckpoint(0L, ""); [EOL] 		verify(hook, times(1)).restoreCheckpoint(eq(0L), eq("")); [EOL] 		assertEquals(originalClassLoader, thread.getContextClassLoader()); [EOL] [EOL] 		// verify createCheckpointDataSerializer [EOL] 		wrapped.createCheckpointDataSerializer(); [EOL] 		verify(hook, times(1)).createCheckpointDataSerializer(); [EOL] 		assertEquals(originalClassLoader, thread.getContextClassLoader()); [EOL] 	} [EOL]
@Test [EOL] 	public void testFromMessage() { [EOL] 		Message m = new Message(a1.toString()); [EOL] 		ByteMultiArray p = ByteMultiArray.fromMessage(m); [EOL] 		assertEquals(a1.toString(), p.toString()); [EOL] 		assertEquals(a1.toJsonObject(), p.toJsonObject()); [EOL] 		assertEquals(a1.getMessageType(), p.getMessageType()); [EOL] 		assertEquals(a1.size(), p.size()); [EOL] 		assertTrue(Arrays.equals(a1.getData(), p.getData())); [EOL] 		assertEquals(a1.getLayout(), p.getLayout()); [EOL] 		assertNotSame(a1, p); [EOL] 		assertNotSame(a1.toString(), p.toString()); [EOL] 		assertNotSame(a1.toJsonObject(), p.toJsonObject()); [EOL] 	} [EOL]
@Test [EOL] public void testParseFlowOptionsSla() throws Exception { [EOL] final HttpServletRequest req = mockRequestWithSla(ImmutableMap.of( [EOL] // job_name, status, duration, is_email, is_kill [EOL] "slaSettings[1]", ",FINISH,2:30,true,false", [EOL] "slaSettings[2]", "test_job,SUCCESS,12:00,false,true", [EOL] "slaSettings[3]", ",SUCCESS,12:00,true,true")); [EOL] final ExecutionOptions options = HttpRequestUtils.parseFlowOptions(req, "test-flow"); [EOL] final List<SlaOption> slaOptions = options.getSlaOptions(); [EOL] final List<SlaOption> expected = Arrays.asList( [EOL] new SlaOption(SlaType.FLOW_FINISH, "test-flow", "", Duration.ofMinutes(150), [EOL] ImmutableSet.of(SlaAction.ALERT), ImmutableList.of()), [EOL] new SlaOption(SlaType.JOB_SUCCEED, "test-flow", "test_job", Duration.ofMinutes(720), [EOL] ImmutableSet.of(SlaAction.KILL), ImmutableList.of()), [EOL] new SlaOption(SlaType.FLOW_SUCCEED, "test-flow", "", Duration.ofMinutes(720), [EOL] ImmutableSet.of(SlaAction.ALERT, SlaAction.KILL), ImmutableList.of()) [EOL] ); [EOL] Assert.assertEquals(expected, slaOptions); [EOL] } [EOL]
@Test [EOL] public void testGetListenersInitial() { [EOL] WeakEventListenerList list = new WeakEventListenerList(); [EOL] // must return empty array [EOL] assertNotNull("array must be not null", list.getListeners(ChangeListener.class)); [EOL] assertEquals("array must be empty", 0, list.getListeners(ChangeListener.class).length); [EOL] [EOL] } [EOL]
@Test [EOL] 	public void testCompare_different_but_clear_0xFE_1px() throws Exception { [EOL] 		BufferedImage image1 = ImageIO.read(getClass().getResource("hifive_logo.png")); [EOL] 		BufferedImage image2 = ImageIO.read(getClass().getResource("hifive_logo.png")); [EOL] [EOL] 		// 1pxだけ色を変える [EOL] 		Random random = new Random(); [EOL] 		int x = random.nextInt(image2.getWidth()); [EOL] 		int y = random.nextInt(image2.getHeight()); [EOL] 		image2.setRGB(x, y, (image2.getRGB(x, y) - 1) & 0xFEFFFFFF); [EOL] [EOL] 		Rectangle rectangle = new Rectangle(0, 0, image1.getWidth(), image2.getHeight()); [EOL] [EOL] 		ImageComparedResult result = new IgnoringClearPixelsImageComparator().compare(image1, rectangle, image2, [EOL] 				rectangle); [EOL] [EOL] 		assertThat(result.isSucceeded(), is(true)); [EOL] 		assertThat(result.isFailed(), is(false)); [EOL] 	} [EOL]
@Test [EOL] public void testListSimple() throws ListProviderException { [EOL] Map<String, String> list = contributorsListProvider.getList(ContributorsListProvider.DEFAULT, null); [EOL] [EOL] Assert.assertTrue(list.containsKey(user1.getName())); [EOL] Assert.assertTrue(list.containsKey(user2.getName())); [EOL] [EOL] Assert.assertTrue(list.containsValue(user1.getName())); [EOL] Assert.assertTrue(list.containsValue(user2.getName())); [EOL] [EOL] Assert.assertTrue(list.containsKey("User 5")); [EOL] Assert.assertTrue(list.containsValue("User 5")); [EOL] [EOL] Assert.assertEquals(3, list.size()); [EOL] } [EOL]
@Test [EOL] public void testDeserialize() throws Exception { [EOL] User u = objMapper.readValue(userJsonStr, User.class); [EOL] assertEquals("U023BECGF", u.getUserId()); [EOL] assertEquals("bobby@slack.com", u.getEmail()); [EOL] assertEquals("bobby", u.getMentionName()); [EOL] assertEquals("Bobby Tables", u.getName()); [EOL] assertEquals("https://test2.com", u.getPhotoUrl()); [EOL] assertEquals("America/New York/New York", u.getTimezone()); [EOL] assertEquals("some status", u.getStatusMessage()); [EOL] assertEquals("title", u.getTitle()); [EOL] assertTrue(u.isDeleted()); [EOL] assertTrue(u.isGroupAdmin()); [EOL] assertNull(u.getCreationDate()); [EOL] assertNull(u.getLastActiveDate()); [EOL] assertNull(u.getStatus()); [EOL] } [EOL]
@Test [EOL] public void testNamedCommitterFactory() throws Throwable { [EOL] Configuration conf = new Configuration(); [EOL] // set up for the schema factory [EOL] conf.set(COMMITTER_FACTORY_CLASS, NAMED_COMMITTER_FACTORY); [EOL] conf.set(NAMED_COMMITTER_CLASS, SimpleCommitter.class.getName()); [EOL] SimpleCommitter sc = createCommitter( [EOL] NamedCommitterFactory.class, [EOL] SimpleCommitter.class, HDFS_PATH, conf); [EOL] assertEquals("Wrong output path from " + sc, [EOL] HDFS_PATH, [EOL] sc.getOutputPath()); [EOL] } [EOL]
@Test [EOL] public void withUri_copiesHttpRequestHeaders() { [EOL] Map<String, String> httpRequestProperties = createRequestProperties(5); [EOL] DataSpec dataSpec = createDataSpecWithHeaders(httpRequestProperties); [EOL] [EOL] DataSpec dataSpecCopy = dataSpec.withUri(Uri.parse("www.new-uri.com")); [EOL] [EOL] assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestProperties); [EOL] } [EOL]
@Test [EOL] public void testCountDenseClosedRange() { [EOL] assertEquals(101, create(dense).count(closed)); [EOL] } [EOL]
@Test(expected = NullPointerException.class) [EOL] 	public void shouldThrowNullPointExceptionIfPortIsNull() throws NoSuchAlgorithmException, [EOL] 		KeyManagementException, URISyntaxException { [EOL] 		RMQConnectionConfig connectionConfig = new RMQConnectionConfig.Builder() [EOL] 			.setHost("localhost").setUserName("guest") [EOL] 			.setPassword("guest").setVirtualHost("/").build(); [EOL] 		connectionConfig.getConnectionFactory(); [EOL] 	} [EOL]
@Test(expected = UnsupportedOperationException.class) [EOL] public void removeUnsupported() [EOL] { [EOL] new PDOutlineItemIterator(new PDOutlineItem()).remove(); [EOL] } [EOL]
@Test(expected = RuntimeException.class) [EOL] 	public void testIllegalArgs() { [EOL] 		ParameterTool.fromArgs(new String[]{"berlin"}); [EOL] 	} [EOL]
@Test [EOL] public void testMocksOnThisClass() { [EOL] mFieldPreparer.prepareFields(this); [EOL] [EOL] assertThat(mMockRunnable) [EOL] .isNotNull() [EOL] .is(mockCondition()); [EOL] assertThat(mSpyRunnable) [EOL] .isNotNull() [EOL] .is(spyCondition()); [EOL] assertThat(mSpyRunnable2) [EOL] .isNotNull() [EOL] .is(spyCondition()); [EOL] } [EOL]
@Test [EOL] 	public void shouldPerformAntiJoin() { [EOL] 		final SopremoTestPlan sopremoPlan = new SopremoTestPlan(2, 1); [EOL] [EOL] 		final AndExpression condition = [EOL] 			new AndExpression(new ElementInSetExpression(createPath("0", "DeptName"), Quantor.EXISTS_NOT_IN, [EOL] 				createPath("1", "Name"))); [EOL] 		final Join join = new Join().withJoinCondition(condition); [EOL] 		join.setInputs(sopremoPlan.getInputOperators(0, 2)); [EOL] 		sopremoPlan.getOutputOperator(0).setInputs(join); [EOL] 		sopremoPlan.getInput(0).addObject("Name", "Harry", "EmpId", 3415, "DeptName", "Finance").addObject("Name", [EOL] 			"Sally", "EmpId", 2241, "DeptName", "Sales") [EOL] 			.addObject("Name", "George", "EmpId", 3401, "DeptName", "Finance").addObject("Name", "Harriet", "EmpId", [EOL] 				2202, "DeptName", "Production"); [EOL] 		sopremoPlan.getInput(1).addObject("Name", "Sales", "Manager", "Harriet").addObject("Name", "Production", [EOL] 			"Manager", "Charles"); [EOL] 		sopremoPlan.getExpectedOutput(0).addArray( [EOL] 			JsonUtil.createObjectNode("Name", "Harry", "EmpId", 3415, "DeptName", "Finance")) [EOL] 			.addArray(JsonUtil.createObjectNode("Name", "George", "EmpId", 3401, "DeptName", "Finance")); [EOL] [EOL] 		sopremoPlan.run(); [EOL] 	} [EOL]
@Test [EOL] 	public void testDataSourceTask() { [EOL] 		int keyCnt = 100; [EOL] 		int valCnt = 20; [EOL] 		 [EOL] 		this.outList = new ArrayList<Record>(); [EOL] 		 [EOL] 		try { [EOL] 			InputFilePreparator.prepareInputFile(new UniformRecordGenerator(keyCnt, valCnt, false), [EOL] 				this.tempTestPath, true); [EOL] 		} catch (IOException e1) { [EOL] 			Assert.fail("Unable to set-up test input file"); [EOL] 		} [EOL] 		 [EOL] 		super.initEnvironment(MEMORY_MANAGER_SIZE, NETWORK_BUFFER_SIZE); [EOL] 		super.addOutput(this.outList); [EOL] 		 [EOL] 		DataSourceTask<Record> testTask = new DataSourceTask<Record>(); [EOL] 		 [EOL] 		super.registerFileInputTask(testTask, MockInputFormat.class, new File(tempTestPath).toURI().toString(), "\n"); [EOL] 		 [EOL] 		try { [EOL] 			testTask.invoke(); [EOL] 		} catch (Exception e) { [EOL] 			System.err.println(e); [EOL] 			Assert.fail("Invoke method caused exception."); [EOL] 		} [EOL] 		 [EOL] 		Assert.assertTrue("Invalid output size. Expected: "+(keyCnt*valCnt)+" Actual: "+this.outList.size(), [EOL] 			this.outList.size() == keyCnt * valCnt); [EOL] 		 [EOL] 		HashMap<Integer,HashSet<Integer>> keyValueCountMap = new HashMap<Integer, HashSet<Integer>>(keyCnt); [EOL] 		 [EOL] 		for (Record kvp : this.outList) { [EOL] 			 [EOL] 			int key = kvp.getField(0, IntValue.class).getValue(); [EOL] 			int val = kvp.getField(1, IntValue.class).getValue(); [EOL] 			 [EOL] 			if(!keyValueCountMap.containsKey(key)) { [EOL] 				keyValueCountMap.put(key,new HashSet<Integer>()); [EOL] 			} [EOL] 			keyValueCountMap.get(key).add(val); [EOL] 			 [EOL] 		} [EOL] 		 [EOL] 		Assert.assertTrue("Invalid key count in out file. Expected: "+keyCnt+" Actual: "+keyValueCountMap.keySet().size(), [EOL] 			keyValueCountMap.keySet().size() == keyCnt); [EOL] 		 [EOL] 		for(Integer mapKey : keyValueCountMap.keySet()) { [EOL] 			Assert.assertTrue("Invalid value count for key: "+mapKey+". Expected: "+valCnt+" Actual: "+keyValueCountMap.get(mapKey).size(), [EOL] 				keyValueCountMap.get(mapKey).size() == valCnt); [EOL] 		} [EOL] 		 [EOL] 	} [EOL]
@Test [EOL] 	public void ndotsBadValues() { [EOL] 		assertThatExceptionOfType(IllegalArgumentException.class) [EOL] 				.isThrownBy(() -> builder.ndots(-2)) [EOL] 				.withMessage("ndots must be greater or equal to -1"); [EOL] 	} [EOL]
@Test [EOL] public void should_throw_exception_when_artefact_to_export_is_not_found() throws Exception { [EOL] NotFoundException cause = new NotFoundException("Page not found"); [EOL] when(pageService.get("unknown-id")).thenThrow(cause); [EOL] [EOL] exception.expect(ExportException.class); [EOL] exception.expectCause(is(cause)); [EOL] [EOL] exporter.handleFileExport("unknown-id", response); [EOL] } [EOL]
@Test [EOL] void get7() { [EOL] assertEquals(m7, instance.get7()); [EOL] } [EOL]
@Test [EOL] public void testConfigureTask() throws Exception { [EOL] Map<String, UpgradePack> upgrades = ambariMetaInfo.getUpgradePacks("HDP", "2.1.1"); [EOL] assertTrue(upgrades.containsKey("upgrade_test")); [EOL] UpgradePack upgrade = upgrades.get("upgrade_test"); [EOL] ConfigUpgradePack cup = ambariMetaInfo.getConfigUpgradePack("HDP", "2.1.1"); [EOL] assertNotNull(upgrade); [EOL] [EOL] Cluster cluster = makeCluster(); [EOL] [EOL] UpgradeContext context = m_upgradeContextFactory.create(cluster, UpgradeType.ROLLING, [EOL] Direction.UPGRADE, UPGRADE_VERSION, new HashMap<String, Object>()); [EOL] context.setResolver(m_masterHostResolver); [EOL] [EOL] List<UpgradeGroupHolder> groups = m_upgradeHelper.createSequence(upgrade, [EOL] context); [EOL] [EOL] assertEquals(7, groups.size()); [EOL] [EOL] // grab the first configure task out of Hive [EOL] UpgradeGroupHolder hiveGroup = groups.get(4); [EOL] assertEquals("HIVE", hiveGroup.name); [EOL] ConfigureTask configureTask = (ConfigureTask) hiveGroup.items.get(1).getTasks().get(0).getTasks().get(0); [EOL] [EOL] Map<String, String> configProperties = configureTask.getConfigurationChanges(cluster, cup); [EOL] assertFalse(configProperties.isEmpty()); [EOL] assertEquals(configProperties.get(ConfigureTask.PARAMETER_CONFIG_TYPE), "hive-site"); [EOL] [EOL] // now set the property in the if-check in the set element so that we have a match [EOL] Map<String, String> hiveConfigs = new HashMap<>(); [EOL] hiveConfigs.put("fooKey", "THIS-BETTER-CHANGE"); [EOL] hiveConfigs.put("ifFooKey", "ifFooValue"); [EOL] ConfigurationRequest configurationRequest = new ConfigurationRequest(); [EOL] configurationRequest.setClusterName(cluster.getClusterName()); [EOL] configurationRequest.setType("hive-site"); [EOL] configurationRequest.setVersionTag("version2"); [EOL] configurationRequest.setProperties(hiveConfigs); [EOL] [EOL] final ClusterRequest clusterRequest = new ClusterRequest( [EOL] cluster.getClusterId(), cluster.getClusterName(), [EOL] cluster.getDesiredStackVersion().getStackVersion(), null); [EOL] [EOL] clusterRequest.setDesiredConfig(Collections.singletonList(configurationRequest)); [EOL] m_managementController.updateClusters(new HashSet<ClusterRequest>() { [EOL] { [EOL] add(clusterRequest); [EOL] } [EOL] }, null); [EOL] [EOL] // the configure task should now return different properties to set based on [EOL] // the if-condition checks [EOL] configProperties = configureTask.getConfigurationChanges(cluster, cup); [EOL] assertFalse(configProperties.isEmpty()); [EOL] assertEquals( configProperties.get(ConfigureTask.PARAMETER_CONFIG_TYPE), "hive-site"); [EOL] [EOL] String configurationJson = configProperties.get(ConfigureTask.PARAMETER_KEY_VALUE_PAIRS); [EOL] assertNotNull(configurationJson); [EOL] [EOL] List<ConfigUpgradeChangeDefinition.ConfigurationKeyValue> keyValuePairs = m_gson.fromJson( [EOL] configurationJson, [EOL] new TypeToken<List<ConfigUpgradeChangeDefinition.ConfigurationKeyValue>>() { [EOL] }.getType()); [EOL] [EOL] assertEquals("fooKey", keyValuePairs.get(0).key); [EOL] assertEquals("fooValue", keyValuePairs.get(0).value); [EOL] } [EOL]
@Test [EOL] public void testConvertRawValueInvalidType() { [EOL] DefaultValueStandardizer standardizer = new DefaultValueStandardizer("default"); [EOL] Object expectedValue = Double.valueOf("1000.05"); [EOL] Object rawValue = Double.valueOf("1000.05"); [EOL] assertEquals(expectedValue, standardizer.convertRawValue(rawValue)); [EOL] } [EOL]
@Test [EOL] public void comparesModel() { [EOL] StringShape a = StringShape.builder().id("ns.foo#a").build(); [EOL] StringShape b = StringShape.builder().id("ns.foo#b").build(); [EOL] TimestampShape c = TimestampShape.builder().id("ns.foo#c").build(); [EOL] Model modelA = Model.builder().addShapes(Arrays.asList(a, b, c)).build(); [EOL] Model modelB = Model.builder().addShapes(modelA).build(); [EOL] [EOL] assertEquals(modelA, modelB); [EOL] } [EOL]
@Test [EOL] public void testGetFacteur() { [EOL] assertEquals(1.0, c1.getFacteur(), 0.0001); [EOL] [EOL] c2.zoomer(2.0); [EOL] c2.update(10.0); [EOL] assertEquals(2.0, c2.getFacteur(), 0.0001); [EOL] } [EOL]
@Test [EOL] 	public void elementoCuadroClasificacionDbEntityTest() { [EOL] 		Assert.notNull(getManager(), "ArchidocManager es nulo"); [EOL] 		IElementoCuadroClasificacionDbEntity dbEntity = getManager() [EOL] 				.getElementoCuadroClasificacionDbEntity(); [EOL] 		Assert.notNull(dbEntity, "entity es nulo"); [EOL] 		Assert.isTrue(ArchivoTables.ASGFELEMENTOCF_TABLE_NAME.equals(dbEntity [EOL] 				.getTableName()),"Las tablas no coinciden"); [EOL] [EOL] 		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount())); [EOL] 	} [EOL]
@Test [EOL] public void getParentIdReturnsParentWorkflowId() { [EOL] instance = new WorkflowInstance.Builder().setParentWorkflowId(42L).build(); [EOL] createExecution(); [EOL] [EOL] assertThat(execution.getParentId(), is(Optional.of(42L))); [EOL] } [EOL]
@Test [EOL] public void testNoArgsConstructor() { [EOL] double sum = 0.0; [EOL] int year = -1; [EOL] int month = -1; [EOL] SumYearMonth bean = new SumYearMonth(); [EOL] assertEquals(sum, bean.getSum(), 0.0); [EOL] assertEquals(year, bean.getYear()); [EOL] assertEquals(month, bean.getMonth()); [EOL] } [EOL]
@Test (timeout=5000) [EOL] public void testQueue() throws IOException { [EOL] File f = null; [EOL] try { [EOL] f = writeFile(); [EOL] [EOL] QueueManager manager = new QueueManager(f.getCanonicalPath(), true); [EOL] manager.setSchedulerInfo("first", "queueInfo"); [EOL] manager.setSchedulerInfo("second", "queueInfoqueueInfo"); [EOL] Queue root = manager.getRoot(); [EOL] assertThat(root.getChildren().size()).isEqualTo(2); [EOL] Iterator<Queue> iterator = root.getChildren().iterator(); [EOL] Queue firstSubQueue = iterator.next(); [EOL] assertEquals("first", firstSubQueue.getName()); [EOL] assertEquals( [EOL] firstSubQueue.getAcls().get("mapred.queue.first.acl-submit-job") [EOL] .toString(), [EOL] "Users [user1, user2] and members of the groups [group1, group2] are allowed"); [EOL] Queue secondSubQueue = iterator.next(); [EOL] assertEquals("second", secondSubQueue.getName()); [EOL] assertThat(secondSubQueue.getProperties().getProperty("key")) [EOL] .isEqualTo("value"); [EOL] assertThat(secondSubQueue.getProperties().getProperty("key1")) [EOL] .isEqualTo("value1"); [EOL] // test status [EOL] assertThat(firstSubQueue.getState().getStateName()) [EOL] .isEqualTo("running"); [EOL] assertThat(secondSubQueue.getState().getStateName()) [EOL] .isEqualTo("stopped"); [EOL] [EOL] Set<String> template = new HashSet<String>(); [EOL] template.add("first"); [EOL] template.add("second"); [EOL] assertEquals(manager.getLeafQueueNames(), template); [EOL] [EOL] // test user access [EOL] [EOL] UserGroupInformation mockUGI = mock(UserGroupInformation.class); [EOL] when(mockUGI.getShortUserName()).thenReturn("user1"); [EOL] String[] groups = { "group1" }; [EOL] when(mockUGI.getGroupNames()).thenReturn(groups); [EOL] assertTrue(manager.hasAccess("first", QueueACL.SUBMIT_JOB, mockUGI)); [EOL] assertFalse(manager.hasAccess("second", QueueACL.SUBMIT_JOB, mockUGI)); [EOL] assertFalse(manager.hasAccess("first", QueueACL.ADMINISTER_JOBS, mockUGI)); [EOL] when(mockUGI.getShortUserName()).thenReturn("user3"); [EOL] assertTrue(manager.hasAccess("first", QueueACL.ADMINISTER_JOBS, mockUGI)); [EOL] [EOL] QueueAclsInfo[] qai = manager.getQueueAcls(mockUGI); [EOL] assertThat(qai.length).isEqualTo(1); [EOL] // test refresh queue [EOL] manager.refreshQueues(getConfiguration(), null); [EOL] [EOL] iterator = root.getChildren().iterator(); [EOL] Queue firstSubQueue1 = iterator.next(); [EOL] Queue secondSubQueue1 = iterator.next(); [EOL] // tets equal method [EOL] assertThat(firstSubQueue).isEqualTo(firstSubQueue1); [EOL] assertThat(firstSubQueue1.getState().getStateName()) [EOL] .isEqualTo("running"); [EOL] assertThat(secondSubQueue1.getState().getStateName()) [EOL] .isEqualTo("stopped"); [EOL] [EOL] assertThat(firstSubQueue1.getSchedulingInfo()) [EOL] .isEqualTo("queueInfo"); [EOL] assertThat(secondSubQueue1.getSchedulingInfo()) [EOL] .isEqualTo("queueInfoqueueInfo"); [EOL] [EOL] // test JobQueueInfo [EOL] assertThat(firstSubQueue.getJobQueueInfo().getQueueName()) [EOL] .isEqualTo("first"); [EOL] assertThat(firstSubQueue.getJobQueueInfo().getState().toString()) [EOL] .isEqualTo("running"); [EOL] assertThat(firstSubQueue.getJobQueueInfo().getSchedulingInfo()) [EOL] .isEqualTo("queueInfo"); [EOL] assertThat(secondSubQueue.getJobQueueInfo().getChildren().size()) [EOL] .isEqualTo(0); [EOL] // test [EOL] assertThat(manager.getSchedulerInfo("first")).isEqualTo("queueInfo"); [EOL] Set<String> queueJobQueueInfos = new HashSet<String>(); [EOL] for(JobQueueInfo jobInfo : manager.getJobQueueInfos()){ [EOL] 	 queueJobQueueInfos.add(jobInfo.getQueueName()); [EOL] } [EOL] Set<String> rootJobQueueInfos = new HashSet<String>(); [EOL] for(Queue queue : root.getChildren()){ [EOL] 	 rootJobQueueInfos.add(queue.getJobQueueInfo().getQueueName()); [EOL] } [EOL] assertEquals(queueJobQueueInfos, rootJobQueueInfos); [EOL] // test getJobQueueInfoMapping [EOL] assertThat(manager.getJobQueueInfoMapping().get("first").getQueueName()) [EOL] .isEqualTo("first"); [EOL] // test dumpConfiguration [EOL] Writer writer = new StringWriter(); [EOL] [EOL] Configuration conf = getConfiguration(); [EOL] conf.unset(DeprecatedQueueConfigurationParser.MAPRED_QUEUE_NAMES_KEY); [EOL] QueueManager.dumpConfiguration(writer, f.getAbsolutePath(), conf); [EOL] String result = writer.toString(); [EOL] assertTrue(result [EOL] .indexOf("\"name\":\"first\",\"state\":\"running\",\"acl_submit_job\":\"user1,user2 group1,group2\",\"acl_administer_jobs\":\"user3,user4 group3,group4\",\"properties\":[],\"children\":[]") > 0); [EOL] [EOL] writer = new StringWriter(); [EOL] QueueManager.dumpConfiguration(writer, conf); [EOL] result = writer.toString(); [EOL] assertTrue(result.contains("{\"queues\":[{\"name\":\"default\",\"state\":\"running\",\"acl_submit_job\":\"*\",\"acl_administer_jobs\":\"*\",\"properties\":[],\"children\":[]},{\"name\":\"q1\",\"state\":\"running\",\"acl_submit_job\":\" \",\"acl_administer_jobs\":\" \",\"properties\":[],\"children\":[{\"name\":\"q1:q2\",\"state\":\"running\",\"acl_submit_job\":\" \",\"acl_administer_jobs\":\" \",\"properties\":[")); [EOL] assertTrue(result.contains("{\"key\":\"capacity\",\"value\":\"20\"}")); [EOL] assertTrue(result.contains("{\"key\":\"user-limit\",\"value\":\"30\"}")); [EOL] assertTrue(result.contains("],\"children\":[]}]}]}")); [EOL] // test constructor QueueAclsInfo [EOL] QueueAclsInfo qi = new QueueAclsInfo(); [EOL] assertNull(qi.getQueueName()); [EOL] [EOL] } finally { [EOL] if (f != null) { [EOL] f.delete(); [EOL] } [EOL] } [EOL] } [EOL]
@Test [EOL] public void getProductMetricDetail() throws Exception { [EOL] when(metricsService.getProductMetricDetail(MetricType.SCM_COMMITS,"portfolio1", "lob","product1")).thenReturn(TestUtils.makeProductMetricDetail()); [EOL] mockMvc.perform(MockMvcRequestBuilders.get("/metrics/SCM/product/portfolio1/lob/product1/detail")) [EOL] .andDo(print()) [EOL] .andExpect(status().isOk()); [EOL] verify(metricsService).getProductMetricDetail(null,"portfolio1", "lob","product1"); [EOL] } [EOL]
@Test [EOL] 	public void testConfigurationYAML() { [EOL] 		File tmpDir = tempFolder.getRoot(); [EOL] 		File confFile = new File(tmpDir, GlobalConfiguration.FLINK_CONF_FILENAME); [EOL] [EOL] 		try { [EOL] 			try (final PrintWriter pw = new PrintWriter(confFile)) { [EOL] [EOL] 				pw.println("###########################"); // should be skipped [EOL] 				pw.println("# Some : comments : to skip"); // should be skipped [EOL] 				pw.println("###########################"); // should be skipped [EOL] 				pw.println("mykey1: myvalue1"); // OK, simple correct case [EOL] 				pw.println("mykey2 : myvalue2"); // OK, whitespace before colon is correct [EOL] 				pw.println("mykey3:myvalue3"); // SKIP, missing white space after colon [EOL] 				pw.println(" some nonsense without colon and whitespace separator"); // SKIP [EOL] 				pw.println(" : "); // SKIP [EOL] 				pw.println(" "); // SKIP (silently) [EOL] 				pw.println(" "); // SKIP (silently) [EOL] 				pw.println("mykey4: myvalue4# some comments"); // OK, skip comments only [EOL] 				pw.println(" mykey5 : myvalue5 "); // OK, trim unnecessary whitespace [EOL] 				pw.println("mykey6: my: value6"); // OK, only use first ': ' as separator [EOL] 				pw.println("mykey7: "); // SKIP, no value provided [EOL] 				pw.println(": myvalue8"); // SKIP, no key provided [EOL] [EOL] 				pw.println("mykey9: myvalue9"); // OK [EOL] 				pw.println("mykey9: myvalue10"); // OK, overwrite last value [EOL] [EOL] 			} catch (FileNotFoundException e) { [EOL] 				e.printStackTrace(); [EOL] 			} [EOL] [EOL] 			Configuration conf = GlobalConfiguration.loadConfiguration(tmpDir.getAbsolutePath()); [EOL] [EOL] 			// all distinct keys from confFile1 + confFile2 key [EOL] 			assertEquals(6, conf.keySet().size()); [EOL] [EOL] 			// keys 1, 2, 4, 5, 6, 7, 8 should be OK and match the expected values [EOL] 			assertEquals("myvalue1", conf.getString("mykey1", null)); [EOL] 			assertEquals("myvalue2", conf.getString("mykey2", null)); [EOL] 			assertEquals("null", conf.getString("mykey3", "null")); [EOL] 			assertEquals("myvalue4", conf.getString("mykey4", null)); [EOL] 			assertEquals("myvalue5", conf.getString("mykey5", null)); [EOL] 			assertEquals("my: value6", conf.getString("mykey6", null)); [EOL] 			assertEquals("null", conf.getString("mykey7", "null")); [EOL] 			assertEquals("null", conf.getString("mykey8", "null")); [EOL] 			assertEquals("myvalue10", conf.getString("mykey9", null)); [EOL] 		} finally { [EOL] 			confFile.delete(); [EOL] 			tmpDir.delete(); [EOL] 		} [EOL] 	} [EOL]
@Test [EOL] void bifunction() { [EOL] assertTripleParameters(BiFunction.class, Integer.class, Long.class, Float.class, DefaultType::bifunction); [EOL] } [EOL]
@Test [EOL] public void testThrowsFlyteLaunchPlanNotFound() { [EOL] doThrow(new StatusRuntimeException(Status.NOT_FOUND)) [EOL] .when(flyteAdminClient).createExecution(any(), any(), any(), any(), any(), any(), any()); [EOL] assertThrows( [EOL] FlyteRunner.LaunchPlanNotFound.class, [EOL] () -> flyteRunner.createExecution(RUN_STATE, "exec", FLYTE_EXEC_CONF, ANNOTATIONS)); [EOL] } [EOL]
@Test [EOL] public void testCreateKey() throws Exception { [EOL] final Configuration conf = new Configuration(); [EOL] KeyProvider kp = [EOL] new UserProvider.Factory().createProvider(new URI("user:///"), conf); [EOL] KeyACLs mock = mock(KeyACLs.class); [EOL] when(mock.isACLPresent("foo", KeyOpType.MANAGEMENT)).thenReturn(true); [EOL] UserGroupInformation u1 = UserGroupInformation.createRemoteUser("u1"); [EOL] when(mock.hasAccessToKey("foo", u1, KeyOpType.MANAGEMENT)).thenReturn(true); [EOL] final KeyProviderCryptoExtension kpExt = [EOL] new KeyAuthorizationKeyProvider( [EOL] KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp), [EOL] mock); [EOL] [EOL] u1.doAs( [EOL] new PrivilegedExceptionAction<Void>() { [EOL] @Override [EOL] public Void run() throws Exception { [EOL] try { [EOL] kpExt.createKey("foo", SecureRandom.getSeed(16), [EOL] newOptions(conf)); [EOL] } catch (IOException ioe) { [EOL] Assert.fail("User should be Authorized !!"); [EOL] } [EOL] [EOL] // "bar" key not configured [EOL] try { [EOL] kpExt.createKey("bar", SecureRandom.getSeed(16), [EOL] newOptions(conf)); [EOL] Assert.fail("User should NOT be Authorized !!"); [EOL] } catch (IOException ioe) { [EOL] // Ignore [EOL] } [EOL] return null; [EOL] } [EOL] } [EOL] ); [EOL] [EOL] // Unauthorized User [EOL] UserGroupInformation.createRemoteUser("badGuy").doAs( [EOL] new PrivilegedExceptionAction<Void>() { [EOL] @Override [EOL] public Void run() throws Exception { [EOL] try { [EOL] kpExt.createKey("foo", SecureRandom.getSeed(16), [EOL] newOptions(conf)); [EOL] Assert.fail("User should NOT be Authorized !!"); [EOL] } catch (IOException ioe) { [EOL] // Ignore [EOL] } [EOL] return null; [EOL] } [EOL] } [EOL] ); [EOL] } [EOL]
@Test [EOL] public void allowsNestedOutputToken() { [EOL] TraitFactory provider = TraitFactory.createServiceFactory(); [EOL] Node node = Node.objectNode() [EOL] .withMember("inputToken", Node.from("inputToken")) [EOL] .withMember("outputToken", Node.from("result.outputToken")); [EOL] Optional<Trait> trait = provider.createTrait( [EOL] ShapeId.from("smithy.api#paginated"), ShapeId.from("ns.qux#foo"), node); [EOL] [EOL] assertThat(trait.isPresent(), is(true)); [EOL] assertThat(trait.get(), instanceOf(PaginatedTrait.class)); [EOL] PaginatedTrait paginatedTrait = (PaginatedTrait) trait.get(); [EOL] assertThat(paginatedTrait.getOutputToken(), equalTo(Optional.of("result.outputToken"))); [EOL] } [EOL]
@Test [EOL] void setUnique() { [EOL] assertDoesNotThrow(() -> getMutatorInstance().setUnique(true)); [EOL] } [EOL]
@Test [EOL] public void testResolve() throws Exception { [EOL] final MetricName name = new MetricName("foo"); [EOL] assertThat(name.resolve("bar")).isEqualTo(new MetricName("foo.bar")); [EOL] } [EOL]
@Test [EOL] public void testFetchClientException() throws Exception { [EOL] when(mockS3.getObject(any(GetObjectRequest.class))) [EOL] .thenThrow(new AmazonClientException("error")); [EOL] [EOL] try { [EOL] downloader.fetch(record); [EOL] failBecauseExceptionWasNotThrown(AmazonClientException.class); [EOL] } catch (AmazonClientException e) { [EOL] } [EOL] verify(mockS3).getObject(any(GetObjectRequest.class)); [EOL] } [EOL]
@Test [EOL] 	public void serieDbEntityTest() { [EOL] 		Assert.notNull(getManager(), "ArchidocManager es nulo"); [EOL] 		ISerieDbEntity dbEntity = getManager().getSerieDbEntity(); [EOL] 		Assert.notNull(dbEntity, "entity es nulo"); [EOL] 		Assert.isTrue(ArchivoTables.ASGFSERIE_TABLE_NAME.equals(dbEntity [EOL] 				.getTableName()),"Las tablas no coinciden"); [EOL] [EOL] 		logger.info(getTextoCount(dbEntity.getTableName(), dbEntity.getCount())); [EOL] 	} [EOL]
@Test [EOL] 	public void testReverse() throws Exception { [EOL] 		seq s = makeSeq(); [EOL] 		s.reverse(); [EOL] 		assertEquals(makeSeq("E", "D", "C", "B", "A"), s); [EOL] 	} [EOL]
@Test [EOL] public void catchesAndShowsErrorsWhenSerializing() { [EOL] ThrowingClass tc = new ThrowingClass(); [EOL] NodeMapper mapper = new NodeMapper(); [EOL] [EOL] NodeSerializationException e = Assertions.assertThrows( [EOL] NodeSerializationException.class, [EOL] () -> mapper.serialize(tc) [EOL] ); [EOL] [EOL] assertThat(e.getMessage(), equalTo( [EOL] "Error serializing `throws` field of software.amazon.smithy.model.node.NodeMapperTest$ThrowingClass " [EOL] + "using getThrows(): Nope!")); [EOL] } [EOL]
@Test [EOL] void hasProperty() [EOL] { [EOL] ExecutionContext context = new ExecutionContext(); [EOL] [EOL] assertFalse(context.hasProperty("key")); [EOL] [EOL] context.setProperty("key", "value"); [EOL] [EOL] assertTrue(context.hasProperty("key")); [EOL] } [EOL]
@Test [EOL] public void testUpdateResourceHostEntryTimestamp() throws Exception [EOL] { [EOL] registry.updateResourceHostEntryTimestamp( HOST_ID ); [EOL] [EOL] verify( hosts ).getIfPresent( HOST_ID ); [EOL] } [EOL]
@Test [EOL] void getters() { [EOL] Tuple1 tuple = Tuple.of(1); [EOL] assertThat(tuple._1()).isEqualTo(1); [EOL] } [EOL]
@Test [EOL] public void testArrayOfSerializedResources() throws Exception { [EOL] @Api [EOL] class ResourceCollection { [EOL] @SuppressWarnings("unused") [EOL] public void foo(@Named("beans") List<StringBean> beans) {} [EOL] } [EOL] String apiConfigSource = g.generateConfig(ResourceCollection.class).get("myapi-v1.api"); [EOL] ObjectNode root = objectMapper.readValue(apiConfigSource, ObjectNode.class); [EOL] JsonNode methodNode = root.path("methods").path("myapi.resourceCollection.foo"); [EOL] assertFalse(methodNode.isMissingNode()); [EOL] verifyMethodRequestParameter(methodNode.get("request"), "beans", "string", true, true); [EOL] } [EOL]
@Test [EOL] public void testAssignVector() throws Exception { [EOL] Vector other = new DenseVector(test.size()); [EOL] test.assign(other); [EOL] for (int i = 0; i < test.size(); i++) { [EOL] assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON); [EOL] } [EOL] } [EOL]
@Test [EOL] public void testConnectionTokens4() throws Exception { [EOL] // Use HTTP 1.1 [EOL] final HttpResponse response = new BasicHttpResponse(200, "OK"); [EOL] response.addHeader("Transfer-Encoding", "chunked"); [EOL] response.addHeader("Connection", "yadda, close, dumdy"); [EOL] response.addHeader("Proxy-Connection", "keep-alive"); [EOL] // Connection takes precedence over Proxy-Connection [EOL] Assert.assertFalse(reuseStrategy.keepAlive(null, response, context)); [EOL] } [EOL]
@Test [EOL] public void testRemoveProperty() { [EOL] Configuration configuration = createConfigurationWithParents_PropsOnly(); [EOL] // property only exists in root level config [EOL] assertEquals("val3.1", configuration.removeProperty("type1", "prop3")); [EOL] assertNull(configuration.getPropertyValue("type1", "prop3")); [EOL] [EOL] // property only exists in configuration instance [EOL] assertEquals("val9.3", configuration.removeProperty("type1", "prop9")); [EOL] assertNull(configuration.getPropertyValue("type1", "prop9")); [EOL] [EOL] // property at multiple levels [EOL] assertEquals("val1.3", configuration.removeProperty("type1", "prop1")); [EOL] assertNull(configuration.getPropertyValue("type1", "prop1")); [EOL] [EOL] assertEquals("val4.3", configuration.removeProperty("type2", "prop4")); [EOL] assertNull(configuration.getPropertyValue("type2", "prop4")); [EOL] [EOL] assertEquals("val2.2", configuration.removeProperty("type1", "prop2")); [EOL] assertNull(configuration.getPropertyValue("type1", "prop2")); [EOL] [EOL] // type and property don't exist [EOL] assertNull(configuration.getPropertyValue("typeXXX", "XXXXX")); [EOL] [EOL] // type exists but property doesn't [EOL] assertNull(configuration.getPropertyValue("type1", "XXXXX")); [EOL] } [EOL]
@Test [EOL] void get2Test() { [EOL] assertEquals(2, (int) instance.get2().orElseThrow(NoSuchElementException::new)); [EOL] } [EOL]
@Test [EOL] 	public void testAliasByTagScopeNMetricWithOneTag() { [EOL] 		Metric metric = new Metric("scope", "metric"); [EOL] 		metric.setTag("device", "someDevice"); [EOL] 		metric.setTag("target", "someTarget"); [EOL] 		Metric actual = aliasByTagTransform.transform(null, Arrays.asList(metric), Arrays.asList("device")).get(0); [EOL] 		 [EOL] 		assertEquals(AliasByTagTransform.DEFAULT_SCOPE_NAME, actual.getScope()); [EOL] 		assertEquals("someDevice", actual.getMetric()); [EOL] 	} [EOL]
@Test(timeout = 8000) [EOL] public void testSingleSourceManyIterators() throws InterruptedException { [EOL] BlockingObservable<Long> source = Observable.interval(200, TimeUnit.MILLISECONDS).take(10).toBlockingObservable(); [EOL] [EOL] Iterable<Long> iter = source.next(); [EOL] [EOL] for (int j = 0; j < 3; j++) { [EOL] Iterator<Long> it = iter.iterator(); [EOL] [EOL] for (int i = 0; i < 9; i++) { [EOL] // hasNext has to set the waiting to true, otherwise, all onNext will be skipped [EOL] Assert.assertEquals(true, it.hasNext()); [EOL] Assert.assertEquals(Long.valueOf(i), it.next()); [EOL] } [EOL] [EOL] Thread.sleep(400); [EOL] [EOL] Assert.assertEquals(false, it.hasNext()); [EOL] } [EOL] [EOL] } [EOL]
@Test [EOL] 	public void findElements_driver_nested_notFound() throws Exception { [EOL] 		expectedException.expect(NoSuchElementException.class); [EOL] [EOL] 		DomSelector selector = new DomSelector(SelectorType.ID, "none", new DomSelector(SelectorType.TAG_NAME, "body")); [EOL] 		selector.findElements(defaultContentElement); [EOL] 	} [EOL]
@Test public void packLong5() { [EOL] byte[] b = new byte[8]; [EOL] Bytes.setLong(0x0102030405060708L,b); [EOL] assertEquals(0x01, b[0]); [EOL] assertEquals(0x02, b[1]); [EOL] assertEquals(0x03, b[2]); [EOL] assertEquals(0x04, b[3]); [EOL] assertEquals(0x05, b[4]); [EOL] assertEquals(0x06, b[5]); [EOL] assertEquals(0x07, b[6]); [EOL] assertEquals(0x08, b[7]); [EOL] } [EOL]
@Test [EOL] public void testSaveOriginReturnsNullOnNullInput() { [EOL] assertNull(getOriginManager().saveOrigin(null)); [EOL] } [EOL]
@Test(expected = IndexOutOfBoundsException.class) [EOL] 	public void testInvalidProjection2() throws IOException{ [EOL] 		rowOrcInputFormat = [EOL] 			new OrcRowInputFormat(getPath(TEST_FILE_FLAT), TEST_SCHEMA_FLAT, new Configuration()); [EOL] 		int[] projectionMask = {1, 2, 3, 9}; [EOL] 		rowOrcInputFormat.selectFields(projectionMask); [EOL] 	} [EOL]
@Test [EOL] public void testWriteInt () { [EOL] ByteBuffer intBuffer = ByteBuffer.allocate(4); [EOL] [EOL] ReadWrite.writeInt(42, intBuffer, 0); [EOL] Assert.assertTrue(ReadWrite.readUnsignedInt(intBuffer, 0) == 42); [EOL] } [EOL]
@Test [EOL] public void indentStyle() { [EOL] Assert.assertEquals(PropertyValue.valid("space", IndentStyleValue.space), [EOL] PropertyType.indent_style.parse("space")); [EOL] Assert.assertEquals(PropertyValue.valid("SPACE", IndentStyleValue.space), [EOL] PropertyType.indent_style.parse("SPACE")); [EOL] Assert.assertEquals(PropertyValue.valid("SpAcE", IndentStyleValue.space), [EOL] PropertyType.indent_style.parse("SpAcE")); [EOL] Assert.assertEquals(PropertyValue.valid("tab", IndentStyleValue.tab), PropertyType.indent_style.parse("tab")); [EOL] Assert.assertFalse(PropertyType.indent_style.parse("").isValid()); [EOL] Assert.assertFalse(PropertyType.indent_style.parse("foo").isValid()); [EOL] Assert.assertFalse(PropertyType.indent_style.parse(null).isValid()); [EOL] } [EOL]
@Test [EOL] public void createFileBasedGeneratorNotSupported() { [EOL] [EOL] // given [EOL] SingleThreadJsonFactory factory = new SingleThreadJsonFactory(); [EOL] [EOL] expectedException.expect(UnsupportedOperationException.class); [EOL] expectedException.expectMessage("File not supported. Use OutputStream"); [EOL] [EOL] // when [EOL] factory.createGenerator(mock(File.class), JsonEncoding.UTF8); [EOL] [EOL] } [EOL]
@Test [EOL] void trim() { [EOL] assertEquals(" A", StringUtils.trim(" A ", StringUtils.Trim.TRAILING)); [EOL] assertEquals("A ", StringUtils.trim(" A ", StringUtils.Trim.LEADING)); [EOL] assertEquals("A", StringUtils.trim(" A ", StringUtils.Trim.LEADING_AND_TRAILING)); [EOL] } [EOL]
@Test [EOL] public void testCustomDelimiter() throws Exception { [EOL] /* TEST_1 [EOL] * The test scenario is the tail of the buffer [EOL] * equals the starting character/s of delimiter [EOL] * [EOL] * The Test Data is such that, [EOL] * [EOL] * 1) we will have "</entity>" as delimiter [EOL] * [EOL] * 2) The tail of the current buffer would be "</" [EOL] * which matches with the starting character sequence of delimiter. [EOL] * [EOL] * 3) The Head of the next buffer would be "id>" [EOL] * which does NOT match with the remaining characters of delimiter. [EOL] * [EOL] * 4) Input data would be prefixed by char 'a' [EOL] * about numberOfCharToFillTheBuffer times. [EOL] * So that, one iteration to buffer the input data, [EOL] * would end at '</' ie equals starting 2 char of delimiter [EOL] * [EOL] * 5) For this we would take BufferSize as 64 * 1024; [EOL] * [EOL] * Check Condition [EOL] * In the second key value pair, the value should contain [EOL] * "</" from currentToken and [EOL] * "id>" from next token [EOL] */ [EOL] [EOL] Delimiter="</entity>"; [EOL] [EOL] String CurrentBufferTailToken= [EOL] "</entity><entity><id>Gelesh</"; [EOL] // Ending part of Input Data Buffer [EOL] // It contains '</' ie delimiter character [EOL] [EOL] String NextBufferHeadToken= [EOL] "id><name>Omathil</name></entity>"; [EOL] // Supposing the start of next buffer is this [EOL] [EOL] String Expected = [EOL] (CurrentBufferTailToken+NextBufferHeadToken) [EOL] .replace(Delimiter, ""); [EOL] // Expected ,must capture from both the buffer, excluding Delimiter [EOL] [EOL] String TestPartOfInput = CurrentBufferTailToken+NextBufferHeadToken; [EOL] [EOL] int BufferSize=64 * 1024; [EOL] int numberOfCharToFillTheBuffer = [EOL] BufferSize - CurrentBufferTailToken.length(); [EOL] StringBuilder fillerString=new StringBuilder(); [EOL] for (int i=0; i<numberOfCharToFillTheBuffer; i++) { [EOL] fillerString.append('a'); // char 'a' as a filler for the test string [EOL] } [EOL] [EOL] TestData = fillerString + TestPartOfInput; [EOL] lineReader = new LineReader( [EOL] new ByteArrayInputStream(TestData.getBytes()), Delimiter.getBytes()); [EOL] [EOL] line = new Text(); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals(fillerString.toString(), line.toString()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals(Expected, line.toString()); [EOL] [EOL] /*TEST_2 [EOL] * The test scenario is such that, [EOL] * the character/s preceding the delimiter, [EOL] * equals the starting character/s of delimiter [EOL] */ [EOL] [EOL] Delimiter = "record"; [EOL] StringBuilder TestStringBuilder = new StringBuilder(); [EOL] [EOL] TestStringBuilder.append(Delimiter + "Kerala "); [EOL] TestStringBuilder.append(Delimiter + "Bangalore"); [EOL] TestStringBuilder.append(Delimiter + " North Korea"); [EOL] TestStringBuilder.append(Delimiter + Delimiter+ [EOL] "Guantanamo"); [EOL] TestStringBuilder.append(Delimiter + "ecord" [EOL] + "recor" + "core"); //~EOF with 're' [EOL] [EOL] TestData=TestStringBuilder.toString(); [EOL] [EOL] lineReader = new LineReader( [EOL] new ByteArrayInputStream(TestData.getBytes()), Delimiter.getBytes()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("", line.toString()); [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("Kerala ", line.toString()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("Bangalore", line.toString()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals(" North Korea", line.toString()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("", line.toString()); [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("Guantanamo", line.toString()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals(("ecord"+"recor"+"core"), line.toString()); [EOL] [EOL] // Test 3 [EOL] // The test scenario is such that, [EOL] // aaaabccc split by aaab [EOL] TestData = "aaaabccc"; [EOL] Delimiter = "aaab"; [EOL] lineReader = new LineReader( [EOL] new ByteArrayInputStream(TestData.getBytes()), Delimiter.getBytes()); [EOL] [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("a", line.toString()); [EOL] lineReader.readLine(line); [EOL] Assert.assertEquals("ccc", line.toString()); [EOL] } [EOL]
@Test(timeout=60000) [EOL] public void testContextIsPassed() throws Exception { [EOL] final NoOpCheckable target1 = new NoOpCheckable(); [EOL] final FakeTimer timer = new FakeTimer(); [EOL] ThrottledAsyncChecker<Boolean, Boolean> checker = [EOL] new ThrottledAsyncChecker<>(timer, MIN_ERROR_CHECK_GAP, 0, [EOL] getExecutorService()); [EOL] [EOL] assertTrue(checker.schedule(target1, true).isPresent()); [EOL] waitTestCheckableCheckCount(target1, 1L); [EOL] timer.advance(MIN_ERROR_CHECK_GAP + 1); [EOL] assertTrue(checker.schedule(target1, false).isPresent()); [EOL] waitTestCheckableCheckCount(target1, 2L); [EOL] [EOL] } [EOL]
@Test [EOL] @TestException(exception = ServerException.class, msgRegExp = "S08.*") [EOL] @TestDir [EOL] public void invalidSservice() throws Exception { [EOL] String dir = TestDirHelper.getTestDir().getAbsolutePath(); [EOL] Configuration conf = new Configuration(false); [EOL] conf.set("server.services", "foo"); [EOL] Server server = new Server("server", dir, dir, dir, dir, conf); [EOL] server.init(); [EOL] } [EOL]
@Test [EOL] public void isAlreadyExists() { [EOL] assertThat(transactionException(1, "", "ALREADY_EXISTS").isAlreadyExists(), is(true)); [EOL] assertThat(transactionException(1, "entity already exists", "").isAlreadyExists(), is(true)); [EOL] assertThat(transactionException(1, "", "").isAlreadyExists(), is(false)); [EOL] } [EOL]
@Test [EOL] public void testGetEntitiesByMetricFilters() throws Exception { [EOL] Client client = createClient(); [EOL] try { [EOL] URI uri = URI.create("http://localhost:" + serverPort + "/ws/v2/" + [EOL] "timeline/clusters/cluster1/apps/app1/entities/app?" + [EOL] "metricfilters=metric3%20ge%200"); [EOL] ClientResponse resp = getResponse(client, uri); [EOL] Set<TimelineEntity> entities = [EOL] resp.getEntity(new GenericType<Set<TimelineEntity>>(){}); [EOL] assertEquals(MediaType.APPLICATION_JSON + "; " + JettyUtils.UTF_8, [EOL] resp.getType().toString()); [EOL] assertNotNull(entities); [EOL] assertEquals(2, entities.size()); [EOL] assertTrue("Entities with id_1 and id_2 should have been present" + [EOL] " in response.", [EOL] entities.contains(newEntity("app", "id_1")) && [EOL] entities.contains(newEntity("app", "id_2"))); [EOL] } finally { [EOL] client.destroy(); [EOL] } [EOL] } [EOL]
@Ignore("Remove to run test") [EOL] @Test [EOL] public void soundFor35IsPlangPlongAsItHasFactors5And7() { [EOL] assertEquals("PlangPlong", raindropConverter.convert(35)); [EOL] } [EOL]
@Test [EOL] public void testSize() { [EOL] assertThat(Pedigree.empty().size(), equalTo(0)); [EOL] assertThat(Pedigree.justProband("Nemo").size(), equalTo(1)); [EOL] assertThat(Pedigree.of(PROBAND, MOTHER, FATHER).size(), equalTo(3)); [EOL] } [EOL]
@Test [EOL] public void testSetex() { [EOL] jedisSentinel.setex("key", 1337, "value"); [EOL] } [EOL]
@Test [EOL] public void shouldFailWhenUnknownAndDepletedResources() { [EOL] setResourceLimit("r1", 0); [EOL] initWorkflow(workflowUsingResources(WORKFLOW_ID1, "r1", "r2", "r3")); [EOL] [EOL] populateActiveStates(RunState.create(INSTANCE_1, State.QUEUED, time.get())); [EOL] [EOL] scheduler.tick(); [EOL] [EOL] verify(stateManager).receiveIgnoreClosed( [EOL] eq(Event.runError(INSTANCE_1, [EOL] "Referenced resources not found: [r2, r3]")), [EOL] anyLong()); [EOL] } [EOL]
@Test [EOL] public void testCompleteJob() throws Exception { [EOL] [EOL] File inputFile = getTestTempFile("prefs.txt"); [EOL] File outputDir = getTestTempDir("output"); [EOL] outputDir.delete(); [EOL] File tmpDir = getTestTempDir("tmp"); [EOL] [EOL] writeLines(inputFile, [EOL] "2,1,1", [EOL] "1,2,1", [EOL] "3,4,1", [EOL] "1,3,2", [EOL] "2,3,1"); [EOL] [EOL] ItemSimilarityJob similarityJob = new ItemSimilarityJob(); [EOL] [EOL] Configuration conf = new Configuration(); [EOL] conf.set("mapred.input.dir", inputFile.getAbsolutePath()); [EOL] conf.set("mapred.output.dir", outputDir.getAbsolutePath()); [EOL] conf.setBoolean("mapred.output.compress", false); [EOL] [EOL] similarityJob.setConf(conf); [EOL] [EOL] similarityJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname", [EOL] CosineSimilarity.class.getName() }); [EOL] [EOL] File outPart = outputDir.listFiles(new FilenameFilter() { [EOL] @Override [EOL] public boolean accept(File dir, String name) { [EOL] return name.startsWith("part-"); [EOL] } [EOL] })[0]; [EOL] BufferedReader reader = Files.newReader(outPart, Charsets.UTF_8); [EOL] [EOL] String line; [EOL] int currentLine = 1; [EOL] while ( (line = reader.readLine()) != null) { [EOL] [EOL] String[] tokens = TAB.split(line); [EOL] [EOL] long itemAID = Long.parseLong(tokens[0]); [EOL] long itemBID = Long.parseLong(tokens[1]); [EOL] double similarity = Double.parseDouble(tokens[2]); [EOL] [EOL] if (currentLine == 1) { [EOL] assertEquals(1L, itemAID); [EOL] assertEquals(3L, itemBID); [EOL] assertEquals(0.45, similarity, 0.01); [EOL] } [EOL] [EOL] if (currentLine == 2) { [EOL] assertEquals(2L, itemAID); [EOL] assertEquals(3L, itemBID); [EOL] assertEquals(0.89, similarity, 0.01); [EOL] } [EOL] [EOL] currentLine++; [EOL] } [EOL] [EOL] int linesWritten = currentLine-1; [EOL] assertEquals(2, linesWritten); [EOL] } [EOL]
@Test [EOL] void testRestRequireNotEquals6() { [EOL] assertThrows(RuntimeException.class, () -> DoubleRangeUtil.requireNotEquals(1.0,1.0, RuntimeException::new)); [EOL] } [EOL]
@Test [EOL] public void testUpdateStageStatus_aborted() throws Exception { [EOL] StageResourceProvider provider = new StageResourceProvider(managementController); [EOL] ActionManager actionManager = createNiceMock(ActionManager.class); [EOL] [EOL] Predicate predicate = new PredicateBuilder().property(StageResourceProvider.STAGE_STAGE_ID).equals(2L).and(). [EOL] property(StageResourceProvider.STAGE_REQUEST_ID).equals(1L).toPredicate(); [EOL] [EOL] Map<String, Object> requestProps = new HashMap<String, Object>(); [EOL] requestProps.put(StageResourceProvider.STAGE_STATUS, HostRoleStatus.ABORTED.name()); [EOL] Request request = PropertyHelper.getUpdateRequest(requestProps, null); [EOL] [EOL] List<StageEntity> entities = getStageEntities(HostRoleStatus.HOLDING); [EOL] [EOL] expect(dao.findAll(request, predicate)).andReturn(entities); [EOL] expect(managementController.getActionManager()).andReturn(actionManager).anyTimes(); [EOL] [EOL] dao.updateStageStatus(entities.get(0), HostRoleStatus.ABORTED, actionManager); [EOL] EasyMock.expectLastCall().atLeastOnce(); [EOL] [EOL] replay(dao, clusters, cluster, actionManager, managementController); [EOL] [EOL] provider.updateResources(request, predicate); [EOL] [EOL] verify(dao, clusters, cluster, actionManager, managementController); [EOL] } [EOL]
@Test [EOL] public void testWriteStringStartsWithAHeaderLine() { [EOL] OutputSettings settings = OutputSettings.builder() [EOL] .outputFormats(EnumSet.of(OutputFormat.TSV_GENE)) [EOL] .build(); [EOL] String outString = instance.writeString(ModeOfInheritance.AUTOSOMAL_DOMINANT, analysis, analysisResults, settings); [EOL] String[] lines = outString.split("\n"); [EOL] assertThat(lines[0] + "\n", equalTo(HEADER)); [EOL] } [EOL]
@Test [EOL] public void testTakeList() { [EOL] assertTrue(mlist(asList(1, 2, 3, 4, 5)).take(0).value().isEmpty()); [EOL] assertEquals(3, mlist(asList(1, 2, 3, 4, 5)).take(3).value().size()); [EOL] assertEquals(5, mlist(asList(1, 2, 3, 4, 5)).take(5).value().size()); [EOL] assertEquals(5, mlist(asList(1, 2, 3, 4, 5)).take(10).value().size()); [EOL] } [EOL]
@Test [EOL] public void testGetConfigurationValue() throws Exception { [EOL] [EOL] AmbariStreamProvider clusterStreamProvider = createNiceMock(AmbariStreamProvider.class); [EOL] [EOL] final String desiredConfigsString = "{\"Clusters\": {\"desired_configs\": {\"test-site\": {\"tag\": \"TAG\"}}}}"; [EOL] final String configurationString = "{\"items\": [{\"properties\": {\"test.property.name\": \"test property value\"}}]}"; [EOL] final int[] desiredConfigPolls = {0}; [EOL] final int[] testConfigPolls = {0}; [EOL] final String clusterPath = "/api/v1/clusters/Test"; [EOL] [EOL] expect(clusterStreamProvider.readFrom(eq( clusterPath + "?fields=services/ServiceInfo,hosts,Clusters"), [EOL] eq("GET"), (String) isNull(), EasyMock.<Map<String, String>>anyObject())).andAnswer(new IAnswer<InputStream>() { [EOL] @Override [EOL] public InputStream answer() throws Throwable { [EOL] desiredConfigPolls[0] += 1; [EOL] return new ByteArrayInputStream(desiredConfigsString.getBytes()); [EOL] } [EOL] }).anyTimes(); [EOL] [EOL] expect(clusterStreamProvider.readFrom(eq(clusterPath + "/configurations?(type=test-site&tag=TAG)"), [EOL] eq("GET"), (String)isNull(), EasyMock.<Map<String, String>>anyObject())).andAnswer(new IAnswer<InputStream>() { [EOL] @Override [EOL] public InputStream answer() throws Throwable { [EOL] testConfigPolls[0] += 1; [EOL] return new ByteArrayInputStream(configurationString.getBytes()); [EOL] } [EOL] }).anyTimes(); [EOL] [EOL] RemoteAmbariClusterEntity entity = createNiceMock(RemoteAmbariClusterEntity.class); [EOL] [EOL] replay(clusterStreamProvider,entity); [EOL] [EOL] RemoteAmbariCluster cluster = new RemoteAmbariCluster("Test", clusterPath, clusterStreamProvider); [EOL] [EOL] String value = cluster.getConfigurationValue("test-site", "test.property.name"); [EOL] assertEquals(value, "test property value"); [EOL] assertEquals(desiredConfigPolls[0], 1); [EOL] assertEquals(testConfigPolls[0], 1); [EOL] [EOL] value = cluster.getConfigurationValue("test-site", "test.property.name"); [EOL] assertEquals(value, "test property value"); [EOL] assertEquals(desiredConfigPolls[0], 1); // cache hit [EOL] assertEquals(testConfigPolls[0], 1); [EOL] } [EOL]
@Test [EOL] public void testBitNotActive() { [EOL] RecordWindow recordWindow = Windows.bitNotActive(booleanChannel("flag")); [EOL] RecordWindow clone = ClonerUtil.clone(recordWindow); [EOL] [EOL] innerTestBitNotActive(recordWindow); [EOL] innerTestBitNotActive(clone); [EOL] } [EOL]
@Test [EOL] public void testConvertMetaFactBindingDefinitionsWithBindings() { [EOL] MetaFactBindingDefinition request1 = new MetaFactBindingDefinition() [EOL] .setFactType(UUID.randomUUID()); [EOL] MetaFactBindingDefinition request2 = new MetaFactBindingDefinition() [EOL] .setFactType(UUID.randomUUID()); [EOL] FactTypeEntity.MetaFactBindingDefinition entity1 = new FactTypeEntity.MetaFactBindingDefinition() [EOL] .setFactTypeID(request1.getFactType()); [EOL] FactTypeEntity.MetaFactBindingDefinition entity2 = new FactTypeEntity.MetaFactBindingDefinition() [EOL] .setFactTypeID(request2.getFactType()); [EOL] [EOL] assertEquals(SetUtils.set(entity1, entity2), helper.convertMetaFactBindingDefinitions(ListUtils.list(request1, request2))); [EOL] } [EOL]
@Test [EOL] public void testOfferProducerWithAddressDoesNotGrantNegativeCredit() throws Exception { [EOL] // Mock returns to get at the runnable that grants credit. [EOL] Mockito.when(manager.getServer()).thenReturn(server); [EOL] Mockito.when(server.getPagingManager()).thenReturn(pagingManager); [EOL] Mockito.when(pagingManager.getPageStore(any(SimpleString.class))).thenReturn(pagingStore); [EOL] [EOL] // Capture credit runnable and invoke to trigger credit top off [EOL] ArgumentCaptor<Runnable> argument = ArgumentCaptor.forClass(Runnable.class); [EOL] AMQPSessionCallback session = new AMQPSessionCallback(protonSPI, manager, connection, transportConnection, executor, operationContext); [EOL] [EOL] // Credit is at threshold [EOL] Mockito.when(receiver.getCredit()).thenReturn(AMQP_LOW_CREDITS_DEFAULT); [EOL] [EOL] session.flow(new SimpleString("test"), ProtonServerReceiverContext.createCreditRunnable(1, AMQP_LOW_CREDITS_DEFAULT, receiver, connection)); [EOL] [EOL] // Run the credit refill code. [EOL] Mockito.verify(pagingStore).checkMemory(argument.capture()); [EOL] assertNotNull(argument.getValue()); [EOL] argument.getValue().run(); [EOL] [EOL] // Ensure we aren't looking at remote credit as that gives us the wrong view of what credit is at the broker [EOL] Mockito.verify(receiver, never()).getRemoteCredit(); [EOL] [EOL] // Credit runnable should not grant what would be negative credit here [EOL] Mockito.verify(receiver, never()).flow(anyInt()); [EOL] } [EOL]
@Test [EOL] public void testPopupMenuListenerNotificationVisible() throws InterruptedException, InvocationTargetException { [EOL] if (GraphicsEnvironment.isHeadless()) { [EOL] LOG.fine("cannot run testLinkPanelNull - headless"); [EOL] return; [EOL] } [EOL] final JXDatePicker picker = new JXDatePicker(); [EOL] final JXFrame frame = new JXFrame("showing", false); [EOL] frame.add(picker); [EOL] frame.pack(); [EOL] frame.setVisible(true); [EOL] final PopupMenuReport report = new PopupMenuReport(); [EOL] picker.addPopupMenuListener(report); [EOL] Action togglePopup = picker.getActionMap().get("TOGGLE_POPUP"); [EOL] togglePopup.actionPerformed(null); [EOL] SwingUtilities.invokeAndWait(new Runnable() { [EOL] @Override [EOL] public void run() { [EOL] assertEquals(1, report.getEventCount()); [EOL] assertEquals(1, report.getVisibleEventCount()); [EOL] frame.dispose(); [EOL] [EOL] } [EOL] }); [EOL] } [EOL]
@Test [EOL] public void testOfferProducerWithAddressDoesNotTopOffCreditAboveThreshold() throws Exception { [EOL] // Mock returns to get at the runnable that grants credit. [EOL] Mockito.when(manager.getServer()).thenReturn(server); [EOL] Mockito.when(server.getPagingManager()).thenReturn(pagingManager); [EOL] Mockito.when(pagingManager.getPageStore(any(SimpleString.class))).thenReturn(pagingStore); [EOL] [EOL] // Capture credit runnable and invoke to trigger credit top off [EOL] ArgumentCaptor<Runnable> argument = ArgumentCaptor.forClass(Runnable.class); [EOL] AMQPSessionCallback session = new AMQPSessionCallback(protonSPI, manager, connection, transportConnection, executor, operationContext); [EOL] [EOL] // Credit is above threshold [EOL] Mockito.when(receiver.getCredit()).thenReturn(AMQP_LOW_CREDITS_DEFAULT + 1); [EOL] [EOL] session.flow(new SimpleString("test"), ProtonServerReceiverContext.createCreditRunnable(AMQP_CREDITS_DEFAULT, AMQP_LOW_CREDITS_DEFAULT, receiver, connection)); [EOL] [EOL] // Run the credit refill code. [EOL] Mockito.verify(pagingStore).checkMemory(argument.capture()); [EOL] assertNotNull(argument.getValue()); [EOL] argument.getValue().run(); [EOL] [EOL] // Ensure we aren't looking at remote credit as that gives us the wrong view of what credit is at the broker [EOL] Mockito.verify(receiver, never()).getRemoteCredit(); [EOL] [EOL] // Credit runnable should not top off credit to configured value [EOL] Mockito.verify(receiver, never()).flow(anyInt()); [EOL] } [EOL]
@Test [EOL] public void testIsCollection01() throws Exception { [EOL] // 前処理 [EOL] 	QName qName = new QName("property"); [EOL] 	BeanPropertyPointerEx_JavaBeanStub01 bean [EOL] 		= new BeanPropertyPointerEx_JavaBeanStub01(); [EOL] 	Locale locale = new Locale("ja"); [EOL] 	NodePointer nodePointer = NodePointer.newNodePointer(qName, bean, locale); [EOL] 	 [EOL] 	JXPathBasicBeanInfo beanInfo = new JXPathBasicBeanInfo(bean.getClass()); [EOL] 	BeanPropertyPointerEx pointer = new BeanPropertyPointerEx(nodePointer, beanInfo); [EOL] 	pointer.setPropertyName("property"); [EOL] [EOL] // テスト実施 [EOL] 	assertFalse(pointer.isCollection()); [EOL] } [EOL]
@Test [EOL] public void default_event_strategy_works_as_expected() { [EOL] // given [EOL] BreakingEventStrategy<Object> dm = [EOL] (BreakingEventStrategy<Object>) CircuitBreakerImpl.DEFAULT_BREAKING_EVENT_STRATEGY; [EOL] [EOL] // expect [EOL] assertThat(dm.isEventACircuitBreakerFailure(new Object())).isFalse(); [EOL] assertThat(dm.isEventACircuitBreakerFailure("foo")).isFalse(); [EOL] assertThat(dm.isEventACircuitBreakerFailure(null)).isFalse(); [EOL] } [EOL]
@Test [EOL] public void test_doAction() { [EOL] PrintJson printJson = new PrintJson(); [EOL] String result = printJson.doAction(resource); [EOL] [EOL] assertTrue(result.contains("\"sling:resourceType\": \"weretail/components/content/heroimage\"")); [EOL] assertTrue(result.contains("\"number\": 123")); [EOL] assertTrue(result.contains("\"multivalue\": [")); [EOL] assertTrue(result.contains("\"v1\",")); [EOL] assertTrue(result.contains("\"v2\",")); [EOL] assertTrue(result.contains("\"v3\"")); [EOL] } [EOL]
